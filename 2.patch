From c0be20ece25a8868e89c8c9549cafafcc8195f63 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 9 Jan 2017 14:16:38 +0100
Subject: [PATCH 001/200] SITL: XPLANE fix member shadowing

---
 libraries/SITL/SIM_XPlane.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/SITL/SIM_XPlane.cpp b/libraries/SITL/SIM_XPlane.cpp
index 7729655..ce0403d 100644
--- a/libraries/SITL/SIM_XPlane.cpp
+++ b/libraries/SITL/SIM_XPlane.cpp
@@ -165,8 +165,8 @@ bool XPlane::receive_data(void)
             loc.lat = data[1] * 1e7;
             loc.lng = data[2] * 1e7;
             loc.alt = data[3] * FEET_TO_METERS * 100.0f;
-            float hagl = data[4] * FEET_TO_METERS;
-            ground_level = loc.alt * 0.01f - hagl;
+            const float altitude_above_ground = data[4] * FEET_TO_METERS;
+            ground_level = loc.alt * 0.01f - altitude_above_ground;
             break;
         }
 

From 974d63a6b5f5128e56baeaef0409b561aec1d79d Mon Sep 17 00:00:00 2001
From: murata <ma2maru@gmail.com>
Date: Mon, 9 Jan 2017 11:10:37 +0900
Subject: [PATCH 002/200] AP_HAL: Change the format of the return value of the
 method header.

---
 libraries/AP_HAL/utility/srxl.cpp | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/libraries/AP_HAL/utility/srxl.cpp b/libraries/AP_HAL/utility/srxl.cpp
index 45507d2..a217dd8 100644
--- a/libraries/AP_HAL/utility/srxl.cpp
+++ b/libraries/AP_HAL/utility/srxl.cpp
@@ -128,7 +128,7 @@ static uint16_t srxl_crc16 (uint16_t crc, uint8_t new_byte)
  * @param[out]  num_values - number of RC channels extracted from srxl frame
  * @param[out]  values - array of RC channels with refreshed information as pulsewidth in microseconds Range: 800us - 2200us
  * @param[out]  failsafe_state - true: RC-receiver is in failsafe state, false: RC-receiver is not in failsafe state
- * @return      0: success
+ * @retval 0 success
  */
 static int srxl_channels_get_v1v2(uint16_t max_values, uint8_t *num_values, uint16_t *values, bool *failsafe_state)
 {
@@ -174,7 +174,7 @@ static int srxl_channels_get_v1v2(uint16_t max_values, uint8_t *num_values, uint
  * @param[out] num_values - number of RC channels extracted from srxl frame
  * @param[out] values - array of RC channels with refreshed information as pulsewidth in microseconds Range: 800us - 2200us
  * @param[out] failsafe_state - true: RC-receiver is in failsafe state, false: RC-receiver is not in failsafe state
- * @return 0: success
+ * @retval 0 success
  */
 static int srxl_channels_get_v5(uint16_t max_values, uint8_t *num_values, uint16_t *values, bool *failsafe_state)
 {
@@ -254,7 +254,10 @@ static int srxl_channels_get_v5(uint16_t max_values, uint8_t *num_values, uint16
  * @param[out] values - array of RC channels with refreshed information as pulsewidth in microseconds Range: 800us - 2200us
  * @param[in] maximum number of values supported by pixhawk
  * @param[out] failsafe_state - true: RC-receiver is in failsafe state, false: RC-receiver is not in failsafe state
- * @return 0: success
+ * @retval 0 success (a decoded packet)
+ * @retval 1 no packet yet (accumulating)
+ * @retval 2 unknown packet
+ * @retval 4 checksum error
  */
 int srxl_decode(uint64_t timestamp_us, uint8_t byte, uint8_t *num_values, uint16_t *values, uint16_t max_values, bool *failsafe_state)
 {

From e65887c393bb85b30911fe6194a2140d490faef3 Mon Sep 17 00:00:00 2001
From: murata <ma2maru@gmail.com>
Date: Fri, 6 Jan 2017 00:43:06 +0900
Subject: [PATCH 003/200] Copter: Change sprintf method to secure snprintf
 method.

---
 ArduCopter/Log.cpp    | 2 +-
 ArduCopter/system.cpp | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/ArduCopter/Log.cpp b/ArduCopter/Log.cpp
index d2b5cc0..af4c68e 100644
--- a/ArduCopter/Log.cpp
+++ b/ArduCopter/Log.cpp
@@ -920,7 +920,7 @@ void Copter::Log_Write_Vehicle_Startup_Messages()
 {
     // only 200(?) bytes are guaranteed by DataFlash
     char frame_buf[20];
-    sprintf(frame_buf, "Frame: %s", get_frame_string());
+    snprintf(frame_buf, sizeof(frame_buf), "Frame: %s", get_frame_string());
     DataFlash.Log_Write_Message(frame_buf);
     DataFlash.Log_Write_Mode(control_mode, control_mode_reason);
 #if AC_RALLY
diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index ab280fc..dbfe0fb 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -158,7 +158,7 @@ void Copter::init_ardupilot()
 #if FRSKY_TELEM_ENABLED == ENABLED
     // setup frsky, and pass a number of parameters to the library
     char firmware_buf[50];
-    sprintf(firmware_buf, FIRMWARE_STRING " %s", get_frame_string());
+    snprintf(firmware_buf, sizeof(firmware_buf), FIRMWARE_STRING " %s", get_frame_string());
     frsky_telemetry.init(serial_manager, firmware_buf,
                          get_frame_mav_type(),
                          &g.fs_batt_voltage, &g.fs_batt_mah, &ap.value);

From c6875e1756dcf97d269a9b2a1593f59c9c850c30 Mon Sep 17 00:00:00 2001
From: Francisco Ferreira <francisco-ferreira@mail.telepac.pt>
Date: Mon, 9 Jan 2017 16:15:59 +0000
Subject: [PATCH 004/200] AP_NavEKF2: remove editor information wrongly added
 in d408d25

---
 libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp | 2 --
 1 file changed, 2 deletions(-)

diff --git a/libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp b/libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp
index d441aeb..5796e83 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2_PosVelFusion.cpp
@@ -1,5 +1,3 @@
-/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-
-
 #include <AP_HAL/AP_HAL.h>
 
 #if HAL_CPU_CLASS >= HAL_CPU_CLASS_150

From d4daa100451d73c6a8176634dbf6d635fce4703c Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Tue, 10 Jan 2017 10:59:43 +0900
Subject: [PATCH 005/200] AP_Proximity: add MAV type to parameter descriptions

---
 libraries/AP_Proximity/AP_Proximity.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_Proximity/AP_Proximity.cpp b/libraries/AP_Proximity/AP_Proximity.cpp
index c3f830c..272bc02 100644
--- a/libraries/AP_Proximity/AP_Proximity.cpp
+++ b/libraries/AP_Proximity/AP_Proximity.cpp
@@ -27,7 +27,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _TYPE
     // @DisplayName: Proximity type
     // @Description: What type of proximity sensor is connected
-    // @Values: 0:None,1:LightWareSF40C
+    // @Values: 0:None,1:LightWareSF40C,2:MAVLink
     // @User: Standard
     AP_GROUPINFO("_TYPE",   1, AP_Proximity, _type[0], 0),
 
@@ -133,7 +133,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: 2_TYPE
     // @DisplayName: Second Proximity type
     // @Description: What type of proximity sensor is connected
-    // @Values: 0:None,1:LightWareSF40C
+    // @Values: 0:None,1:LightWareSF40C,2:MAVLink
     // @User: Advanced
     AP_GROUPINFO("2_TYPE", 16, AP_Proximity, _type[1], 0),
 

From 9b7f0f7957c0bf4652587dbf03dec573d07e913e Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sun, 8 Jan 2017 12:26:54 +1100
Subject: [PATCH 006/200] AP_HAL: make new_input() API clearer in comments

---
 libraries/AP_HAL/RCInput.h | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git a/libraries/AP_HAL/RCInput.h b/libraries/AP_HAL/RCInput.h
index d1db3b0..4017e4a 100644
--- a/libraries/AP_HAL/RCInput.h
+++ b/libraries/AP_HAL/RCInput.h
@@ -17,12 +17,9 @@ class AP_HAL::RCInput {
     virtual void teardown() {};
 
     /**
-     * Return true if there has been new input since the last read()
-     * call. This call also clears the new_input flag, so once it
-     * returns true it won't return true again until another frame is
-     * received.
+     * Return true if there has been new input since the last call to new_input()
      */
-    virtual bool new_input() = 0;
+    virtual bool new_input(void) = 0;
 
     /**
      * Return the number of valid channels in the last read

From 0a18f5e7b2369a4a91cf2da7565c45a880f522f9 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sun, 8 Jan 2017 12:37:07 +1100
Subject: [PATCH 007/200] HAL_Linux: fixed a bug in RCInput::new_input

when a library called read() it would clear the new input flag, which
would cause new_input() in the main loop to return false. This could
trigger a false RC failsafe.
---
 libraries/AP_HAL_Linux/RCInput.cpp       | 32 +++++++++++++++++---------------
 libraries/AP_HAL_Linux/RCInput.h         |  3 ++-
 libraries/AP_HAL_Linux/RCInput_Multi.cpp |  2 +-
 3 files changed, 20 insertions(+), 17 deletions(-)

diff --git a/libraries/AP_HAL_Linux/RCInput.cpp b/libraries/AP_HAL_Linux/RCInput.cpp
index 5f44a46..e1e93ef 100644
--- a/libraries/AP_HAL_Linux/RCInput.cpp
+++ b/libraries/AP_HAL_Linux/RCInput.cpp
@@ -25,8 +25,7 @@ extern const AP_HAL::HAL& hal;
 
 using namespace Linux;
 
-RCInput::RCInput() :
-    new_rc_input(false)
+RCInput::RCInput()
 {
     ppm_state._channel_counter = -1;
 }
@@ -37,7 +36,11 @@ void RCInput::init()
 
 bool RCInput::new_input()
 {
-    return new_rc_input;
+    bool ret = rc_input_count != last_rc_input_count;
+    if (ret) {
+        last_rc_input_count = rc_input_count;
+    }
+    return ret;
 }
 
 uint8_t RCInput::num_channels()
@@ -47,7 +50,6 @@ uint8_t RCInput::num_channels()
 
 uint16_t RCInput::read(uint8_t ch)
 {
-    new_rc_input = false;
     if (_override[ch]) {
         return _override[ch];
     }
@@ -84,7 +86,7 @@ bool RCInput::set_override(uint8_t channel, int16_t override)
     if (channel < LINUX_RC_INPUT_NUM_CHANNELS) {
         _override[channel] = override;
         if (override != 0) {
-            new_rc_input = true;
+            rc_input_count++;
             return true;
         }
     }
@@ -112,7 +114,7 @@ void RCInput::_process_ppmsum_pulse(uint16_t width_usec)
                 _pwm_values[i] = ppm_state._pulse_capt[i];
             }
             _num_channels = ppm_state._channel_counter;
-            new_rc_input = true;
+            rc_input_count++;
         }
         ppm_state._channel_counter = 0;
         return;
@@ -143,7 +145,7 @@ void RCInput::_process_ppmsum_pulse(uint16_t width_usec)
             _pwm_values[i] = ppm_state._pulse_capt[i];
         }
         _num_channels = ppm_state._channel_counter;
-        new_rc_input = true;
+        rc_input_count++;
         ppm_state._channel_counter = -1;
     }
 }
@@ -221,7 +223,7 @@ void RCInput::_process_sbus_pulse(uint16_t width_s0, uint16_t width_s1)
             }
             _num_channels = num_values;
             if (!sbus_failsafe) {
-                new_rc_input = true;
+                rc_input_count++;
             }
         }
         goto reset;
@@ -291,7 +293,7 @@ void RCInput::_process_dsm_pulse(uint16_t width_s0, uint16_t width_s1)
                     _pwm_values[i] = values[i];
                 }
                 _num_channels = num_values;
-                new_rc_input = true;
+                rc_input_count++;
             }
         }
         memset(&dsm_state, 0, sizeof(dsm_state));
@@ -349,7 +351,7 @@ void RCInput::_update_periods(uint16_t *periods, uint8_t len)
         _pwm_values[i] = periods[i];
     }
     _num_channels = len;
-    new_rc_input = true;
+    rc_input_count++;
 }
 
 
@@ -408,7 +410,7 @@ bool RCInput::add_dsm_input(const uint8_t *bytes, size_t nbytes)
                 if (num_values > _num_channels) {
                     _num_channels = num_values;
                 }
-                new_rc_input = true;
+                rc_input_count++;
 #if 0
                 printf("Decoded DSM %u channels %u %u %u %u %u %u %u %u\n",
                        (unsigned)num_values,
@@ -444,7 +446,7 @@ bool RCInput::add_sumd_input(const uint8_t *bytes, size_t nbytes)
                 }
             }
             _num_channels = channel_count;
-            new_rc_input = true;
+            rc_input_count++;
             ret = true;
         }
         nbytes--;
@@ -474,7 +476,7 @@ bool RCInput::add_st24_input(const uint8_t *bytes, size_t nbytes)
                 }
             }
             _num_channels = channel_count;
-            new_rc_input = true;
+            rc_input_count++;
             ret = true;
         }
         nbytes--;
@@ -503,7 +505,7 @@ bool RCInput::add_srxl_input(const uint8_t *bytes, size_t nbytes)
             }
             _num_channels = channel_count;
             if (failsafe_state == false) {
-                new_rc_input = true;
+                rc_input_count++;
             }
             ret = true;
         }
@@ -564,7 +566,7 @@ void RCInput::add_sbus_input(const uint8_t *bytes, size_t nbytes)
                     _num_channels = num_values;
                 }
                 if (!sbus_failsafe) {
-                    new_rc_input = true;
+                    rc_input_count++;
                 }
 #if 0
                 printf("Decoded SBUS %u channels %u %u %u %u %u %u %u %u %s\n",
diff --git a/libraries/AP_HAL_Linux/RCInput.h b/libraries/AP_HAL_Linux/RCInput.h
index fe51a79..19b49cf 100644
--- a/libraries/AP_HAL_Linux/RCInput.h
+++ b/libraries/AP_HAL_Linux/RCInput.h
@@ -47,7 +47,8 @@ class RCInput : public AP_HAL::RCInput {
     void _process_rc_pulse(uint16_t width_s0, uint16_t width_s1);
     void _update_periods(uint16_t *periods, uint8_t len);
 
-    volatile bool new_rc_input;
+    volatile uint32_t rc_input_count;
+    uint32_t last_rc_input_count;
 
     uint16_t _pwm_values[LINUX_RC_INPUT_NUM_CHANNELS];
     uint8_t  _num_channels;
diff --git a/libraries/AP_HAL_Linux/RCInput_Multi.cpp b/libraries/AP_HAL_Linux/RCInput_Multi.cpp
index dacad24..6f22e97 100644
--- a/libraries/AP_HAL_Linux/RCInput_Multi.cpp
+++ b/libraries/AP_HAL_Linux/RCInput_Multi.cpp
@@ -58,7 +58,7 @@ void RCInput_Multi::_timer_tick(void)
         if (inputs[i]->new_input()) {
             inputs[i]->read(_pwm_values, inputs[i]->num_channels());
             _num_channels = inputs[i]->num_channels();
-            new_rc_input = true;
+            rc_input_count++;
         }        
     }
 }

From 1dec5ba7238c1ca7bb30a219bdb657286d1d5528 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Wed, 11 Jan 2017 09:31:38 +1100
Subject: [PATCH 008/200] mavlink: submodule update

---
 modules/mavlink | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/modules/mavlink b/modules/mavlink
index 12cba5f..2d24de0 160000
--- a/modules/mavlink
+++ b/modules/mavlink
@@ -1 +1 @@
-Subproject commit 12cba5fb07c50d34f96b6f77c01744a5b39127b6
+Subproject commit 2d24de028d15673e2e3f83a32511cd8196b9b6b1

From bdbb07a3b1db1221524f757ff546c20f5c6137ff Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Wed, 11 Jan 2017 08:46:43 +0900
Subject: [PATCH 009/200] Copter: remove version from Copter.cpp

Also added wiki page URL
---
 ArduCopter/ArduCopter.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/ArduCopter/ArduCopter.cpp b/ArduCopter/ArduCopter.cpp
index cf76021..1c6f329 100644
--- a/ArduCopter/ArduCopter.cpp
+++ b/ArduCopter/ArduCopter.cpp
@@ -13,7 +13,8 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 /*
- *  ArduCopter Version 3.0
+ *  ArduCopter (also known as APM, APM:Copter or just Copter)
+ *  Wiki:           copter.ardupilot.org
  *  Creator:        Jason Short
  *  Lead Developer: Randy Mackay
  *  Lead Tester:    Marco Robustini 

From b910f230fb52c1ed9beb8e8347e2b96e2866651c Mon Sep 17 00:00:00 2001
From: Lucas De Marchi <lucas.demarchi@intel.com>
Date: Mon, 9 Jan 2017 22:08:42 -0800
Subject: [PATCH 010/200] AP_HAL_Linux: RCInput: replace volatile with atomic

---
 libraries/AP_HAL_Linux/RCInput.cpp | 2 +-
 libraries/AP_HAL_Linux/RCInput.h   | 8 +++++---
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/libraries/AP_HAL_Linux/RCInput.cpp b/libraries/AP_HAL_Linux/RCInput.cpp
index e1e93ef..a3b8866 100644
--- a/libraries/AP_HAL_Linux/RCInput.cpp
+++ b/libraries/AP_HAL_Linux/RCInput.cpp
@@ -38,7 +38,7 @@ bool RCInput::new_input()
 {
     bool ret = rc_input_count != last_rc_input_count;
     if (ret) {
-        last_rc_input_count = rc_input_count;
+        last_rc_input_count.store(rc_input_count);
     }
     return ret;
 }
diff --git a/libraries/AP_HAL_Linux/RCInput.h b/libraries/AP_HAL_Linux/RCInput.h
index 19b49cf..6ff251d 100644
--- a/libraries/AP_HAL_Linux/RCInput.h
+++ b/libraries/AP_HAL_Linux/RCInput.h
@@ -1,5 +1,7 @@
 #pragma once
 
+#include <atomic>
+
 #include "AP_HAL_Linux.h"
 
 #define LINUX_RC_INPUT_NUM_CHANNELS 16
@@ -42,13 +44,13 @@ class RCInput : public AP_HAL::RCInput {
 
     // add some srxl input bytes, for RCInput over a serial port
     bool add_srxl_input(const uint8_t *bytes, size_t nbytes);
-    
+
 protected:
     void _process_rc_pulse(uint16_t width_s0, uint16_t width_s1);
     void _update_periods(uint16_t *periods, uint8_t len);
 
-    volatile uint32_t rc_input_count;
-    uint32_t last_rc_input_count;
+    std::atomic<unsigned int> rc_input_count;
+    std::atomic<unsigned int> last_rc_input_count;
 
     uint16_t _pwm_values[LINUX_RC_INPUT_NUM_CHANNELS];
     uint8_t  _num_channels;

From 742cdf6b13a7cfa7e39c24a035b68d7d369582b8 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Wed, 11 Jan 2017 21:38:22 +0900
Subject: [PATCH 011/200] Copter: fix arming while armed bug

If a mavlink command was sent to arm the vehicle while it was already armed, the in_arm_motors boolean was left as true meaning the vehicle could never be armed again using a mavlink message.  This resolves issue #5546.
---
 ArduCopter/motors.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/ArduCopter/motors.cpp b/ArduCopter/motors.cpp
index 80f8291..1ea260e 100644
--- a/ArduCopter/motors.cpp
+++ b/ArduCopter/motors.cpp
@@ -132,6 +132,7 @@ bool Copter::init_arm_motors(bool arming_from_gcs)
 
     // return true if already armed
     if (motors.armed()) {
+        in_arm_motors = false;
         return true;
     }
 

From a0a8472a44321f97b65bb93b055a0f6c45ff8c83 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Tue, 10 Jan 2017 12:09:18 +0900
Subject: [PATCH 012/200] AP_Proximity: fix consumption of distance-sensor
 messages

---
 libraries/AP_Proximity/AP_Proximity.cpp       | 12 +++++++++++-
 libraries/AP_Proximity/AP_Proximity.h         |  3 +++
 libraries/AP_Proximity/AP_Proximity_Backend.h |  3 +++
 libraries/AP_Proximity/AP_Proximity_MAV.cpp   |  1 +
 libraries/AP_Proximity/AP_Proximity_MAV.h     |  2 +-
 5 files changed, 19 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_Proximity/AP_Proximity.cpp b/libraries/AP_Proximity/AP_Proximity.cpp
index 272bc02..1f78760 100644
--- a/libraries/AP_Proximity/AP_Proximity.cpp
+++ b/libraries/AP_Proximity/AP_Proximity.cpp
@@ -242,6 +242,16 @@ AP_Proximity::Proximity_Status AP_Proximity::get_status() const
     return get_status(primary_instance);
 }
 
+// handle mavlink DISTANCE_SENSOR messages
+void AP_Proximity::handle_msg(mavlink_message_t *msg)
+{
+    for (uint8_t i=0; i<num_instances; i++) {
+        if ((drivers[i] != nullptr) && (_type[i] != Proximity_Type_None)) {
+            drivers[i]->handle_msg(msg);
+        }
+    }
+}
+
 //  detect if an instance of a proximity sensor is connected.
 void AP_Proximity::detect_instance(uint8_t instance)
 {
@@ -340,7 +350,7 @@ bool AP_Proximity::get_distances(Proximity_Distance_Array &prx_dist_array) const
     if ((drivers[primary_instance] == nullptr) || (_type[primary_instance] == Proximity_Type_None)) {
         return 0.0f;
     }
-    // get maximum distance from backend
+    // get distances from backend
     return drivers[primary_instance]->get_distances(prx_dist_array);
 }
 
diff --git a/libraries/AP_Proximity/AP_Proximity.h b/libraries/AP_Proximity/AP_Proximity.h
index e509c3a..1908edd 100644
--- a/libraries/AP_Proximity/AP_Proximity.h
+++ b/libraries/AP_Proximity/AP_Proximity.h
@@ -98,6 +98,9 @@ class AP_Proximity
     float distance_max() const;
     float distance_min() const;
 
+    // handle mavlink DISTANCE_SENSOR messages
+    void handle_msg(mavlink_message_t *msg);
+
     // The Proximity_State structure is filled in by the backend driver
     struct Proximity_State {
         uint8_t                 instance;   // the instance number of this proximity sensor
diff --git a/libraries/AP_Proximity/AP_Proximity_Backend.h b/libraries/AP_Proximity/AP_Proximity_Backend.h
index 8471b8e..d4131c1 100644
--- a/libraries/AP_Proximity/AP_Proximity_Backend.h
+++ b/libraries/AP_Proximity/AP_Proximity_Backend.h
@@ -38,6 +38,9 @@ class AP_Proximity_Backend
     virtual float distance_max() const = 0;
     virtual float distance_min() const = 0;
 
+    // handle mavlink DISTANCE_SENSOR messages
+    virtual void handle_msg(mavlink_message_t *msg) {}
+
     // get distance in meters in a particular direction in degrees (0 is forward, clockwise)
     // returns true on successful read and places distance in distance
     bool get_horizontal_distance(float angle_deg, float &distance) const;
diff --git a/libraries/AP_Proximity/AP_Proximity_MAV.cpp b/libraries/AP_Proximity/AP_Proximity_MAV.cpp
index 3f3a2b6..19fef8c 100644
--- a/libraries/AP_Proximity/AP_Proximity_MAV.cpp
+++ b/libraries/AP_Proximity/AP_Proximity_MAV.cpp
@@ -58,5 +58,6 @@ void AP_Proximity_MAV::handle_msg(mavlink_message_t *msg)
         _distance_min = packet.min_distance / 100.0f;
         _distance_max = packet.max_distance / 100.0f;
         _last_update_ms = AP_HAL::millis();
+        update_boundary_for_sector(sector);
     }
 }
diff --git a/libraries/AP_Proximity/AP_Proximity_MAV.h b/libraries/AP_Proximity/AP_Proximity_MAV.h
index 5adc1a7..d898b54 100644
--- a/libraries/AP_Proximity/AP_Proximity_MAV.h
+++ b/libraries/AP_Proximity/AP_Proximity_MAV.h
@@ -20,7 +20,7 @@ class AP_Proximity_MAV : public AP_Proximity_Backend
     float distance_min() const { return _distance_min; };
 
     // handle mavlink DISTANCE_SENSOR messages
-    void handle_msg(mavlink_message_t *msg);
+    void handle_msg(mavlink_message_t *msg) override;
 
 private:
 

From 20ca021cab01bd2bff78fff40e2fb088d5f9e360 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Tue, 10 Jan 2017 12:09:39 +0900
Subject: [PATCH 013/200] Copter: pass distance-sensor messages to AP_Proximity

---
 ArduCopter/GCS_Mavlink.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/ArduCopter/GCS_Mavlink.cpp b/ArduCopter/GCS_Mavlink.cpp
index 2c4685c..4553848 100644
--- a/ArduCopter/GCS_Mavlink.cpp
+++ b/ArduCopter/GCS_Mavlink.cpp
@@ -1765,6 +1765,9 @@ void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
     {
         result = MAV_RESULT_ACCEPTED;
         copter.rangefinder.handle_msg(msg);
+#if PROXIMITY_ENABLED == ENABLED
+        copter.g2.proximity.handle_msg(msg);
+#endif
         break;
     }
 

From 74f1899aeb401b0fbe5449700ef3d3f0b310bd44 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Tue, 10 Jan 2017 14:02:43 +0900
Subject: [PATCH 014/200] AP_Proximity: boundary_points requires only one valid
 distance

Object avoidance is possible with just one valid distance
Boundary is initialised in new init_boundary function to be 100m from
vehicle
If sectors do not have valid distance measurements, we use the distance
from adjacent sectors.  This conveniently leads to a concave shaped
boundary that keeps the vehicle from travelling into the dataless sector.
---
 libraries/AP_Proximity/AP_Proximity_Backend.cpp    | 69 ++++++++++++++++------
 libraries/AP_Proximity/AP_Proximity_Backend.h      |  5 ++
 .../AP_Proximity/AP_Proximity_LightWareSF40C.cpp   |  3 +
 3 files changed, 59 insertions(+), 18 deletions(-)

diff --git a/libraries/AP_Proximity/AP_Proximity_Backend.cpp b/libraries/AP_Proximity/AP_Proximity_Backend.cpp
index c8801ad..bbf37f3 100644
--- a/libraries/AP_Proximity/AP_Proximity_Backend.cpp
+++ b/libraries/AP_Proximity/AP_Proximity_Backend.cpp
@@ -26,6 +26,8 @@ AP_Proximity_Backend::AP_Proximity_Backend(AP_Proximity &_frontend, AP_Proximity
         frontend(_frontend),
         state(_state)
 {
+    // initialise sector edge vector used for building the boundary fence
+    init_boundary();
 }
 
 // get distance in meters in a particular direction in degrees (0 is forward, angles increase in the clockwise direction)
@@ -142,19 +144,36 @@ const Vector2f* AP_Proximity_Backend::get_boundary_points(uint16_t& num_points)
         return nullptr;
     }
 
-    // check all sectors have valid data, if not, exit
+    // check at least one sector has valid data, if not, exit
+    bool some_valid = false;
     for (uint8_t i=0; i<_num_sectors; i++) {
-        if (!_distance_valid[i]) {
-            num_points = 0;
-            return nullptr;
+        if (_distance_valid[i]) {
+            some_valid = true;
+            break;
         }
     }
+    if (!some_valid) {
+        num_points = 0;
+        return nullptr;
+    }
 
     // return boundary points
     num_points = _num_sectors;
     return _boundary_point;
 }
 
+// initialise the boundary and sector_edge_vector array used for object avoidance
+//   should be called if the sector_middle_deg or _setor_width_deg arrays are changed
+void AP_Proximity_Backend::init_boundary()
+{
+    for (uint8_t sector=0; sector < _num_sectors; sector++) {
+        float angle_rad = radians((float)_sector_middle_deg[sector]+(float)_sector_width_deg[sector]/2.0f);
+        _sector_edge_vector[sector].x = cosf(angle_rad) * 100.0f;
+        _sector_edge_vector[sector].y = sinf(angle_rad) * 100.0f;
+        _boundary_point[sector] = _sector_edge_vector[sector] * PROXIMITY_BOUNDARY_DIST_DEFAULT;
+    }
+}
+
 // update boundary points used for object avoidance based on a single sector's distance changing
 //   the boundary points lie on the line between sectors meaning two boundary points may be updated based on a single sector's distance changing
 //   the boundary point is set to the shortest distance found in the two adjacent sectors, this is a conservative boundary around the vehicle
@@ -165,13 +184,6 @@ void AP_Proximity_Backend::update_boundary_for_sector(uint8_t sector)
         return;
     }
 
-    // initialise sector_edge_vector if necessary
-    if (_sector_edge_vector[sector].is_zero()) {
-        float angle_rad = radians((float)_sector_middle_deg[sector]+(float)_sector_width_deg[sector]/2.0f);
-        _sector_edge_vector[sector].x = cosf(angle_rad) * 100.0f;
-        _sector_edge_vector[sector].y = sinf(angle_rad) * 100.0f;
-    }
-
     // find adjacent sector (clockwise)
     uint8_t next_sector = sector + 1;
     if (next_sector >= _num_sectors) {
@@ -179,19 +191,40 @@ void AP_Proximity_Backend::update_boundary_for_sector(uint8_t sector)
     }
 
     // boundary point lies on the line between the two sectors at the shorter distance found in the two sectors
+    float shortest_distance = PROXIMITY_BOUNDARY_DIST_DEFAULT;
     if (_distance_valid[sector] && _distance_valid[next_sector]) {
-        float shortest_distance = MIN(_distance[sector], _distance[next_sector]);
-        if (shortest_distance < PROXIMITY_BOUNDARY_DIST_MIN) {
-            shortest_distance = PROXIMITY_BOUNDARY_DIST_MIN;
-        }
-        _boundary_point[sector] = _sector_edge_vector[sector] * shortest_distance;
+        shortest_distance = MIN(_distance[sector], _distance[next_sector]);
+    } else if (_distance_valid[sector]) {
+        shortest_distance = _distance[sector];
+    } else if (_distance_valid[next_sector]) {
+        shortest_distance = _distance[next_sector];
+    }
+    if (shortest_distance < PROXIMITY_BOUNDARY_DIST_MIN) {
+        shortest_distance = PROXIMITY_BOUNDARY_DIST_MIN;
+    }
+    _boundary_point[sector] = _sector_edge_vector[sector] * shortest_distance;
+
+    // if the next sector (clockwise) has an invalid distance, set boundary to create a cup like boundary
+    if (!_distance_valid[next_sector]) {
+        _boundary_point[next_sector] = _sector_edge_vector[next_sector] * shortest_distance;
     }
 
     // repeat for edge between sector and previous sector
     uint8_t prev_sector = (sector == 0) ? _num_sectors-1 : sector-1;
+    shortest_distance = PROXIMITY_BOUNDARY_DIST_DEFAULT;
     if (_distance_valid[prev_sector] && _distance_valid[sector]) {
-        float shortest_distance = MIN(_distance[prev_sector], _distance[sector]);
-        _boundary_point[prev_sector] = _sector_edge_vector[prev_sector] * shortest_distance;
+        shortest_distance = MIN(_distance[prev_sector], _distance[sector]);
+    } else if (_distance_valid[prev_sector]) {
+        shortest_distance = _distance[prev_sector];
+    } else if (_distance_valid[sector]) {
+        shortest_distance = _distance[sector];
+    }
+    _boundary_point[prev_sector] = _sector_edge_vector[prev_sector] * shortest_distance;
+
+    // if the sector counter-clockwise from the previous sector has an invalid distance, set boundary to create a cup like boundary
+    uint8_t prev_sector_ccw = (prev_sector == 0) ? _num_sectors-1 : prev_sector-1;
+    if (!_distance_valid[prev_sector_ccw]) {
+        _boundary_point[prev_sector_ccw] = _sector_edge_vector[prev_sector_ccw] * shortest_distance;
     }
 }
 
diff --git a/libraries/AP_Proximity/AP_Proximity_Backend.h b/libraries/AP_Proximity/AP_Proximity_Backend.h
index d4131c1..2410232 100644
--- a/libraries/AP_Proximity/AP_Proximity_Backend.h
+++ b/libraries/AP_Proximity/AP_Proximity_Backend.h
@@ -20,6 +20,7 @@
 
 #define PROXIMITY_SECTORS_MAX   12  // maximum number of sectors
 #define PROXIMITY_BOUNDARY_DIST_MIN 0.6f    // minimum distance for a boundary point.  This ensures the object avoidance code doesn't think we are outside the boundary.
+#define PROXIMITY_BOUNDARY_DIST_DEFAULT 100 // if we have no data for a sector, boundary is placed 100m out
 
 class AP_Proximity_Backend
 {
@@ -68,6 +69,10 @@ class AP_Proximity_Backend
     // find which sector a given angle falls into
     bool convert_angle_to_sector(float angle_degrees, uint8_t &sector) const;
 
+    // initialise the boundary and sector_edge_vector array used for object avoidance
+    //   should be called if the sector_middle_deg or _setor_width_deg arrays are changed
+    void init_boundary();
+
     // update boundary points used for object avoidance based on a single sector's distance changing
     //   the boundary points lie on the line between sectors meaning two boundary points may be updated based on a single sector's distance changing
     //   the boundary point is set to the shortest distance found in the two adjacent sectors, this is a conservative boundary around the vehicle
diff --git a/libraries/AP_Proximity/AP_Proximity_LightWareSF40C.cpp b/libraries/AP_Proximity/AP_Proximity_LightWareSF40C.cpp
index f39b7c1..984ec8c 100644
--- a/libraries/AP_Proximity/AP_Proximity_LightWareSF40C.cpp
+++ b/libraries/AP_Proximity/AP_Proximity_LightWareSF40C.cpp
@@ -162,6 +162,9 @@ void AP_Proximity_LightWareSF40C::init_sectors()
     // set num sectors
     _num_sectors = sector;
 
+    // re-initialise boundary because sector locations have changed
+    init_boundary();
+
     // record success
     _sector_initialised = true;
 }

From 7c7144fd8fa421c9811001adc702d8006648c7f8 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Tue, 10 Jan 2017 15:12:30 +0900
Subject: [PATCH 015/200] AP_Proximity: minor comment spelling fix

---
 libraries/AP_Proximity/AP_Proximity_LightWareSF40C.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_Proximity/AP_Proximity_LightWareSF40C.h b/libraries/AP_Proximity/AP_Proximity_LightWareSF40C.h
index 930f366..246a8cc 100644
--- a/libraries/AP_Proximity/AP_Proximity_LightWareSF40C.h
+++ b/libraries/AP_Proximity/AP_Proximity_LightWareSF40C.h
@@ -33,7 +33,7 @@ class AP_Proximity_LightWareSF40C : public AP_Proximity_Backend
         RequestType_DistanceMeasurement
     };
 
-    // initialise sensor (returns true if sensor is succesfully initialised)
+    // initialise sensor (returns true if sensor is successfully initialised)
     bool initialise();
     void init_sectors();
     void set_motor_speed(bool on_off);

From 1432763ca546b88f885a3910f9efc824b1bcf66f Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Wed, 11 Jan 2017 16:02:05 +1100
Subject: [PATCH 016/200] Tools: permit overriding shell to use when running in
 terminal window

---
 Tools/autotest/run_in_terminal_window.sh | 21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/Tools/autotest/run_in_terminal_window.sh b/Tools/autotest/run_in_terminal_window.sh
index 1d7a008..25816ed 100755
--- a/Tools/autotest/run_in_terminal_window.sh
+++ b/Tools/autotest/run_in_terminal_window.sh
@@ -6,8 +6,25 @@
 name="$1"
 shift
 echo "RiTW: Starting $name : $*"
-# default to xterm as it has the most consistent options and can start minimised
-if [ -n "$DISPLAY" -a -n "$(which osascript)" ]; then
+
+if [ -n "$SITL_RITW_TERMINAL" ]; then
+  # create a small shell script containing the command to run; this
+  # avoids problems where "screen" expects arguments in
+  # argv[1],argv[2],argv[3] where gnome-terminal expects the command
+  # to run be in argv[n+1] where argv[n] is "-e"
+  # this should work with:
+  # export SITL_RITW_TERMINAL="screen -D -m"
+  # export SITL_RITW_TERMINAL="gnome-terminal -e"
+  # export SITL_RITW_TERMINAL="konsole -e"
+
+  test -z "$TMPDIR" && TMPDIR="/tmp/"
+  FILENAME="ritw-`date '+%Y%m%d%H%M%S'`"
+  FILEPATH="$TMPDIR/$FILENAME"
+  echo "#!/bin/sh" >"$FILEPATH"
+  echo "$*" >>"$FILEPATH"
+  chmod +x "$FILEPATH"
+  $SITL_RITW_TERMINAL "$FILEPATH" &
+elif [ -n "$DISPLAY" -a -n "$(which osascript)" ]; then
   osascript -e 'tell application "Terminal" to do script "'"$* "'"'
 elif [ -n "$DISPLAY" -a -n "$(which xterm)" ]; then
   xterm -iconic -xrm 'XTerm*selectToClipboard: true' -xrm 'XTerm*initialFont: 6' -n "$name" -name "$name" -T "$name" -hold -e $* &

From b1e494a2093b3a487c21b81f631d800303cf6c60 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Thu, 12 Jan 2017 09:27:02 +0900
Subject: [PATCH 017/200] Copter: return MAV_TYPE as quadcopter by default

This allows the GCSs to know that the firmware is for a multicopter
---
 ArduCopter/system.cpp | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index dbfe0fb..4ed6e04 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -497,6 +497,7 @@ uint8_t Copter::get_frame_mav_type()
 {
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
         case AP_Motors::MOTOR_FRAME_QUAD:
+        case AP_Motors::MOTOR_FRAME_UNDEFINED:
             return MAV_TYPE_QUADROTOR;
         case AP_Motors::MOTOR_FRAME_HEXA:
         case AP_Motors::MOTOR_FRAME_Y6:
@@ -511,9 +512,6 @@ uint8_t Copter::get_frame_mav_type()
         case AP_Motors::MOTOR_FRAME_SINGLE:
         case AP_Motors::MOTOR_FRAME_COAX:
             return MAV_TYPE_COAXIAL;
-        case AP_Motors::MOTOR_FRAME_UNDEFINED:
-        default:
-            break;
     }
     // unknown frame so return generic
     return MAV_TYPE_GENERIC;

From d35433b25336b919d6aff6f99f5c01dc2cd9743c Mon Sep 17 00:00:00 2001
From: "Dr.-Ing. Amilcar Do Carmo Lucas" <amilcar.lucas@iav.de>
Date: Wed, 11 Jan 2017 11:33:30 +0100
Subject: [PATCH 018/200] gitignore: ignore generated parameter documentation
 files

---
 .gitignore | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/.gitignore b/.gitignore
index e97592d..e75986a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,10 @@
 /.waf*
 /Tools/autotest/aircraft/Rascal/reset.xml
 /Tools/autotest/ch7_mission.txt
+/Tools/autotest/param_metadata/Parameters.html
+/Tools/autotest/param_metadata/Parameters.rst
+/Tools/autotest/param_metadata/Parameters.wiki
+/Tools/autotest/param_metadata/apm.pdef.xml
 /Tools/autotest/jsb_sim/fgout.xml
 /Tools/autotest/jsb_sim/rascal_test.xml
 /Tools/autotest/jsbsim_fgout_0.xml

From 5b2b4430b3c82b428b2339054e6b1613f17c2c33 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 9 Jan 2017 13:22:43 +0100
Subject: [PATCH 019/200] AP_HAL_SITL: AnalogIn minor fixes

change pin to int16_t to match real implementation and prevent casting.
make constructor explicit
---
 libraries/AP_HAL_SITL/AnalogIn.cpp | 2 +-
 libraries/AP_HAL_SITL/AnalogIn.h   | 8 +++-----
 2 files changed, 4 insertions(+), 6 deletions(-)

diff --git a/libraries/AP_HAL_SITL/AnalogIn.cpp b/libraries/AP_HAL_SITL/AnalogIn.cpp
index 957c27f..920851a 100644
--- a/libraries/AP_HAL_SITL/AnalogIn.cpp
+++ b/libraries/AP_HAL_SITL/AnalogIn.cpp
@@ -9,7 +9,7 @@ using namespace HALSITL;
 
 extern const AP_HAL::HAL& hal;
 
-ADCSource::ADCSource(SITL_State *sitlState, uint8_t pin) :
+ADCSource::ADCSource(SITL_State *sitlState, int16_t pin) :
     _sitlState(sitlState),
     _pin(pin)
 {}
diff --git a/libraries/AP_HAL_SITL/AnalogIn.h b/libraries/AP_HAL_SITL/AnalogIn.h
index 936fcea..c05d8d9 100644
--- a/libraries/AP_HAL_SITL/AnalogIn.h
+++ b/libraries/AP_HAL_SITL/AnalogIn.h
@@ -9,7 +9,7 @@ class HALSITL::ADCSource : public AP_HAL::AnalogSource {
 public:
     friend class HALSITL::AnalogIn;
     /* pin designates the ADC input number */
-    ADCSource(SITL_State *sitlState, uint8_t pin);
+    ADCSource(SITL_State *sitlState, int16_t pin);
 
     /* implement AnalogSource virtual api: */
     float read_average();
@@ -25,16 +25,14 @@ class HALSITL::ADCSource : public AP_HAL::AnalogSource {
 
 private:
     SITL_State *_sitlState;
-    uint8_t _pin;
+    int16_t _pin;
 };
 
 /* AnalogIn : a concrete class providing the implementations of the
  * timer event and the AP_HAL::AnalogIn interface */
 class HALSITL::AnalogIn : public AP_HAL::AnalogIn {
 public:
-    AnalogIn(SITL_State *sitlState) {
-        _sitlState = sitlState;
-    }
+    explicit AnalogIn(SITL_State *sitlState): _sitlState(sitlState) {}
     void init();
     AP_HAL::AnalogSource* channel(int16_t n);
     float board_voltage(void) {

From 8ade9d1fe831e387b3255b21d3b12e3e3e3560d8 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 9 Jan 2017 13:23:23 +0100
Subject: [PATCH 020/200] AP_HAL_SITL: style fixes

---
 libraries/AP_HAL_SITL/AP_HAL_SITL.h           |  2 +-
 libraries/AP_HAL_SITL/AP_HAL_SITL_Namespace.h |  2 +-
 libraries/AP_HAL_SITL/HAL_SITL_Class.cpp      | 32 +++++++++++++--------------
 libraries/AP_HAL_SITL/HAL_SITL_Class.h        |  2 +-
 libraries/AP_HAL_SITL/Semaphores.cpp          | 10 ++++-----
 libraries/AP_HAL_SITL/Semaphores.h            |  2 +-
 6 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/libraries/AP_HAL_SITL/AP_HAL_SITL.h b/libraries/AP_HAL_SITL/AP_HAL_SITL.h
index 68a4ea0..10c4aa7 100644
--- a/libraries/AP_HAL_SITL/AP_HAL_SITL.h
+++ b/libraries/AP_HAL_SITL/AP_HAL_SITL.h
@@ -6,4 +6,4 @@
 
 #include "HAL_SITL_Class.h"
 
-#endif // CONFIG_HAL_BOARD
+#endif  // CONFIG_HAL_BOARD
diff --git a/libraries/AP_HAL_SITL/AP_HAL_SITL_Namespace.h b/libraries/AP_HAL_SITL/AP_HAL_SITL_Namespace.h
index 58e9abc..a5d54c4 100644
--- a/libraries/AP_HAL_SITL/AP_HAL_SITL_Namespace.h
+++ b/libraries/AP_HAL_SITL/AP_HAL_SITL_Namespace.h
@@ -14,4 +14,4 @@ class Util;
 class Semaphore;
 class GPIO;
 class DigitalSource;
-}
+}  // namespace HALSITL
diff --git a/libraries/AP_HAL_SITL/HAL_SITL_Class.cpp b/libraries/AP_HAL_SITL/HAL_SITL_Class.cpp
index 84eedd0..b11c5ce 100644
--- a/libraries/AP_HAL_SITL/HAL_SITL_Class.cpp
+++ b/libraries/AP_HAL_SITL/HAL_SITL_Class.cpp
@@ -46,22 +46,22 @@ static Util utilInstance(&sitlState);
 
 HAL_SITL::HAL_SITL() :
     AP_HAL::HAL(
-        &sitlUart0Driver,  /* uartA */
-        &sitlUart1Driver,  /* uartB */
-        &sitlUart2Driver,  /* uartC */
-        &sitlUart3Driver,  /* uartD */
-        &sitlUart4Driver,  /* uartE */
-        &sitlUart5Driver,  /* uartF */
+        &sitlUart0Driver,   /* uartA */
+        &sitlUart1Driver,   /* uartB */
+        &sitlUart2Driver,   /* uartC */
+        &sitlUart3Driver,   /* uartD */
+        &sitlUart4Driver,   /* uartE */
+        &sitlUart5Driver,   /* uartF */
         &i2c_mgr_instance,
-        &emptySPI, /* spi */
-        &sitlAnalogIn, /* analogin */
+        &emptySPI,          /* spi */
+        &sitlAnalogIn,      /* analogin */
         &sitlEEPROMStorage, /* storage */
-        &sitlUart0Driver, /* console */
-        &sitlGPIO, /* gpio */
-        &sitlRCInput,  /* rcinput */
-        &sitlRCOutput, /* rcoutput */
-        &sitlScheduler, /* scheduler */
-        &utilInstance, /* util */
+        &sitlUart0Driver,   /* console */
+        &sitlGPIO,          /* gpio */
+        &sitlRCInput,       /* rcinput */
+        &sitlRCOutput,      /* rcoutput */
+        &sitlScheduler,     /* scheduler */
+        &utilInstance,      /* util */
         &emptyOpticalFlow), /* onboard optical flow */
     _sitl_state(&sitlState)
 {}
@@ -77,7 +77,7 @@ void HAL_SITL::run(int argc, char * const argv[], Callbacks* callbacks) const
     rcin->init();
     rcout->init();
 
-    //spi->init();
+    // spi->init();
     analogin->init();
 
     callbacks->setup();
@@ -93,4 +93,4 @@ const AP_HAL::HAL& AP_HAL::get_HAL() {
     return hal;
 }
 
-#endif // CONFIG_HAL_BOARD == HAL_BOARD_SITL
+#endif  // CONFIG_HAL_BOARD == HAL_BOARD_SITL
diff --git a/libraries/AP_HAL_SITL/HAL_SITL_Class.h b/libraries/AP_HAL_SITL/HAL_SITL_Class.h
index 09f2711..268ee6f 100644
--- a/libraries/AP_HAL_SITL/HAL_SITL_Class.h
+++ b/libraries/AP_HAL_SITL/HAL_SITL_Class.h
@@ -17,4 +17,4 @@ class HAL_SITL : public AP_HAL::HAL {
     HALSITL::SITL_State *_sitl_state;
 };
 
-#endif // CONFIG_HAL_BOARD == HAL_BOARD_SITL
+#endif  // CONFIG_HAL_BOARD == HAL_BOARD_SITL
diff --git a/libraries/AP_HAL_SITL/Semaphores.cpp b/libraries/AP_HAL_SITL/Semaphores.cpp
index 5c46a07..5a207d7 100644
--- a/libraries/AP_HAL_SITL/Semaphores.cpp
+++ b/libraries/AP_HAL_SITL/Semaphores.cpp
@@ -8,12 +8,12 @@ extern const AP_HAL::HAL& hal;
 
 using namespace HALSITL;
 
-bool Semaphore::give() 
+bool Semaphore::give()
 {
     return pthread_mutex_unlock(&_lock) == 0;
 }
 
-bool Semaphore::take(uint32_t timeout_ms) 
+bool Semaphore::take(uint32_t timeout_ms)
 {
     if (timeout_ms == 0) {
         return pthread_mutex_lock(&_lock) == 0;
@@ -27,13 +27,13 @@ bool Semaphore::take(uint32_t timeout_ms)
         if (take_nonblocking()) {
             return true;
         }
-    } while ((AP_HAL::micros64() - start) < timeout_ms*1000);
+    } while ((AP_HAL::micros64() - start) < timeout_ms * 1000);
     return false;
 }
 
-bool Semaphore::take_nonblocking() 
+bool Semaphore::take_nonblocking()
 {
     return pthread_mutex_trylock(&_lock) == 0;
 }
 
-#endif // CONFIG_HAL_BOARD
+#endif  // CONFIG_HAL_BOARD
diff --git a/libraries/AP_HAL_SITL/Semaphores.h b/libraries/AP_HAL_SITL/Semaphores.h
index f36d253..04a2253 100644
--- a/libraries/AP_HAL_SITL/Semaphores.h
+++ b/libraries/AP_HAL_SITL/Semaphores.h
@@ -17,5 +17,5 @@ class HALSITL::Semaphore : public AP_HAL::Semaphore {
 private:
     pthread_mutex_t _lock;
 };
-#endif // CONFIG_HAL_BOARD
+#endif  // CONFIG_HAL_BOARD
 

From 7f5b32f59f0c0593620883085eb6791857ea36e8 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 9 Jan 2017 13:25:29 +0100
Subject: [PATCH 021/200] AP_HAL_SITL: GPIO minor fixes

fix style
make constructor explicit
fix implicit cast for unsigned to signed value
correct DigitalSource constructor definition
---
 libraries/AP_HAL_SITL/GPIO.cpp | 38 +++++++++++++++++++++-----------------
 libraries/AP_HAL_SITL/GPIO.h   | 30 ++++++++++++++----------------
 2 files changed, 35 insertions(+), 33 deletions(-)

diff --git a/libraries/AP_HAL_SITL/GPIO.cpp b/libraries/AP_HAL_SITL/GPIO.cpp
index ff54ceb..6de3a40 100644
--- a/libraries/AP_HAL_SITL/GPIO.cpp
+++ b/libraries/AP_HAL_SITL/GPIO.cpp
@@ -13,33 +13,32 @@ void GPIO::pinMode(uint8_t pin, uint8_t output)
 
 int8_t GPIO::analogPinToDigitalPin(uint8_t pin)
 {
-	return pin;
+    return pin;
 }
 
-
 uint8_t GPIO::read(uint8_t pin)
 {
-    if (!sitlState->_sitl) {
+    if (!_sitlState->_sitl) {
         return 0;
     }
-    uint8_t mask = sitlState->_sitl->pin_mask.get();
-    return mask & (1U<<pin)? 1: 0;
+    uint8_t mask = static_cast<uint8_t>(_sitlState->_sitl->pin_mask.get());
+    return static_cast<uint8_t>((mask & (1U << pin)) ? 1 : 0);
 }
 
 void GPIO::write(uint8_t pin, uint8_t value)
 {
-    if (!sitlState->_sitl) {
+    if (!_sitlState->_sitl) {
         return;
     }
-    uint8_t mask = sitlState->_sitl->pin_mask.get();
+    uint8_t mask = static_cast<uint8_t>(_sitlState->_sitl->pin_mask.get());
     uint8_t new_mask = mask;
     if (value) {
-        new_mask |= (1U<<pin);
+        new_mask |= (1U << pin);
     } else {
-        new_mask &= ~(1U<<pin);
+        new_mask &= ~(1U << pin);
     }
     if (mask != new_mask) {
-        sitlState->_sitl->pin_mask.set_and_notify(new_mask);
+        _sitlState->_sitl->pin_mask.set_and_notify(new_mask);
     }
 }
 
@@ -50,7 +49,12 @@ void GPIO::toggle(uint8_t pin)
 
 /* Alternative interface: */
 AP_HAL::DigitalSource* GPIO::channel(uint16_t n) {
-    return new DigitalSource(0);
+    if (n < 8) {  // (ie. sizeof(pin_mask)*8)
+        return new DigitalSource(static_cast<uint8_t>(n));
+    } else {
+        return nullptr;
+    }
+
 }
 
 /* Interrupt interface: */
@@ -64,8 +68,8 @@ bool GPIO::usb_connected(void)
     return false;
 }
 
-DigitalSource::DigitalSource(uint8_t v) :
-    pin(v)
+DigitalSource::DigitalSource(uint8_t pin) :
+    _pin(pin)
 {}
 
 void DigitalSource::mode(uint8_t output)
@@ -73,16 +77,16 @@ void DigitalSource::mode(uint8_t output)
 
 uint8_t DigitalSource::read()
 {
-    return hal.gpio->read(pin);
+    return hal.gpio->read(_pin);
 }
 
 void DigitalSource::write(uint8_t value)
 {
-    value = value?1:0;
-    return hal.gpio->write(pin, value);
+    value = static_cast<uint8_t>(value ? 1 : 0);
+    return hal.gpio->write(_pin, value);
 }
 
 void DigitalSource::toggle()
 {
-    return hal.gpio->write(pin, !hal.gpio->read(pin));
+    return hal.gpio->write(_pin, !hal.gpio->read(_pin));
 }
diff --git a/libraries/AP_HAL_SITL/GPIO.h b/libraries/AP_HAL_SITL/GPIO.h
index d31f443..7c36ccf 100644
--- a/libraries/AP_HAL_SITL/GPIO.h
+++ b/libraries/AP_HAL_SITL/GPIO.h
@@ -4,38 +4,36 @@
 
 class HALSITL::GPIO : public AP_HAL::GPIO {
 public:
-    GPIO(SITL_State *_sitlState) {
-        sitlState = _sitlState;
-    }
-    void    init();
-    void    pinMode(uint8_t pin, uint8_t output);
-    int8_t  analogPinToDigitalPin(uint8_t pin);
+    explicit GPIO(SITL_State *sitlState): _sitlState(sitlState) {}
+    void init();
+    void pinMode(uint8_t pin, uint8_t output);
+    int8_t analogPinToDigitalPin(uint8_t pin);
     uint8_t read(uint8_t pin);
-    void    write(uint8_t pin, uint8_t value);
-    void    toggle(uint8_t pin);
+    void write(uint8_t pin, uint8_t value);
+    void toggle(uint8_t pin);
 
     /* Alternative interface: */
     AP_HAL::DigitalSource* channel(uint16_t n);
 
     /* Interrupt interface: */
-    bool    attach_interrupt(uint8_t interrupt_num, AP_HAL::Proc p,
+    bool attach_interrupt(uint8_t interrupt_num, AP_HAL::Proc p,
             uint8_t mode);
 
     /* return true if USB cable is connected */
-    bool    usb_connected(void);
+    bool usb_connected(void);
 
 private:
-    SITL_State *sitlState;
+    SITL_State *_sitlState;
 };
 
 class HALSITL::DigitalSource : public AP_HAL::DigitalSource {
 public:
-    DigitalSource(uint8_t _pin);
-    void    mode(uint8_t output);
+    explicit DigitalSource(uint8_t pin);
+    void mode(uint8_t output);
     uint8_t read();
-    void    write(uint8_t value); 
-    void    toggle();
+    void write(uint8_t value);
+    void toggle();
 
 private:
-    uint8_t pin;
+    uint8_t _pin;
 };

From ff46964d221f69cebc7a3735bb6cdb5424d04ce9 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 9 Jan 2017 13:28:35 +0100
Subject: [PATCH 022/200] AP_HAL_SITL: RCInput minor fix

fix style
make constructor explicit
remove unused _valid
correct read to return real length instead of fixed 8
correct implicit cast
---
 libraries/AP_HAL_SITL/RCInput.cpp | 10 ++++++----
 libraries/AP_HAL_SITL/RCInput.h   |  7 ++-----
 2 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/libraries/AP_HAL_SITL/RCInput.cpp b/libraries/AP_HAL_SITL/RCInput.cpp
index 443dd60..0639d21 100644
--- a/libraries/AP_HAL_SITL/RCInput.cpp
+++ b/libraries/AP_HAL_SITL/RCInput.cpp
@@ -37,10 +37,10 @@ uint8_t RCInput::read(uint16_t* periods, uint8_t len)
     if (len > SITL_RC_INPUT_CHANNELS) {
         len = SITL_RC_INPUT_CHANNELS;
     }
-    for (uint8_t i=0; i<len; i++) {
+    for (uint8_t i=0; i < len; i++) {
         periods[i] = read(i);
     }
-    return 8;
+    return len;
 }
 
 bool RCInput::set_overrides(int16_t *overrides, uint8_t len)
@@ -57,9 +57,11 @@ bool RCInput::set_overrides(int16_t *overrides, uint8_t len)
 
 bool RCInput::set_override(uint8_t channel, int16_t override)
 {
-    if (override < 0) return false; /* -1: no change. */
+    if (override < 0) {
+        return false;  /* -1: no change. */
+    }
     if (channel < SITL_RC_INPUT_CHANNELS) {
-        _override[channel] = override;
+        _override[channel] = static_cast<uint16_t>(override);
         if (override != 0) {
             return true;
         }
diff --git a/libraries/AP_HAL_SITL/RCInput.h b/libraries/AP_HAL_SITL/RCInput.h
index 8a4b971..f18f979 100644
--- a/libraries/AP_HAL_SITL/RCInput.h
+++ b/libraries/AP_HAL_SITL/RCInput.h
@@ -9,11 +9,9 @@
 
 class HALSITL::RCInput : public AP_HAL::RCInput {
 public:
-    RCInput(SITL_State *sitlState) {
-        _sitlState = sitlState;
-    }
+    explicit RCInput(SITL_State *sitlState): _sitlState(sitlState) {}
     void init() override;
-    bool  new_input() override;
+    bool new_input() override;
     uint8_t num_channels() override {
         return SITL_RC_INPUT_CHANNELS;
     }
@@ -26,7 +24,6 @@ class HALSITL::RCInput : public AP_HAL::RCInput {
 
 private:
     SITL_State *_sitlState;
-    bool _valid;
 
     /* override state */
     uint16_t _override[SITL_RC_INPUT_CHANNELS];

From 63b3618fc73deb664d70eb9cc08d13c182425da3 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 9 Jan 2017 13:31:44 +0100
Subject: [PATCH 023/200] AP_HAL_SITL: RCOuput minor fix

correct style
make constructor explicit
use c++ cast
---
 libraries/AP_HAL_SITL/RCOutput.cpp | 20 ++++++++++----------
 libraries/AP_HAL_SITL/RCOutput.h   | 21 +++++++++------------
 2 files changed, 19 insertions(+), 22 deletions(-)

diff --git a/libraries/AP_HAL_SITL/RCOutput.cpp b/libraries/AP_HAL_SITL/RCOutput.cpp
index 3fd9941..01d8e89 100644
--- a/libraries/AP_HAL_SITL/RCOutput.cpp
+++ b/libraries/AP_HAL_SITL/RCOutput.cpp
@@ -2,12 +2,12 @@
 #if CONFIG_HAL_BOARD == HAL_BOARD_SITL
 
 #include "RCOutput.h"
-#include <stdio.h>
 
 #define ENABLE_DEBUG 0
 
 #if ENABLE_DEBUG
-# define Debug(fmt, args ...)  do {::printf("%s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args); } while(0)
+# include <stdio.h>
+# define Debug(fmt, args ...)  do {::printf("%s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args); } while (0)
 #else
 # define Debug(fmt, args ...)
 #endif
@@ -18,7 +18,7 @@ void RCOutput::init() {}
 
 void RCOutput::set_freq(uint32_t chmask, uint16_t freq_hz)
 {
-    Debug("set_freq(0x%04x, %u)\n", (unsigned)chmask, (unsigned)freq_hz);
+    Debug("set_freq(0x%04x, %u)\n", static_cast<uint32_t>(chmask), static_cast<uint32_t>(freq_hz));
     _freq_hz = freq_hz;
 }
 
@@ -29,18 +29,18 @@ uint16_t RCOutput::get_freq(uint8_t ch)
 
 void RCOutput::enable_ch(uint8_t ch)
 {
-    if (!(_enable_mask & (1U<<ch))) {
+    if (!(_enable_mask & (1U << ch))) {
         Debug("enable_ch(%u)\n", ch);
     }
-    _enable_mask |= 1U<<ch;
+    _enable_mask |= 1U << ch;
 }
 
 void RCOutput::disable_ch(uint8_t ch)
 {
-    if (_enable_mask & (1U<<ch)) {
+    if (_enable_mask & (1U << ch)) {
         Debug("disable_ch(%u)\n", ch);
     }
-    _enable_mask &= ~1U<<ch;
+    _enable_mask &= ~1U << ch;
 }
 
 void RCOutput::write(uint8_t ch, uint16_t period_us)
@@ -64,18 +64,18 @@ uint16_t RCOutput::read(uint8_t ch)
 
 void RCOutput::read(uint16_t* period_us, uint8_t len)
 {
-    memcpy(period_us, _sitlState->pwm_output, len*sizeof(uint16_t));
+    memcpy(period_us, _sitlState->pwm_output, len * sizeof(uint16_t));
 }
 
 void RCOutput::cork(void)
 {
-    memcpy(_pending, _sitlState->pwm_output, SITL_NUM_CHANNELS*sizeof(uint16_t));
+    memcpy(_pending, _sitlState->pwm_output, SITL_NUM_CHANNELS * sizeof(uint16_t));
     _corked = true;
 }
 
 void RCOutput::push(void)
 {
-    memcpy(_sitlState->pwm_output, _pending, SITL_NUM_CHANNELS*sizeof(uint16_t));
+    memcpy(_sitlState->pwm_output, _pending, SITL_NUM_CHANNELS * sizeof(uint16_t));
     _corked = false;
 }
 
diff --git a/libraries/AP_HAL_SITL/RCOutput.h b/libraries/AP_HAL_SITL/RCOutput.h
index c777de0..ec72c3d 100644
--- a/libraries/AP_HAL_SITL/RCOutput.h
+++ b/libraries/AP_HAL_SITL/RCOutput.h
@@ -6,20 +6,17 @@
 
 class HALSITL::RCOutput : public AP_HAL::RCOutput {
 public:
-    RCOutput(SITL_State *sitlState) {
-        _sitlState = sitlState;
-        _freq_hz = 50;
-    }
-    void     init() override;
-    void     set_freq(uint32_t chmask, uint16_t freq_hz) override;
+    explicit RCOutput(SITL_State *sitlState): _sitlState(sitlState), _freq_hz(50) {}
+    void init() override;
+    void set_freq(uint32_t chmask, uint16_t freq_hz) override;
     uint16_t get_freq(uint8_t ch) override;
-    void     enable_ch(uint8_t ch) override;
-    void     disable_ch(uint8_t ch) override;
-    void     write(uint8_t ch, uint16_t period_us) override;
+    void enable_ch(uint8_t ch) override;
+    void disable_ch(uint8_t ch) override;
+    void write(uint8_t ch, uint16_t period_us) override;
     uint16_t read(uint8_t ch) override;
-    void     read(uint16_t* period_us, uint8_t len) override;
-    void     cork(void);
-    void     push(void);
+    void read(uint16_t* period_us, uint8_t len) override;
+    void cork(void);
+    void push(void);
 
 private:
     SITL_State *_sitlState;

From ab9e88299fc1d4fdc843555d82892c78b2f23b2a Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 9 Jan 2017 13:33:52 +0100
Subject: [PATCH 024/200] AP_HAL_SITL: Scheduler remove unreachable code &
 minor fix

usleep wasn't reached since synthetic clock is always used
correct style
make constructor explicit
use c++ cast
---
 libraries/AP_HAL_SITL/Scheduler.cpp | 14 ++++---------
 libraries/AP_HAL_SITL/Scheduler.h   | 42 +++++++++++++++++--------------------
 2 files changed, 23 insertions(+), 33 deletions(-)

diff --git a/libraries/AP_HAL_SITL/Scheduler.cpp b/libraries/AP_HAL_SITL/Scheduler.cpp
index 78f1d0a..3a87a49 100644
--- a/libraries/AP_HAL_SITL/Scheduler.cpp
+++ b/libraries/AP_HAL_SITL/Scheduler.cpp
@@ -5,7 +5,6 @@
 #include "Scheduler.h"
 #include "UARTDriver.h"
 #include <sys/time.h>
-#include <unistd.h>
 #include <fenv.h>
 
 using namespace HALSITL;
@@ -43,11 +42,7 @@ void Scheduler::delay_microseconds(uint16_t usec)
         if (dtime >= usec) {
             break;
         }
-        if (_stopped_clock_usec) {
-            _sitlState->wait_clock(start + usec);
-        } else {
-            usleep(usec - dtime);
-        }
+        _sitlState->wait_clock(start + usec);
     } while (true);
 }
 
@@ -83,7 +78,6 @@ void Scheduler::register_timer_process(AP_HAL::MemberProc proc)
         _timer_proc[_num_timer_procs] = proc;
         _num_timer_procs++;
     }
-
 }
 
 void Scheduler::register_io_process(AP_HAL::MemberProc proc)
@@ -98,7 +92,6 @@ void Scheduler::register_io_process(AP_HAL::MemberProc proc)
         _io_proc[_num_io_procs] = proc;
         _num_io_procs++;
     }
-
 }
 
 void Scheduler::register_timer_failsafe(AP_HAL::Proc failsafe, uint32_t period_us)
@@ -141,10 +134,11 @@ void Scheduler::system_initialized() {
 }
 
 void Scheduler::sitl_end_atomic() {
-    if (_nested_atomic_ctr == 0)
+    if (_nested_atomic_ctr == 0) {
         hal.uartA->println("NESTED ATOMIC ERROR");
-    else
+    } else {
         _nested_atomic_ctr--;
+    }
 }
 
 void Scheduler::reboot(bool hold_in_bootloader)
diff --git a/libraries/AP_HAL_SITL/Scheduler.h b/libraries/AP_HAL_SITL/Scheduler.h
index 70ac155..56805ce 100644
--- a/libraries/AP_HAL_SITL/Scheduler.h
+++ b/libraries/AP_HAL_SITL/Scheduler.h
@@ -10,39 +10,39 @@
 /* Scheduler implementation: */
 class HALSITL::Scheduler : public AP_HAL::Scheduler {
 public:
-    Scheduler(SITL_State *sitlState);
+    explicit Scheduler(SITL_State *sitlState);
     static Scheduler *from(AP_HAL::Scheduler *scheduler) {
         return static_cast<HALSITL::Scheduler*>(scheduler);
     }
 
     /* AP_HAL::Scheduler methods */
 
-    void     init();
-    void     delay(uint16_t ms);
-    void     delay_microseconds(uint16_t us);
-    void     register_delay_callback(AP_HAL::Proc, uint16_t min_time_ms);
+    void init();
+    void delay(uint16_t ms);
+    void delay_microseconds(uint16_t us);
+    void register_delay_callback(AP_HAL::Proc, uint16_t min_time_ms);
 
-    void     register_timer_process(AP_HAL::MemberProc);
-    void     register_io_process(AP_HAL::MemberProc);
-    void     suspend_timer_procs();
-    void     resume_timer_procs();
+    void register_timer_process(AP_HAL::MemberProc);
+    void register_io_process(AP_HAL::MemberProc);
+    void suspend_timer_procs();
+    void resume_timer_procs();
 
-    bool     in_timerprocess();
+    bool in_timerprocess();
 
-    void     register_timer_failsafe(AP_HAL::Proc, uint32_t period_us);
+    void register_timer_failsafe(AP_HAL::Proc, uint32_t period_us);
 
-    void     system_initialized();
+    void system_initialized();
 
-    void     reboot(bool hold_in_bootloader);
+    void reboot(bool hold_in_bootloader);
 
-    bool     interrupts_are_blocked(void) {
+    bool interrupts_are_blocked(void) {
         return _nested_atomic_ctr != 0;
     }
 
-    void     sitl_begin_atomic() {
+    void sitl_begin_atomic() {
         _nested_atomic_ctr++;
     }
-    void     sitl_end_atomic();
+    void sitl_end_atomic();
 
     static void timer_event() {
         _run_timer_procs(true);
@@ -67,16 +67,12 @@ class HALSITL::Scheduler : public AP_HAL::Scheduler {
     static AP_HAL::MemberProc _io_proc[SITL_SCHEDULER_MAX_TIMER_PROCS];
     static uint8_t _num_timer_procs;
     static uint8_t _num_io_procs;
-    static bool    _in_timer_proc;
-    static bool    _in_io_proc;
+    static bool _in_timer_proc;
+    static bool _in_io_proc;
 
     void stop_clock(uint64_t time_usec);
 
     bool _initialized;
     uint64_t _stopped_clock_usec;
 };
-#endif // CONFIG_HAL_BOARD
-
-
-
-
+#endif  // CONFIG_HAL_BOARD

From 712fbfe84bc19cf5f37e835b10dfcb5d04a1b2cf Mon Sep 17 00:00:00 2001
From: "Dr.-Ing. Amilcar Do Carmo Lucas" <amilcar.lucas@iav.de>
Date: Thu, 5 Jan 2017 18:40:02 +0100
Subject: [PATCH 025/200] Copter: Update descriptions of stream rate parameters

---
 ArduCopter/GCS_Mavlink.cpp | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/ArduCopter/GCS_Mavlink.cpp b/ArduCopter/GCS_Mavlink.cpp
index 4553848..df82e8e 100644
--- a/ArduCopter/GCS_Mavlink.cpp
+++ b/ArduCopter/GCS_Mavlink.cpp
@@ -627,7 +627,7 @@ bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
 const AP_Param::GroupInfo GCS_MAVLINK::var_info[] = {
     // @Param: RAW_SENS
     // @DisplayName: Raw sensor stream rate
-    // @Description: Stream rate of RAW_IMU, SCALED_IMU2, SCALED_PRESSURE, and SENSOR_OFFSETS to ground station
+    // @Description: Stream rate of RAW_IMU, SCALED_IMU2, SCALED_IMU3, SCALED_PRESSURE, SCALED_PRESSURE2, SCALED_PRESSURE3 and SENSOR_OFFSETS to ground station
     // @Units: Hz
     // @Range: 0 10
     // @Increment: 1
@@ -636,7 +636,7 @@ const AP_Param::GroupInfo GCS_MAVLINK::var_info[] = {
 
     // @Param: EXT_STAT
     // @DisplayName: Extended status stream rate to ground station
-    // @Description: Stream rate of SYS_STATUS, MEMINFO, MISSION_CURRENT, GPS_RAW_INT, NAV_CONTROLLER_OUTPUT, and LIMITS_STATUS to ground station
+    // @Description: Stream rate of SYS_STATUS, POWER_STATUS, MEMINFO, CURRENT_WAYPOINT, GPS_RAW_INT, NAV_CONTROLLER_OUTPUT, and FENCE_STATUS to ground station
     // @Units: Hz
     // @Range: 0 10
     // @Increment: 1
@@ -663,7 +663,7 @@ const AP_Param::GroupInfo GCS_MAVLINK::var_info[] = {
 
     // @Param: POSITION
     // @DisplayName: Position stream rate to ground station
-    // @Description: Stream rate of GLOBAL_POSITION_INT to ground station
+    // @Description: Stream rate of GLOBAL_POSITION_INT and LOCAL_POSITION_NED to ground station
     // @Units: Hz
     // @Range: 0 10
     // @Increment: 1
@@ -672,7 +672,7 @@ const AP_Param::GroupInfo GCS_MAVLINK::var_info[] = {
 
     // @Param: EXTRA1
     // @DisplayName: Extra data type 1 stream rate to ground station
-    // @Description: Stream rate of ATTITUDE and SIMSTATE (SITL only) to ground station
+    // @Description: Stream rate of ATTITUDE, SIMSTATE (SITL only), AHRS2 and PID_TUNING to ground station
     // @Units: Hz
     // @Range: 0 10
     // @Increment: 1
@@ -690,7 +690,7 @@ const AP_Param::GroupInfo GCS_MAVLINK::var_info[] = {
 
     // @Param: EXTRA3
     // @DisplayName: Extra data type 3 stream rate to ground station
-    // @Description: Stream rate of AHRS, HWSTATUS, and SYSTEM_TIME to ground station
+    // @Description: Stream rate of AHRS, HWSTATUS, SYSTEM_TIME, RANGEFINDER, DISTANCE_SENSOR, TERRAIN_REQUEST, BATTERY2, MOUNT_STATUS, OPTICAL_FLOW, GIMBAL_REPORT, MAG_CAL_REPORT, MAG_CAL_PROGRESS, EKF_STATUS_REPORT, VIBRATION and RPM to ground station
     // @Units: Hz
     // @Range: 0 10
     // @Increment: 1
@@ -750,16 +750,16 @@ GCS_MAVLINK_Copter::data_stream_send(void)
     }
 
     if (stream_trigger(STREAM_RAW_SENSORS)) {
-        send_message(MSG_RAW_IMU1);
-        send_message(MSG_RAW_IMU2);
-        send_message(MSG_RAW_IMU3);
+        send_message(MSG_RAW_IMU1);  // RAW_IMU, SCALED_IMU2, SCALED_IMU3
+        send_message(MSG_RAW_IMU2);  // SCALED_PRESSURE, SCALED_PRESSURE2, SCALED_PRESSURE3
+        send_message(MSG_RAW_IMU3);  // SENSOR_OFFSETS
     }
 
     if (copter.gcs_out_of_time) return;
 
     if (stream_trigger(STREAM_EXTENDED_STATUS)) {
-        send_message(MSG_EXTENDED_STATUS1);
-        send_message(MSG_EXTENDED_STATUS2);
+        send_message(MSG_EXTENDED_STATUS1); // SYS_STATUS, POWER_STATUS
+        send_message(MSG_EXTENDED_STATUS2); // MEMINFO
         send_message(MSG_CURRENT_WAYPOINT);
         send_message(MSG_GPS_RAW);
         send_message(MSG_NAV_CONTROLLER_OUTPUT);
@@ -790,7 +790,7 @@ GCS_MAVLINK_Copter::data_stream_send(void)
 
     if (stream_trigger(STREAM_EXTRA1)) {
         send_message(MSG_ATTITUDE);
-        send_message(MSG_SIMSTATE);
+        send_message(MSG_SIMSTATE); // SIMSTATE, AHRS2
         send_message(MSG_PID_TUNING);
     }
 

From 11b635df12777b0af8875d565d0ed225e61ea216 Mon Sep 17 00:00:00 2001
From: Francisco Ferreira <francisco-ferreira@mail.telepac.pt>
Date: Thu, 12 Jan 2017 01:50:32 +0000
Subject: [PATCH 026/200] Copter: correct limit status to fence status

---
 ArduCopter/Copter.h        |  2 +-
 ArduCopter/GCS_Mavlink.cpp | 12 ++++++------
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index 007881c..25369ff 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -688,7 +688,7 @@ class Copter : public AP_HAL::HAL::Callbacks {
     void gcs_send_deferred(void);
     void send_heartbeat(mavlink_channel_t chan);
     void send_attitude(mavlink_channel_t chan);
-    void send_limits_status(mavlink_channel_t chan);
+    void send_fence_status(mavlink_channel_t chan);
     void send_extended_status1(mavlink_channel_t chan);
     void send_location(mavlink_channel_t chan);
     void send_nav_controller_output(mavlink_channel_t chan);
diff --git a/ArduCopter/GCS_Mavlink.cpp b/ArduCopter/GCS_Mavlink.cpp
index df82e8e..080eb02 100644
--- a/ArduCopter/GCS_Mavlink.cpp
+++ b/ArduCopter/GCS_Mavlink.cpp
@@ -99,7 +99,7 @@ NOINLINE void Copter::send_attitude(mavlink_channel_t chan)
 }
 
 #if AC_FENCE == ENABLED
-NOINLINE void Copter::send_limits_status(mavlink_channel_t chan)
+NOINLINE void Copter::send_fence_status(mavlink_channel_t chan)
 {
     fence_send_mavlink_status(chan);
 }
@@ -525,10 +525,10 @@ bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
         // depreciated, use GCS_MAVLINK::send_statustext*
         return false;
 
-    case MSG_LIMITS_STATUS:
+    case MSG_FENCE_STATUS:
 #if AC_FENCE == ENABLED
-        CHECK_PAYLOAD_SIZE(LIMITS_STATUS);
-        copter.send_limits_status(chan);
+        CHECK_PAYLOAD_SIZE(FENCE_STATUS);
+        copter.send_fence_status(chan);
 #endif
         break;
 
@@ -582,7 +582,7 @@ bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
         copter.ahrs.send_ekf_status_report(chan);
         break;
 
-    case MSG_FENCE_STATUS:
+    case MSG_LIMITS_STATUS:
     case MSG_WIND:
     case MSG_POSITION_TARGET_GLOBAL_INT:
         // unused
@@ -763,7 +763,7 @@ GCS_MAVLINK_Copter::data_stream_send(void)
         send_message(MSG_CURRENT_WAYPOINT);
         send_message(MSG_GPS_RAW);
         send_message(MSG_NAV_CONTROLLER_OUTPUT);
-        send_message(MSG_LIMITS_STATUS);
+        send_message(MSG_FENCE_STATUS);
     }
 
     if (copter.gcs_out_of_time) return;

From 62fabca19d3e625d17d49dfa7913da138e4faea7 Mon Sep 17 00:00:00 2001
From: mirkix <mirkix@gmail.com>
Date: Thu, 29 Dec 2016 15:42:13 +0100
Subject: [PATCH 027/200] AP_InertialSensor: Enable I2C bypass for MPU9250
 conntected via I2C to access internal AK8963

---
 libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp b/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp
index 662fcc9..1e4ff3a 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp
@@ -118,6 +118,7 @@ extern const AP_HAL::HAL& hal;
 #define MPUREG_I2C_SLV2_ADDR                    0x2B
 #define MPUREG_I2C_SLV3_ADDR                    0x2E
 #define MPUREG_INT_PIN_CFG                      0x37
+#       define BIT_BYPASS_EN                        0x02
 #       define BIT_INT_RD_CLEAR                     0x10    // clear the interrupt when any read occurs
 #       define BIT_LATCH_INT_EN                     0x20    // latch data ready pin
 #define MPUREG_I2C_SLV4_CTRL                    0x34
@@ -444,7 +445,7 @@ void AP_InertialSensor_Invensense::start()
 
     // clear interrupt on any read, and hold the data ready pin high
     // until we clear the interrupt
-    _register_write(MPUREG_INT_PIN_CFG, BIT_INT_RD_CLEAR | BIT_LATCH_INT_EN);
+    _register_write(MPUREG_INT_PIN_CFG, _register_read(MPUREG_INT_PIN_CFG) | BIT_INT_RD_CLEAR | BIT_LATCH_INT_EN);
 
     // now that we have initialised, we set the bus speed to high
     _dev->set_speed(AP_HAL::Device::SPEED_HIGH);
@@ -866,6 +867,12 @@ bool AP_InertialSensor_Invensense::_hardware_init(void)
             _register_write(MPUREG_USER_CTRL, _last_stat_user_ctrl);
         }
 
+        /* bus-dependent initialization */
+        if ((_dev->bus_type() == AP_HAL::Device::BUS_TYPE_I2C) && (_mpu_type == Invensense_MPU9250)) {
+            /* Enable I2C bypass to access internal AK8963 */
+            _register_write(MPUREG_INT_PIN_CFG, BIT_BYPASS_EN);
+        }
+
         // Wake up device and select GyroZ clock. Note that the
         // Invensense starts up in sleep mode, and it can take some time
         // for it to come out of sleep

From 64aa13e7f4232ccbc1a12b73e456da901617e878 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 22 Oct 2016 21:27:40 +1100
Subject: [PATCH 028/200] RC_Channel: 2nd stage of SRV_Channels conversion

allow for 16 output channel objects
---
 libraries/RC_Channel/RC_Channel.cpp                | 535 +++++++------------
 libraries/RC_Channel/RC_Channel.h                  | 177 +++----
 libraries/RC_Channel/RC_Channel_aux.cpp            | 505 ------------------
 libraries/RC_Channel/RC_Channel_aux.h              | 184 -------
 libraries/RC_Channel/SRV_Channel.cpp               | 430 ++++++++--------
 libraries/RC_Channel/SRV_Channel.h                 | 365 ++++++++++++-
 libraries/RC_Channel/SRV_Channel_aux.cpp           | 569 +++++++++++++++++++++
 .../RC_Channel/examples/RC_Channel/RC_Channel.cpp  |  74 +--
 libraries/RC_Channel/examples/RC_UART/RC_UART.cpp  |  12 +-
 9 files changed, 1395 insertions(+), 1456 deletions(-)
 delete mode 100644 libraries/RC_Channel/RC_Channel_aux.cpp
 delete mode 100644 libraries/RC_Channel/RC_Channel_aux.h
 create mode 100644 libraries/RC_Channel/SRV_Channel_aux.cpp

diff --git a/libraries/RC_Channel/RC_Channel.cpp b/libraries/RC_Channel/RC_Channel.cpp
index c5800cb..0d3f343 100644
--- a/libraries/RC_Channel/RC_Channel.cpp
+++ b/libraries/RC_Channel/RC_Channel.cpp
@@ -29,9 +29,7 @@ extern const AP_HAL::HAL& hal;
 
 #include "RC_Channel.h"
 
-/// global array with pointers to all APM RC channels, will be used by AP_Mount
-/// and AP_Camera classes / It points to RC input channels.
-RC_Channel *RC_Channel::_rc_ch[RC_MAX_CHANNELS];
+RC_Channel *RC_Channels::channels;
 
 const AP_Param::GroupInfo RC_Channel::var_info[] = {
     // @Param: MIN
@@ -41,7 +39,7 @@ const AP_Param::GroupInfo RC_Channel::var_info[] = {
     // @Range: 800 2200
     // @Increment: 1
     // @User: Advanced
-    AP_GROUPINFO_FLAGS("MIN",  0, RC_Channel, _radio_min, 1100, AP_PARAM_NO_SHIFT),
+    AP_GROUPINFO("MIN",  1, RC_Channel, radio_min, 1100),
 
     // @Param: TRIM
     // @DisplayName: RC trim PWM
@@ -50,7 +48,7 @@ const AP_Param::GroupInfo RC_Channel::var_info[] = {
     // @Range: 800 2200
     // @Increment: 1
     // @User: Advanced
-    AP_GROUPINFO("TRIM", 1, RC_Channel, _radio_trim, 1500),
+    AP_GROUPINFO("TRIM", 2, RC_Channel, radio_trim, 1500),
 
     // @Param: MAX
     // @DisplayName: RC max PWM
@@ -59,19 +57,14 @@ const AP_Param::GroupInfo RC_Channel::var_info[] = {
     // @Range: 800 2200
     // @Increment: 1
     // @User: Advanced
-    AP_GROUPINFO("MAX",  2, RC_Channel, _radio_max, 1900),
+    AP_GROUPINFO("MAX",  3, RC_Channel, radio_max, 1900),
 
-    // @Param: REV
-    // @DisplayName: RC reverse
-    // @Description: Reverse servo operation. Set to 1 for normal (forward) operation. Set to -1 to reverse this channel.
-    // @Values: -1:Reversed,1:Normal
+    // @Param: REVERSED
+    // @DisplayName: RC reversed
+    // @Description: Reverse servo operation. Set to 0 for normal (forward) operation. Set to 1 to reverse this input channel.
+    // @Values: 0:Normal,1:Reversed
     // @User: Advanced
-    AP_GROUPINFO("REV",  3, RC_Channel, _reverse, 1),
-
-    // Note: index 4 was used by the previous _dead_zone value. We
-    // changed it to 5 as dead zone values had previously been
-    // incorrectly saved, overriding user values. They were also
-    // incorrectly interpreted for the throttle on APM:Plane
+    AP_GROUPINFO("REVERSED",  4, RC_Channel, reversed, 0),
 
     // @Param: DZ
     // @DisplayName: RC dead-zone
@@ -79,115 +72,140 @@ const AP_Param::GroupInfo RC_Channel::var_info[] = {
     // @Units: pwm
     // @Range: 0 200
     // @User: Advanced
-    AP_GROUPINFO("DZ",   5, RC_Channel, _dead_zone, 0),
+    AP_GROUPINFO("DZ",   5, RC_Channel, dead_zone, 0),
 
     AP_GROUPEND
 };
 
-// setup the control preferences
-void
-RC_Channel::set_range(int16_t low, int16_t high)
-{
-    set_range_in(low, high);
-    set_range_out(low, high);
-}
 
-void
-RC_Channel::set_range_out(int16_t low, int16_t high)
-{
-    _type_out       = RC_CHANNEL_TYPE_RANGE;
-    _high_out       = high;
-    _low_out        = low;
-}
+const AP_Param::GroupInfo RC_Channels::var_info[] = {
+    // @Group: 1_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[0], "1_",  1, RC_Channels, RC_Channel),
 
-void
-RC_Channel::set_range_in(int16_t low, int16_t high)
-{
-    _type_in       = RC_CHANNEL_TYPE_RANGE;
-    _high_in       = high;
-    _low_in        = low;
-}
+    // @Group: 2_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[1], "2_",  2, RC_Channels, RC_Channel),
 
-void
-RC_Channel::set_angle(int16_t angle)
-{
-    set_angle_in(angle);
-    set_angle_out(angle);
-}
+    // @Group: 3_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[2], "3_",  3, RC_Channels, RC_Channel),
 
-void
-RC_Channel::set_angle_out(int16_t angle)
-{
-    _type_out   = RC_CHANNEL_TYPE_ANGLE;
-    _high_out   = angle;
-}
+    // @Group: 4_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[3], "4_",  4, RC_Channels, RC_Channel),
 
-void
-RC_Channel::set_angle_in(int16_t angle)
-{
-    _type_in   = RC_CHANNEL_TYPE_ANGLE;
-    _high_in   = angle;
-}
+    // @Group: 5_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[4], "5_",  5, RC_Channels, RC_Channel),
 
-void
-RC_Channel::set_default_dead_zone(int16_t dzone)
-{
-    _dead_zone.set_default(abs(dzone));
-}
+    // @Group: 6_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[5], "6_",  6, RC_Channels, RC_Channel),
 
-void
-RC_Channel::set_reverse(bool reverse)
+    // @Group: 7_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[6], "7_",  7, RC_Channels, RC_Channel),
+
+    // @Group: 8_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[7], "8_",  8, RC_Channels, RC_Channel),
+
+    // @Group: 9_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[8], "9_",  9, RC_Channels, RC_Channel),
+
+    // @Group: 10_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[9], "10_", 10, RC_Channels, RC_Channel),
+
+    // @Group: 11_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[10], "11_", 11, RC_Channels, RC_Channel),
+
+    // @Group: 12_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[11], "12_", 12, RC_Channels, RC_Channel),
+
+    // @Group: 13_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[12], "13_", 13, RC_Channels, RC_Channel),
+
+    // @Group: 14_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[13], "14_", 14, RC_Channels, RC_Channel),
+
+    // @Group: 15_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[14], "15_", 15, RC_Channels, RC_Channel),
+
+    // @Group: 16_
+    // @Path: RC_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[15], "16_", 16, RC_Channels, RC_Channel),
+    
+    AP_GROUPEND
+};
+
+
+// constructor
+RC_Channel::RC_Channel(void)
 {
-    if (reverse) _reverse = -1;
-    else _reverse = 1;
+    AP_Param::setup_object_defaults(this, var_info);
 }
 
-bool
-RC_Channel::get_reverse(void) const
+/*
+  channels group object constructor
+ */
+RC_Channels::RC_Channels(void)
 {
-    if (_reverse == -1) {
-        return true;
+    channels = obj_channels;
+    
+    // set defaults from the parameter table
+    AP_Param::setup_object_defaults(this, var_info);
+
+    // setup ch_in on channels
+    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
+        channels[i].ch_in = i;
     }
-    return false;
 }
 
 void
-RC_Channel::set_type(uint8_t t)
+RC_Channel::set_range(uint16_t high)
 {
-    set_type_in(t);
-    set_type_out(t);
+    type_in = RC_CHANNEL_TYPE_RANGE;
+    high_in = high;
 }
 
 void
-RC_Channel::set_type_in(uint8_t t)
+RC_Channel::set_angle(uint16_t angle)
 {
-    _type_in  = t;
+    type_in = RC_CHANNEL_TYPE_ANGLE;
+    high_in = angle;
 }
 
 void
-RC_Channel::set_type_out(uint8_t t)
+RC_Channel::set_default_dead_zone(int16_t dzone)
 {
-    _type_out = t;
+    dead_zone.set_default(abs(dzone));
 }
 
-// call after first read
-void
-RC_Channel::trim()
+bool
+RC_Channel::get_reverse(void) const
 {
-    _radio_trim = _radio_in;
+    return bool(reversed.get());
 }
 
 // read input from APM_RC - create a control_in value
 void
 RC_Channel::set_pwm(int16_t pwm)
 {
-    _radio_in = pwm;
+    radio_in = pwm;
 
-    if (_type_in == RC_CHANNEL_TYPE_RANGE) {
-        _control_in = pwm_to_range();
+    if (type_in == RC_CHANNEL_TYPE_RANGE) {
+        control_in = pwm_to_range();
     } else {
-        //RC_CHANNEL_TYPE_ANGLE, RC_CHANNEL_TYPE_ANGLE_RAW
-        _control_in = pwm_to_angle();
+        //RC_CHANNEL_TYPE_ANGLE
+        control_in = pwm_to_angle();
     }
 }
 
@@ -195,12 +213,10 @@ RC_Channel::set_pwm(int16_t pwm)
   call read() and set_pwm() on all channels
  */
 void
-RC_Channel::set_pwm_all(void)
+RC_Channels::set_pwm_all(void)
 {
-    for (uint8_t i=0; i<RC_MAX_CHANNELS; i++) {
-        if (_rc_ch[i] != nullptr) {
-            _rc_ch[i]->set_pwm(_rc_ch[i]->read());
-        }
+    for (uint8_t i=0; i<NUM_RC_CHANNELS; i++) {
+        channels[i].set_pwm(channels[i].read());
     }
 }
 
@@ -210,54 +226,32 @@ RC_Channel::set_pwm_all(void)
 void
 RC_Channel::set_pwm_no_deadzone(int16_t pwm)
 {
-    _radio_in = pwm;
+    radio_in = pwm;
 
-    if (_type_in == RC_CHANNEL_TYPE_RANGE) {
-        _control_in = pwm_to_range_dz(0);
+    if (type_in == RC_CHANNEL_TYPE_RANGE) {
+        control_in = pwm_to_range_dz(0);
     } else {
-        //RC_CHANNEL_ANGLE, RC_CHANNEL_ANGLE_RAW
-        _control_in = pwm_to_angle_dz(0);
+        //RC_CHANNEL_ANGLE
+        control_in = pwm_to_angle_dz(0);
     }
 }
 
-// returns just the PWM without the offset from radio_min
-void
-RC_Channel::calc_pwm(void)
-{
-    if(_type_out == RC_CHANNEL_TYPE_RANGE) {
-        _pwm_out         = range_to_pwm();
-        _radio_out       = (_reverse >= 0) ? (_radio_min + _pwm_out) : (_radio_max - _pwm_out);
-
-    }else if(_type_out == RC_CHANNEL_TYPE_ANGLE_RAW) {
-        _pwm_out         = (float)_servo_out * 0.1f;
-        int16_t reverse_mul = (_reverse==-1?-1:1);
-        _radio_out       = (_pwm_out * reverse_mul) + _radio_trim;
-
-    }else{     // RC_CHANNEL_TYPE_ANGLE
-        _pwm_out         = angle_to_pwm();
-        _radio_out       = _pwm_out + _radio_trim;
-    }
-
-    _radio_out = constrain_int16(_radio_out, _radio_min.get(), _radio_max.get());
-}
-
-
 /*
   return the center stick position expressed as a control_in value
   used for thr_mid in copter
  */
-int16_t
-RC_Channel::get_control_mid() const {
-    if (_type_in == RC_CHANNEL_TYPE_RANGE) {
-        int16_t r_in = (_radio_min.get()+_radio_max.get())/2;
+int16_t RC_Channel::get_control_mid() const
+{
+    if (type_in == RC_CHANNEL_TYPE_RANGE) {
+        int16_t r_in = (radio_min.get() + radio_max.get())/2;
 
-        if (_reverse == -1) {
-            r_in = _radio_max.get() - (r_in - _radio_min.get());
+        if (reversed) {
+            r_in = radio_max.get() - (r_in - radio_min.get());
         }
 
-        int16_t radio_trim_low  = _radio_min + _dead_zone;
+        int16_t radio_trim_low  = radio_min + dead_zone;
 
-        return (_low_in + ((int32_t)(_high_in - _low_in) * (int32_t)(r_in - radio_trim_low)) / (int32_t)(_radio_max - radio_trim_low));
+        return (((int32_t)(high_in) * (int32_t)(r_in - radio_trim_low)) / (int32_t)(radio_max - radio_trim_low));
     } else {
         return 0;
     }
@@ -265,39 +259,22 @@ RC_Channel::get_control_mid() const {
 
 // ------------------------------------------
 
-void
-RC_Channel::load_eeprom(void)
-{
-    _radio_min.load();
-    _radio_trim.load();
-    _radio_max.load();
-    _reverse.load();
-    _dead_zone.load();
-}
-
-void
-RC_Channel::save_eeprom(void)
-{
-    _radio_min.save();
-    _radio_trim.save();
-    _radio_max.save();
-    _reverse.save();
-    _dead_zone.save();
-}
-
-// ------------------------------------------
-
-void
-RC_Channel::zero_min_max()
+void RC_Channel::load_eeprom(void)
 {
-    _radio_min = _radio_max = _radio_in;
+    radio_min.load();
+    radio_trim.load();
+    radio_max.load();
+    reversed.load();
+    dead_zone.load();
 }
 
-void
-RC_Channel::update_min_max()
+void RC_Channel::save_eeprom(void)
 {
-    _radio_min = MIN(_radio_min.get(), _radio_in);
-    _radio_max = MAX(_radio_max.get(), _radio_in);
+    radio_min.save();
+    radio_trim.save();
+    radio_max.save();
+    reversed.save();
+    dead_zone.save();
 }
 
 /*
@@ -305,22 +282,23 @@ RC_Channel::update_min_max()
   the current radio_in value using the specified dead_zone
  */
 int16_t
-RC_Channel::pwm_to_angle_dz_trim(uint16_t dead_zone, uint16_t _trim)
+RC_Channel::pwm_to_angle_dz_trim(uint16_t _dead_zone, uint16_t trim)
 {
-    int16_t radio_trim_high = _trim + dead_zone;
-    int16_t radio_trim_low  = _trim - dead_zone;
+    int16_t radio_trim_high = trim + _dead_zone;
+    int16_t radio_trim_low  = trim - _dead_zone;
 
     // prevent div by 0
-    if ((radio_trim_low - _radio_min) == 0 || (_radio_max - radio_trim_high) == 0)
+    if ((radio_trim_low - radio_min) == 0 || (radio_max - radio_trim_high) == 0)
         return 0;
 
-    int16_t reverse_mul = (_reverse==-1?-1:1);
-    if(_radio_in > radio_trim_high) {
-        return reverse_mul * ((int32_t)_high_in * (int32_t)(_radio_in - radio_trim_high)) / (int32_t)(_radio_max  - radio_trim_high);
-    }else if(_radio_in < radio_trim_low) {
-        return reverse_mul * ((int32_t)_high_in * (int32_t)(_radio_in - radio_trim_low)) / (int32_t)(radio_trim_low - _radio_min);
-    }else
+    int16_t reverse_mul = (reversed?-1:1);
+    if (radio_in > radio_trim_high) {
+        return reverse_mul * ((int32_t)high_in * (int32_t)(radio_in - radio_trim_high)) / (int32_t)(radio_max  - radio_trim_high);
+    } else if (radio_in < radio_trim_low) {
+        return reverse_mul * ((int32_t)high_in * (int32_t)(radio_in - radio_trim_low)) / (int32_t)(radio_trim_low - radio_min);
+    } else {
         return 0;
+    }
 }
 
 /*
@@ -328,9 +306,9 @@ RC_Channel::pwm_to_angle_dz_trim(uint16_t dead_zone, uint16_t _trim)
   the current radio_in value using the specified dead_zone
  */
 int16_t
-RC_Channel::pwm_to_angle_dz(uint16_t dead_zone)
+RC_Channel::pwm_to_angle_dz(uint16_t _dead_zone)
 {
-    return pwm_to_angle_dz_trim(dead_zone, _radio_trim);
+    return pwm_to_angle_dz_trim(_dead_zone, radio_trim);
 }
 
 /*
@@ -340,42 +318,29 @@ RC_Channel::pwm_to_angle_dz(uint16_t dead_zone)
 int16_t
 RC_Channel::pwm_to_angle()
 {
-	return pwm_to_angle_dz(_dead_zone);
+	return pwm_to_angle_dz(dead_zone);
 }
 
 
-int16_t
-RC_Channel::angle_to_pwm()
-{
-    int16_t reverse_mul = (_reverse==-1?-1:1);
-    if((_servo_out * reverse_mul) > 0) {
-        return reverse_mul * ((int32_t)_servo_out * (int32_t)(_radio_max - _radio_trim)) / (int32_t)_high_out;
-    } else {
-        return reverse_mul * ((int32_t)_servo_out * (int32_t)(_radio_trim - _radio_min)) / (int32_t)_high_out;
-    }
-}
-
 /*
   convert a pulse width modulation value to a value in the configured
   range, using the specified deadzone
  */
 int16_t
-RC_Channel::pwm_to_range_dz(uint16_t dead_zone)
+RC_Channel::pwm_to_range_dz(uint16_t _dead_zone)
 {
-    int16_t r_in = constrain_int16(_radio_in, _radio_min.get(), _radio_max.get());
+    int16_t r_in = constrain_int16(radio_in, radio_min.get(), radio_max.get());
 
-    if (_reverse == -1) {
-	    r_in = _radio_max.get() - (r_in - _radio_min.get());
+    if (reversed) {
+	    r_in = radio_max.get() - (r_in - radio_min.get());
     }
 
-    int16_t radio_trim_low  = _radio_min + dead_zone;
+    int16_t radio_trim_low  = radio_min + _dead_zone;
 
-    if (r_in > radio_trim_low)
-        return (_low_in + ((int32_t)(_high_in - _low_in) * (int32_t)(r_in - radio_trim_low)) / (int32_t)(_radio_max - radio_trim_low));
-    else if (dead_zone > 0)
-        return 0;
-    else
-        return _low_in;
+    if (r_in > radio_trim_low) {
+        return (((int32_t)(high_in) * (int32_t)(r_in - radio_trim_low)) / (int32_t)(radio_max - radio_trim_low));
+    }
+    return 0;
 }
 
 /*
@@ -385,17 +350,16 @@ RC_Channel::pwm_to_range_dz(uint16_t dead_zone)
 int16_t
 RC_Channel::pwm_to_range()
 {
-    return pwm_to_range_dz(_dead_zone);
+    return pwm_to_range_dz(dead_zone);
 }
 
 
-int16_t
-RC_Channel::range_to_pwm()
+int16_t RC_Channel::get_control_in_zero_dz(void)
 {
-    if (_high_out == _low_out) {
-        return _radio_trim;
+    if (type_in == RC_CHANNEL_TYPE_RANGE) {
+        return pwm_to_range_dz(0);
     }
-    return ((int32_t)(_servo_out - _low_out) * (int32_t)(_radio_max - _radio_min)) / (int32_t)(_high_out - _low_out);
+    return pwm_to_angle_dz(0);
 }
 
 // ------------------------------------------
@@ -404,17 +368,17 @@ float
 RC_Channel::norm_input()
 {
     float ret;
-    int16_t reverse_mul = (_reverse==-1?-1:1);
-    if (_radio_in < _radio_trim) {
-        if (_radio_min >= _radio_trim) {
+    int16_t reverse_mul = (reversed?-1:1);
+    if (radio_in < radio_trim) {
+        if (radio_min >= radio_trim) {
             return 0.0f;
         }
-        ret = reverse_mul * (float)(_radio_in - _radio_trim) / (float)(_radio_trim - _radio_min);
+        ret = reverse_mul * (float)(radio_in - radio_trim) / (float)(radio_trim - radio_min);
     } else {
-        if (_radio_max <= _radio_trim) {
+        if (radio_max <= radio_trim) {
             return 0.0f;
         }
-        ret = reverse_mul * (float)(_radio_in - _radio_trim) / (float)(_radio_max  - _radio_trim);
+        ret = reverse_mul * (float)(radio_in - radio_trim) / (float)(radio_max  - radio_trim);
     }
     return constrain_float(ret, -1.0f, 1.0f);
 }
@@ -422,14 +386,14 @@ RC_Channel::norm_input()
 float
 RC_Channel::norm_input_dz()
 {
-    int16_t dz_min = _radio_trim - _dead_zone;
-    int16_t dz_max = _radio_trim + _dead_zone;
+    int16_t dz_min = radio_trim - dead_zone;
+    int16_t dz_max = radio_trim + dead_zone;
     float ret;
-    int16_t reverse_mul = (_reverse==-1?-1:1);
-    if (_radio_in < dz_min && dz_min > _radio_min) {
-        ret = reverse_mul * (float)(_radio_in - dz_min) / (float)(dz_min - _radio_min);
-    } else if (_radio_in > dz_max && _radio_max > dz_max) {
-        ret = reverse_mul * (float)(_radio_in - dz_max) / (float)(_radio_max  - dz_max);
+    int16_t reverse_mul = (reversed?-1:1);
+    if (radio_in < dz_min && dz_min > radio_min) {
+        ret = reverse_mul * (float)(radio_in - dz_min) / (float)(dz_min - radio_min);
+    } else if (radio_in > dz_max && radio_max > dz_max) {
+        ret = reverse_mul * (float)(radio_in - dz_max) / (float)(radio_max  - dz_max);
     } else {
         ret = 0;
     }
@@ -442,125 +406,29 @@ RC_Channel::norm_input_dz()
 uint8_t
 RC_Channel::percent_input()
 {
-    if (_radio_in <= _radio_min) {
-        return _reverse==-1?100:0;
+    if (radio_in <= radio_min) {
+        return reversed?100:0;
     }
-    if (_radio_in >= _radio_max) {
-        return _reverse==-1?0:100;
+    if (radio_in >= radio_max) {
+        return reversed?0:100;
     }
-    uint8_t ret = 100.0f * (_radio_in - _radio_min) / (float)(_radio_max - _radio_min);
-    if (_reverse == -1) {
+    uint8_t ret = 100.0f * (radio_in - radio_min) / (float)(radio_max - radio_min);
+    if (reversed) {
         ret = 100 - ret;
     }
     return ret;
 }
 
-float
-RC_Channel::norm_output()
-{
-    int16_t mid = (_radio_max + _radio_min) / 2;
-    float ret;
-    if (mid <= _radio_min) {
-        return 0;
-    }
-    if (_radio_out < mid) {
-        ret = (float)(_radio_out - mid) / (float)(mid - _radio_min);
-    } else if (_radio_out > mid) {
-        ret = (float)(_radio_out - mid) / (float)(_radio_max  - mid);
-    } else {
-        ret = 0;
-    }
-    if (_reverse == -1) {
-	    ret = -ret;
-    }
-    return ret;
-}
-
-void RC_Channel::output() const
-{
-    hal.rcout->write(_ch_out, _radio_out);
-}
-
-void RC_Channel::output_trim()
-{
-    _radio_out = _radio_trim;
-    output();
-}
-
-void RC_Channel::output_trim_all()
-{
-    for (uint8_t i=0; i<RC_MAX_CHANNELS; i++) {
-        if (_rc_ch[i] != nullptr) {
-            _rc_ch[i]->output_trim();
-        }
-    }
-}
-
-/*
-  setup the failsafe value to the trim value for all channels in chmask
- */
-void RC_Channel::setup_failsafe_trim_mask(uint16_t chmask)
-{
-    for (uint8_t i=0; i<RC_MAX_CHANNELS; i++) {
-        if (_rc_ch[i] != nullptr && ((1U<<i)&chmask)) {
-            hal.rcout->set_failsafe_pwm(1U<<i, _rc_ch[i]->_radio_trim);
-        }
-    }
-}
-
-/*
-  setup the failsafe value to the trim value for all channels
- */
-void RC_Channel::setup_failsafe_trim_all()
-{
-    setup_failsafe_trim_mask(0xFFFF);
-}
-
 void
 RC_Channel::input()
 {
-    _radio_in = hal.rcin->read(_ch_out);
+    radio_in = hal.rcin->read(ch_in);
 }
 
 uint16_t
 RC_Channel::read() const
 {
-    return hal.rcin->read(_ch_out);
-}
-
-void
-RC_Channel::enable_out()
-{
-    hal.rcout->enable_ch(_ch_out);
-}
-
-void
-RC_Channel::disable_out()
-{
-    hal.rcout->disable_ch(_ch_out);
-}
-
-RC_Channel *RC_Channel::rc_channel(uint8_t i)
-{
-    if (i >= RC_MAX_CHANNELS) {
-        return nullptr;
-    }
-    return _rc_ch[i];
-}
-
-// return a limit PWM value
-uint16_t RC_Channel::get_limit_pwm(LimitValue limit) const
-{
-    switch (limit) {
-    case RC_CHANNEL_LIMIT_TRIM:
-        return _radio_trim;
-    case RC_CHANNEL_LIMIT_MAX:
-        return get_reverse() ? _radio_min : _radio_max;
-    case RC_CHANNEL_LIMIT_MIN:
-        return get_reverse() ? _radio_max : _radio_min;
-    }
-    // invalid limit value, return trim
-    return _radio_trim;
+    return hal.rcin->read(ch_in);
 }
 
 /*
@@ -568,45 +436,6 @@ uint16_t RC_Channel::get_limit_pwm(LimitValue limit) const
 */
 bool RC_Channel::in_trim_dz()
 {
-    return is_bounded_int32(_radio_in, _radio_trim - _dead_zone, _radio_trim + _dead_zone);
+    return is_bounded_int32(radio_in, radio_trim - dead_zone, radio_trim + dead_zone);
 }
 
-
-/*
-  return the current radio_out value normalised as a float with 1.0
-  being full output and 0.0 being zero output, taking into account
-  output type and reversals
-
-  For angle outputs the returned value is from -1 to 1
-
-  For range outputs the returned value is from 0 to 1
- */
-float RC_Channel::get_radio_out_normalised(uint16_t pwm) const
-{
-    if (_radio_max <= _radio_min) {
-        return 0;
-    }
-    float ret;
-    if (_type_out == RC_CHANNEL_TYPE_RANGE) {
-        if (pwm <= _radio_min) {
-            ret = 0;
-        } else if (pwm >= _radio_max) {
-            ret = 1;
-        } else {
-            ret = (pwm - _radio_min) / float(_radio_max - _radio_min);
-        }
-        if (_reverse == -1) {
-            ret = 1 - ret;
-        }
-    } else {
-        if (pwm < _radio_trim) {
-            ret = -(_radio_trim - pwm) / float(_radio_trim - _radio_min);
-        } else {
-            ret = (pwm - _radio_trim) / float(_radio_max - _radio_trim);
-        }
-        if (_reverse == -1) {
-            ret = -ret;
-        }
-    }
-    return ret;
-}
diff --git a/libraries/RC_Channel/RC_Channel.h b/libraries/RC_Channel/RC_Channel.h
index dd214bf..ec81539 100644
--- a/libraries/RC_Channel/RC_Channel.h
+++ b/libraries/RC_Channel/RC_Channel.h
@@ -7,28 +7,16 @@
 
 #define RC_CHANNEL_TYPE_ANGLE       0
 #define RC_CHANNEL_TYPE_RANGE       1
-#define RC_CHANNEL_TYPE_ANGLE_RAW   2
 
-#define RC_MAX_CHANNELS 14
+#define NUM_RC_CHANNELS 16
 
 /// @class	RC_Channel
 /// @brief	Object managing one RC channel
 class RC_Channel {
 public:
-    /// Constructor
-    ///
-    /// @param key      EEPROM storage key for the channel trim parameters.
-    /// @param name     Optional name for the group.
-    ///
-    RC_Channel(uint8_t ch_out) :
-        _high_in(1),
-        _ch_out(ch_out) 
-    {
-		  AP_Param::setup_object_defaults(this, var_info);
-        if (ch_out < RC_MAX_CHANNELS) {
-            _rc_ch[ch_out] = this;
-        }
-    }
+    friend class RC_Channels;
+    // Constructor
+    RC_Channel(void);
 
     // used to get min/max/trim limit value based on _reverse
     enum LimitValue {
@@ -37,52 +25,29 @@ class RC_Channel {
         RC_CHANNEL_LIMIT_MAX
     };
 
-    // setup min and max radio values in CLI
-    void        update_min_max();
-    void        zero_min_max();
-
     // startup
     void        load_eeprom(void);
     void        save_eeprom(void);
     void        save_trim(void);
-    void        set_type(uint8_t t);
-    void        set_type_in(uint8_t t);
-    void        set_type_out(uint8_t t);
 
     // setup the control preferences
-    void        set_range(int16_t low, int16_t high);
-    void        set_range_out(int16_t low, int16_t high);
-    void        set_range_in(int16_t low, int16_t high);
-    void        set_angle(int16_t angle);
-    void        set_angle_in(int16_t angle);
-    void        set_angle_out(int16_t angle);
-    void        set_reverse(bool reverse);
+    void        set_range(uint16_t high);
+    void        set_angle(uint16_t angle);
     bool        get_reverse(void) const;
     void        set_default_dead_zone(int16_t dzone);
-    uint16_t    get_dead_zone(void) const { return _dead_zone; }
+    uint16_t    get_dead_zone(void) const { return dead_zone; }
     
-    // get the channel number
-    uint8_t     get_ch_out(void) const { return _ch_out; }
-
     // get the center stick position expressed as a control_in value
     int16_t     get_control_mid() const;
 
     // read input from APM_RC - create a control_in value
     void        set_pwm(int16_t pwm);
-    static void set_pwm_all(void);
     void        set_pwm_no_deadzone(int16_t pwm);
 
-    // return a limit PWM value
-    uint16_t    get_limit_pwm(LimitValue limit) const;
-
     // call after first set_pwm
     void        trim();
 
-    // generate PWM from servo_out value
-    void        calc_pwm(void);
-
     int16_t     pwm_to_angle_dz_trim(uint16_t dead_zone, uint16_t trim);
-    int16_t     pwm_to_angle_dz(uint16_t dead_zone);
     int16_t     pwm_to_angle();
 
     /*
@@ -98,98 +63,82 @@ class RC_Channel {
     float       norm_input_dz();
 
     uint8_t     percent_input();
-    float       norm_output();
-    int16_t     angle_to_pwm();
     int16_t     pwm_to_range();
     int16_t     pwm_to_range_dz(uint16_t dead_zone);
-    int16_t     range_to_pwm();
-    void        output() const;
-    void        output_trim();
-    static void output_trim_all();
-    static void setup_failsafe_trim_mask(uint16_t chmask);
-    static void setup_failsafe_trim_all();
     uint16_t    read() const;
     void        input();
-    void        enable_out();
-    void        disable_out();
 
-    static const struct AP_Param::GroupInfo         var_info[];
+    static const struct AP_Param::GroupInfo var_info[];
+
+    bool       in_trim_dz();
+
+    int16_t    get_radio_in() const { return radio_in;}
+    void       set_radio_in(int16_t val) {radio_in = val;}
+
+    int16_t    get_control_in() const { return control_in;}
+    void       set_control_in(int16_t val) { control_in = val;}
+
+    // get control input with zero deadzone
+    int16_t     get_control_in_zero_dz(void);
+    
+    int16_t    get_radio_min() const {return radio_min.get();}
+    void       set_radio_min(int16_t val) { radio_min = val;}
+
+    int16_t    get_radio_max() const {return radio_max.get();}
+    void       set_radio_max(int16_t val) {radio_max = val;}
 
-    static RC_Channel *rc_channel(uint8_t i);
+    int16_t    get_radio_trim() const { return radio_trim.get();}
+    void       set_radio_trim(int16_t val) { radio_trim.set(val);}
+    void       save_radio_trim() { radio_trim.save();}
 
-    static RC_Channel **rc_channel_array(void) 
+    bool min_max_configured()
     {
-        return _rc_ch;
+        return radio_min.configured() && radio_max.configured();
     }
     
-    bool       in_trim_dz();
+private:
 
-    int16_t    get_radio_in() const { return _radio_in;}
-    void       set_radio_in(int16_t val){_radio_in = val;}
+    // pwm is stored here
+    int16_t     radio_in;
 
-    int16_t    get_control_in() const { return _control_in;}
-    void       set_control_in(int16_t val) { _control_in = val;}
+    // value generated from PWM normalised to configured scale
+    int16_t    control_in;
+    
+    AP_Int16    radio_min;
+    AP_Int16    radio_trim;
+    AP_Int16    radio_max;
 
-    int16_t    get_servo_out() const {return _servo_out;}
-    void       set_servo_out(int16_t val){_servo_out = val;}
+    AP_Int8     reversed;
+    AP_Int16    dead_zone;
 
-    int16_t    get_pwm_out() const { return _pwm_out;}
+    uint8_t     type_in;
+    int16_t     high_in;
 
-    int16_t    get_radio_out() const { return _radio_out;}
-    void       set_radio_out(int16_t val){ _radio_out = val;}
+    // the input channel this corresponds to
+    uint8_t     ch_in;
 
-    int16_t    get_radio_min() const {return _radio_min.get();}
-    void       set_radio_min(int16_t val){_radio_min = val;}
+    int16_t pwm_to_angle_dz(uint16_t dead_zone);
+};
 
-    int16_t    get_radio_max() const {return _radio_max.get();}
-    void       set_radio_max(int16_t val){_radio_max = val;}
 
-    int16_t    get_radio_trim() const { return _radio_trim.get();}
-    void       set_radio_trim(int16_t val) { _radio_trim.set(val);}
-    void       save_radio_trim() { _radio_trim.save();}
+/*
+  class	RC_Channels. Hold the full set of RC_Channel objects
+*/
+class RC_Channels {
+public:
+    // constructor
+    RC_Channels(void);
 
-    // return output type RC_CHANNEL_TYPE_*
-    uint8_t    get_type_out(void) const { return _type_out; }
-    
-    // get the current radio_out value as a floating point number
-    // normalised so that 1.0 is full output
-    float      get_radio_out_normalised(uint16_t pwm) const;
-    
-    bool min_max_configured()
-    {
-        return _radio_min.configured() && _radio_max.configured();
+    static const struct AP_Param::GroupInfo var_info[];
+
+    static RC_Channel *rc_channel(uint8_t chan) {
+        return (chan < NUM_RC_CHANNELS)?&channels[chan]:nullptr;
     }
+
+    static void set_pwm_all(void);
     
 private:
-
-    // pwm is stored here
-    int16_t     _radio_in;
-    // value generated from PWM
-    int16_t     _control_in;
-    // current values to the servos - degrees * 100 (approx assuming servo is -45 to 45 degrees except [3] is 0 to 100
-    int16_t     _servo_out;
-    // PWM is without the offset from radio_min
-    int16_t     _pwm_out;
-    int16_t     _radio_out;
-
-    AP_Int16    _radio_min;
-    AP_Int16    _radio_trim;
-    AP_Int16    _radio_max;
-
-    AP_Int8     _reverse;
-    AP_Int16    _dead_zone;
-    uint8_t     _type_in;
-    int16_t     _high_in;
-    int16_t     _low_in;
-    uint8_t     _type_out;
-    int16_t     _high_out;
-    int16_t     _low_out;
-
-    static RC_Channel *_rc_ch[RC_MAX_CHANNELS];
-
-protected:
-    uint8_t     _ch_out;
+    // this static arrangement is to avoid static pointers in AP_Param tables
+    static RC_Channel *channels;
+    RC_Channel obj_channels[NUM_RC_CHANNELS];
 };
-
-// This is ugly, but it fixes poorly architected library
-#include "RC_Channel_aux.h"
diff --git a/libraries/RC_Channel/RC_Channel_aux.cpp b/libraries/RC_Channel/RC_Channel_aux.cpp
deleted file mode 100644
index 2db7ada..0000000
--- a/libraries/RC_Channel/RC_Channel_aux.cpp
+++ /dev/null
@@ -1,505 +0,0 @@
-#include "RC_Channel_aux.h"
-
-#include <AP_Math/AP_Math.h>
-#include <AP_HAL/AP_HAL.h>
-extern const AP_HAL::HAL& hal;
-
-const AP_Param::GroupInfo RC_Channel_aux::var_info[] = {
-    AP_NESTEDGROUPINFO(RC_Channel, 0),
-
-    // @Param: FUNCTION
-    // @DisplayName: Servo out function
-    // @Description: Setting this to Disabled(0) will setup this output for control by auto missions or MAVLink servo set commands. any other value will enable the corresponding function
-    // @Values: 0:Disabled,1:RCPassThru,2:Flap,3:Flap_auto,4:Aileron,6:mount_pan,7:mount_tilt,8:mount_roll,9:mount_open,10:camera_trigger,11:release,12:mount2_pan,13:mount2_tilt,14:mount2_roll,15:mount2_open,16:DifferentialSpoiler1,17:DifferentialSpoiler2,18:AileronWithInput,19:Elevator,20:ElevatorWithInput,21:Rudder,24:Flaperon1,25:Flaperon2,26:GroundSteering,27:Parachute,28:Gripper,29:LandingGear,30:EngineRunEnable,31:HeliRSC,32:HeliTailRSC,33:Motor1,34:Motor2,35:Motor3,36:Motor4,37:Motor5,38:Motor6,39:Motor7,40:Motor8,51:RCIN1,52:RCIN2,53:RCIN3,54:RCIN4,55:RCIN5,56:RCIN6,57:RCIN7,58:RCIN8,59:RCIN9,60:RCIN10,61:RCIN11,62:RCIN12,63:RCIN13,64:RCIN14,65:RCIN15,66:RCIN16,67:Ignition,68:Choke,69:Starter,70:Throttle
-    // @User: Standard
-    AP_GROUPINFO("FUNCTION",       1, RC_Channel_aux, function, 0),
-
-    AP_GROUPEND
-};
-
-RC_Channel_aux *RC_Channel_aux::_aux_channels[RC_AUX_MAX_CHANNELS];
-uint64_t RC_Channel_aux::_function_mask[2];
-bool RC_Channel_aux::_initialised;
-bool RC_Channel_aux::_disable_passthrough;
-
-void
-RC_Channel_aux::set_function_mask(uint8_t fn)
-{
-    uint8_t idx = fn / 64;
-    uint8_t bit = fn % 64;
-    _function_mask[idx] |= (1ULL<<(uint8_t)bit);
-}
-
-void
-RC_Channel_aux::clear_function_mask(void)
-{
-    memset(_function_mask, 0, sizeof(_function_mask));
-}
-
-/// map a function to a servo channel and output it
-void
-RC_Channel_aux::output_ch(void)
-{
-    // take care of two corner cases
-    switch(function)
-    {
-    case k_none:                // disabled
-        return;
-    case k_manual:              // manual
-        if (_disable_passthrough) {
-            set_radio_out(get_radio_trim());
-        } else {
-            set_radio_out(get_radio_in());
-        }
-        break;
-    case k_rcin1 ... k_rcin16: // rc pass-thru
-        if (_disable_passthrough) {
-            set_radio_out(get_radio_trim());
-        } else {
-            set_radio_out(hal.rcin->read(function-k_rcin1));
-        }
-        break;
-    case k_motor1 ... k_motor8:
-        // handled by AP_Motors::rc_write()
-        return;
-    }
-    hal.rcout->write(_ch_out, get_radio_out());
-}
-
-/*
-  call output_ch() on all auxiliary channels
- */
-void
-RC_Channel_aux::output_ch_all(void)
-{
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i]) {
-            _aux_channels[i]->output_ch();
-        }
-    }    
-}
-
-/*
-  prevent a channel from being used for auxiliary functions
-  This is used by the copter code to ensure channels used for motors
-  can't be used for auxiliary functions
-*/
-void RC_Channel_aux::disable_aux_channel(uint8_t channel)
-{
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->_ch_out == channel) {
-            _aux_channels[i] = nullptr;
-        }
-    }    
-}
-
-/*
-  return the current function for a channel
-*/
-RC_Channel_aux::Aux_servo_function_t RC_Channel_aux::channel_function(uint8_t channel)
-{
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->_ch_out == channel) {
-            return (RC_Channel_aux::Aux_servo_function_t)_aux_channels[i]->function.get();
-        }
-    }    
-    return RC_Channel_aux::k_none;
-}
-
-/* 
-   setup a channels aux servo function
-*/
-void RC_Channel_aux::aux_servo_function_setup(void)
-{
-    switch (function) {
-    case RC_Channel_aux::k_flap:
-    case RC_Channel_aux::k_flap_auto:
-    case RC_Channel_aux::k_egg_drop:
-        set_range_out(0,100);
-        break;
-    case RC_Channel_aux::k_heli_rsc:
-    case RC_Channel_aux::k_heli_tail_rsc:
-        set_range_out(0,1000);
-        break;
-    case RC_Channel_aux::k_aileron_with_input:
-    case RC_Channel_aux::k_elevator_with_input:
-        set_angle(4500);
-        break;
-    case RC_Channel_aux::k_aileron:
-    case RC_Channel_aux::k_elevator:
-    case RC_Channel_aux::k_dspoiler1:
-    case RC_Channel_aux::k_dspoiler2:
-    case RC_Channel_aux::k_rudder:
-    case RC_Channel_aux::k_steering:
-    case RC_Channel_aux::k_flaperon1:
-    case RC_Channel_aux::k_flaperon2:
-        set_angle_out(4500);
-        break;
-    case RC_Channel_aux::k_motor_tilt:
-        // tenth percentage tilt
-        set_range_out(0,1000);
-        break;
-    case RC_Channel_aux::k_throttle:
-        // fixed wing throttle
-        set_range_out(0,100);
-        break;
-    default:
-        break;
-    }
-
-    if (function < k_nr_aux_servo_functions) {
-        set_function_mask((uint8_t)function.get());
-    }
-}
-
-/// Update the _aux_channels array of pointers to rc_x channels
-/// This is to be done before rc_init so that the channels get correctly initialized.
-/// It also should be called periodically because the user might change the configuration and
-/// expects the changes to take effect instantly
-/// Supports up to eight aux servo outputs (typically CH5 ... CH11)
-/// All servos must be configured with a single call to this function
-/// (do not call this twice with different parameters, the second call will reset the effect of the first call)
-void RC_Channel_aux::update_aux_servo_function(void)
-{
-    clear_function_mask();
-
-    // set auxiliary ranges
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] == nullptr) continue;
-        _aux_channels[i]->aux_servo_function_setup();
-	}
-    _initialised = true;
-}
-
-
-/// Should be called after the the servo functions have been initialized
-void RC_Channel_aux::enable_aux_servos()
-{
-    update_aux_servo_function();
-
-    // enable all channels that are not set to a valid function. This
-    // includes k_none servos, which allows those to get their initial
-    // trim value on startup
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i]) {
-			   RC_Channel_aux::Aux_servo_function_t function = (RC_Channel_aux::Aux_servo_function_t)_aux_channels[i]->function.get();
-			   // see if it is a valid function
-			   if (function < RC_Channel_aux::k_nr_aux_servo_functions) {
-				    _aux_channels[i]->enable_out();
-			   }
-		  }
-	 }
-}
-
-/*
-  set radio_out for all channels matching the given function type
- */
-void
-RC_Channel_aux::set_radio(RC_Channel_aux::Aux_servo_function_t function, int16_t value)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-            _aux_channels[i]->set_radio_out(value);
-            _aux_channels[i]->output();
-		  }
-    }
-}
-
-/*
-  get radio_out for *first* channel matching the given function type.
-  Returns true if a value was found.
- */
-bool RC_Channel_aux::get_radio(RC_Channel_aux::Aux_servo_function_t function, int16_t &value)
-{
-    if (!function_assigned(function)) {
-        return false;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-            value = _aux_channels[i]->get_radio_out();
-            return true;
-        }
-    }
-    return false;
-}
-
-/*
-  set radio_out for all channels matching the given function type, allow radio_trim to center servo
- */
-void
-RC_Channel_aux::set_radio_trimmed(RC_Channel_aux::Aux_servo_function_t function, int16_t value)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-        	   int16_t value2 = value - 1500 + _aux_channels[i]->get_radio_trim();
-			   _aux_channels[i]->set_radio_out(constrain_int16(value2,_aux_channels[i]->get_radio_min(),_aux_channels[i]->get_radio_max()));
-            _aux_channels[i]->output();
-		  }
-    }
-}
-
-/*
-  set and save the trim value to radio_in for all channels matching
-  the given function type
- */
-void
-RC_Channel_aux::set_trim_to_radio_in_for(RC_Channel_aux::Aux_servo_function_t function)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-			   if (_aux_channels[i]->get_radio_in() != 0) {
-				    _aux_channels[i]->set_radio_trim( _aux_channels[i]->get_radio_in());
-				    _aux_channels[i]->save_radio_trim();
-			   }
-		  }
-    }
-}
-
-/*
-  set the radio_out value for any channel with the given function to radio_min
- */
-void
-RC_Channel_aux::set_radio_to_min(RC_Channel_aux::Aux_servo_function_t function)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-            _aux_channels[i]->set_radio_out( _aux_channels[i]->get_radio_min());
-            _aux_channels[i]->output();
-		  }
-    }
-}
-
-/*
-  set the radio_out value for any channel with the given function to radio_max
- */
-void
-RC_Channel_aux::set_radio_to_max(RC_Channel_aux::Aux_servo_function_t function)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-            _aux_channels[i]->set_radio_out(_aux_channels[i]->get_radio_max());
-            _aux_channels[i]->output();
-		}
-    }
-}
-
-/*
-  set the radio_out value for any channel with the given function to radio_trim
- */
-void
-RC_Channel_aux::set_radio_to_trim(RC_Channel_aux::Aux_servo_function_t function)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-			   _aux_channels[i]->set_radio_out( _aux_channels[i]->get_radio_trim());
-            _aux_channels[i]->output();
-		  }
-    }
-}
-
-/*
-  copy radio_in to radio_out for a given function
- */
-void
-RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::Aux_servo_function_t function, bool do_input_output)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-			   if (do_input_output) {
-				    _aux_channels[i]->input();
-			   }
-			   _aux_channels[i]->set_radio_out(_aux_channels[i]->get_radio_in());
-			   if (do_input_output) {
-				    _aux_channels[i]->output();
-			   }
-		  }
-    }
-}
-
-/*
-  set servo_out and call calc_pwm() for a given function
- */
-void
-RC_Channel_aux::set_servo_out_for(RC_Channel_aux::Aux_servo_function_t function, int16_t value)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-			   _aux_channels[i]->set_servo_out(value);
-			   _aux_channels[i]->calc_pwm();
-            _aux_channels[i]->output();
-		  }
-    }
-}
-
-/*
-  setup failsafe value for an auxiliary function type to a LimitValue
- */
-void
-RC_Channel_aux::set_servo_failsafe_pwm(RC_Channel_aux::Aux_servo_function_t function, uint16_t pwm)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        const RC_Channel_aux *ch = _aux_channels[i];
-        if (ch && ch->function.get() == function) {
-            hal.rcout->set_failsafe_pwm(1U<<ch->get_ch_out(), pwm);
-        }
-    }
-}
-
-/*
-  setup failsafe value for an auxiliary function type to a LimitValue
- */
-void
-RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::Aux_servo_function_t function, RC_Channel::LimitValue limit)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        const RC_Channel_aux *ch = _aux_channels[i];
-        if (ch && ch->function.get() == function) {
-            uint16_t pwm = ch->get_limit_pwm(limit);
-            hal.rcout->set_failsafe_pwm(1U<<ch->get_ch_out(), pwm);
-        }
-    }
-}
-
-/*
-  set radio output value for an auxiliary function type to a LimitValue
- */
-void
-RC_Channel_aux::set_servo_limit(RC_Channel_aux::Aux_servo_function_t function, RC_Channel::LimitValue limit)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        RC_Channel_aux *ch = _aux_channels[i];
-        if (ch && ch->function.get() == function) {
-            uint16_t pwm = ch->get_limit_pwm(limit);
-            ch->set_radio_out(pwm);
-            if (ch->function.get() == k_manual) {
-                // in order for output_ch() to work for k_manual we
-                // also have to override radio_in
-                ch->set_radio_in(pwm);
-            }
-            if (ch->function.get() >= k_rcin1 && ch->function.get() <= k_rcin16) {
-                // save for k_rcin*
-                ch->set_radio_in(pwm);
-            }
-        }
-    }
-}
-
-/*
-  return true if a particular function is assigned to at least one RC channel
- */
-bool
-RC_Channel_aux::function_assigned(RC_Channel_aux::Aux_servo_function_t function)
-{
-    if (function < k_nr_aux_servo_functions) {
-        uint8_t fn = (uint8_t)function;
-        uint8_t idx = fn / 64;
-        uint8_t bit = fn % 64;
-        return (_function_mask[idx] & (1ULL<<bit)) != 0;
-    }
-	 return false;
-}
-
-/*
-  set servo_out and angle_min/max, then calc_pwm and output a
-  value. This is used to move a AP_Mount servo
- */
-void
-RC_Channel_aux::move_servo(RC_Channel_aux::Aux_servo_function_t function,
-						   int16_t value, int16_t angle_min, int16_t angle_max)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function.get() == function) {
-			_aux_channels[i]->set_servo_out(value);
-			_aux_channels[i]->set_range(angle_min, angle_max);
-			_aux_channels[i]->calc_pwm();
-			_aux_channels[i]->output();
-		}
-	}
-}
-
-/*
-  set the default channel an auxiliary output function should be on
- */
-bool RC_Channel_aux::set_aux_channel_default(RC_Channel_aux::Aux_servo_function_t function, uint8_t channel)
-{
-    if (!_initialised) {
-        update_aux_servo_function();
-    }
-    if (function_assigned(function)) {
-        // already assigned
-        return true;
-    }
-    for (uint8_t i=0; i<RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->_ch_out == channel) {
-            if (_aux_channels[i]->function != k_none) {
-                if (_aux_channels[i]->function == function) {
-                    return true;
-                }
-                hal.console->printf("Channel %u already assigned %u\n",
-                                    (unsigned)channel,
-                                    (unsigned)_aux_channels[i]->function);
-                return false;
-            }
-            _aux_channels[i]->function.set(function);
-            _aux_channels[i]->aux_servo_function_setup();
-            return true;
-        }
-    }
-    hal.console->printf("AUX channel %u not available\n",
-                        (unsigned)channel);
-    return false;    
-}
-
-// find first channel that a function is assigned to
-bool RC_Channel_aux::find_channel(RC_Channel_aux::Aux_servo_function_t function, uint8_t &chan)
-{
-    if (!_initialised) {
-        update_aux_servo_function();
-    }
-    if (!function_assigned(function)) {
-        return false;
-    }
-    for (uint8_t i=0; i<RC_AUX_MAX_CHANNELS; i++) {
-        if (_aux_channels[i] && _aux_channels[i]->function == function) {
-            chan = _aux_channels[i]->_ch_out;
-            return true;
-        }
-    }
-    return false;
-}
diff --git a/libraries/RC_Channel/RC_Channel_aux.h b/libraries/RC_Channel/RC_Channel_aux.h
deleted file mode 100644
index 50465d8..0000000
--- a/libraries/RC_Channel/RC_Channel_aux.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/// @file	RC_Channel_aux.h
-/// @brief	RC_Channel manager for auxiliary channels (5..8), with EEPROM-backed storage of constants.
-/// @author Amilcar Lucas
-#pragma once
-
-#include <AP_HAL/AP_HAL.h>
-#include "RC_Channel.h"
-
-#define RC_AUX_MAX_CHANNELS 12
-
-/// @class	RC_Channel_aux
-/// @brief	Object managing one aux. RC channel (CH5-8), with information about its function
-class RC_Channel_aux : public RC_Channel {
-public:
-    /// Constructor
-    ///
-    /// @param key      EEPROM storage key for the channel trim parameters.
-    /// @param name     Optional name for the group.
-    ///
-    RC_Channel_aux(uint8_t ch_out) :
-        RC_Channel(ch_out)
-    {
-        for (uint8_t i=0; i<RC_AUX_MAX_CHANNELS; i++) {
-            if (_aux_channels[i] == nullptr) {
-                _aux_channels[i] = this;
-                break;
-            }
-        }
-		AP_Param::setup_object_defaults(this, var_info);
-    }
-
-    typedef enum
-    {
-        k_none                  = 0,            ///< disabled
-        k_manual                = 1,            ///< manual, just pass-thru the RC in signal
-        k_flap                  = 2,            ///< flap
-        k_flap_auto             = 3,            ///< flap automated
-        k_aileron               = 4,            ///< aileron
-        k_unused1               = 5,            ///< unused function
-        k_mount_pan             = 6,            ///< mount yaw (pan)
-        k_mount_tilt            = 7,            ///< mount pitch (tilt)
-        k_mount_roll            = 8,            ///< mount roll
-        k_mount_open            = 9,            ///< mount open (deploy) / close (retract)
-        k_cam_trigger           = 10,           ///< camera trigger
-        k_egg_drop              = 11,           ///< egg drop
-        k_mount2_pan            = 12,           ///< mount2 yaw (pan)
-        k_mount2_tilt           = 13,           ///< mount2 pitch (tilt)
-        k_mount2_roll           = 14,           ///< mount2 roll
-        k_mount2_open           = 15,           ///< mount2 open (deploy) / close (retract)
-        k_dspoiler1             = 16,           ///< differential spoiler 1 (left wing)
-        k_dspoiler2             = 17,           ///< differential spoiler 2 (right wing)
-        k_aileron_with_input    = 18,            ///< aileron, with rc input
-        k_elevator              = 19,            ///< elevator
-        k_elevator_with_input   = 20,            ///< elevator, with rc input
-        k_rudder                = 21,            ///< secondary rudder channel
-        k_sprayer_pump          = 22,            ///< crop sprayer pump channel
-        k_sprayer_spinner       = 23,            ///< crop sprayer spinner channel
-        k_flaperon1             = 24,            ///< flaperon, left wing
-        k_flaperon2             = 25,            ///< flaperon, right wing
-        k_steering              = 26,            ///< ground steering, used to separate from rudder
-        k_parachute_release     = 27,            ///< parachute release
-        k_gripper               = 28,            ///< gripper
-        k_landing_gear_control  = 29,            ///< landing gear controller
-        k_engine_run_enable     = 30,            ///< engine kill switch, used for gas airplanes and helicopters
-        k_heli_rsc              = 31,            ///< helicopter RSC output
-        k_heli_tail_rsc         = 32,            ///< helicopter tail RSC output
-        k_motor1                = 33,            ///< these allow remapping of copter motors
-        k_motor2                = 34,
-        k_motor3                = 35,
-        k_motor4                = 36,
-        k_motor5                = 37,
-        k_motor6                = 38,
-        k_motor7                = 39,
-        k_motor8                = 40,
-        k_motor_tilt            = 41,            ///< tiltrotor motor tilt control
-        k_rcin1                 = 51,            ///< these are for pass-thru from arbitrary rc inputs
-        k_rcin2                 = 52,
-        k_rcin3                 = 53,
-        k_rcin4                 = 54,
-        k_rcin5                 = 55,
-        k_rcin6                 = 56,
-        k_rcin7                 = 57,
-        k_rcin8                 = 58,
-        k_rcin9                 = 59,
-        k_rcin10                = 60,
-        k_rcin11                = 61,
-        k_rcin12                = 62,
-        k_rcin13                = 63,
-        k_rcin14                = 64,
-        k_rcin15                = 65,
-        k_rcin16                = 66,
-        k_ignition              = 67,
-        k_choke                 = 68,
-        k_starter               = 69,
-        k_throttle              = 70,
-        k_nr_aux_servo_functions         ///< This must be the last enum value (only add new values _before_ this one)
-    } Aux_servo_function_t;
-
-    AP_Int8         function;           ///< see Aux_servo_function_t enum
-
-    // output one auxiliary channel
-    void            output_ch(void);
-
-    // output all auxiliary channels
-    static void     output_ch_all(void);
-
-	// set radio_out for a function channel
-	static void set_radio(Aux_servo_function_t function, int16_t value);
-
-    // get radio_out for *first* channel matching the given function type.
-    static bool get_radio(RC_Channel_aux::Aux_servo_function_t function, int16_t &value);
-
-	// set radio_out for all channels matching the given function type, allow radio_trim to center servo
-	static void set_radio_trimmed(Aux_servo_function_t function, int16_t value);
-
-	// set and save the trim for a function channel to radio_in
-	static void set_trim_to_radio_in_for(Aux_servo_function_t function);
-
-	// set radio_out to radio_min
-	static void set_radio_to_min(Aux_servo_function_t function);
-
-	// set radio_out to radio_max
-	static void set_radio_to_max(Aux_servo_function_t function);
-
-	// set radio_out to radio_trim
-	static void set_radio_to_trim(Aux_servo_function_t function);
-
-	// copy radio_in to radio_out
-	static void copy_radio_in_out(Aux_servo_function_t function, bool do_input_output=false);
-
-	// set servo_out
-	static void set_servo_out_for(Aux_servo_function_t function, int16_t value);
-
-    // setup failsafe for an auxiliary channel function, by pwm
-    static void set_servo_failsafe_pwm(RC_Channel_aux::Aux_servo_function_t function, uint16_t pwm);
-    
-	// setup failsafe for an auxiliary channel function
-	static void set_servo_failsafe(Aux_servo_function_t function, RC_Channel::LimitValue limit);
-
-	// set servo to a LimitValue
-	static void set_servo_limit(Aux_servo_function_t function, RC_Channel::LimitValue limit);
-
-	// return true if a function is assigned to a channel
-	static bool function_assigned(Aux_servo_function_t function);
-
-	// set a servo_out value, and angle range, then calc_pwm
-	static void move_servo(Aux_servo_function_t function,
-						   int16_t value, int16_t angle_min, int16_t angle_max);
-
-    static const struct AP_Param::GroupInfo        var_info[];
-
-    // assigned and enable auxiliary channels
-    static void enable_aux_servos(void);
-    
-    // prevent a channel from being used for auxiliary functions
-    static void disable_aux_channel(uint8_t channel);
-
-    // return the current function for a channel
-    static Aux_servo_function_t channel_function(uint8_t channel);
-
-    // refresh aux servo to function mapping
-    static void update_aux_servo_function(void);
-
-    // set default channel for an auxiliary function
-    static bool set_aux_channel_default(Aux_servo_function_t function, uint8_t channel);
-
-    // find first channel that a function is assigned to
-    static bool find_channel(Aux_servo_function_t function, uint8_t &chan);
-
-    // control pass-thru of channels
-    static void disable_passthrough(bool disable) {
-        _disable_passthrough = disable;
-    }
-    
-private:
-    static uint64_t _function_mask[2];
-    static bool _initialised;
-    static RC_Channel_aux *_aux_channels[RC_AUX_MAX_CHANNELS];
-    static bool _disable_passthrough;
-
-    void aux_servo_function_setup(void);
-    static void set_function_mask(uint8_t function);
-    static void clear_function_mask(void);
-};
diff --git a/libraries/RC_Channel/SRV_Channel.cpp b/libraries/RC_Channel/SRV_Channel.cpp
index 8adf8b6..bc70425 100644
--- a/libraries/RC_Channel/SRV_Channel.cpp
+++ b/libraries/RC_Channel/SRV_Channel.cpp
@@ -19,295 +19,303 @@
 
 #include <AP_HAL/AP_HAL.h>
 #include <AP_Math/AP_Math.h>
+#include <AP_Vehicle/AP_Vehicle.h>
 #include "SRV_Channel.h"
 #include "RC_Channel.h"
 
 extern const AP_HAL::HAL& hal;
 
-const AP_Param::GroupInfo SRV_Channels::var_info[] = {
-    // @Param: RNG_ENABLE
-    // @DisplayName: Enable servo output ranges
-    // @Description: This enables the use of separate servo output ranges from input ranges. 
-    // @Values: 0:Disable,1:Enable
-    // @User: Advanced
-    AP_GROUPINFO_FLAGS("_RNG_ENABLE",  1, SRV_Channels, enable, 0, AP_PARAM_FLAG_ENABLE),
+SRV_Channel *SRV_Channels::channels;
+bool SRV_Channels::disabled_passthrough;
+bool SRV_Channels::initialised;
+Bitmask SRV_Channels::function_mask{SRV_Channel::k_nr_aux_servo_functions};
+SRV_Channels::srv_function SRV_Channels::functions[SRV_Channel::k_nr_aux_servo_functions];
+SRV_Channel::servo_mask_t SRV_Channel::have_pwm_mask;
 
-    // @Param: 1_MIN
-    // @DisplayName: Servo1 min PWM
-    // @Description: servo1 minimum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
+const AP_Param::GroupInfo SRV_Channel::var_info[] = {
+    // @Param: MIN
+    // @DisplayName: Minimum PWM
+    // @Description: minimum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
     // @Units: pwm
     // @Range: 800 2200
     // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("1_MIN",  2, SRV_Channels, servo_min[0], 1100),
+    // @User: Standard
+    AP_GROUPINFO("MIN",  1, SRV_Channel, servo_min, 1100),
 
-    // @Param: 1_MAX
-    // @DisplayName: Servo1 max PWM
-    // @Description: servo1 maximum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
+    // @Param: MAX
+    // @DisplayName: Maximum PWM
+    // @Description: maximum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
     // @Units: pwm
     // @Range: 800 2200
     // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("1_MAX",  3, SRV_Channels, servo_max[0], 1900),
+    // @User: Standard
+    AP_GROUPINFO("MAX",  2, SRV_Channel, servo_max, 1900),
 
-    // @Param: 1_TRIM
-    // @DisplayName: Servo1 trim PWM
-    // @Description: servo1 trim PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
+    // @Param: TRIM
+    // @DisplayName: Trim PWM
+    // @Description: Trim PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
     // @Units: pwm
     // @Range: 800 2200
     // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("1_TRIM",  4, SRV_Channels, servo_trim[0], 1500),
+    // @User: Standard
+    AP_GROUPINFO("TRIM",  3, SRV_Channel, servo_trim, 1500),
     
-    // @Param: 1_REV
-    // @DisplayName: Servo1 reverse
-    // @Description: Reverse servo operation. Set to 1 for normal (forward) operation. Set to -1 to reverse this channel.
-    // @Values: -1:Reversed,1:Normal
-    // @User: Advanced
-    AP_GROUPINFO("1_REV",  5, SRV_Channels, reverse[0], 1),
+    // @Param: REVERSED
+    // @DisplayName: Servo reverse
+    // @Description: Reverse servo operation. Set to 0 for normal operation. Set to 1 to reverse this channel.
+    // @Values: 0:Normal,1:Reversed
+    // @User: Standard
+    AP_GROUPINFO("REVERSED",  4, SRV_Channel, reversed, 0),
 
-    // @Param: 2_MIN
-    // @DisplayName: Servo1 min PWM
-    // @Description: servo1 minimum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("2_MIN",  6, SRV_Channels, servo_min[1], 1100),
+    // @Param: FUNCTION
+    // @DisplayName: Servo output function
+    // @Description: Function assigned to this servo. Seeing this to Disabled(0) will setup this output for control by auto missions or MAVLink servo set commands. any other value will enable the corresponding function
+    // @Values: 0:Disabled,1:RCPassThru,2:Flap,3:Flap_auto,4:Aileron,6:mount_pan,7:mount_tilt,8:mount_roll,9:mount_open,10:camera_trigger,11:release,12:mount2_pan,13:mount2_tilt,14:mount2_roll,15:mount2_open,16:DifferentialSpoiler1,17:DifferentialSpoiler2,18:AileronWithInput,19:Elevator,20:ElevatorWithInput,21:Rudder,24:Flaperon1,25:Flaperon2,26:GroundSteering,27:Parachute,28:EPM,29:LandingGear,30:EngineRunEnable,31:HeliRSC,32:HeliTailRSC,33:Motor1,34:Motor2,35:Motor3,36:Motor4,37:Motor5,38:Motor6,39:Motor7,40:Motor8,51:RCIN1,52:RCIN2,53:RCIN3,54:RCIN4,55:RCIN5,56:RCIN6,57:RCIN7,58:RCIN8,59:RCIN9,60:RCIN10,61:RCIN11,62:RCIN12,63:RCIN13,64:RCIN14,65:RCIN15,66:RCIN16,67:Ignition,68:Choke,69:Starter,70:Throttle
+    // @User: Standard
+    AP_GROUPINFO("FUNCTION",  5, SRV_Channel, function, 0),
+    
+    AP_GROUPEND
+};
 
-    // @Param: 2_MAX
-    // @DisplayName: Servo1 max PWM
-    // @Description: servo1 maximum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("2_MAX",  7, SRV_Channels, servo_max[1], 1900),
 
-    // @Param: 2_TRIM
-    // @DisplayName: Servo1 trim PWM
-    // @Description: servo1 trim PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("2_TRIM",  8, SRV_Channels, servo_trim[1], 1500),
-    
-    // @Param: 2_REV
-    // @DisplayName: Servo1 reverse
-    // @Description: Reverse servo operation. Set to 1 for normal (forward) operation. Set to -1 to reverse this channel.
-    // @Values: -1:Reversed,1:Normal
-    // @User: Advanced
-    AP_GROUPINFO("2_REV",  9, SRV_Channels, reverse[1], 1),
+const AP_Param::GroupInfo SRV_Channels::var_info[] = {
+    // @Group: 1_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[0], "1_",  1, SRV_Channels, SRV_Channel),
 
-    // @Param: 3_MIN
-    // @DisplayName: Servo1 min PWM
-    // @Description: servo1 minimum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("3_MIN",  10, SRV_Channels, servo_min[2], 1100),
+    // @Group: 2_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[1], "2_",  2, SRV_Channels, SRV_Channel),
 
-    // @Param: 3_MAX
-    // @DisplayName: Servo1 max PWM
-    // @Description: servo1 maximum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("3_MAX",  11, SRV_Channels, servo_max[2], 1900),
+    // @Group: 3_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[2], "3_",  3, SRV_Channels, SRV_Channel),
 
-    // @Param: 3_TRIM
-    // @DisplayName: Servo1 trim PWM
-    // @Description: servo1 trim PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("3_TRIM",  12, SRV_Channels, servo_trim[2], 1500),
-    
-    // @Param: 3_REV
-    // @DisplayName: Servo1 reverse
-    // @Description: Reverse servo operation. Set to 1 for normal (forward) operation. Set to -1 to reverse this channel.
-    // @Values: -1:Reversed,1:Normal
-    // @User: Advanced
-    AP_GROUPINFO("3_REV",  13, SRV_Channels, reverse[2], 1),
+    // @Group: 4_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[3], "4_",  4, SRV_Channels, SRV_Channel),
 
-    // @Param: 4_MIN
-    // @DisplayName: Servo1 min PWM
-    // @Description: servo1 minimum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("4_MIN",  14, SRV_Channels, servo_min[3], 1100),
+    // @Group: 5_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[4], "5_",  5, SRV_Channels, SRV_Channel),
 
-    // @Param: 4_MAX
-    // @DisplayName: Servo1 max PWM
-    // @Description: servo1 maximum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("4_MAX",  15, SRV_Channels, servo_max[3], 1900),
+    // @Group: 6_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[5], "6_",  6, SRV_Channels, SRV_Channel),
 
-    // @Param: 4_TRIM
-    // @DisplayName: Servo1 trim PWM
-    // @Description: servo1 trim PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Advanced
-    AP_GROUPINFO("4_TRIM",  16, SRV_Channels, servo_trim[3], 1500),
-    
-    // @Param: 4_REV
-    // @DisplayName: Servo1 reverse
-    // @Description: Reverse servo operation. Set to 1 for normal (forward) operation. Set to -1 to reverse this channel.
-    // @Values: -1:Reversed,1:Normal
-    // @User: Advanced
-    AP_GROUPINFO("4_REV",  17, SRV_Channels, reverse[3], 1),
+    // @Group: 7_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[6], "7_",  7, SRV_Channels, SRV_Channel),
+
+    // @Group: 8_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[7], "8_",  8, SRV_Channels, SRV_Channel),
+
+    // @Group: 9_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[8], "9_",  9, SRV_Channels, SRV_Channel),
+
+    // @Group: 10_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[9], "10_",  10, SRV_Channels, SRV_Channel),
+
+    // @Group: 11_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[10], "11_",  11, SRV_Channels, SRV_Channel),
+
+    // @Group: 12_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[11], "12_",  12, SRV_Channels, SRV_Channel),
+
+    // @Group: 13_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[12], "13_",  13, SRV_Channels, SRV_Channel),
+
+    // @Group: 14_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[13], "14_",  14, SRV_Channels, SRV_Channel),
+
+    // @Group: 15_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[14], "15_",  15, SRV_Channels, SRV_Channel),
 
+    // @Group: 16_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[15], "16_",  16, SRV_Channels, SRV_Channel),
+    
     // @Param: _AUTO_TRIM
     // @DisplayName: Automatic servo trim
     // @Description: This enables automatic servo trim in flight. Servos will be trimed in stabilized flight modes when the aircraft is close to level. Changes to servo trim will be saved every 10 seconds and will persist between flights.
     // @Values: 0:Disable,1:Enable
     // @User: Advanced
-    AP_GROUPINFO("_AUTO_TRIM",  18, SRV_Channels, auto_trim, 0),
+    AP_GROUPINFO("_AUTO_TRIM",  17, SRV_Channels, auto_trim, 0),
     
     AP_GROUPEND
 };
 
+SRV_Channel::SRV_Channel(void)
+{
+    AP_Param::setup_object_defaults(this, var_info);
+    // start with all pwm at zero
+    have_pwm_mask = ~uint16_t(0);
+}
+
 
 /*
   constructor
  */
-SRV_Channels::SRV_Channels(void)
+SRV_Channels::SRV_Channels(const RCMapper &_rcmap) :
+    rcmap(_rcmap)
 {
+    channels = obj_channels;
+    
+    // set defaults from the parameter table
     AP_Param::setup_object_defaults(this, var_info);
-}
 
+    // setup ch_num on channels
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        channels[i].ch_num = i;
+    }
+}
 
-// remap a PWM value from a channel in value
-uint16_t SRV_Channels::remap_pwm(uint8_t i, uint16_t pwm) const
+/*
+  save adjusted trims
+ */
+void SRV_Channels::save_trim(void)
 {
-    const RC_Channel *ch = RC_Channel::rc_channel(i);
-    if (ch == nullptr) {
-        return 0;
-    }
-    float v = ch->get_radio_out_normalised(pwm);
-    uint16_t radio_out;
-    if (ch->get_type_out() == RC_CHANNEL_TYPE_RANGE) {
-        if (reverse[i] == -1) {
-            v = 1 - v;
-        }
-        radio_out = servo_min[i] + v * (servo_max[i] - servo_min[i]);
-    } else {
-        if (reverse[i] == -1) {
-            v = -v;
-        }
-        if (v > 0) {
-            radio_out = servo_trim[i] + v * (servo_max[i] - servo_trim[i]);
-        } else {
-            radio_out = servo_trim[i] + v * (servo_trim[i] - servo_min[i]);
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (trimmed_mask & (1U<<i)) {
+            channels[i].servo_trim.set_and_save(channels[i].servo_trim.get());
         }
     }
-    radio_out = constrain_int16(radio_out, servo_min[i], servo_max[i]);
-    return radio_out;
+    trimmed_mask = 0;
 }
 
-/*
-  remap radio_out values for first 4 servos using SERVO* parameters, if enabled
-  This should be called with cork enabled in hal.rcout
- */
-void SRV_Channels::remap_servo_output(void)
+// convert a 0..range_max to a pwm
+uint16_t SRV_Channel::pwm_from_range(int16_t scaled_value) const
 {
-    // cope with SERVO_RNG_ENABLE being changed at runtime. If we
-    // don't change the ESC scaling immediately then some ESCs will
-    // fire up for one second
-    if (last_enable != enable && esc_cal_chan != -1) {
-        last_enable = enable;
-        set_esc_scaling(esc_cal_chan);
+    if (servo_max <= servo_min || high_out == 0) {
+        return servo_min;
     }
-    if (!enable) {
-        return;
+    if (scaled_value >= high_out) {
+        scaled_value = high_out;
     }
-    for (uint8_t i=0; i<NUM_SERVO_RANGE_CHANNELS; i++) {
-        RC_Channel *ch = RC_Channel::rc_channel(i);
-        if (ch == nullptr) {
-            continue;
-        }
-        uint16_t radio_out = remap_pwm(i, ch->get_radio_out());
-        ch->set_radio_out(radio_out);
+    if (scaled_value < 0) {
+        scaled_value = 0;
     }
+    if (reversed) {
+        scaled_value = high_out - scaled_value;
+    }
+    return servo_min + ((int32_t)scaled_value * (int32_t)(servo_max - servo_min)) / (int32_t)high_out;
 }
 
+// convert a -angle_max..angle_max to a pwm
+uint16_t SRV_Channel::pwm_from_angle(int16_t scaled_value) const
+{
+    if (reversed) {
+        scaled_value = -scaled_value;
+    }
+    if (scaled_value > 0) {
+        return servo_trim + ((int32_t)scaled_value * (int32_t)(servo_max - servo_trim)) / (int32_t)high_out;
+    } else {
+        return servo_trim - (-(int32_t)scaled_value * (int32_t)(servo_trim - servo_min)) / (int32_t)high_out;
+    }
+}
 
-/*
-  set trim values for output channels
- */
-void SRV_Channels::set_trim(void)
+void SRV_Channel::calc_pwm(int16_t output_scaled)
 {
-    if (!enable) {
+    if (have_pwm_mask & (1U<<ch_num)) {
         return;
     }
-    for (uint8_t i=0; i<NUM_SERVO_RANGE_CHANNELS; i++) {
-        const RC_Channel *ch = RC_Channel::rc_channel(i);
-        if (ch == nullptr) {
-            continue;
-        }
-        if (ch->get_type_out() == RC_CHANNEL_TYPE_RANGE) {
-            // we don't trim range channels (like throttle)
-            continue;
-        }
-        uint16_t new_trim = remap_pwm(i, ch->get_radio_trim());
-        servo_trim[i].set_and_save(new_trim);
+    uint16_t pwm;
+    if (type_angle) {
+        pwm = pwm_from_angle(output_scaled);
+    } else {
+        pwm = pwm_from_range(output_scaled);
     }
+    set_output_pwm(pwm);
 }
 
-void SRV_Channels::set_esc_scaling(uint8_t chnum)
+void SRV_Channels::output_trim_all(void)
 {
-    esc_cal_chan = chnum;
-    if (!enable || chnum >= NUM_SERVO_RANGE_CHANNELS) {
-        const RC_Channel *ch = RC_Channel::rc_channel(chnum);
-        hal.rcout->set_esc_scaling(ch->get_radio_min(), ch->get_radio_max());
-    } else {
-        hal.rcout->set_esc_scaling(servo_min[chnum], servo_max[chnum]);
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        channels[i].set_output_pwm(channels[i].servo_trim);
     }
 }
 
+void SRV_Channels::setup_failsafe_trim_all(void)
+{
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        hal.rcout->set_failsafe_pwm(1U<<channels[i].ch_num, channels[i].servo_trim);
+    }
+}
+
+void SRV_Channel::set_output_pwm(uint16_t pwm)
+{
+    output_pwm = pwm;
+    have_pwm_mask |= (1U<<ch_num);
+}
+
+// set angular range of scaled output
+void SRV_Channel::set_angle(int16_t angle)
+{
+    type_angle = true;
+    high_out = angle;    
+    type_setup = true;
+}
+
+// set range of scaled output
+void SRV_Channel::set_range(uint16_t high)
+{
+    type_angle = false;
+    high_out = high;
+    type_setup = true;
+}
+
 /*
-  auto-adjust channel trim from an integrator value. Positive v means
-  adjust trim up. Negative means decrease
+  get normalised output from -1 to 1, assuming 0 at mid point of servo_min/servo_max
  */
-void SRV_Channels::adjust_trim(uint8_t chnum, float v)
+float SRV_Channel::get_output_norm(void)
 {
-    if (reverse[chnum] == -1) {
-        v = -v;
+    uint16_t mid = (servo_max + servo_min) / 2;
+    float ret;
+    if (mid <= servo_min) {
+        return 0;
     }
-    uint16_t new_trim = servo_trim[chnum];
-    float trim_scaled = float(servo_trim[chnum] - servo_min[chnum]) / (servo_max[chnum] - servo_min[chnum]);
-    if (v > 0 && trim_scaled < 0.6f) {
-        new_trim++;
-    } else if (v < 0  && trim_scaled > 0.4f) {
-        new_trim--;
+    if (output_pwm < mid) {
+        ret = (float)(output_pwm - mid) / (float)(mid - servo_min);
+    } else if (output_pwm > mid) {
+        ret = (float)(output_pwm - mid) / (float)(servo_max  - mid);
     } else {
-        return;
+        ret = 0;
+    }
+    if (get_reversed()) {
+           ret = -ret;
     }
-    servo_trim[chnum].set(new_trim);
+    return ret;
+}
 
-    trimmed_mask |= 1U<<chnum;
+uint16_t SRV_Channel::get_limit_pwm(LimitValue limit) const
+{
+    switch (limit) {
+    case SRV_CHANNEL_LIMIT_TRIM:
+        return servo_trim;
+    case SRV_CHANNEL_LIMIT_MIN:
+        return servo_min;
+    case SRV_CHANNEL_LIMIT_MAX:
+        return servo_max;
+    case SRV_CHANNEL_LIMIT_ZERO_PWM:
+    default:
+        return 0;
+    }
 }
 
 /*
-  save adjusted trims
+  run calc_pwm for all channels
  */
-void SRV_Channels::save_trim(void)
+void SRV_Channels::calc_pwm(void)
 {
-    for (uint8_t i=0; i<NUM_SERVO_RANGE_CHANNELS; i++) {
-        if (trimmed_mask & (1U<<i)) {
-            servo_trim[i].set_and_save(servo_trim[i].get());
-        }
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        channels[i].calc_pwm(functions[channels[i].function].output_scaled);
     }
-    trimmed_mask = 0;
 }
diff --git a/libraries/RC_Channel/SRV_Channel.h b/libraries/RC_Channel/SRV_Channel.h
index 775d33b..7885f0b 100644
--- a/libraries/RC_Channel/SRV_Channel.h
+++ b/libraries/RC_Channel/SRV_Channel.h
@@ -15,59 +15,374 @@
 
 #include <AP_Common/AP_Common.h>
 #include <AP_Param/AP_Param.h>
+#include <AP_RCMapper/AP_RCMapper.h>
+#include <AP_Common/Bitmask.h>
+
 #include "RC_Channel.h"
 
-#define NUM_SERVO_RANGE_CHANNELS 4
+#define NUM_SERVO_CHANNELS 16
+
+class SRV_Channels;
+
+/*
+  class SRV_Channel. The class SRV_Channels contains an array of
+  SRV_Channel objects. This is done to fit within the AP_Param limit
+  of 64 parameters per object.
+*/
+class SRV_Channel {
+public:
+    friend class SRV_Channels;
+    // constructor
+    SRV_Channel(void);
+
+    static const struct AP_Param::GroupInfo var_info[];
+
+    typedef enum
+    {
+        k_none                  = 0,            ///< disabled
+        k_manual                = 1,            ///< manual, just pass-thru the RC in signal
+        k_flap                  = 2,            ///< flap
+        k_flap_auto             = 3,            ///< flap automated
+        k_aileron               = 4,            ///< aileron
+        k_unused1               = 5,            ///< unused function
+        k_mount_pan             = 6,            ///< mount yaw (pan)
+        k_mount_tilt            = 7,            ///< mount pitch (tilt)
+        k_mount_roll            = 8,            ///< mount roll
+        k_mount_open            = 9,            ///< mount open (deploy) / close (retract)
+        k_cam_trigger           = 10,           ///< camera trigger
+        k_egg_drop              = 11,           ///< egg drop
+        k_mount2_pan            = 12,           ///< mount2 yaw (pan)
+        k_mount2_tilt           = 13,           ///< mount2 pitch (tilt)
+        k_mount2_roll           = 14,           ///< mount2 roll
+        k_mount2_open           = 15,           ///< mount2 open (deploy) / close (retract)
+        k_dspoiler1             = 16,           ///< differential spoiler 1 (left wing)
+        k_dspoiler2             = 17,           ///< differential spoiler 2 (right wing)
+        k_aileron_with_input    = 18,            ///< aileron, with rc input
+        k_elevator              = 19,            ///< elevator
+        k_elevator_with_input   = 20,            ///< elevator, with rc input
+        k_rudder                = 21,            ///< secondary rudder channel
+        k_sprayer_pump          = 22,            ///< crop sprayer pump channel
+        k_sprayer_spinner       = 23,            ///< crop sprayer spinner channel
+        k_flaperon1             = 24,            ///< flaperon, left wing
+        k_flaperon2             = 25,            ///< flaperon, right wing
+        k_steering              = 26,            ///< ground steering, used to separate from rudder
+        k_parachute_release     = 27,            ///< parachute release
+        k_gripper               = 28,            ///< gripper
+        k_landing_gear_control  = 29,            ///< landing gear controller
+        k_engine_run_enable     = 30,            ///< engine kill switch, used for gas airplanes and helicopters
+        k_heli_rsc              = 31,            ///< helicopter RSC output
+        k_heli_tail_rsc         = 32,            ///< helicopter tail RSC output
+        k_motor1                = 33,            ///< these allow remapping of copter motors
+        k_motor2                = 34,
+        k_motor3                = 35,
+        k_motor4                = 36,
+        k_motor5                = 37,
+        k_motor6                = 38,
+        k_motor7                = 39,
+        k_motor8                = 40,
+        k_motor_tilt            = 41,            ///< tiltrotor motor tilt control
+        k_rcin1                 = 51,            ///< these are for pass-thru from arbitrary rc inputs
+        k_rcin2                 = 52,
+        k_rcin3                 = 53,
+        k_rcin4                 = 54,
+        k_rcin5                 = 55,
+        k_rcin6                 = 56,
+        k_rcin7                 = 57,
+        k_rcin8                 = 58,
+        k_rcin9                 = 59,
+        k_rcin10                = 60,
+        k_rcin11                = 61,
+        k_rcin12                = 62,
+        k_rcin13                = 63,
+        k_rcin14                = 64,
+        k_rcin15                = 65,
+        k_rcin16                = 66,
+        k_ignition              = 67,
+        k_choke                 = 68,
+        k_starter               = 69,
+        k_throttle              = 70,
+        k_nr_aux_servo_functions         ///< This must be the last enum value (only add new values _before_ this one)
+    } Aux_servo_function_t;
+
+    // used to get min/max/trim limit value based on reverse
+    enum LimitValue {
+        SRV_CHANNEL_LIMIT_TRIM,
+        SRV_CHANNEL_LIMIT_MIN,
+        SRV_CHANNEL_LIMIT_MAX,
+        SRV_CHANNEL_LIMIT_ZERO_PWM
+    };
+
+    // a special scaled output value that is recognised as meaning no pwm output
+    static const int16_t ZERO_PWM = INT16_MIN;
+
+    // set the output value as a pwm value
+    void set_output_pwm(uint16_t pwm);
+
+    // get the output value as a pwm value
+    uint16_t get_output_pwm(void) const { return output_pwm; }
+
+    // set angular range of scaled output
+    void set_angle(int16_t angle);
+
+    // set range of scaled output. Low is always zero
+    void set_range(uint16_t high);
+
+    // return true if the channel is reversed
+    bool get_reversed(void) const {
+        return reversed?true:false;
+    }
+
+    // set MIN/MAX parameters
+    void set_output_min(uint16_t pwm) {
+        servo_min.set(pwm);
+    }
+    void set_output_max(uint16_t pwm) {
+        servo_max.set(pwm);
+    }
+
+    // get MIN/MAX/TRIM parameters
+    uint16_t get_output_min(void) const {
+        return servo_min;
+    }
+    uint16_t get_output_max(void) const {
+        return servo_max;
+    }
+    uint16_t get_trim(void) const {
+        return servo_trim;
+    }
+
+private:
+    AP_Int16 servo_min;
+    AP_Int16 servo_max;
+    AP_Int16 servo_trim;
+    // reversal, following convention that 1 means reversed, 0 means normal
+    AP_Int8 reversed;
+    AP_Int8 function;
+
+    // a pending output value as PWM
+    uint16_t output_pwm;
+
+    // true for angle output type
+    bool type_angle:1;
+
+    // set_range() or set_angle() has been called
+    bool type_setup:1;
+    
+    // the hal channel number
+    uint8_t ch_num;
+
+    // high point of angle or range output
+    uint16_t high_out;
+
+    // convert a 0..range_max to a pwm
+    uint16_t pwm_from_range(int16_t scaled_value) const;
+
+    // convert a -angle_max..angle_max to a pwm
+    uint16_t pwm_from_angle(int16_t scaled_value) const;
+
+    // convert a scaled output to a pwm value
+    void calc_pwm(int16_t output_scaled);
+
+    // output value based on function
+    void output_ch(void);
+
+    // setup output type and range based on function
+    void aux_servo_function_setup(void);
+
+    // return PWM for a given limit value
+    uint16_t get_limit_pwm(LimitValue limit) const;
+
+    // get normalised output from -1 to 1
+    float get_output_norm(void);
+    
+    // a bitmask type wide enough for NUM_SERVO_CHANNELS
+    typedef uint16_t servo_mask_t;
+
+    // mask of channels where we have a output_pwm value. Cleared when a
+    // scaled value is written. 
+    static servo_mask_t have_pwm_mask;
+};
 
 /*
-  class	SRV_Channel
+  class	SRV_Channels
 */
 class SRV_Channels {
 public:
     // constructor
-    SRV_Channels(void);
+    SRV_Channels(const RCMapper &_rcmap);
 
     static const struct AP_Param::GroupInfo var_info[];
 
+    // set the default function for a channel
+    static void set_default_function(uint8_t chan, SRV_Channel::Aux_servo_function_t function);
+
+    // set output value for a function channel as a pwm value
+    static void set_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t value);
+
+    // set output value for a function channel as a pwm value on the first matching channel
+    static void set_output_pwm_first(SRV_Channel::Aux_servo_function_t function, uint16_t value);
+
+    // set output value for a function channel as a scaled value. This
+    // calls calc_pwm() to also set the pwm value
+    static void set_output_scaled(SRV_Channel::Aux_servo_function_t function, int16_t value);
+
+    // get scaled output for the given function type.
+    static int16_t get_output_scaled(SRV_Channel::Aux_servo_function_t function);
+
+    // get pwm output for the first channel of the given function type.
+    static bool get_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t &value);
+
+    // get normalised output (-1 to 1 for angle, 0 to 1 for range). Value is taken from pwm value
+    // return zero on error.
+    static float get_output_norm(SRV_Channel::Aux_servo_function_t function);
+
+    // limit slew rate to given limit in percent per second
+    static void limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate);
+
+    // call output_ch() on all channels
+    static void output_ch_all(void);
+
     // take current radio_out for first 4 channels and remap using
     // servo ranges if enabled
     void remap_servo_output(void);
 
-    // set and save trim values from current RC input trim
-    void set_trim(void);
-
-    // setup output ESC scaling for a channel
-    void set_esc_scaling(uint8_t chnum);
-
-    // return true when enabled
-    bool enabled(void) const { return enable; }
+    // setup output ESC scaling based on a channels MIN/MAX
+    void set_esc_scaling_for(SRV_Channel::Aux_servo_function_t function);
 
     // return true when auto_trim enabled
     bool auto_trim_enabled(void) const { return auto_trim; }
-    
+
     // adjust trim of a channel by a small increment
-    void adjust_trim(uint8_t ch, float v);
+    void adjust_trim(SRV_Channel::Aux_servo_function_t function, float v);
 
     // save trims
     void save_trim(void);
+
+    // setup for a reversible k_throttle (from -100 to 100)
+    void set_reversible_throttle(void) {
+        flags.k_throttle_reversible = true;
+    }
+
+    // set all outputs to the TRIM value
+    static void output_trim_all(void);
+
+    // setup IO failsafe for all channels to trim
+    static void setup_failsafe_trim_all(void);
+
+    // set output for all channels matching the given function type, allow radio_trim to center servo
+    static void set_output_pwm_trimmed(SRV_Channel::Aux_servo_function_t function, int16_t value);
+
+    // set and save the trim for a function channel to radio_in on matching input channel
+    static void set_trim_to_radio_in_for(SRV_Channel::Aux_servo_function_t function);
+
+    // set the trim for a function channel to min of the channel
+    static void set_trim_to_min_for(SRV_Channel::Aux_servo_function_t function);
+
+    // set the trim for a function channel to given pwm
+    static void set_trim_to_pwm_for(SRV_Channel::Aux_servo_function_t function, int16_t pwm);
+
+    // set output to min value
+    static void set_output_to_min(SRV_Channel::Aux_servo_function_t function);
+
+    // set output to max value
+    static void set_output_to_max(SRV_Channel::Aux_servo_function_t function);
+
+    // set output to trim value
+    static void set_output_to_trim(SRV_Channel::Aux_servo_function_t function);
+
+    // copy radio_in to radio_out
+    static void copy_radio_in_out(SRV_Channel::Aux_servo_function_t function, bool do_input_output=false);
+
+    // setup failsafe for an auxiliary channel function, by pwm
+    static void set_failsafe_pwm(SRV_Channel::SRV_Channel::Aux_servo_function_t function, uint16_t pwm);
+
+    // setup failsafe for an auxiliary channel function
+    static void set_failsafe_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
+
+    // setup safety for an auxiliary channel function (used when disarmed)
+    static void set_safety_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
+
+    // set servo to a LimitValue
+    static void set_output_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
+
+    // return true if a function is assigned to a channel
+    static bool function_assigned(SRV_Channel::Aux_servo_function_t function);
+
+    // set a servo_out value, and angle range, then calc_pwm
+    static void move_servo(SRV_Channel::Aux_servo_function_t function,
+                           int16_t value, int16_t angle_min, int16_t angle_max);
+
+    // assign and enable auxiliary channels
+    static void enable_aux_servos(void);
+
+    // prevent a channel from being used for auxiliary functions
+    static void disable_aux_channel(uint8_t channel);
+
+    // return the current function for a channel
+    static SRV_Channel::Aux_servo_function_t channel_function(uint8_t channel);
+
+    // refresh aux servo to function mapping
+    static void update_aux_servo_function(void);
+
+    // set default channel for an auxiliary function
+    static bool set_aux_channel_default(SRV_Channel::Aux_servo_function_t function, uint8_t channel);
+
+    // find first channel that a function is assigned to
+    static bool find_channel(SRV_Channel::Aux_servo_function_t function, uint8_t &chan);
+
+    // find first channel that a function is assigned to, returning SRV_Channel object
+    static SRV_Channel *get_channel_for(SRV_Channel::Aux_servo_function_t function, int8_t default_chan=-1);
+
+    // call set_angle() on matching channels
+    static void set_angle(SRV_Channel::Aux_servo_function_t function, uint16_t angle);
+
+    // call set_range() on matching channels
+    static void set_range(SRV_Channel::Aux_servo_function_t function, uint16_t range);
     
+    // control pass-thru of channels
+    void disable_passthrough(bool disable) {
+        disabled_passthrough = disable;
+    }
+
+    static bool passthrough_disabled(void) {
+        return disabled_passthrough;
+    }
+
+    // calculate PWM for all channels
+    static void calc_pwm(void);
+
+    static SRV_Channel *srv_channel(uint8_t i) {
+        return i<NUM_SERVO_CHANNELS?&channels[i]:nullptr;
+    }
+
 private:
-    AP_Int8 enable;
+    const RCMapper &rcmap;
+
+    struct {
+        bool k_throttle_reversible:1;
+    } flags;
+
+    static bool disabled_passthrough;
 
-    int8_t esc_cal_chan;
-    bool last_enable;
-    uint8_t trimmed_mask;
+    uint16_t trimmed_mask;
+
+    static Bitmask function_mask;
+    static bool initialised;
+    
+    // this static arrangement is to avoid having static objects in AP_Param tables
+    static SRV_Channel *channels;
+    SRV_Channel obj_channels[NUM_SERVO_CHANNELS];
 
-    // PWM values for min/max and trim
-    AP_Int16 servo_min[NUM_SERVO_RANGE_CHANNELS];
-    AP_Int16 servo_max[NUM_SERVO_RANGE_CHANNELS];
-    AP_Int16 servo_trim[NUM_SERVO_RANGE_CHANNELS];
+    static struct srv_function {
+        // mask of what channels this applies to
+        SRV_Channel::servo_mask_t channel_mask;
 
-    // reversal, following convention that < 0 means reversed, >= 0 means normal
-    AP_Int8 reverse[NUM_SERVO_RANGE_CHANNELS];
+        // scaled output for this function
+        int16_t output_scaled;
+    } functions[SRV_Channel::k_nr_aux_servo_functions];
 
     AP_Int8 auto_trim;
 
-    // remap a PWM value from a channel in value
-    uint16_t remap_pwm(uint8_t ch, uint16_t pwm) const;
+    // initialise parameters from RC_Channel
+    void initialise_parameters(void);
 };
diff --git a/libraries/RC_Channel/SRV_Channel_aux.cpp b/libraries/RC_Channel/SRV_Channel_aux.cpp
new file mode 100644
index 0000000..af9df3f
--- /dev/null
+++ b/libraries/RC_Channel/SRV_Channel_aux.cpp
@@ -0,0 +1,569 @@
+/*
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+  SRV_Channel_aux.cpp - handling of servo auxillary functions
+ */
+#include "SRV_Channel.h"
+
+#include <AP_Math/AP_Math.h>
+#include <AP_HAL/AP_HAL.h>
+
+extern const AP_HAL::HAL& hal;
+
+/// map a function to a servo channel and output it
+void SRV_Channel::output_ch(void)
+{
+    int8_t passthrough_from = -1;
+
+    // take care of special function cases
+    switch(function)
+    {
+    case k_manual:              // manual
+        passthrough_from = ch_num;
+        break;
+    case k_rcin1 ... k_rcin16: // rc pass-thru
+        passthrough_from = int8_t(function - k_rcin1);
+        break;
+    case k_motor1 ... k_motor8:
+        // handled by AP_Motors::rc_write()
+        return;
+    }
+    if (passthrough_from != -1) {
+        // we are doing passthrough from input to output for this channel
+        RC_Channel *rc = RC_Channels::rc_channel(passthrough_from);
+        if (rc) {
+            if (SRV_Channels::passthrough_disabled()) {
+                output_pwm = rc->get_radio_trim();
+            } else {
+                output_pwm = rc->get_radio_in();
+            }
+        }
+    }
+    hal.rcout->write(ch_num, output_pwm);
+}
+
+/*
+  call output_ch() on all channels
+ */
+void SRV_Channels::output_ch_all(void)
+{
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        channels[i].output_ch();
+    }
+}
+
+/*
+  return the current function for a channel
+*/
+SRV_Channel::Aux_servo_function_t SRV_Channels::channel_function(uint8_t channel)
+{
+    if (channel < NUM_SERVO_CHANNELS) {
+        return (SRV_Channel::Aux_servo_function_t)channels[channel].function.get();
+    }
+    return SRV_Channel::k_none;
+}
+
+/*
+   setup a channels aux servo function
+*/
+void SRV_Channel::aux_servo_function_setup(void)
+{
+    if (type_setup) {
+        return;
+    }
+    switch (function) {
+    case k_flap:
+    case k_flap_auto:
+    case k_egg_drop:
+        set_range(100);
+        break;
+    case k_heli_rsc:
+    case k_heli_tail_rsc:
+    case k_motor_tilt:
+        set_range(1000);
+        break;
+    case k_aileron_with_input:
+    case k_elevator_with_input:
+    case k_aileron:
+    case k_elevator:
+    case k_dspoiler1:
+    case k_dspoiler2:
+    case k_rudder:
+    case k_steering:
+    case k_flaperon1:
+    case k_flaperon2:
+        set_angle(4500);
+        break;
+    case k_throttle:
+        // fixed wing throttle
+        set_range(100);
+        break;
+    default:
+        break;
+    }
+}
+
+/// setup the output range types of all functions
+void SRV_Channels::update_aux_servo_function(void)
+{
+    function_mask.clearall();
+
+    for (uint8_t i = 0; i < SRV_Channel::k_nr_aux_servo_functions; i++) {
+        functions[i].channel_mask = 0;
+    }
+    
+    // set auxiliary ranges
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        channels[i].aux_servo_function_setup();
+        function_mask.set((uint8_t)channels[i].function.get());
+        functions[channels[i].function.get()].channel_mask |= 1U<<i;
+    }
+    initialised = true;
+}
+
+
+/// Should be called after the the servo functions have been initialized
+void SRV_Channels::enable_aux_servos()
+{
+    update_aux_servo_function();
+
+    // enable all channels that are set to a valid function. This
+    // includes k_none servos, which allows those to get their initial
+    // trim value on startup
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel::Aux_servo_function_t function = (SRV_Channel::Aux_servo_function_t)channels[i].function.get();
+        // see if it is a valid function
+        if (function < SRV_Channel::k_nr_aux_servo_functions) {
+            hal.rcout->enable_ch(channels[i].ch_num);
+        }
+    }
+}
+
+/*
+  set radio_out for all channels matching the given function type
+ */
+void SRV_Channels::set_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t value)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function.get() == function) {
+            channels[i].set_output_pwm(value);
+            channels[i].output_ch();
+        }
+    }
+}
+
+/*
+  set radio_out for all channels matching the given function type
+  trim the output assuming a 1500 center on the given value
+ */
+void
+SRV_Channels::set_output_pwm_trimmed(SRV_Channel::Aux_servo_function_t function, int16_t value)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function.get() == function) {
+            int16_t value2 = value - 1500 + channels[i].get_trim();
+            channels[i].set_output_pwm(constrain_int16(value2,channels[i].get_output_min(),channels[i].get_output_max()));
+            channels[i].output_ch();
+          }
+    }
+}
+
+/*
+  set and save the trim value to radio_in for all channels matching
+  the given function type
+ */
+void
+SRV_Channels::set_trim_to_radio_in_for(SRV_Channel::Aux_servo_function_t function)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function.get() == function) {
+            RC_Channel *rc = RC_Channels::rc_channel(channels[i].ch_num);
+            if (rc && rc->get_radio_in() != 0) {
+                rc->set_radio_trim(rc->get_radio_in());
+                rc->save_radio_trim();
+            }
+        }
+    }
+}
+
+/*
+  copy radio_in to radio_out for a given function
+ */
+void
+SRV_Channels::copy_radio_in_out(SRV_Channel::Aux_servo_function_t function, bool do_input_output)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function.get() == function) {
+            RC_Channel *rc = RC_Channels::rc_channel(channels[i].ch_num);
+            if (rc == nullptr) {
+                continue;
+            }
+            if (do_input_output) {
+                rc->read();
+            }
+            channels[i].set_output_pwm(rc->get_radio_in());
+            if (do_input_output) {
+                channels[i].output_ch();
+            }
+        }
+    }
+}
+
+/*
+  setup failsafe value for an auxiliary function type to a LimitValue
+ */
+void
+SRV_Channels::set_failsafe_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t pwm)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        const SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            hal.rcout->set_failsafe_pwm(1U<<ch.ch_num, pwm);
+        }
+    }
+}
+
+/*
+  setup failsafe value for an auxiliary function type to a LimitValue
+ */
+void
+SRV_Channels::set_failsafe_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        const SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            uint16_t pwm = ch.get_limit_pwm(limit);
+            hal.rcout->set_failsafe_pwm(1U<<ch.ch_num, pwm);
+        }
+    }
+}
+
+/*
+  setup safety value for an auxiliary function type to a LimitValue
+ */
+void
+SRV_Channels::set_safety_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        const SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            uint16_t pwm = ch.get_limit_pwm(limit);
+            hal.rcout->set_safety_pwm(1U<<ch.ch_num, pwm);
+        }
+    }
+}
+
+/*
+  set radio output value for an auxiliary function type to a LimitValue
+ */
+void
+SRV_Channels::set_output_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            uint16_t pwm = ch.get_limit_pwm(limit);
+            ch.set_output_pwm(pwm);
+            if (ch.function.get() == SRV_Channel::k_manual) {
+                RC_Channel *rc = RC_Channels::rc_channel(ch.ch_num);
+                if (rc != nullptr) {
+                    // in order for output_ch() to work for k_manual we
+                    // also have to override radio_in
+                    rc->set_radio_in(pwm);
+                }
+            }
+        }
+    }
+}
+
+/*
+  return true if a particular function is assigned to at least one RC channel
+ */
+bool
+SRV_Channels::function_assigned(SRV_Channel::Aux_servo_function_t function)
+{
+    return function_mask.get(uint16_t(function));
+}
+
+/*
+  set servo_out and angle_min/max, then calc_pwm and output a
+  value. This is used to move a AP_Mount servo
+ */
+void
+SRV_Channels::move_servo(SRV_Channel::Aux_servo_function_t function,
+                         int16_t value, int16_t angle_min, int16_t angle_max)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    if (angle_max <= angle_min) {
+        return;
+    }
+    float v = float(value - angle_min) / float(angle_max - angle_min);
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            uint16_t pwm = ch.servo_min + v * (ch.servo_max - ch.servo_min);
+            ch.set_output_pwm(pwm);
+        }
+    }
+}
+
+/*
+  set the default channel an auxiliary output function should be on
+ */
+bool SRV_Channels::set_aux_channel_default(SRV_Channel::Aux_servo_function_t function, uint8_t channel)
+{
+    if (!initialised) {
+        update_aux_servo_function();
+    }
+    if (function_assigned(function)) {
+        // already assigned
+        return true;
+    }
+    if (channels[channel].function != SRV_Channel::k_none) {
+        if (channels[channel].function == function) {
+            return true;
+        }
+        hal.console->printf("Channel %u already assigned %u\n",
+                            (unsigned)channel,
+                            (unsigned)channels[channel].function);
+        return false;
+    }
+    channels[channel].type_setup = false;
+    channels[channel].function.set(function);
+    channels[channel].aux_servo_function_setup();
+    function_mask.set((uint8_t)function);
+    return true;
+}
+
+// find first channel that a function is assigned to
+bool SRV_Channels::find_channel(SRV_Channel::Aux_servo_function_t function, uint8_t &chan)
+{
+    if (!initialised) {
+        update_aux_servo_function();
+    }
+    if (!function_assigned(function)) {
+        return false;
+    }
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            chan = channels[i].ch_num;
+            return true;
+        }
+    }
+    return false;
+}
+
+/*
+  get a pointer to first auxillary channel for a channel function
+*/
+SRV_Channel *SRV_Channels::get_channel_for(SRV_Channel::Aux_servo_function_t function, int8_t default_chan)
+{
+    uint8_t chan;
+    if (default_chan >= 0) {
+        set_aux_channel_default(function, default_chan);
+    }
+    if (!find_channel(function, chan)) {
+        return nullptr;
+    }
+    return &channels[chan];
+}
+
+void SRV_Channels::set_output_scaled(SRV_Channel::Aux_servo_function_t function, int16_t value)
+{
+    if (function < SRV_Channel::k_nr_aux_servo_functions) {
+        functions[function].output_scaled = value;
+        SRV_Channel::have_pwm_mask &= ~functions[function].channel_mask;
+    }
+}
+
+int16_t SRV_Channels::get_output_scaled(SRV_Channel::Aux_servo_function_t function)
+{
+    if (function < SRV_Channel::k_nr_aux_servo_functions) {
+        return functions[function].output_scaled;
+    }
+    return 0;
+}
+
+
+// set the trim for a function channel to given pwm
+void SRV_Channels::set_trim_to_pwm_for(SRV_Channel::Aux_servo_function_t function, int16_t pwm)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].servo_trim.set(pwm);
+        }
+    }
+}
+
+// set the trim for a function channel to min output
+void SRV_Channels::set_trim_to_min_for(SRV_Channel::Aux_servo_function_t function)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].servo_trim.set(channels[i].get_reversed()?channels[i].servo_max:channels[i].servo_min);
+        }
+    }
+}
+
+/*
+  set the default function for a channel
+*/
+void SRV_Channels::set_default_function(uint8_t chan, SRV_Channel::Aux_servo_function_t function)
+{
+    if (chan < NUM_SERVO_CHANNELS) {
+        channels[chan].function.set_default((uint8_t)function);
+    }
+}
+
+
+void SRV_Channels::set_esc_scaling_for(SRV_Channel::Aux_servo_function_t function)
+{
+    uint8_t chan;
+    if (find_channel(function, chan)) {
+        hal.rcout->set_esc_scaling(channels[chan].get_output_min(), channels[chan].get_output_max());
+    }
+}
+
+/*
+  auto-adjust channel trim from an integrator value. Positive v means
+  adjust trim up. Negative means decrease
+ */
+void SRV_Channels::adjust_trim(SRV_Channel::Aux_servo_function_t function, float v)
+{
+    if (is_zero(v)) {
+        return;
+    }
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel &c = channels[i];
+        if (function != (SRV_Channel::Aux_servo_function_t)(c.function.get())) {
+            continue;
+        }
+        float change = c.reversed?-v:v;
+        uint16_t new_trim = c.servo_trim;
+        float trim_scaled = float(c.servo_trim - c.servo_min) / (c.servo_max - c.servo_min);
+        if (change > 0 && trim_scaled < 0.6f) {
+            new_trim++;
+        } else if (change < 0 && trim_scaled > 0.4f) {
+            new_trim--;
+        } else {
+            return;
+        }
+        c.servo_trim.set(new_trim);
+
+        trimmed_mask |= 1U<<i;
+    }
+}
+
+
+// get pwm output for the first channel of the given function type.
+bool SRV_Channels::get_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t &value)
+{
+    uint8_t chan;
+    if (!find_channel(function, chan)) {
+        return false;
+    }
+    channels[chan].calc_pwm(functions[function].output_scaled);
+    value = channels[chan].output_pwm;
+    return true;
+}
+
+// set output pwm to trim for the given function
+void SRV_Channels::set_output_to_trim(SRV_Channel::Aux_servo_function_t function)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].set_output_pwm(channels[i].servo_trim);
+        }
+    }
+}
+
+// set output pwm to for first matching channel
+void SRV_Channels::set_output_pwm_first(SRV_Channel::Aux_servo_function_t function, uint16_t pwm)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].set_output_pwm(pwm);
+            break;
+        }
+    }
+}
+
+/*
+  get the normalised output for a channel function from the pwm value
+  of the first matching channel
+ */
+float SRV_Channels::get_output_norm(SRV_Channel::Aux_servo_function_t function)
+{
+    uint8_t chan;
+    if (!find_channel(function, chan)) {
+        return 0;
+    }
+    channels[chan].calc_pwm(functions[function].output_scaled);
+    return channels[chan].get_output_norm();
+}
+
+/*
+  limit slew rate for an output function to given rate in percent per second
+ */
+void SRV_Channels::limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate)
+{
+    // NOT IMPLEMENTED YET
+}
+
+// call set_angle() on matching channels
+void SRV_Channels::set_angle(SRV_Channel::Aux_servo_function_t function, uint16_t angle)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].set_angle(angle);
+        }
+    }    
+}
+
+// call set_range() on matching channels
+void SRV_Channels::set_range(SRV_Channel::Aux_servo_function_t function, uint16_t range)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].set_range(range);
+        }
+    }
+}
diff --git a/libraries/RC_Channel/examples/RC_Channel/RC_Channel.cpp b/libraries/RC_Channel/examples/RC_Channel/RC_Channel.cpp
index f39c281..03f5c14 100644
--- a/libraries/RC_Channel/examples/RC_Channel/RC_Channel.cpp
+++ b/libraries/RC_Channel/examples/RC_Channel/RC_Channel.cpp
@@ -2,14 +2,6 @@
  *       Example of RC_Channel library.
  *       Based on original sketch by Jason Short. 2010
  */
-#define CH_1 0
-#define CH_2 1
-#define CH_3 2
-#define CH_4 3
-#define CH_5 4
-#define CH_6 5
-#define CH_7 6
-#define CH_8 7
 
 #include <AP_HAL/AP_HAL.h>
 #include <RC_Channel/RC_Channel.h>
@@ -18,68 +10,54 @@ const AP_HAL::HAL& hal = AP_HAL::get_HAL();
 
 #define NUM_CHANNELS 8
 
-static RC_Channel rc_1(CH_1);
-static RC_Channel rc_2(CH_2);
-static RC_Channel rc_3(CH_3);
-static RC_Channel rc_4(CH_4);
-static RC_Channel rc_5(CH_5);
-static RC_Channel rc_6(CH_6);
-static RC_Channel rc_7(CH_7);
-static RC_Channel rc_8(CH_8);
-static RC_Channel **rc = RC_Channel::rc_channel_array();
+static RC_Channels rc_channels;
+static RC_Channel *rc;
 
 static void print_pwm(void);
 static void print_radio_values();
-static void copy_input_output(void);
 
 
 void setup()
 {
     hal.console->println("ArduPilot RC Channel test");
 
+    rc = RC_Channels::rc_channel(CH_1);
+    
     print_radio_values();
 
     // set type of output, symmetrical angles or a number range;
-    rc_1.set_angle(4500);
-    rc_1.set_default_dead_zone(80);
-    rc_1.set_type(RC_CHANNEL_TYPE_ANGLE_RAW);
+    rc[CH_1].set_angle(4500);
+    rc[CH_1].set_default_dead_zone(80);
 
-    rc_2.set_angle(4500);
-    rc_2.set_default_dead_zone(80);
-    rc_2.set_type(RC_CHANNEL_TYPE_ANGLE_RAW);
+    rc[CH_2].set_angle(4500);
+    rc[CH_2].set_default_dead_zone(80);
 
-    rc_3.set_range(0,1000);
-    rc_3.set_default_dead_zone(20);
+    rc[CH_3].set_range(1000);
+    rc[CH_3].set_default_dead_zone(20);
 
-    rc_4.set_angle(6000);
-    rc_4.set_default_dead_zone(500);
-    rc_4.set_type(RC_CHANNEL_TYPE_ANGLE_RAW);
+    rc[CH_4].set_angle(6000);
+    rc[CH_4].set_default_dead_zone(500);
 
-    rc_5.set_range(0,1000);
-    rc_6.set_range(200,800);
+    rc[CH_5].set_range(1000);
+    rc[CH_6].set_range(800);
 
-    rc_7.set_range(0,1000);
+    rc[CH_7].set_range(1000);
 
-    rc_8.set_range(0,1000);
-    for (int i=0; i<NUM_CHANNELS; i++) {
-        rc[i]->enable_out();
-    }
+    rc[CH_8].set_range(1000);
 }
 
 void loop()
 {
-    RC_Channel::set_pwm_all();
+    RC_Channels::set_pwm_all();
     print_pwm();
     
-    copy_input_output();
-
     hal.scheduler->delay(20);
 }
 
 static void print_pwm(void)
 {
     for (int i=0; i<NUM_CHANNELS; i++) {
-	    hal.console->printf("ch%u: %4d ", (unsigned)i+1, (int)rc[i]->get_control_in());
+	    hal.console->printf("ch%u: %4d ", (unsigned)i+1, (int)rc[i].get_control_in());
     }
     hal.console->printf("\n");
 }
@@ -90,22 +68,10 @@ static void print_radio_values()
     for (int i=0; i<NUM_CHANNELS; i++) {
 	     hal.console->printf("CH%u: %u|%u\n",
 			  (unsigned)i+1, 
-			  (unsigned)rc[i]->get_radio_min(), 
-			  (unsigned)rc[i]->get_radio_max()); 
+			  (unsigned)rc[i].get_radio_min(), 
+			  (unsigned)rc[i].get_radio_max()); 
     }
 }
 
 
-/*
-  copy scaled input to output
- */
-static void copy_input_output(void)
-{
-    for (int i=0; i<NUM_CHANNELS; i++) {
-        rc[i]->set_servo_out(rc[i]->get_control_in());
-        rc[i]->calc_pwm();
-        rc[i]->output();
-    }
-}
-
 AP_HAL_MAIN();
diff --git a/libraries/RC_Channel/examples/RC_UART/RC_UART.cpp b/libraries/RC_Channel/examples/RC_UART/RC_UART.cpp
index e5eff55..6fc7311 100644
--- a/libraries/RC_Channel/examples/RC_UART/RC_UART.cpp
+++ b/libraries/RC_Channel/examples/RC_UART/RC_UART.cpp
@@ -3,7 +3,6 @@
  */
 
 #include <AP_HAL/AP_HAL.h>
-#include <RC_Channel/RC_Channel.h>
 #include <GCS_MAVLink/include/mavlink/v2.0/checksum.h>
 
 const AP_HAL::HAL& hal = AP_HAL::get_HAL();
@@ -24,12 +23,6 @@ class RC_UART : public AP_HAL::HAL::Callbacks {
     uint8_t enable_mask;
     const uint32_t baudrate = 115200;
     uint32_t counter;
-
-    RC_Channel rc_1{0};
-    RC_Channel rc_2{1};
-    RC_Channel rc_3{2};
-    RC_Channel rc_4{3};
-    RC_Channel *rc = &rc_1;
 };
 
 void RC_UART::setup()
@@ -94,11 +87,10 @@ void RC_UART::loop()
             if (enable_mask == 0) {
                 hal.rcout->force_safety_off();
             }
-            rc[i].enable_out();
+            hal.rcout->enable_ch(i);
             enable_mask |= 1U<<i;
         }
-        rc[i].set_radio_out(u.period[i]);
-        rc[i].output();
+        hal.rcout->write(i, u.period[i]);
     }
 
     // report periods to console for debug

From 0791186cd25a2a7ac0162292b218e9ffe61afa33 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 12:02:32 +1100
Subject: [PATCH 029/200] RC_Channel: split SRV_Channel into separate directory

---
 libraries/RC_Channel/RC_Channel.cpp      |   6 +-
 libraries/RC_Channel/SRV_Channel.cpp     | 321 -----------------
 libraries/RC_Channel/SRV_Channel.h       | 388 ---------------------
 libraries/RC_Channel/SRV_Channel_aux.cpp | 569 -------------------------------
 4 files changed, 3 insertions(+), 1281 deletions(-)
 delete mode 100644 libraries/RC_Channel/SRV_Channel.cpp
 delete mode 100644 libraries/RC_Channel/SRV_Channel.h
 delete mode 100644 libraries/RC_Channel/SRV_Channel_aux.cpp

diff --git a/libraries/RC_Channel/RC_Channel.cpp b/libraries/RC_Channel/RC_Channel.cpp
index 0d3f343..ed2058a 100644
--- a/libraries/RC_Channel/RC_Channel.cpp
+++ b/libraries/RC_Channel/RC_Channel.cpp
@@ -282,10 +282,10 @@ void RC_Channel::save_eeprom(void)
   the current radio_in value using the specified dead_zone
  */
 int16_t
-RC_Channel::pwm_to_angle_dz_trim(uint16_t _dead_zone, uint16_t trim)
+RC_Channel::pwm_to_angle_dz_trim(uint16_t _dead_zone, uint16_t _trim)
 {
-    int16_t radio_trim_high = trim + _dead_zone;
-    int16_t radio_trim_low  = trim - _dead_zone;
+    int16_t radio_trim_high = _trim + _dead_zone;
+    int16_t radio_trim_low  = _trim - _dead_zone;
 
     // prevent div by 0
     if ((radio_trim_low - radio_min) == 0 || (radio_max - radio_trim_high) == 0)
diff --git a/libraries/RC_Channel/SRV_Channel.cpp b/libraries/RC_Channel/SRV_Channel.cpp
deleted file mode 100644
index bc70425..0000000
--- a/libraries/RC_Channel/SRV_Channel.cpp
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-/*
-  SRV_Channel.cpp - object to separate input and output channel
-  ranges, trim and reversal
- */
-
-#include <AP_HAL/AP_HAL.h>
-#include <AP_Math/AP_Math.h>
-#include <AP_Vehicle/AP_Vehicle.h>
-#include "SRV_Channel.h"
-#include "RC_Channel.h"
-
-extern const AP_HAL::HAL& hal;
-
-SRV_Channel *SRV_Channels::channels;
-bool SRV_Channels::disabled_passthrough;
-bool SRV_Channels::initialised;
-Bitmask SRV_Channels::function_mask{SRV_Channel::k_nr_aux_servo_functions};
-SRV_Channels::srv_function SRV_Channels::functions[SRV_Channel::k_nr_aux_servo_functions];
-SRV_Channel::servo_mask_t SRV_Channel::have_pwm_mask;
-
-const AP_Param::GroupInfo SRV_Channel::var_info[] = {
-    // @Param: MIN
-    // @DisplayName: Minimum PWM
-    // @Description: minimum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Standard
-    AP_GROUPINFO("MIN",  1, SRV_Channel, servo_min, 1100),
-
-    // @Param: MAX
-    // @DisplayName: Maximum PWM
-    // @Description: maximum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Standard
-    AP_GROUPINFO("MAX",  2, SRV_Channel, servo_max, 1900),
-
-    // @Param: TRIM
-    // @DisplayName: Trim PWM
-    // @Description: Trim PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
-    // @Units: pwm
-    // @Range: 800 2200
-    // @Increment: 1
-    // @User: Standard
-    AP_GROUPINFO("TRIM",  3, SRV_Channel, servo_trim, 1500),
-    
-    // @Param: REVERSED
-    // @DisplayName: Servo reverse
-    // @Description: Reverse servo operation. Set to 0 for normal operation. Set to 1 to reverse this channel.
-    // @Values: 0:Normal,1:Reversed
-    // @User: Standard
-    AP_GROUPINFO("REVERSED",  4, SRV_Channel, reversed, 0),
-
-    // @Param: FUNCTION
-    // @DisplayName: Servo output function
-    // @Description: Function assigned to this servo. Seeing this to Disabled(0) will setup this output for control by auto missions or MAVLink servo set commands. any other value will enable the corresponding function
-    // @Values: 0:Disabled,1:RCPassThru,2:Flap,3:Flap_auto,4:Aileron,6:mount_pan,7:mount_tilt,8:mount_roll,9:mount_open,10:camera_trigger,11:release,12:mount2_pan,13:mount2_tilt,14:mount2_roll,15:mount2_open,16:DifferentialSpoiler1,17:DifferentialSpoiler2,18:AileronWithInput,19:Elevator,20:ElevatorWithInput,21:Rudder,24:Flaperon1,25:Flaperon2,26:GroundSteering,27:Parachute,28:EPM,29:LandingGear,30:EngineRunEnable,31:HeliRSC,32:HeliTailRSC,33:Motor1,34:Motor2,35:Motor3,36:Motor4,37:Motor5,38:Motor6,39:Motor7,40:Motor8,51:RCIN1,52:RCIN2,53:RCIN3,54:RCIN4,55:RCIN5,56:RCIN6,57:RCIN7,58:RCIN8,59:RCIN9,60:RCIN10,61:RCIN11,62:RCIN12,63:RCIN13,64:RCIN14,65:RCIN15,66:RCIN16,67:Ignition,68:Choke,69:Starter,70:Throttle
-    // @User: Standard
-    AP_GROUPINFO("FUNCTION",  5, SRV_Channel, function, 0),
-    
-    AP_GROUPEND
-};
-
-
-const AP_Param::GroupInfo SRV_Channels::var_info[] = {
-    // @Group: 1_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[0], "1_",  1, SRV_Channels, SRV_Channel),
-
-    // @Group: 2_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[1], "2_",  2, SRV_Channels, SRV_Channel),
-
-    // @Group: 3_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[2], "3_",  3, SRV_Channels, SRV_Channel),
-
-    // @Group: 4_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[3], "4_",  4, SRV_Channels, SRV_Channel),
-
-    // @Group: 5_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[4], "5_",  5, SRV_Channels, SRV_Channel),
-
-    // @Group: 6_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[5], "6_",  6, SRV_Channels, SRV_Channel),
-
-    // @Group: 7_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[6], "7_",  7, SRV_Channels, SRV_Channel),
-
-    // @Group: 8_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[7], "8_",  8, SRV_Channels, SRV_Channel),
-
-    // @Group: 9_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[8], "9_",  9, SRV_Channels, SRV_Channel),
-
-    // @Group: 10_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[9], "10_",  10, SRV_Channels, SRV_Channel),
-
-    // @Group: 11_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[10], "11_",  11, SRV_Channels, SRV_Channel),
-
-    // @Group: 12_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[11], "12_",  12, SRV_Channels, SRV_Channel),
-
-    // @Group: 13_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[12], "13_",  13, SRV_Channels, SRV_Channel),
-
-    // @Group: 14_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[13], "14_",  14, SRV_Channels, SRV_Channel),
-
-    // @Group: 15_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[14], "15_",  15, SRV_Channels, SRV_Channel),
-
-    // @Group: 16_
-    // @Path: SRV_Channel.cpp
-    AP_SUBGROUPINFO(obj_channels[15], "16_",  16, SRV_Channels, SRV_Channel),
-    
-    // @Param: _AUTO_TRIM
-    // @DisplayName: Automatic servo trim
-    // @Description: This enables automatic servo trim in flight. Servos will be trimed in stabilized flight modes when the aircraft is close to level. Changes to servo trim will be saved every 10 seconds and will persist between flights.
-    // @Values: 0:Disable,1:Enable
-    // @User: Advanced
-    AP_GROUPINFO("_AUTO_TRIM",  17, SRV_Channels, auto_trim, 0),
-    
-    AP_GROUPEND
-};
-
-SRV_Channel::SRV_Channel(void)
-{
-    AP_Param::setup_object_defaults(this, var_info);
-    // start with all pwm at zero
-    have_pwm_mask = ~uint16_t(0);
-}
-
-
-/*
-  constructor
- */
-SRV_Channels::SRV_Channels(const RCMapper &_rcmap) :
-    rcmap(_rcmap)
-{
-    channels = obj_channels;
-    
-    // set defaults from the parameter table
-    AP_Param::setup_object_defaults(this, var_info);
-
-    // setup ch_num on channels
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        channels[i].ch_num = i;
-    }
-}
-
-/*
-  save adjusted trims
- */
-void SRV_Channels::save_trim(void)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        if (trimmed_mask & (1U<<i)) {
-            channels[i].servo_trim.set_and_save(channels[i].servo_trim.get());
-        }
-    }
-    trimmed_mask = 0;
-}
-
-// convert a 0..range_max to a pwm
-uint16_t SRV_Channel::pwm_from_range(int16_t scaled_value) const
-{
-    if (servo_max <= servo_min || high_out == 0) {
-        return servo_min;
-    }
-    if (scaled_value >= high_out) {
-        scaled_value = high_out;
-    }
-    if (scaled_value < 0) {
-        scaled_value = 0;
-    }
-    if (reversed) {
-        scaled_value = high_out - scaled_value;
-    }
-    return servo_min + ((int32_t)scaled_value * (int32_t)(servo_max - servo_min)) / (int32_t)high_out;
-}
-
-// convert a -angle_max..angle_max to a pwm
-uint16_t SRV_Channel::pwm_from_angle(int16_t scaled_value) const
-{
-    if (reversed) {
-        scaled_value = -scaled_value;
-    }
-    if (scaled_value > 0) {
-        return servo_trim + ((int32_t)scaled_value * (int32_t)(servo_max - servo_trim)) / (int32_t)high_out;
-    } else {
-        return servo_trim - (-(int32_t)scaled_value * (int32_t)(servo_trim - servo_min)) / (int32_t)high_out;
-    }
-}
-
-void SRV_Channel::calc_pwm(int16_t output_scaled)
-{
-    if (have_pwm_mask & (1U<<ch_num)) {
-        return;
-    }
-    uint16_t pwm;
-    if (type_angle) {
-        pwm = pwm_from_angle(output_scaled);
-    } else {
-        pwm = pwm_from_range(output_scaled);
-    }
-    set_output_pwm(pwm);
-}
-
-void SRV_Channels::output_trim_all(void)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        channels[i].set_output_pwm(channels[i].servo_trim);
-    }
-}
-
-void SRV_Channels::setup_failsafe_trim_all(void)
-{
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        hal.rcout->set_failsafe_pwm(1U<<channels[i].ch_num, channels[i].servo_trim);
-    }
-}
-
-void SRV_Channel::set_output_pwm(uint16_t pwm)
-{
-    output_pwm = pwm;
-    have_pwm_mask |= (1U<<ch_num);
-}
-
-// set angular range of scaled output
-void SRV_Channel::set_angle(int16_t angle)
-{
-    type_angle = true;
-    high_out = angle;    
-    type_setup = true;
-}
-
-// set range of scaled output
-void SRV_Channel::set_range(uint16_t high)
-{
-    type_angle = false;
-    high_out = high;
-    type_setup = true;
-}
-
-/*
-  get normalised output from -1 to 1, assuming 0 at mid point of servo_min/servo_max
- */
-float SRV_Channel::get_output_norm(void)
-{
-    uint16_t mid = (servo_max + servo_min) / 2;
-    float ret;
-    if (mid <= servo_min) {
-        return 0;
-    }
-    if (output_pwm < mid) {
-        ret = (float)(output_pwm - mid) / (float)(mid - servo_min);
-    } else if (output_pwm > mid) {
-        ret = (float)(output_pwm - mid) / (float)(servo_max  - mid);
-    } else {
-        ret = 0;
-    }
-    if (get_reversed()) {
-           ret = -ret;
-    }
-    return ret;
-}
-
-uint16_t SRV_Channel::get_limit_pwm(LimitValue limit) const
-{
-    switch (limit) {
-    case SRV_CHANNEL_LIMIT_TRIM:
-        return servo_trim;
-    case SRV_CHANNEL_LIMIT_MIN:
-        return servo_min;
-    case SRV_CHANNEL_LIMIT_MAX:
-        return servo_max;
-    case SRV_CHANNEL_LIMIT_ZERO_PWM:
-    default:
-        return 0;
-    }
-}
-
-/*
-  run calc_pwm for all channels
- */
-void SRV_Channels::calc_pwm(void)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        channels[i].calc_pwm(functions[channels[i].function].output_scaled);
-    }
-}
diff --git a/libraries/RC_Channel/SRV_Channel.h b/libraries/RC_Channel/SRV_Channel.h
deleted file mode 100644
index 7885f0b..0000000
--- a/libraries/RC_Channel/SRV_Channel.h
+++ /dev/null
@@ -1,388 +0,0 @@
-/*
-  control of servo output ranges, trim and servo reversal. This can
-  optionally be used to provide separation of input and output channel
-  ranges so that RCn_MIN, RCn_MAX, RCn_TRIM and RCn_REV only apply to
-  the input side of RC_Channel
-
-  It works by running servo output calculations as normal, then
-  re-mapping the output according to the servo MIN/MAX/TRIM/REV from
-  this object
-
-  Only 4 channels of ranges are defined as those match the input
-  channels for R/C sticks
- */
-#pragma once
-
-#include <AP_Common/AP_Common.h>
-#include <AP_Param/AP_Param.h>
-#include <AP_RCMapper/AP_RCMapper.h>
-#include <AP_Common/Bitmask.h>
-
-#include "RC_Channel.h"
-
-#define NUM_SERVO_CHANNELS 16
-
-class SRV_Channels;
-
-/*
-  class SRV_Channel. The class SRV_Channels contains an array of
-  SRV_Channel objects. This is done to fit within the AP_Param limit
-  of 64 parameters per object.
-*/
-class SRV_Channel {
-public:
-    friend class SRV_Channels;
-    // constructor
-    SRV_Channel(void);
-
-    static const struct AP_Param::GroupInfo var_info[];
-
-    typedef enum
-    {
-        k_none                  = 0,            ///< disabled
-        k_manual                = 1,            ///< manual, just pass-thru the RC in signal
-        k_flap                  = 2,            ///< flap
-        k_flap_auto             = 3,            ///< flap automated
-        k_aileron               = 4,            ///< aileron
-        k_unused1               = 5,            ///< unused function
-        k_mount_pan             = 6,            ///< mount yaw (pan)
-        k_mount_tilt            = 7,            ///< mount pitch (tilt)
-        k_mount_roll            = 8,            ///< mount roll
-        k_mount_open            = 9,            ///< mount open (deploy) / close (retract)
-        k_cam_trigger           = 10,           ///< camera trigger
-        k_egg_drop              = 11,           ///< egg drop
-        k_mount2_pan            = 12,           ///< mount2 yaw (pan)
-        k_mount2_tilt           = 13,           ///< mount2 pitch (tilt)
-        k_mount2_roll           = 14,           ///< mount2 roll
-        k_mount2_open           = 15,           ///< mount2 open (deploy) / close (retract)
-        k_dspoiler1             = 16,           ///< differential spoiler 1 (left wing)
-        k_dspoiler2             = 17,           ///< differential spoiler 2 (right wing)
-        k_aileron_with_input    = 18,            ///< aileron, with rc input
-        k_elevator              = 19,            ///< elevator
-        k_elevator_with_input   = 20,            ///< elevator, with rc input
-        k_rudder                = 21,            ///< secondary rudder channel
-        k_sprayer_pump          = 22,            ///< crop sprayer pump channel
-        k_sprayer_spinner       = 23,            ///< crop sprayer spinner channel
-        k_flaperon1             = 24,            ///< flaperon, left wing
-        k_flaperon2             = 25,            ///< flaperon, right wing
-        k_steering              = 26,            ///< ground steering, used to separate from rudder
-        k_parachute_release     = 27,            ///< parachute release
-        k_gripper               = 28,            ///< gripper
-        k_landing_gear_control  = 29,            ///< landing gear controller
-        k_engine_run_enable     = 30,            ///< engine kill switch, used for gas airplanes and helicopters
-        k_heli_rsc              = 31,            ///< helicopter RSC output
-        k_heli_tail_rsc         = 32,            ///< helicopter tail RSC output
-        k_motor1                = 33,            ///< these allow remapping of copter motors
-        k_motor2                = 34,
-        k_motor3                = 35,
-        k_motor4                = 36,
-        k_motor5                = 37,
-        k_motor6                = 38,
-        k_motor7                = 39,
-        k_motor8                = 40,
-        k_motor_tilt            = 41,            ///< tiltrotor motor tilt control
-        k_rcin1                 = 51,            ///< these are for pass-thru from arbitrary rc inputs
-        k_rcin2                 = 52,
-        k_rcin3                 = 53,
-        k_rcin4                 = 54,
-        k_rcin5                 = 55,
-        k_rcin6                 = 56,
-        k_rcin7                 = 57,
-        k_rcin8                 = 58,
-        k_rcin9                 = 59,
-        k_rcin10                = 60,
-        k_rcin11                = 61,
-        k_rcin12                = 62,
-        k_rcin13                = 63,
-        k_rcin14                = 64,
-        k_rcin15                = 65,
-        k_rcin16                = 66,
-        k_ignition              = 67,
-        k_choke                 = 68,
-        k_starter               = 69,
-        k_throttle              = 70,
-        k_nr_aux_servo_functions         ///< This must be the last enum value (only add new values _before_ this one)
-    } Aux_servo_function_t;
-
-    // used to get min/max/trim limit value based on reverse
-    enum LimitValue {
-        SRV_CHANNEL_LIMIT_TRIM,
-        SRV_CHANNEL_LIMIT_MIN,
-        SRV_CHANNEL_LIMIT_MAX,
-        SRV_CHANNEL_LIMIT_ZERO_PWM
-    };
-
-    // a special scaled output value that is recognised as meaning no pwm output
-    static const int16_t ZERO_PWM = INT16_MIN;
-
-    // set the output value as a pwm value
-    void set_output_pwm(uint16_t pwm);
-
-    // get the output value as a pwm value
-    uint16_t get_output_pwm(void) const { return output_pwm; }
-
-    // set angular range of scaled output
-    void set_angle(int16_t angle);
-
-    // set range of scaled output. Low is always zero
-    void set_range(uint16_t high);
-
-    // return true if the channel is reversed
-    bool get_reversed(void) const {
-        return reversed?true:false;
-    }
-
-    // set MIN/MAX parameters
-    void set_output_min(uint16_t pwm) {
-        servo_min.set(pwm);
-    }
-    void set_output_max(uint16_t pwm) {
-        servo_max.set(pwm);
-    }
-
-    // get MIN/MAX/TRIM parameters
-    uint16_t get_output_min(void) const {
-        return servo_min;
-    }
-    uint16_t get_output_max(void) const {
-        return servo_max;
-    }
-    uint16_t get_trim(void) const {
-        return servo_trim;
-    }
-
-private:
-    AP_Int16 servo_min;
-    AP_Int16 servo_max;
-    AP_Int16 servo_trim;
-    // reversal, following convention that 1 means reversed, 0 means normal
-    AP_Int8 reversed;
-    AP_Int8 function;
-
-    // a pending output value as PWM
-    uint16_t output_pwm;
-
-    // true for angle output type
-    bool type_angle:1;
-
-    // set_range() or set_angle() has been called
-    bool type_setup:1;
-    
-    // the hal channel number
-    uint8_t ch_num;
-
-    // high point of angle or range output
-    uint16_t high_out;
-
-    // convert a 0..range_max to a pwm
-    uint16_t pwm_from_range(int16_t scaled_value) const;
-
-    // convert a -angle_max..angle_max to a pwm
-    uint16_t pwm_from_angle(int16_t scaled_value) const;
-
-    // convert a scaled output to a pwm value
-    void calc_pwm(int16_t output_scaled);
-
-    // output value based on function
-    void output_ch(void);
-
-    // setup output type and range based on function
-    void aux_servo_function_setup(void);
-
-    // return PWM for a given limit value
-    uint16_t get_limit_pwm(LimitValue limit) const;
-
-    // get normalised output from -1 to 1
-    float get_output_norm(void);
-    
-    // a bitmask type wide enough for NUM_SERVO_CHANNELS
-    typedef uint16_t servo_mask_t;
-
-    // mask of channels where we have a output_pwm value. Cleared when a
-    // scaled value is written. 
-    static servo_mask_t have_pwm_mask;
-};
-
-/*
-  class	SRV_Channels
-*/
-class SRV_Channels {
-public:
-    // constructor
-    SRV_Channels(const RCMapper &_rcmap);
-
-    static const struct AP_Param::GroupInfo var_info[];
-
-    // set the default function for a channel
-    static void set_default_function(uint8_t chan, SRV_Channel::Aux_servo_function_t function);
-
-    // set output value for a function channel as a pwm value
-    static void set_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t value);
-
-    // set output value for a function channel as a pwm value on the first matching channel
-    static void set_output_pwm_first(SRV_Channel::Aux_servo_function_t function, uint16_t value);
-
-    // set output value for a function channel as a scaled value. This
-    // calls calc_pwm() to also set the pwm value
-    static void set_output_scaled(SRV_Channel::Aux_servo_function_t function, int16_t value);
-
-    // get scaled output for the given function type.
-    static int16_t get_output_scaled(SRV_Channel::Aux_servo_function_t function);
-
-    // get pwm output for the first channel of the given function type.
-    static bool get_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t &value);
-
-    // get normalised output (-1 to 1 for angle, 0 to 1 for range). Value is taken from pwm value
-    // return zero on error.
-    static float get_output_norm(SRV_Channel::Aux_servo_function_t function);
-
-    // limit slew rate to given limit in percent per second
-    static void limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate);
-
-    // call output_ch() on all channels
-    static void output_ch_all(void);
-
-    // take current radio_out for first 4 channels and remap using
-    // servo ranges if enabled
-    void remap_servo_output(void);
-
-    // setup output ESC scaling based on a channels MIN/MAX
-    void set_esc_scaling_for(SRV_Channel::Aux_servo_function_t function);
-
-    // return true when auto_trim enabled
-    bool auto_trim_enabled(void) const { return auto_trim; }
-
-    // adjust trim of a channel by a small increment
-    void adjust_trim(SRV_Channel::Aux_servo_function_t function, float v);
-
-    // save trims
-    void save_trim(void);
-
-    // setup for a reversible k_throttle (from -100 to 100)
-    void set_reversible_throttle(void) {
-        flags.k_throttle_reversible = true;
-    }
-
-    // set all outputs to the TRIM value
-    static void output_trim_all(void);
-
-    // setup IO failsafe for all channels to trim
-    static void setup_failsafe_trim_all(void);
-
-    // set output for all channels matching the given function type, allow radio_trim to center servo
-    static void set_output_pwm_trimmed(SRV_Channel::Aux_servo_function_t function, int16_t value);
-
-    // set and save the trim for a function channel to radio_in on matching input channel
-    static void set_trim_to_radio_in_for(SRV_Channel::Aux_servo_function_t function);
-
-    // set the trim for a function channel to min of the channel
-    static void set_trim_to_min_for(SRV_Channel::Aux_servo_function_t function);
-
-    // set the trim for a function channel to given pwm
-    static void set_trim_to_pwm_for(SRV_Channel::Aux_servo_function_t function, int16_t pwm);
-
-    // set output to min value
-    static void set_output_to_min(SRV_Channel::Aux_servo_function_t function);
-
-    // set output to max value
-    static void set_output_to_max(SRV_Channel::Aux_servo_function_t function);
-
-    // set output to trim value
-    static void set_output_to_trim(SRV_Channel::Aux_servo_function_t function);
-
-    // copy radio_in to radio_out
-    static void copy_radio_in_out(SRV_Channel::Aux_servo_function_t function, bool do_input_output=false);
-
-    // setup failsafe for an auxiliary channel function, by pwm
-    static void set_failsafe_pwm(SRV_Channel::SRV_Channel::Aux_servo_function_t function, uint16_t pwm);
-
-    // setup failsafe for an auxiliary channel function
-    static void set_failsafe_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
-
-    // setup safety for an auxiliary channel function (used when disarmed)
-    static void set_safety_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
-
-    // set servo to a LimitValue
-    static void set_output_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
-
-    // return true if a function is assigned to a channel
-    static bool function_assigned(SRV_Channel::Aux_servo_function_t function);
-
-    // set a servo_out value, and angle range, then calc_pwm
-    static void move_servo(SRV_Channel::Aux_servo_function_t function,
-                           int16_t value, int16_t angle_min, int16_t angle_max);
-
-    // assign and enable auxiliary channels
-    static void enable_aux_servos(void);
-
-    // prevent a channel from being used for auxiliary functions
-    static void disable_aux_channel(uint8_t channel);
-
-    // return the current function for a channel
-    static SRV_Channel::Aux_servo_function_t channel_function(uint8_t channel);
-
-    // refresh aux servo to function mapping
-    static void update_aux_servo_function(void);
-
-    // set default channel for an auxiliary function
-    static bool set_aux_channel_default(SRV_Channel::Aux_servo_function_t function, uint8_t channel);
-
-    // find first channel that a function is assigned to
-    static bool find_channel(SRV_Channel::Aux_servo_function_t function, uint8_t &chan);
-
-    // find first channel that a function is assigned to, returning SRV_Channel object
-    static SRV_Channel *get_channel_for(SRV_Channel::Aux_servo_function_t function, int8_t default_chan=-1);
-
-    // call set_angle() on matching channels
-    static void set_angle(SRV_Channel::Aux_servo_function_t function, uint16_t angle);
-
-    // call set_range() on matching channels
-    static void set_range(SRV_Channel::Aux_servo_function_t function, uint16_t range);
-    
-    // control pass-thru of channels
-    void disable_passthrough(bool disable) {
-        disabled_passthrough = disable;
-    }
-
-    static bool passthrough_disabled(void) {
-        return disabled_passthrough;
-    }
-
-    // calculate PWM for all channels
-    static void calc_pwm(void);
-
-    static SRV_Channel *srv_channel(uint8_t i) {
-        return i<NUM_SERVO_CHANNELS?&channels[i]:nullptr;
-    }
-
-private:
-    const RCMapper &rcmap;
-
-    struct {
-        bool k_throttle_reversible:1;
-    } flags;
-
-    static bool disabled_passthrough;
-
-    uint16_t trimmed_mask;
-
-    static Bitmask function_mask;
-    static bool initialised;
-    
-    // this static arrangement is to avoid having static objects in AP_Param tables
-    static SRV_Channel *channels;
-    SRV_Channel obj_channels[NUM_SERVO_CHANNELS];
-
-    static struct srv_function {
-        // mask of what channels this applies to
-        SRV_Channel::servo_mask_t channel_mask;
-
-        // scaled output for this function
-        int16_t output_scaled;
-    } functions[SRV_Channel::k_nr_aux_servo_functions];
-
-    AP_Int8 auto_trim;
-
-    // initialise parameters from RC_Channel
-    void initialise_parameters(void);
-};
diff --git a/libraries/RC_Channel/SRV_Channel_aux.cpp b/libraries/RC_Channel/SRV_Channel_aux.cpp
deleted file mode 100644
index af9df3f..0000000
--- a/libraries/RC_Channel/SRV_Channel_aux.cpp
+++ /dev/null
@@ -1,569 +0,0 @@
-/*
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-/*
-  SRV_Channel_aux.cpp - handling of servo auxillary functions
- */
-#include "SRV_Channel.h"
-
-#include <AP_Math/AP_Math.h>
-#include <AP_HAL/AP_HAL.h>
-
-extern const AP_HAL::HAL& hal;
-
-/// map a function to a servo channel and output it
-void SRV_Channel::output_ch(void)
-{
-    int8_t passthrough_from = -1;
-
-    // take care of special function cases
-    switch(function)
-    {
-    case k_manual:              // manual
-        passthrough_from = ch_num;
-        break;
-    case k_rcin1 ... k_rcin16: // rc pass-thru
-        passthrough_from = int8_t(function - k_rcin1);
-        break;
-    case k_motor1 ... k_motor8:
-        // handled by AP_Motors::rc_write()
-        return;
-    }
-    if (passthrough_from != -1) {
-        // we are doing passthrough from input to output for this channel
-        RC_Channel *rc = RC_Channels::rc_channel(passthrough_from);
-        if (rc) {
-            if (SRV_Channels::passthrough_disabled()) {
-                output_pwm = rc->get_radio_trim();
-            } else {
-                output_pwm = rc->get_radio_in();
-            }
-        }
-    }
-    hal.rcout->write(ch_num, output_pwm);
-}
-
-/*
-  call output_ch() on all channels
- */
-void SRV_Channels::output_ch_all(void)
-{
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        channels[i].output_ch();
-    }
-}
-
-/*
-  return the current function for a channel
-*/
-SRV_Channel::Aux_servo_function_t SRV_Channels::channel_function(uint8_t channel)
-{
-    if (channel < NUM_SERVO_CHANNELS) {
-        return (SRV_Channel::Aux_servo_function_t)channels[channel].function.get();
-    }
-    return SRV_Channel::k_none;
-}
-
-/*
-   setup a channels aux servo function
-*/
-void SRV_Channel::aux_servo_function_setup(void)
-{
-    if (type_setup) {
-        return;
-    }
-    switch (function) {
-    case k_flap:
-    case k_flap_auto:
-    case k_egg_drop:
-        set_range(100);
-        break;
-    case k_heli_rsc:
-    case k_heli_tail_rsc:
-    case k_motor_tilt:
-        set_range(1000);
-        break;
-    case k_aileron_with_input:
-    case k_elevator_with_input:
-    case k_aileron:
-    case k_elevator:
-    case k_dspoiler1:
-    case k_dspoiler2:
-    case k_rudder:
-    case k_steering:
-    case k_flaperon1:
-    case k_flaperon2:
-        set_angle(4500);
-        break;
-    case k_throttle:
-        // fixed wing throttle
-        set_range(100);
-        break;
-    default:
-        break;
-    }
-}
-
-/// setup the output range types of all functions
-void SRV_Channels::update_aux_servo_function(void)
-{
-    function_mask.clearall();
-
-    for (uint8_t i = 0; i < SRV_Channel::k_nr_aux_servo_functions; i++) {
-        functions[i].channel_mask = 0;
-    }
-    
-    // set auxiliary ranges
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        channels[i].aux_servo_function_setup();
-        function_mask.set((uint8_t)channels[i].function.get());
-        functions[channels[i].function.get()].channel_mask |= 1U<<i;
-    }
-    initialised = true;
-}
-
-
-/// Should be called after the the servo functions have been initialized
-void SRV_Channels::enable_aux_servos()
-{
-    update_aux_servo_function();
-
-    // enable all channels that are set to a valid function. This
-    // includes k_none servos, which allows those to get their initial
-    // trim value on startup
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        SRV_Channel::Aux_servo_function_t function = (SRV_Channel::Aux_servo_function_t)channels[i].function.get();
-        // see if it is a valid function
-        if (function < SRV_Channel::k_nr_aux_servo_functions) {
-            hal.rcout->enable_ch(channels[i].ch_num);
-        }
-    }
-}
-
-/*
-  set radio_out for all channels matching the given function type
- */
-void SRV_Channels::set_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t value)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function.get() == function) {
-            channels[i].set_output_pwm(value);
-            channels[i].output_ch();
-        }
-    }
-}
-
-/*
-  set radio_out for all channels matching the given function type
-  trim the output assuming a 1500 center on the given value
- */
-void
-SRV_Channels::set_output_pwm_trimmed(SRV_Channel::Aux_servo_function_t function, int16_t value)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function.get() == function) {
-            int16_t value2 = value - 1500 + channels[i].get_trim();
-            channels[i].set_output_pwm(constrain_int16(value2,channels[i].get_output_min(),channels[i].get_output_max()));
-            channels[i].output_ch();
-          }
-    }
-}
-
-/*
-  set and save the trim value to radio_in for all channels matching
-  the given function type
- */
-void
-SRV_Channels::set_trim_to_radio_in_for(SRV_Channel::Aux_servo_function_t function)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function.get() == function) {
-            RC_Channel *rc = RC_Channels::rc_channel(channels[i].ch_num);
-            if (rc && rc->get_radio_in() != 0) {
-                rc->set_radio_trim(rc->get_radio_in());
-                rc->save_radio_trim();
-            }
-        }
-    }
-}
-
-/*
-  copy radio_in to radio_out for a given function
- */
-void
-SRV_Channels::copy_radio_in_out(SRV_Channel::Aux_servo_function_t function, bool do_input_output)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function.get() == function) {
-            RC_Channel *rc = RC_Channels::rc_channel(channels[i].ch_num);
-            if (rc == nullptr) {
-                continue;
-            }
-            if (do_input_output) {
-                rc->read();
-            }
-            channels[i].set_output_pwm(rc->get_radio_in());
-            if (do_input_output) {
-                channels[i].output_ch();
-            }
-        }
-    }
-}
-
-/*
-  setup failsafe value for an auxiliary function type to a LimitValue
- */
-void
-SRV_Channels::set_failsafe_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t pwm)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        const SRV_Channel &ch = channels[i];
-        if (ch.function.get() == function) {
-            hal.rcout->set_failsafe_pwm(1U<<ch.ch_num, pwm);
-        }
-    }
-}
-
-/*
-  setup failsafe value for an auxiliary function type to a LimitValue
- */
-void
-SRV_Channels::set_failsafe_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        const SRV_Channel &ch = channels[i];
-        if (ch.function.get() == function) {
-            uint16_t pwm = ch.get_limit_pwm(limit);
-            hal.rcout->set_failsafe_pwm(1U<<ch.ch_num, pwm);
-        }
-    }
-}
-
-/*
-  setup safety value for an auxiliary function type to a LimitValue
- */
-void
-SRV_Channels::set_safety_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        const SRV_Channel &ch = channels[i];
-        if (ch.function.get() == function) {
-            uint16_t pwm = ch.get_limit_pwm(limit);
-            hal.rcout->set_safety_pwm(1U<<ch.ch_num, pwm);
-        }
-    }
-}
-
-/*
-  set radio output value for an auxiliary function type to a LimitValue
- */
-void
-SRV_Channels::set_output_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        SRV_Channel &ch = channels[i];
-        if (ch.function.get() == function) {
-            uint16_t pwm = ch.get_limit_pwm(limit);
-            ch.set_output_pwm(pwm);
-            if (ch.function.get() == SRV_Channel::k_manual) {
-                RC_Channel *rc = RC_Channels::rc_channel(ch.ch_num);
-                if (rc != nullptr) {
-                    // in order for output_ch() to work for k_manual we
-                    // also have to override radio_in
-                    rc->set_radio_in(pwm);
-                }
-            }
-        }
-    }
-}
-
-/*
-  return true if a particular function is assigned to at least one RC channel
- */
-bool
-SRV_Channels::function_assigned(SRV_Channel::Aux_servo_function_t function)
-{
-    return function_mask.get(uint16_t(function));
-}
-
-/*
-  set servo_out and angle_min/max, then calc_pwm and output a
-  value. This is used to move a AP_Mount servo
- */
-void
-SRV_Channels::move_servo(SRV_Channel::Aux_servo_function_t function,
-                         int16_t value, int16_t angle_min, int16_t angle_max)
-{
-    if (!function_assigned(function)) {
-        return;
-    }
-    if (angle_max <= angle_min) {
-        return;
-    }
-    float v = float(value - angle_min) / float(angle_max - angle_min);
-    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
-        SRV_Channel &ch = channels[i];
-        if (ch.function.get() == function) {
-            uint16_t pwm = ch.servo_min + v * (ch.servo_max - ch.servo_min);
-            ch.set_output_pwm(pwm);
-        }
-    }
-}
-
-/*
-  set the default channel an auxiliary output function should be on
- */
-bool SRV_Channels::set_aux_channel_default(SRV_Channel::Aux_servo_function_t function, uint8_t channel)
-{
-    if (!initialised) {
-        update_aux_servo_function();
-    }
-    if (function_assigned(function)) {
-        // already assigned
-        return true;
-    }
-    if (channels[channel].function != SRV_Channel::k_none) {
-        if (channels[channel].function == function) {
-            return true;
-        }
-        hal.console->printf("Channel %u already assigned %u\n",
-                            (unsigned)channel,
-                            (unsigned)channels[channel].function);
-        return false;
-    }
-    channels[channel].type_setup = false;
-    channels[channel].function.set(function);
-    channels[channel].aux_servo_function_setup();
-    function_mask.set((uint8_t)function);
-    return true;
-}
-
-// find first channel that a function is assigned to
-bool SRV_Channels::find_channel(SRV_Channel::Aux_servo_function_t function, uint8_t &chan)
-{
-    if (!initialised) {
-        update_aux_servo_function();
-    }
-    if (!function_assigned(function)) {
-        return false;
-    }
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function == function) {
-            chan = channels[i].ch_num;
-            return true;
-        }
-    }
-    return false;
-}
-
-/*
-  get a pointer to first auxillary channel for a channel function
-*/
-SRV_Channel *SRV_Channels::get_channel_for(SRV_Channel::Aux_servo_function_t function, int8_t default_chan)
-{
-    uint8_t chan;
-    if (default_chan >= 0) {
-        set_aux_channel_default(function, default_chan);
-    }
-    if (!find_channel(function, chan)) {
-        return nullptr;
-    }
-    return &channels[chan];
-}
-
-void SRV_Channels::set_output_scaled(SRV_Channel::Aux_servo_function_t function, int16_t value)
-{
-    if (function < SRV_Channel::k_nr_aux_servo_functions) {
-        functions[function].output_scaled = value;
-        SRV_Channel::have_pwm_mask &= ~functions[function].channel_mask;
-    }
-}
-
-int16_t SRV_Channels::get_output_scaled(SRV_Channel::Aux_servo_function_t function)
-{
-    if (function < SRV_Channel::k_nr_aux_servo_functions) {
-        return functions[function].output_scaled;
-    }
-    return 0;
-}
-
-
-// set the trim for a function channel to given pwm
-void SRV_Channels::set_trim_to_pwm_for(SRV_Channel::Aux_servo_function_t function, int16_t pwm)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function == function) {
-            channels[i].servo_trim.set(pwm);
-        }
-    }
-}
-
-// set the trim for a function channel to min output
-void SRV_Channels::set_trim_to_min_for(SRV_Channel::Aux_servo_function_t function)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function == function) {
-            channels[i].servo_trim.set(channels[i].get_reversed()?channels[i].servo_max:channels[i].servo_min);
-        }
-    }
-}
-
-/*
-  set the default function for a channel
-*/
-void SRV_Channels::set_default_function(uint8_t chan, SRV_Channel::Aux_servo_function_t function)
-{
-    if (chan < NUM_SERVO_CHANNELS) {
-        channels[chan].function.set_default((uint8_t)function);
-    }
-}
-
-
-void SRV_Channels::set_esc_scaling_for(SRV_Channel::Aux_servo_function_t function)
-{
-    uint8_t chan;
-    if (find_channel(function, chan)) {
-        hal.rcout->set_esc_scaling(channels[chan].get_output_min(), channels[chan].get_output_max());
-    }
-}
-
-/*
-  auto-adjust channel trim from an integrator value. Positive v means
-  adjust trim up. Negative means decrease
- */
-void SRV_Channels::adjust_trim(SRV_Channel::Aux_servo_function_t function, float v)
-{
-    if (is_zero(v)) {
-        return;
-    }
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        SRV_Channel &c = channels[i];
-        if (function != (SRV_Channel::Aux_servo_function_t)(c.function.get())) {
-            continue;
-        }
-        float change = c.reversed?-v:v;
-        uint16_t new_trim = c.servo_trim;
-        float trim_scaled = float(c.servo_trim - c.servo_min) / (c.servo_max - c.servo_min);
-        if (change > 0 && trim_scaled < 0.6f) {
-            new_trim++;
-        } else if (change < 0 && trim_scaled > 0.4f) {
-            new_trim--;
-        } else {
-            return;
-        }
-        c.servo_trim.set(new_trim);
-
-        trimmed_mask |= 1U<<i;
-    }
-}
-
-
-// get pwm output for the first channel of the given function type.
-bool SRV_Channels::get_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t &value)
-{
-    uint8_t chan;
-    if (!find_channel(function, chan)) {
-        return false;
-    }
-    channels[chan].calc_pwm(functions[function].output_scaled);
-    value = channels[chan].output_pwm;
-    return true;
-}
-
-// set output pwm to trim for the given function
-void SRV_Channels::set_output_to_trim(SRV_Channel::Aux_servo_function_t function)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function == function) {
-            channels[i].set_output_pwm(channels[i].servo_trim);
-        }
-    }
-}
-
-// set output pwm to for first matching channel
-void SRV_Channels::set_output_pwm_first(SRV_Channel::Aux_servo_function_t function, uint16_t pwm)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function == function) {
-            channels[i].set_output_pwm(pwm);
-            break;
-        }
-    }
-}
-
-/*
-  get the normalised output for a channel function from the pwm value
-  of the first matching channel
- */
-float SRV_Channels::get_output_norm(SRV_Channel::Aux_servo_function_t function)
-{
-    uint8_t chan;
-    if (!find_channel(function, chan)) {
-        return 0;
-    }
-    channels[chan].calc_pwm(functions[function].output_scaled);
-    return channels[chan].get_output_norm();
-}
-
-/*
-  limit slew rate for an output function to given rate in percent per second
- */
-void SRV_Channels::limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate)
-{
-    // NOT IMPLEMENTED YET
-}
-
-// call set_angle() on matching channels
-void SRV_Channels::set_angle(SRV_Channel::Aux_servo_function_t function, uint16_t angle)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function == function) {
-            channels[i].set_angle(angle);
-        }
-    }    
-}
-
-// call set_range() on matching channels
-void SRV_Channels::set_range(SRV_Channel::Aux_servo_function_t function, uint16_t range)
-{
-    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
-        if (channels[i].function == function) {
-            channels[i].set_range(range);
-        }
-    }
-}

From fd081a8cc6c43313086be18969b0f1213e8a9513 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 12:02:32 +1100
Subject: [PATCH 030/200] SRV_Channel: split SRV_Channel into separate
 directory

---
 libraries/SRV_Channel/SRV_Channel.cpp     | 319 ++++++++++++++++
 libraries/SRV_Channel/SRV_Channel.h       | 387 ++++++++++++++++++++
 libraries/SRV_Channel/SRV_Channel_aux.cpp | 581 ++++++++++++++++++++++++++++++
 3 files changed, 1287 insertions(+)
 create mode 100644 libraries/SRV_Channel/SRV_Channel.cpp
 create mode 100644 libraries/SRV_Channel/SRV_Channel.h
 create mode 100644 libraries/SRV_Channel/SRV_Channel_aux.cpp

diff --git a/libraries/SRV_Channel/SRV_Channel.cpp b/libraries/SRV_Channel/SRV_Channel.cpp
new file mode 100644
index 0000000..0cf796c
--- /dev/null
+++ b/libraries/SRV_Channel/SRV_Channel.cpp
@@ -0,0 +1,319 @@
+/*
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+  SRV_Channel.cpp - object to separate input and output channel
+  ranges, trim and reversal
+ */
+
+#include <AP_HAL/AP_HAL.h>
+#include <AP_Math/AP_Math.h>
+#include <AP_Vehicle/AP_Vehicle.h>
+#include "SRV_Channel.h"
+
+extern const AP_HAL::HAL& hal;
+
+SRV_Channel *SRV_Channels::channels;
+bool SRV_Channels::disabled_passthrough;
+bool SRV_Channels::initialised;
+Bitmask SRV_Channels::function_mask{SRV_Channel::k_nr_aux_servo_functions};
+SRV_Channels::srv_function SRV_Channels::functions[SRV_Channel::k_nr_aux_servo_functions];
+SRV_Channel::servo_mask_t SRV_Channel::have_pwm_mask;
+
+const AP_Param::GroupInfo SRV_Channel::var_info[] = {
+    // @Param: MIN
+    // @DisplayName: Minimum PWM
+    // @Description: minimum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
+    // @Units: pwm
+    // @Range: 800 2200
+    // @Increment: 1
+    // @User: Standard
+    AP_GROUPINFO("MIN",  1, SRV_Channel, servo_min, 1100),
+
+    // @Param: MAX
+    // @DisplayName: Maximum PWM
+    // @Description: maximum PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
+    // @Units: pwm
+    // @Range: 800 2200
+    // @Increment: 1
+    // @User: Standard
+    AP_GROUPINFO("MAX",  2, SRV_Channel, servo_max, 1900),
+
+    // @Param: TRIM
+    // @DisplayName: Trim PWM
+    // @Description: Trim PWM pulse width. Typically 1000 is lower limit, 1500 is neutral and 2000 is upper limit.
+    // @Units: pwm
+    // @Range: 800 2200
+    // @Increment: 1
+    // @User: Standard
+    AP_GROUPINFO("TRIM",  3, SRV_Channel, servo_trim, 1500),
+    
+    // @Param: REVERSED
+    // @DisplayName: Servo reverse
+    // @Description: Reverse servo operation. Set to 0 for normal operation. Set to 1 to reverse this channel.
+    // @Values: 0:Normal,1:Reversed
+    // @User: Standard
+    AP_GROUPINFO("REVERSED",  4, SRV_Channel, reversed, 0),
+
+    // @Param: FUNCTION
+    // @DisplayName: Servo output function
+    // @Description: Function assigned to this servo. Seeing this to Disabled(0) will setup this output for control by auto missions or MAVLink servo set commands. any other value will enable the corresponding function
+    // @Values: 0:Disabled,1:RCPassThru,2:Flap,3:Flap_auto,4:Aileron,6:mount_pan,7:mount_tilt,8:mount_roll,9:mount_open,10:camera_trigger,11:release,12:mount2_pan,13:mount2_tilt,14:mount2_roll,15:mount2_open,16:DifferentialSpoiler1,17:DifferentialSpoiler2,18:AileronWithInput,19:Elevator,20:ElevatorWithInput,21:Rudder,24:Flaperon1,25:Flaperon2,26:GroundSteering,27:Parachute,28:EPM,29:LandingGear,30:EngineRunEnable,31:HeliRSC,32:HeliTailRSC,33:Motor1,34:Motor2,35:Motor3,36:Motor4,37:Motor5,38:Motor6,39:Motor7,40:Motor8,51:RCIN1,52:RCIN2,53:RCIN3,54:RCIN4,55:RCIN5,56:RCIN6,57:RCIN7,58:RCIN8,59:RCIN9,60:RCIN10,61:RCIN11,62:RCIN12,63:RCIN13,64:RCIN14,65:RCIN15,66:RCIN16,67:Ignition,68:Choke,69:Starter,70:Throttle
+    // @User: Standard
+    AP_GROUPINFO("FUNCTION",  5, SRV_Channel, function, 0),
+    
+    AP_GROUPEND
+};
+
+
+const AP_Param::GroupInfo SRV_Channels::var_info[] = {
+    // @Group: 1_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[0], "1_",  1, SRV_Channels, SRV_Channel),
+
+    // @Group: 2_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[1], "2_",  2, SRV_Channels, SRV_Channel),
+
+    // @Group: 3_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[2], "3_",  3, SRV_Channels, SRV_Channel),
+
+    // @Group: 4_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[3], "4_",  4, SRV_Channels, SRV_Channel),
+
+    // @Group: 5_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[4], "5_",  5, SRV_Channels, SRV_Channel),
+
+    // @Group: 6_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[5], "6_",  6, SRV_Channels, SRV_Channel),
+
+    // @Group: 7_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[6], "7_",  7, SRV_Channels, SRV_Channel),
+
+    // @Group: 8_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[7], "8_",  8, SRV_Channels, SRV_Channel),
+
+    // @Group: 9_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[8], "9_",  9, SRV_Channels, SRV_Channel),
+
+    // @Group: 10_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[9], "10_",  10, SRV_Channels, SRV_Channel),
+
+    // @Group: 11_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[10], "11_",  11, SRV_Channels, SRV_Channel),
+
+    // @Group: 12_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[11], "12_",  12, SRV_Channels, SRV_Channel),
+
+    // @Group: 13_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[12], "13_",  13, SRV_Channels, SRV_Channel),
+
+    // @Group: 14_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[13], "14_",  14, SRV_Channels, SRV_Channel),
+
+    // @Group: 15_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[14], "15_",  15, SRV_Channels, SRV_Channel),
+
+    // @Group: 16_
+    // @Path: SRV_Channel.cpp
+    AP_SUBGROUPINFO(obj_channels[15], "16_",  16, SRV_Channels, SRV_Channel),
+    
+    // @Param: _AUTO_TRIM
+    // @DisplayName: Automatic servo trim
+    // @Description: This enables automatic servo trim in flight. Servos will be trimed in stabilized flight modes when the aircraft is close to level. Changes to servo trim will be saved every 10 seconds and will persist between flights.
+    // @Values: 0:Disable,1:Enable
+    // @User: Advanced
+    AP_GROUPINFO("_AUTO_TRIM",  17, SRV_Channels, auto_trim, 0),
+    
+    AP_GROUPEND
+};
+
+SRV_Channel::SRV_Channel(void)
+{
+    AP_Param::setup_object_defaults(this, var_info);
+    // start with all pwm at zero
+    have_pwm_mask = ~uint16_t(0);
+}
+
+
+/*
+  constructor
+ */
+SRV_Channels::SRV_Channels(void)
+{
+    channels = obj_channels;
+    
+    // set defaults from the parameter table
+    AP_Param::setup_object_defaults(this, var_info);
+
+    // setup ch_num on channels
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        channels[i].ch_num = i;
+    }
+}
+
+/*
+  save adjusted trims
+ */
+void SRV_Channels::save_trim(void)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (trimmed_mask & (1U<<i)) {
+            channels[i].servo_trim.set_and_save(channels[i].servo_trim.get());
+        }
+    }
+    trimmed_mask = 0;
+}
+
+// convert a 0..range_max to a pwm
+uint16_t SRV_Channel::pwm_from_range(int16_t scaled_value) const
+{
+    if (servo_max <= servo_min || high_out == 0) {
+        return servo_min;
+    }
+    if (scaled_value >= high_out) {
+        scaled_value = high_out;
+    }
+    if (scaled_value < 0) {
+        scaled_value = 0;
+    }
+    if (reversed) {
+        scaled_value = high_out - scaled_value;
+    }
+    return servo_min + ((int32_t)scaled_value * (int32_t)(servo_max - servo_min)) / (int32_t)high_out;
+}
+
+// convert a -angle_max..angle_max to a pwm
+uint16_t SRV_Channel::pwm_from_angle(int16_t scaled_value) const
+{
+    if (reversed) {
+        scaled_value = -scaled_value;
+    }
+    if (scaled_value > 0) {
+        return servo_trim + ((int32_t)scaled_value * (int32_t)(servo_max - servo_trim)) / (int32_t)high_out;
+    } else {
+        return servo_trim - (-(int32_t)scaled_value * (int32_t)(servo_trim - servo_min)) / (int32_t)high_out;
+    }
+}
+
+void SRV_Channel::calc_pwm(int16_t output_scaled)
+{
+    if (have_pwm_mask & (1U<<ch_num)) {
+        return;
+    }
+    uint16_t pwm;
+    if (type_angle) {
+        pwm = pwm_from_angle(output_scaled);
+    } else {
+        pwm = pwm_from_range(output_scaled);
+    }
+    set_output_pwm(pwm);
+}
+
+void SRV_Channels::output_trim_all(void)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        channels[i].set_output_pwm(channels[i].servo_trim);
+    }
+}
+
+void SRV_Channels::setup_failsafe_trim_all(void)
+{
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        hal.rcout->set_failsafe_pwm(1U<<channels[i].ch_num, channels[i].servo_trim);
+    }
+}
+
+void SRV_Channel::set_output_pwm(uint16_t pwm)
+{
+    output_pwm = pwm;
+    have_pwm_mask |= (1U<<ch_num);
+}
+
+// set angular range of scaled output
+void SRV_Channel::set_angle(int16_t angle)
+{
+    type_angle = true;
+    high_out = angle;    
+    type_setup = true;
+}
+
+// set range of scaled output
+void SRV_Channel::set_range(uint16_t high)
+{
+    type_angle = false;
+    high_out = high;
+    type_setup = true;
+}
+
+/*
+  get normalised output from -1 to 1, assuming 0 at mid point of servo_min/servo_max
+ */
+float SRV_Channel::get_output_norm(void)
+{
+    uint16_t mid = (servo_max + servo_min) / 2;
+    float ret;
+    if (mid <= servo_min) {
+        return 0;
+    }
+    if (output_pwm < mid) {
+        ret = (float)(output_pwm - mid) / (float)(mid - servo_min);
+    } else if (output_pwm > mid) {
+        ret = (float)(output_pwm - mid) / (float)(servo_max  - mid);
+    } else {
+        ret = 0;
+    }
+    if (get_reversed()) {
+           ret = -ret;
+    }
+    return ret;
+}
+
+uint16_t SRV_Channel::get_limit_pwm(LimitValue limit) const
+{
+    switch (limit) {
+    case SRV_CHANNEL_LIMIT_TRIM:
+        return servo_trim;
+    case SRV_CHANNEL_LIMIT_MIN:
+        return servo_min;
+    case SRV_CHANNEL_LIMIT_MAX:
+        return servo_max;
+    case SRV_CHANNEL_LIMIT_ZERO_PWM:
+    default:
+        return 0;
+    }
+}
+
+/*
+  run calc_pwm for all channels
+ */
+void SRV_Channels::calc_pwm(void)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        channels[i].calc_pwm(functions[channels[i].function].output_scaled);
+    }
+}
diff --git a/libraries/SRV_Channel/SRV_Channel.h b/libraries/SRV_Channel/SRV_Channel.h
new file mode 100644
index 0000000..244ffcb
--- /dev/null
+++ b/libraries/SRV_Channel/SRV_Channel.h
@@ -0,0 +1,387 @@
+/*
+  control of servo output ranges, trim and servo reversal. This can
+  optionally be used to provide separation of input and output channel
+  ranges so that RCn_MIN, RCn_MAX, RCn_TRIM and RCn_REV only apply to
+  the input side of RC_Channel
+
+  It works by running servo output calculations as normal, then
+  re-mapping the output according to the servo MIN/MAX/TRIM/REV from
+  this object
+
+  Only 4 channels of ranges are defined as those match the input
+  channels for R/C sticks
+ */
+#pragma once
+
+#include <AP_Common/AP_Common.h>
+#include <AP_Param/AP_Param.h>
+#include <AP_RCMapper/AP_RCMapper.h>
+#include <AP_Common/Bitmask.h>
+
+#define NUM_SERVO_CHANNELS 16
+
+class SRV_Channels;
+
+/*
+  class SRV_Channel. The class SRV_Channels contains an array of
+  SRV_Channel objects. This is done to fit within the AP_Param limit
+  of 64 parameters per object.
+*/
+class SRV_Channel {
+public:
+    friend class SRV_Channels;
+    // constructor
+    SRV_Channel(void);
+
+    static const struct AP_Param::GroupInfo var_info[];
+
+    typedef enum
+    {
+        k_none                  = 0,            ///< disabled
+        k_manual                = 1,            ///< manual, just pass-thru the RC in signal
+        k_flap                  = 2,            ///< flap
+        k_flap_auto             = 3,            ///< flap automated
+        k_aileron               = 4,            ///< aileron
+        k_unused1               = 5,            ///< unused function
+        k_mount_pan             = 6,            ///< mount yaw (pan)
+        k_mount_tilt            = 7,            ///< mount pitch (tilt)
+        k_mount_roll            = 8,            ///< mount roll
+        k_mount_open            = 9,            ///< mount open (deploy) / close (retract)
+        k_cam_trigger           = 10,           ///< camera trigger
+        k_egg_drop              = 11,           ///< egg drop
+        k_mount2_pan            = 12,           ///< mount2 yaw (pan)
+        k_mount2_tilt           = 13,           ///< mount2 pitch (tilt)
+        k_mount2_roll           = 14,           ///< mount2 roll
+        k_mount2_open           = 15,           ///< mount2 open (deploy) / close (retract)
+        k_dspoiler1             = 16,           ///< differential spoiler 1 (left wing)
+        k_dspoiler2             = 17,           ///< differential spoiler 2 (right wing)
+        k_aileron_with_input    = 18,            ///< aileron, with rc input
+        k_elevator              = 19,            ///< elevator
+        k_elevator_with_input   = 20,            ///< elevator, with rc input
+        k_rudder                = 21,            ///< secondary rudder channel
+        k_sprayer_pump          = 22,            ///< crop sprayer pump channel
+        k_sprayer_spinner       = 23,            ///< crop sprayer spinner channel
+        k_flaperon1             = 24,            ///< flaperon, left wing
+        k_flaperon2             = 25,            ///< flaperon, right wing
+        k_steering              = 26,            ///< ground steering, used to separate from rudder
+        k_parachute_release     = 27,            ///< parachute release
+        k_gripper               = 28,            ///< gripper
+        k_landing_gear_control  = 29,            ///< landing gear controller
+        k_engine_run_enable     = 30,            ///< engine kill switch, used for gas airplanes and helicopters
+        k_heli_rsc              = 31,            ///< helicopter RSC output
+        k_heli_tail_rsc         = 32,            ///< helicopter tail RSC output
+        k_motor1                = 33,            ///< these allow remapping of copter motors
+        k_motor2                = 34,
+        k_motor3                = 35,
+        k_motor4                = 36,
+        k_motor5                = 37,
+        k_motor6                = 38,
+        k_motor7                = 39,
+        k_motor8                = 40,
+        k_motor_tilt            = 41,            ///< tiltrotor motor tilt control
+        k_rcin1                 = 51,            ///< these are for pass-thru from arbitrary rc inputs
+        k_rcin2                 = 52,
+        k_rcin3                 = 53,
+        k_rcin4                 = 54,
+        k_rcin5                 = 55,
+        k_rcin6                 = 56,
+        k_rcin7                 = 57,
+        k_rcin8                 = 58,
+        k_rcin9                 = 59,
+        k_rcin10                = 60,
+        k_rcin11                = 61,
+        k_rcin12                = 62,
+        k_rcin13                = 63,
+        k_rcin14                = 64,
+        k_rcin15                = 65,
+        k_rcin16                = 66,
+        k_ignition              = 67,
+        k_choke                 = 68,
+        k_starter               = 69,
+        k_throttle              = 70,
+        k_nr_aux_servo_functions         ///< This must be the last enum value (only add new values _before_ this one)
+    } Aux_servo_function_t;
+
+    // used to get min/max/trim limit value based on reverse
+    enum LimitValue {
+        SRV_CHANNEL_LIMIT_TRIM,
+        SRV_CHANNEL_LIMIT_MIN,
+        SRV_CHANNEL_LIMIT_MAX,
+        SRV_CHANNEL_LIMIT_ZERO_PWM
+    };
+
+    // a special scaled output value that is recognised as meaning no pwm output
+    static const int16_t ZERO_PWM = INT16_MIN;
+
+    // set the output value as a pwm value
+    void set_output_pwm(uint16_t pwm);
+
+    // get the output value as a pwm value
+    uint16_t get_output_pwm(void) const { return output_pwm; }
+
+    // set angular range of scaled output
+    void set_angle(int16_t angle);
+
+    // set range of scaled output. Low is always zero
+    void set_range(uint16_t high);
+
+    // return true if the channel is reversed
+    bool get_reversed(void) const {
+        return reversed?true:false;
+    }
+
+    // set MIN/MAX parameters
+    void set_output_min(uint16_t pwm) {
+        servo_min.set(pwm);
+    }
+    void set_output_max(uint16_t pwm) {
+        servo_max.set(pwm);
+    }
+
+    // get MIN/MAX/TRIM parameters
+    uint16_t get_output_min(void) const {
+        return servo_min;
+    }
+    uint16_t get_output_max(void) const {
+        return servo_max;
+    }
+    uint16_t get_trim(void) const {
+        return servo_trim;
+    }
+
+private:
+    AP_Int16 servo_min;
+    AP_Int16 servo_max;
+    AP_Int16 servo_trim;
+    // reversal, following convention that 1 means reversed, 0 means normal
+    AP_Int8 reversed;
+    AP_Int8 function;
+
+    // a pending output value as PWM
+    uint16_t output_pwm;
+
+    // true for angle output type
+    bool type_angle:1;
+
+    // set_range() or set_angle() has been called
+    bool type_setup:1;
+    
+    // the hal channel number
+    uint8_t ch_num;
+
+    // high point of angle or range output
+    uint16_t high_out;
+
+    // convert a 0..range_max to a pwm
+    uint16_t pwm_from_range(int16_t scaled_value) const;
+
+    // convert a -angle_max..angle_max to a pwm
+    uint16_t pwm_from_angle(int16_t scaled_value) const;
+
+    // convert a scaled output to a pwm value
+    void calc_pwm(int16_t output_scaled);
+
+    // output value based on function
+    void output_ch(void);
+
+    // setup output type and range based on function
+    void aux_servo_function_setup(void);
+
+    // return PWM for a given limit value
+    uint16_t get_limit_pwm(LimitValue limit) const;
+
+    // get normalised output from -1 to 1
+    float get_output_norm(void);
+    
+    // a bitmask type wide enough for NUM_SERVO_CHANNELS
+    typedef uint16_t servo_mask_t;
+
+    // mask of channels where we have a output_pwm value. Cleared when a
+    // scaled value is written. 
+    static servo_mask_t have_pwm_mask;
+};
+
+/*
+  class	SRV_Channels
+*/
+class SRV_Channels {
+public:
+    // constructor
+    SRV_Channels(void);
+
+    static const struct AP_Param::GroupInfo var_info[];
+
+    // set the default function for a channel
+    static void set_default_function(uint8_t chan, SRV_Channel::Aux_servo_function_t function);
+
+    // set output value for a function channel as a pwm value
+    static void set_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t value);
+
+    // set output value for a function channel as a pwm value on the first matching channel
+    static void set_output_pwm_first(SRV_Channel::Aux_servo_function_t function, uint16_t value);
+
+    // set output value for a function channel as a scaled value. This
+    // calls calc_pwm() to also set the pwm value
+    static void set_output_scaled(SRV_Channel::Aux_servo_function_t function, int16_t value);
+
+    // get scaled output for the given function type.
+    static int16_t get_output_scaled(SRV_Channel::Aux_servo_function_t function);
+
+    // get pwm output for the first channel of the given function type.
+    static bool get_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t &value);
+
+    // get normalised output (-1 to 1 for angle, 0 to 1 for range). Value is taken from pwm value
+    // return zero on error.
+    static float get_output_norm(SRV_Channel::Aux_servo_function_t function);
+
+    // limit slew rate to given limit in percent per second
+    static void limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate);
+
+    // call output_ch() on all channels
+    static void output_ch_all(void);
+
+    // take current radio_out for first 4 channels and remap using
+    // servo ranges if enabled
+    void remap_servo_output(void);
+
+    // setup output ESC scaling based on a channels MIN/MAX
+    void set_esc_scaling_for(SRV_Channel::Aux_servo_function_t function);
+
+    // return true when auto_trim enabled
+    bool auto_trim_enabled(void) const { return auto_trim; }
+
+    // adjust trim of a channel by a small increment
+    void adjust_trim(SRV_Channel::Aux_servo_function_t function, float v);
+
+    // save trims
+    void save_trim(void);
+
+    // setup for a reversible k_throttle (from -100 to 100)
+    void set_reversible_throttle(void) {
+        flags.k_throttle_reversible = true;
+    }
+
+    // set all outputs to the TRIM value
+    static void output_trim_all(void);
+
+    // setup IO failsafe for all channels to trim
+    static void setup_failsafe_trim_all(void);
+
+    // set output for all channels matching the given function type, allow radio_trim to center servo
+    static void set_output_pwm_trimmed(SRV_Channel::Aux_servo_function_t function, int16_t value);
+
+    // set and save the trim for a function channel to radio_in on matching input channel
+    static void set_trim_to_radio_in_for(SRV_Channel::Aux_servo_function_t function);
+
+    // set the trim for a function channel to min of the channel
+    static void set_trim_to_min_for(SRV_Channel::Aux_servo_function_t function);
+
+    // set the trim for a function channel to given pwm
+    static void set_trim_to_pwm_for(SRV_Channel::Aux_servo_function_t function, int16_t pwm);
+
+    // set output to min value
+    static void set_output_to_min(SRV_Channel::Aux_servo_function_t function);
+
+    // set output to max value
+    static void set_output_to_max(SRV_Channel::Aux_servo_function_t function);
+
+    // set output to trim value
+    static void set_output_to_trim(SRV_Channel::Aux_servo_function_t function);
+
+    // copy radio_in to radio_out
+    static void copy_radio_in_out(SRV_Channel::Aux_servo_function_t function, bool do_input_output=false);
+
+    // setup failsafe for an auxiliary channel function, by pwm
+    static void set_failsafe_pwm(SRV_Channel::SRV_Channel::Aux_servo_function_t function, uint16_t pwm);
+
+    // setup failsafe for an auxiliary channel function
+    static void set_failsafe_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
+
+    // setup safety for an auxiliary channel function (used when disarmed)
+    static void set_safety_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
+
+    // set servo to a LimitValue
+    static void set_output_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit);
+
+    // return true if a function is assigned to a channel
+    static bool function_assigned(SRV_Channel::Aux_servo_function_t function);
+
+    // set a servo_out value, and angle range, then calc_pwm
+    static void move_servo(SRV_Channel::Aux_servo_function_t function,
+                           int16_t value, int16_t angle_min, int16_t angle_max);
+
+    // assign and enable auxiliary channels
+    static void enable_aux_servos(void);
+
+    // prevent a channel from being used for auxiliary functions
+    static void disable_aux_channel(uint8_t channel);
+
+    // return the current function for a channel
+    static SRV_Channel::Aux_servo_function_t channel_function(uint8_t channel);
+
+    // refresh aux servo to function mapping
+    static void update_aux_servo_function(void);
+
+    // set default channel for an auxiliary function
+    static bool set_aux_channel_default(SRV_Channel::Aux_servo_function_t function, uint8_t channel);
+
+    // find first channel that a function is assigned to
+    static bool find_channel(SRV_Channel::Aux_servo_function_t function, uint8_t &chan);
+
+    // find first channel that a function is assigned to, returning SRV_Channel object
+    static SRV_Channel *get_channel_for(SRV_Channel::Aux_servo_function_t function, int8_t default_chan=-1);
+
+    // call set_angle() on matching channels
+    static void set_angle(SRV_Channel::Aux_servo_function_t function, uint16_t angle);
+
+    // call set_range() on matching channels
+    static void set_range(SRV_Channel::Aux_servo_function_t function, uint16_t range);
+    
+    // control pass-thru of channels
+    void disable_passthrough(bool disable) {
+        disabled_passthrough = disable;
+    }
+
+    static bool passthrough_disabled(void) {
+        return disabled_passthrough;
+    }
+
+    // constrain to output min/max for function
+    static void constrain_pwm(SRV_Channel::Aux_servo_function_t function);
+    
+    // calculate PWM for all channels
+    static void calc_pwm(void);
+
+    static SRV_Channel *srv_channel(uint8_t i) {
+        return i<NUM_SERVO_CHANNELS?&channels[i]:nullptr;
+    }
+
+private:
+    struct {
+        bool k_throttle_reversible:1;
+    } flags;
+
+    static bool disabled_passthrough;
+
+    uint16_t trimmed_mask;
+
+    static Bitmask function_mask;
+    static bool initialised;
+    
+    // this static arrangement is to avoid having static objects in AP_Param tables
+    static SRV_Channel *channels;
+    SRV_Channel obj_channels[NUM_SERVO_CHANNELS];
+
+    static struct srv_function {
+        // mask of what channels this applies to
+        SRV_Channel::servo_mask_t channel_mask;
+
+        // scaled output for this function
+        int16_t output_scaled;
+    } functions[SRV_Channel::k_nr_aux_servo_functions];
+
+    AP_Int8 auto_trim;
+
+    // initialise parameters from RC_Channel
+    void initialise_parameters(void);
+};
diff --git a/libraries/SRV_Channel/SRV_Channel_aux.cpp b/libraries/SRV_Channel/SRV_Channel_aux.cpp
new file mode 100644
index 0000000..2bf4ddf
--- /dev/null
+++ b/libraries/SRV_Channel/SRV_Channel_aux.cpp
@@ -0,0 +1,581 @@
+/*
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/*
+  SRV_Channel_aux.cpp - handling of servo auxillary functions
+ */
+#include "SRV_Channel.h"
+
+#include <AP_Math/AP_Math.h>
+#include <AP_HAL/AP_HAL.h>
+#include <RC_Channel/RC_Channel.h>
+
+extern const AP_HAL::HAL& hal;
+
+/// map a function to a servo channel and output it
+void SRV_Channel::output_ch(void)
+{
+    int8_t passthrough_from = -1;
+
+    // take care of special function cases
+    switch(function)
+    {
+    case k_manual:              // manual
+        passthrough_from = ch_num;
+        break;
+    case k_rcin1 ... k_rcin16: // rc pass-thru
+        passthrough_from = int8_t(function - k_rcin1);
+        break;
+    case k_motor1 ... k_motor8:
+        // handled by AP_Motors::rc_write()
+        return;
+    }
+    if (passthrough_from != -1) {
+        // we are doing passthrough from input to output for this channel
+        RC_Channel *rc = RC_Channels::rc_channel(passthrough_from);
+        if (rc) {
+            if (SRV_Channels::passthrough_disabled()) {
+                output_pwm = rc->get_radio_trim();
+            } else {
+                output_pwm = rc->get_radio_in();
+            }
+        }
+    }
+    hal.rcout->write(ch_num, output_pwm);
+}
+
+/*
+  call output_ch() on all channels
+ */
+void SRV_Channels::output_ch_all(void)
+{
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        channels[i].output_ch();
+    }
+}
+
+/*
+  return the current function for a channel
+*/
+SRV_Channel::Aux_servo_function_t SRV_Channels::channel_function(uint8_t channel)
+{
+    if (channel < NUM_SERVO_CHANNELS) {
+        return (SRV_Channel::Aux_servo_function_t)channels[channel].function.get();
+    }
+    return SRV_Channel::k_none;
+}
+
+/*
+   setup a channels aux servo function
+*/
+void SRV_Channel::aux_servo_function_setup(void)
+{
+    if (type_setup) {
+        return;
+    }
+    switch (function) {
+    case k_flap:
+    case k_flap_auto:
+    case k_egg_drop:
+        set_range(100);
+        break;
+    case k_heli_rsc:
+    case k_heli_tail_rsc:
+    case k_motor_tilt:
+        set_range(1000);
+        break;
+    case k_aileron_with_input:
+    case k_elevator_with_input:
+    case k_aileron:
+    case k_elevator:
+    case k_dspoiler1:
+    case k_dspoiler2:
+    case k_rudder:
+    case k_steering:
+    case k_flaperon1:
+    case k_flaperon2:
+        set_angle(4500);
+        break;
+    case k_throttle:
+        // fixed wing throttle
+        set_range(100);
+        break;
+    default:
+        break;
+    }
+}
+
+/// setup the output range types of all functions
+void SRV_Channels::update_aux_servo_function(void)
+{
+    function_mask.clearall();
+
+    for (uint8_t i = 0; i < SRV_Channel::k_nr_aux_servo_functions; i++) {
+        functions[i].channel_mask = 0;
+    }
+    
+    // set auxiliary ranges
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        channels[i].aux_servo_function_setup();
+        function_mask.set((uint8_t)channels[i].function.get());
+        functions[channels[i].function.get()].channel_mask |= 1U<<i;
+    }
+    initialised = true;
+}
+
+
+/// Should be called after the the servo functions have been initialized
+void SRV_Channels::enable_aux_servos()
+{
+    update_aux_servo_function();
+
+    // enable all channels that are set to a valid function. This
+    // includes k_none servos, which allows those to get their initial
+    // trim value on startup
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel::Aux_servo_function_t function = (SRV_Channel::Aux_servo_function_t)channels[i].function.get();
+        // see if it is a valid function
+        if (function < SRV_Channel::k_nr_aux_servo_functions) {
+            hal.rcout->enable_ch(channels[i].ch_num);
+        }
+    }
+}
+
+/*
+  set radio_out for all channels matching the given function type
+ */
+void SRV_Channels::set_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t value)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function.get() == function) {
+            channels[i].set_output_pwm(value);
+            channels[i].output_ch();
+        }
+    }
+}
+
+/*
+  set radio_out for all channels matching the given function type
+  trim the output assuming a 1500 center on the given value
+ */
+void
+SRV_Channels::set_output_pwm_trimmed(SRV_Channel::Aux_servo_function_t function, int16_t value)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function.get() == function) {
+            int16_t value2 = value - 1500 + channels[i].get_trim();
+            channels[i].set_output_pwm(constrain_int16(value2,channels[i].get_output_min(),channels[i].get_output_max()));
+            channels[i].output_ch();
+          }
+    }
+}
+
+/*
+  set and save the trim value to radio_in for all channels matching
+  the given function type
+ */
+void
+SRV_Channels::set_trim_to_radio_in_for(SRV_Channel::Aux_servo_function_t function)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function.get() == function) {
+            RC_Channel *rc = RC_Channels::rc_channel(channels[i].ch_num);
+            if (rc && rc->get_radio_in() != 0) {
+                rc->set_radio_trim(rc->get_radio_in());
+                rc->save_radio_trim();
+            }
+        }
+    }
+}
+
+/*
+  copy radio_in to radio_out for a given function
+ */
+void
+SRV_Channels::copy_radio_in_out(SRV_Channel::Aux_servo_function_t function, bool do_input_output)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function.get() == function) {
+            RC_Channel *rc = RC_Channels::rc_channel(channels[i].ch_num);
+            if (rc == nullptr) {
+                continue;
+            }
+            if (do_input_output) {
+                rc->read();
+            }
+            channels[i].set_output_pwm(rc->get_radio_in());
+            if (do_input_output) {
+                channels[i].output_ch();
+            }
+        }
+    }
+}
+
+/*
+  setup failsafe value for an auxiliary function type to a LimitValue
+ */
+void
+SRV_Channels::set_failsafe_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t pwm)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        const SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            hal.rcout->set_failsafe_pwm(1U<<ch.ch_num, pwm);
+        }
+    }
+}
+
+/*
+  setup failsafe value for an auxiliary function type to a LimitValue
+ */
+void
+SRV_Channels::set_failsafe_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        const SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            uint16_t pwm = ch.get_limit_pwm(limit);
+            hal.rcout->set_failsafe_pwm(1U<<ch.ch_num, pwm);
+        }
+    }
+}
+
+/*
+  setup safety value for an auxiliary function type to a LimitValue
+ */
+void
+SRV_Channels::set_safety_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        const SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            uint16_t pwm = ch.get_limit_pwm(limit);
+            hal.rcout->set_safety_pwm(1U<<ch.ch_num, pwm);
+        }
+    }
+}
+
+/*
+  set radio output value for an auxiliary function type to a LimitValue
+ */
+void
+SRV_Channels::set_output_limit(SRV_Channel::Aux_servo_function_t function, SRV_Channel::LimitValue limit)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            uint16_t pwm = ch.get_limit_pwm(limit);
+            ch.set_output_pwm(pwm);
+            if (ch.function.get() == SRV_Channel::k_manual) {
+                RC_Channel *rc = RC_Channels::rc_channel(ch.ch_num);
+                if (rc != nullptr) {
+                    // in order for output_ch() to work for k_manual we
+                    // also have to override radio_in
+                    rc->set_radio_in(pwm);
+                }
+            }
+        }
+    }
+}
+
+/*
+  return true if a particular function is assigned to at least one RC channel
+ */
+bool
+SRV_Channels::function_assigned(SRV_Channel::Aux_servo_function_t function)
+{
+    return function_mask.get(uint16_t(function));
+}
+
+/*
+  set servo_out and angle_min/max, then calc_pwm and output a
+  value. This is used to move a AP_Mount servo
+ */
+void
+SRV_Channels::move_servo(SRV_Channel::Aux_servo_function_t function,
+                         int16_t value, int16_t angle_min, int16_t angle_max)
+{
+    if (!function_assigned(function)) {
+        return;
+    }
+    if (angle_max <= angle_min) {
+        return;
+    }
+    float v = float(value - angle_min) / float(angle_max - angle_min);
+    for (uint8_t i = 0; i < NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel &ch = channels[i];
+        if (ch.function.get() == function) {
+            uint16_t pwm = ch.servo_min + v * (ch.servo_max - ch.servo_min);
+            ch.set_output_pwm(pwm);
+        }
+    }
+}
+
+/*
+  set the default channel an auxiliary output function should be on
+ */
+bool SRV_Channels::set_aux_channel_default(SRV_Channel::Aux_servo_function_t function, uint8_t channel)
+{
+    if (!initialised) {
+        update_aux_servo_function();
+    }
+    if (function_assigned(function)) {
+        // already assigned
+        return true;
+    }
+    if (channels[channel].function != SRV_Channel::k_none) {
+        if (channels[channel].function == function) {
+            return true;
+        }
+        hal.console->printf("Channel %u already assigned %u\n",
+                            (unsigned)channel,
+                            (unsigned)channels[channel].function);
+        return false;
+    }
+    channels[channel].type_setup = false;
+    channels[channel].function.set(function);
+    channels[channel].aux_servo_function_setup();
+    function_mask.set((uint8_t)function);
+    return true;
+}
+
+// find first channel that a function is assigned to
+bool SRV_Channels::find_channel(SRV_Channel::Aux_servo_function_t function, uint8_t &chan)
+{
+    if (!initialised) {
+        update_aux_servo_function();
+    }
+    if (!function_assigned(function)) {
+        return false;
+    }
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            chan = channels[i].ch_num;
+            return true;
+        }
+    }
+    return false;
+}
+
+/*
+  get a pointer to first auxillary channel for a channel function
+*/
+SRV_Channel *SRV_Channels::get_channel_for(SRV_Channel::Aux_servo_function_t function, int8_t default_chan)
+{
+    uint8_t chan;
+    if (default_chan >= 0) {
+        set_aux_channel_default(function, default_chan);
+    }
+    if (!find_channel(function, chan)) {
+        return nullptr;
+    }
+    return &channels[chan];
+}
+
+void SRV_Channels::set_output_scaled(SRV_Channel::Aux_servo_function_t function, int16_t value)
+{
+    if (function < SRV_Channel::k_nr_aux_servo_functions) {
+        functions[function].output_scaled = value;
+        SRV_Channel::have_pwm_mask &= ~functions[function].channel_mask;
+    }
+}
+
+int16_t SRV_Channels::get_output_scaled(SRV_Channel::Aux_servo_function_t function)
+{
+    if (function < SRV_Channel::k_nr_aux_servo_functions) {
+        return functions[function].output_scaled;
+    }
+    return 0;
+}
+
+
+// set the trim for a function channel to given pwm
+void SRV_Channels::set_trim_to_pwm_for(SRV_Channel::Aux_servo_function_t function, int16_t pwm)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].servo_trim.set(pwm);
+        }
+    }
+}
+
+// set the trim for a function channel to min output
+void SRV_Channels::set_trim_to_min_for(SRV_Channel::Aux_servo_function_t function)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].servo_trim.set(channels[i].get_reversed()?channels[i].servo_max:channels[i].servo_min);
+        }
+    }
+}
+
+/*
+  set the default function for a channel
+*/
+void SRV_Channels::set_default_function(uint8_t chan, SRV_Channel::Aux_servo_function_t function)
+{
+    if (chan < NUM_SERVO_CHANNELS) {
+        channels[chan].function.set_default((uint8_t)function);
+    }
+}
+
+
+void SRV_Channels::set_esc_scaling_for(SRV_Channel::Aux_servo_function_t function)
+{
+    uint8_t chan;
+    if (find_channel(function, chan)) {
+        hal.rcout->set_esc_scaling(channels[chan].get_output_min(), channels[chan].get_output_max());
+    }
+}
+
+/*
+  auto-adjust channel trim from an integrator value. Positive v means
+  adjust trim up. Negative means decrease
+ */
+void SRV_Channels::adjust_trim(SRV_Channel::Aux_servo_function_t function, float v)
+{
+    if (is_zero(v)) {
+        return;
+    }
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel &c = channels[i];
+        if (function != (SRV_Channel::Aux_servo_function_t)(c.function.get())) {
+            continue;
+        }
+        float change = c.reversed?-v:v;
+        uint16_t new_trim = c.servo_trim;
+        float trim_scaled = float(c.servo_trim - c.servo_min) / (c.servo_max - c.servo_min);
+        if (change > 0 && trim_scaled < 0.6f) {
+            new_trim++;
+        } else if (change < 0 && trim_scaled > 0.4f) {
+            new_trim--;
+        } else {
+            return;
+        }
+        c.servo_trim.set(new_trim);
+
+        trimmed_mask |= 1U<<i;
+    }
+}
+
+
+// get pwm output for the first channel of the given function type.
+bool SRV_Channels::get_output_pwm(SRV_Channel::Aux_servo_function_t function, uint16_t &value)
+{
+    uint8_t chan;
+    if (!find_channel(function, chan)) {
+        return false;
+    }
+    channels[chan].calc_pwm(functions[function].output_scaled);
+    value = channels[chan].output_pwm;
+    return true;
+}
+
+// set output pwm to trim for the given function
+void SRV_Channels::set_output_to_trim(SRV_Channel::Aux_servo_function_t function)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].set_output_pwm(channels[i].servo_trim);
+        }
+    }
+}
+
+// set output pwm to for first matching channel
+void SRV_Channels::set_output_pwm_first(SRV_Channel::Aux_servo_function_t function, uint16_t pwm)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].set_output_pwm(pwm);
+            break;
+        }
+    }
+}
+
+/*
+  get the normalised output for a channel function from the pwm value
+  of the first matching channel
+ */
+float SRV_Channels::get_output_norm(SRV_Channel::Aux_servo_function_t function)
+{
+    uint8_t chan;
+    if (!find_channel(function, chan)) {
+        return 0;
+    }
+    channels[chan].calc_pwm(functions[function].output_scaled);
+    return channels[chan].get_output_norm();
+}
+
+/*
+  limit slew rate for an output function to given rate in percent per second
+ */
+void SRV_Channels::limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate)
+{
+    // NOT IMPLEMENTED YET
+}
+
+// call set_angle() on matching channels
+void SRV_Channels::set_angle(SRV_Channel::Aux_servo_function_t function, uint16_t angle)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].set_angle(angle);
+        }
+    }    
+}
+
+// call set_range() on matching channels
+void SRV_Channels::set_range(SRV_Channel::Aux_servo_function_t function, uint16_t range)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        if (channels[i].function == function) {
+            channels[i].set_range(range);
+        }
+    }
+}
+
+// constrain to output min/max for function
+void SRV_Channels::constrain_pwm(SRV_Channel::Aux_servo_function_t function)
+{
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel &ch = channels[i];
+        if (ch.function == function) {
+            ch.output_pwm = constrain_int16(ch.output_pwm, ch.servo_min, ch.servo_max);
+        }
+    }
+}

From 9dc7dbfa1618c8f0f77fbb63a8a6bca6615cd36e Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 3 Jan 2017 20:56:20 +1100
Subject: [PATCH 031/200] AP_AdvancedFailsafe: adapt to new RC_Channel API

---
 libraries/AP_AdvancedFailsafe/AP_AdvancedFailsafe.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_AdvancedFailsafe/AP_AdvancedFailsafe.cpp b/libraries/AP_AdvancedFailsafe/AP_AdvancedFailsafe.cpp
index 88d8ba9..e1b889c 100644
--- a/libraries/AP_AdvancedFailsafe/AP_AdvancedFailsafe.cpp
+++ b/libraries/AP_AdvancedFailsafe/AP_AdvancedFailsafe.cpp
@@ -22,7 +22,7 @@
 #include <AP_HAL/AP_HAL.h>
 #include "AP_AdvancedFailsafe.h"
 #include <RC_Channel/RC_Channel.h>
-#include <RC_Channel/RC_Channel_aux.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include <GCS_MAVLink/GCS.h>
 
 extern const AP_HAL::HAL& hal;

From 117974ef0f6ebb3e164b6972053f08f816776d47 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 3 Jan 2017 20:56:43 +1100
Subject: [PATCH 032/200] HAL_SITL: obey enable mask for output channels

---
 libraries/AP_HAL_SITL/RCOutput.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_HAL_SITL/RCOutput.cpp b/libraries/AP_HAL_SITL/RCOutput.cpp
index 01d8e89..8f1ffad 100644
--- a/libraries/AP_HAL_SITL/RCOutput.cpp
+++ b/libraries/AP_HAL_SITL/RCOutput.cpp
@@ -45,7 +45,7 @@ void RCOutput::disable_ch(uint8_t ch)
 
 void RCOutput::write(uint8_t ch, uint16_t period_us)
 {
-    if (ch < SITL_NUM_CHANNELS) {
+    if (ch < SITL_NUM_CHANNELS && (_enable_mask & (1U<<ch))) {
         if (_corked) {
             _pending[ch] = period_us;
         } else {

From 04ce73d8d7d8c513bc2f560f0a90b5ac76521aaf Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 3 Jan 2017 20:56:49 +1100
Subject: [PATCH 033/200] AP_ICEngine: adapt to new RC_Channel API

---
 libraries/AP_ICEngine/AP_ICEngine.cpp | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/libraries/AP_ICEngine/AP_ICEngine.cpp b/libraries/AP_ICEngine/AP_ICEngine.cpp
index 4c902a8..e592c83 100644
--- a/libraries/AP_ICEngine/AP_ICEngine.cpp
+++ b/libraries/AP_ICEngine/AP_ICEngine.cpp
@@ -14,7 +14,7 @@
  */
 
 
-#include <RC_Channel/RC_Channel_aux.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include <GCS_MAVLink/GCS.h>
 #include "AP_ICEngine.h"
 
@@ -214,20 +214,20 @@ void AP_ICEngine::update(void)
     /* now set output channels */
     switch (state) {
     case ICE_OFF:
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_ignition, pwm_ignition_off);
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_starter,  pwm_starter_off);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_ignition, pwm_ignition_off);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_starter,  pwm_starter_off);
         starter_start_time_ms = 0;
         break;
 
     case ICE_START_HEIGHT_DELAY:
     case ICE_START_DELAY:
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_ignition, pwm_ignition_on);
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_starter,  pwm_starter_off);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_ignition, pwm_ignition_on);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_starter,  pwm_starter_off);
         break;
         
     case ICE_STARTING:
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_ignition, pwm_ignition_on);
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_starter,  pwm_starter_on);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_ignition, pwm_ignition_on);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_starter,  pwm_starter_on);
         if (starter_start_time_ms == 0) {
             starter_start_time_ms = now;
         }
@@ -235,8 +235,8 @@ void AP_ICEngine::update(void)
         break;
 
     case ICE_RUNNING:
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_ignition, pwm_ignition_on);
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_starter,  pwm_starter_off);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_ignition, pwm_ignition_on);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_starter,  pwm_starter_off);
         starter_start_time_ms = 0;
         break;
     }

From 638f1364bea68e83f9edbacf0de7fe81497d11c8 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 3 Jan 2017 20:56:57 +1100
Subject: [PATCH 034/200] AP_Motors: adapt to new RC_Channel API

---
 libraries/AP_Motors/AP_MotorsCoax.cpp              | 36 ++++++++-----------
 libraries/AP_Motors/AP_MotorsCoax.h                | 15 ++++----
 libraries/AP_Motors/AP_MotorsHeli.cpp              | 13 ++++---
 libraries/AP_Motors/AP_MotorsHeli.h                |  7 ++--
 libraries/AP_Motors/AP_MotorsHeli_RSC.cpp          |  4 +--
 libraries/AP_Motors/AP_MotorsHeli_RSC.h            |  7 ++--
 libraries/AP_Motors/AP_MotorsHeli_Single.cpp       | 39 ++++++++++----------
 libraries/AP_Motors/AP_MotorsHeli_Single.h         | 24 ++++++-------
 libraries/AP_Motors/AP_MotorsSingle.cpp            | 41 ++++++++++------------
 libraries/AP_Motors/AP_MotorsSingle.h              | 14 ++++----
 libraries/AP_Motors/AP_Motors_Class.cpp            | 29 +++++++--------
 libraries/AP_Motors/AP_Motors_Class.h              |  6 ++--
 .../examples/AP_Motors_test/AP_Motors_test.cpp     |  2 +-
 13 files changed, 112 insertions(+), 125 deletions(-)

diff --git a/libraries/AP_Motors/AP_MotorsCoax.cpp b/libraries/AP_Motors/AP_MotorsCoax.cpp
index ca32591..e2c0971 100644
--- a/libraries/AP_Motors/AP_MotorsCoax.cpp
+++ b/libraries/AP_Motors/AP_MotorsCoax.cpp
@@ -22,6 +22,7 @@
 #include <AP_HAL/AP_HAL.h>
 #include <AP_Math/AP_Math.h>
 #include "AP_MotorsCoax.h"
+#include <GCS_MAVLink/GCS.h>
 
 extern const AP_HAL::HAL& hal;
 
@@ -44,19 +45,6 @@ const AP_Param::GroupInfo AP_MotorsCoax::var_info[] = {
     // @Units: Hz
     AP_GROUPINFO("SV_SPEED", 43, AP_MotorsCoax, _servo_speed, AP_MOTORS_SINGLE_SPEED_DIGITAL_SERVOS),
 
-    // @Group: SV1_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_servo1, "SV1_", 44, AP_MotorsCoax, RC_Channel),
-    // @Group: SV2_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_servo2, "SV2_", 45, AP_MotorsCoax, RC_Channel),
-    // @Group: SV3_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_servo3, "SV3_", 46, AP_MotorsCoax, RC_Channel),
-    // @Group: SV4_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_servo4, "SV4_", 47, AP_MotorsCoax, RC_Channel),
-
     AP_GROUPEND
 };
 // init
@@ -65,19 +53,25 @@ void AP_MotorsCoax::init(motor_frame_class frame_class, motor_frame_type frame_t
     // set update rate for the 3 motors (but not the servo on channel 7)
     set_update_rate(_speed_hz);
 
+    _servo1 = SRV_Channels::get_channel_for(SRV_Channel::k_motor1, CH_1);
+    _servo2 = SRV_Channels::get_channel_for(SRV_Channel::k_motor2, CH_2);
+    _servo3 = SRV_Channels::get_channel_for(SRV_Channel::k_motor3, CH_3);
+    _servo4 = SRV_Channels::get_channel_for(SRV_Channel::k_motor4, CH_4);
+    if (!_servo1 || !_servo2 || !_servo3 || !_servo4) {
+        GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_ERROR, "MotorsCoax: unable to setup output channels");
+        // don't set initialised_ok
+        return;
+    }
+    
     // set the motor_enabled flag so that the main ESC can be calibrated like other frame types
     motor_enabled[AP_MOTORS_MOT_5] = true;
     motor_enabled[AP_MOTORS_MOT_6] = true;
 
     // we set four servos to angle
-    _servo1.set_type(RC_CHANNEL_TYPE_ANGLE);
-    _servo2.set_type(RC_CHANNEL_TYPE_ANGLE);
-    _servo3.set_type(RC_CHANNEL_TYPE_ANGLE);
-    _servo4.set_type(RC_CHANNEL_TYPE_ANGLE);
-    _servo1.set_angle(AP_MOTORS_COAX_SERVO_INPUT_RANGE);
-    _servo2.set_angle(AP_MOTORS_COAX_SERVO_INPUT_RANGE);
-    _servo3.set_angle(AP_MOTORS_COAX_SERVO_INPUT_RANGE);
-    _servo4.set_angle(AP_MOTORS_COAX_SERVO_INPUT_RANGE);
+    _servo1->set_angle(AP_MOTORS_COAX_SERVO_INPUT_RANGE);
+    _servo2->set_angle(AP_MOTORS_COAX_SERVO_INPUT_RANGE);
+    _servo3->set_angle(AP_MOTORS_COAX_SERVO_INPUT_RANGE);
+    _servo4->set_angle(AP_MOTORS_COAX_SERVO_INPUT_RANGE);
 
     // record successful initialisation if what we setup was the desired frame_class
     _flags.initialised_ok = (frame_class == MOTOR_FRAME_COAX);
diff --git a/libraries/AP_Motors/AP_MotorsCoax.h b/libraries/AP_Motors/AP_MotorsCoax.h
index d3f9302..92a9de8 100644
--- a/libraries/AP_Motors/AP_MotorsCoax.h
+++ b/libraries/AP_Motors/AP_MotorsCoax.h
@@ -4,7 +4,7 @@
 
 #include <AP_Common/AP_Common.h>
 #include <AP_Math/AP_Math.h>        // ArduPilot Mega Vector/Matrix math Library
-#include <RC_Channel/RC_Channel.h>     // RC Channel Library
+#include <SRV_Channel/SRV_Channel.h>
 #include "AP_MotorsMulticopter.h"
 
 // feedback direction
@@ -24,8 +24,7 @@ class AP_MotorsCoax : public AP_MotorsMulticopter {
 
     /// Constructor
     AP_MotorsCoax(uint16_t loop_rate, uint16_t speed_hz = AP_MOTORS_SPEED_DEFAULT) :
-        AP_MotorsMulticopter(loop_rate, speed_hz),
-        _servo1(CH_NONE), _servo2(CH_NONE), _servo3(CH_NONE), _servo4(CH_NONE)
+        AP_MotorsMulticopter(loop_rate, speed_hz)
     {
         AP_Param::setup_object_defaults(this, var_info);
     };
@@ -64,13 +63,11 @@ class AP_MotorsCoax : public AP_MotorsMulticopter {
     // servo speed
     AP_Int16            _servo_speed;
 
-    // Allow the use of a 4 servo output to make it easy to test coax and single using same airframe
-    RC_Channel          _servo1;
-    RC_Channel          _servo2;
-    RC_Channel          _servo3;
-    RC_Channel          _servo4;
-
     float               _actuator_out[NUM_ACTUATORS]; // combined roll, pitch, yaw and throttle outputs to motors in 0~1 range
     float               _thrust_yt_ccw;
     float               _thrust_yt_cw;
+    SRV_Channel         *_servo1;
+    SRV_Channel         *_servo2;
+    SRV_Channel         *_servo3;
+    SRV_Channel         *_servo4;
 };
diff --git a/libraries/AP_Motors/AP_MotorsHeli.cpp b/libraries/AP_Motors/AP_MotorsHeli.cpp
index d2d23a4..1e77358 100644
--- a/libraries/AP_Motors/AP_MotorsHeli.cpp
+++ b/libraries/AP_Motors/AP_MotorsHeli.cpp
@@ -194,7 +194,10 @@ void AP_MotorsHeli::init(motor_frame_class frame_class, motor_frame_type frame_t
     _throttle_radio_passthrough = 0.5f;
 
     // initialise Servo/PWM ranges and endpoints
-    init_outputs();
+    if (!init_outputs()) {
+        // don't set initialised_ok
+        return;
+    }
 
     // calculate all scalars
     calculate_scalars();
@@ -367,13 +370,13 @@ bool AP_MotorsHeli::parameter_check(bool display_msg) const
 }
 
 // reset_swash_servo
-void AP_MotorsHeli::reset_swash_servo(RC_Channel& servo)
+void AP_MotorsHeli::reset_swash_servo(SRV_Channel *servo)
 {
-    servo.set_range_out(0, 1000);
+    servo->set_range(1000);
 
     // swash servos always use full endpoints as restricting them would lead to scaling errors
-    servo.set_radio_min(1000);
-    servo.set_radio_max(2000);
+    servo->set_output_min(1000);
+    servo->set_output_max(2000);
 }
 
 // update the throttle input filter
diff --git a/libraries/AP_Motors/AP_MotorsHeli.h b/libraries/AP_Motors/AP_MotorsHeli.h
index 13d380e..f4b381f 100644
--- a/libraries/AP_Motors/AP_MotorsHeli.h
+++ b/libraries/AP_Motors/AP_MotorsHeli.h
@@ -6,7 +6,8 @@
 
 #include <AP_Common/AP_Common.h>
 #include <AP_Math/AP_Math.h>            // ArduPilot Mega Vector/Matrix math Library
-#include <RC_Channel/RC_Channel.h>      // RC Channel Library
+#include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include "AP_Motors_Class.h"
 #include "AP_MotorsHeli_RSC.h"
 
@@ -160,10 +161,10 @@ class AP_MotorsHeli : public AP_Motors {
     virtual void move_actuators(float roll_out, float pitch_out, float coll_in, float yaw_out) = 0;
 
     // reset_swash_servo - free up swash servo for maximum movement
-    void reset_swash_servo(RC_Channel& servo);
+    void reset_swash_servo(SRV_Channel *servo);
 
     // init_outputs - initialise Servo/PWM ranges and endpoints
-    virtual void init_outputs() = 0;
+    virtual bool init_outputs() = 0;
 
     // calculate_armed_scalars - must be implemented by child classes
     virtual void calculate_armed_scalars() = 0;
diff --git a/libraries/AP_Motors/AP_MotorsHeli_RSC.cpp b/libraries/AP_Motors/AP_MotorsHeli_RSC.cpp
index 3f9a054..20728bf 100644
--- a/libraries/AP_Motors/AP_MotorsHeli_RSC.cpp
+++ b/libraries/AP_Motors/AP_MotorsHeli_RSC.cpp
@@ -24,7 +24,7 @@ extern const AP_HAL::HAL& hal;
 void AP_MotorsHeli_RSC::init_servo()
 {
     // setup RSC on specified channel by default
-    RC_Channel_aux::set_aux_channel_default(_aux_fn, _default_channel);
+    SRV_Channels::set_aux_channel_default(_aux_fn, _default_channel);
 }
 
 // set_power_output_range
@@ -194,6 +194,6 @@ void AP_MotorsHeli_RSC::write_rsc(float servo_out)
         } else {
             pwm = _pwm_max - pwm;
         }
-        RC_Channel_aux::set_radio(_aux_fn, pwm);
+        SRV_Channels::set_output_pwm(_aux_fn, pwm);
     }
 }
diff --git a/libraries/AP_Motors/AP_MotorsHeli_RSC.h b/libraries/AP_Motors/AP_MotorsHeli_RSC.h
index 5b0d02b..938445e 100644
--- a/libraries/AP_Motors/AP_MotorsHeli_RSC.h
+++ b/libraries/AP_Motors/AP_MotorsHeli_RSC.h
@@ -2,7 +2,8 @@
 
 #include <AP_Common/AP_Common.h>
 #include <AP_Math/AP_Math.h>            // ArduPilot Mega Vector/Matrix math Library
-#include <RC_Channel/RC_Channel.h>      // RC Channel Library
+#include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 
 // rotor controller states
 enum RotorControlState {
@@ -24,7 +25,7 @@ class AP_MotorsHeli_RSC {
 public:
     friend class AP_MotorsHeli_Single;
     
-    AP_MotorsHeli_RSC(RC_Channel_aux::Aux_servo_function_t aux_fn,
+    AP_MotorsHeli_RSC(SRV_Channel::Aux_servo_function_t aux_fn,
                       uint8_t default_channel) :
         _aux_fn(aux_fn),
         _default_channel(default_channel)
@@ -80,7 +81,7 @@ class AP_MotorsHeli_RSC {
     uint64_t        _last_update_us;
     
     // channel setup for aux function
-    RC_Channel_aux::Aux_servo_function_t _aux_fn;
+    SRV_Channel::Aux_servo_function_t _aux_fn;
     uint8_t         _default_channel;
     
     // internal variables
diff --git a/libraries/AP_Motors/AP_MotorsHeli_Single.cpp b/libraries/AP_Motors/AP_MotorsHeli_Single.cpp
index d79246d..1bbefb6 100644
--- a/libraries/AP_Motors/AP_MotorsHeli_Single.cpp
+++ b/libraries/AP_Motors/AP_MotorsHeli_Single.cpp
@@ -15,7 +15,7 @@
 
 #include <stdlib.h>
 #include <AP_HAL/AP_HAL.h>
-#include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include "AP_MotorsHeli_Single.h"
 #include <GCS_MAVLink/GCS.h>
 
@@ -116,22 +116,6 @@ const AP_Param::GroupInfo AP_MotorsHeli_Single::var_info[] = {
     // @User: Standard
     AP_GROUPINFO("GYR_GAIN_ACRO", 11, AP_MotorsHeli_Single,  _ext_gyro_gain_acro, 0),
 
-    // @Group: SV1_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_swash_servo_1, "SV1_", 12, AP_MotorsHeli_Single, RC_Channel),
-
-    // @Group: SV2_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_swash_servo_2, "SV2_", 13, AP_MotorsHeli_Single, RC_Channel),
-
-    // @Group: SV3_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_swash_servo_3, "SV3_", 14, AP_MotorsHeli_Single, RC_Channel),
-
-    // @Group: SV4_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_yaw_servo, "SV4_", 15, AP_MotorsHeli_Single, RC_Channel),
-
     // @Param: RSC_PWM_MIN
     // @DisplayName: RSC PWM output miniumum
     // @Description: This sets the PWM output on RSC channel for maximum rotor speed
@@ -186,18 +170,31 @@ void AP_MotorsHeli_Single::enable()
 }
 
 // init_outputs - initialise Servo/PWM ranges and endpoints
-void AP_MotorsHeli_Single::init_outputs()
+bool AP_MotorsHeli_Single::init_outputs()
 {
+    if (!_flags.initialised_ok) {
+        _swash_servo_1 = SRV_Channels::get_channel_for(SRV_Channel::k_motor1, CH_1);
+        _swash_servo_2 = SRV_Channels::get_channel_for(SRV_Channel::k_motor2, CH_2);
+        _swash_servo_3 = SRV_Channels::get_channel_for(SRV_Channel::k_motor3, CH_3);
+        _yaw_servo = SRV_Channels::get_channel_for(SRV_Channel::k_motor4, CH_4);
+        _servo_aux = SRV_Channels::get_channel_for(SRV_Channel::k_motor7, CH_7);
+        if (!_swash_servo_1 || !_swash_servo_2 || !_swash_servo_3 || !_yaw_servo || !_servo_aux) {
+            return false;
+        }
+    }
+
     // reset swash servo range and endpoints
     reset_swash_servo (_swash_servo_1);
     reset_swash_servo (_swash_servo_2);
     reset_swash_servo (_swash_servo_3);
 
-    _yaw_servo.set_angle(4500);
+    _yaw_servo->set_angle(4500);
 
     // set main rotor servo range
     // tail rotor servo use range as set in vehicle code for rc7
     _main_rotor.init_servo();
+
+    return true;
 }
 
 // output_test - spin a motor at the pwm value specified
@@ -357,10 +354,10 @@ void AP_MotorsHeli_Single::update_motor_control(RotorControlState state)
 
     if (state == ROTOR_CONTROL_STOP){
         // set engine run enable aux output to not run position to kill engine when disarmed
-        RC_Channel_aux::set_radio_to_min(RC_Channel_aux::k_engine_run_enable);
+        SRV_Channels::set_output_limit(SRV_Channel::k_engine_run_enable, SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
     } else {
         // else if armed, set engine run enable output to run position
-        RC_Channel_aux::set_radio_to_max(RC_Channel_aux::k_engine_run_enable);
+        SRV_Channels::set_output_limit(SRV_Channel::k_engine_run_enable, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
     }
 
     // Check if both rotors are run-up, tail rotor controller always returns true if not enabled
diff --git a/libraries/AP_Motors/AP_MotorsHeli_Single.h b/libraries/AP_Motors/AP_MotorsHeli_Single.h
index 49c0543..f51b0a2 100644
--- a/libraries/AP_Motors/AP_MotorsHeli_Single.h
+++ b/libraries/AP_Motors/AP_MotorsHeli_Single.h
@@ -4,7 +4,7 @@
 
 #include <AP_Common/AP_Common.h>
 #include <AP_Math/AP_Math.h>            // ArduPilot Mega Vector/Matrix math Library
-#include <RC_Channel/RC_Channel.h>      // RC Channel Library
+#include <SRV_Channel/SRV_Channel.h>
 #include "AP_MotorsHeli.h"
 #include "AP_MotorsHeli_RSC.h"
 
@@ -42,14 +42,11 @@
 class AP_MotorsHeli_Single : public AP_MotorsHeli {
 public:
     // constructor
-    AP_MotorsHeli_Single(RC_Channel&    servo_aux,
-                         uint16_t       loop_rate,
+    AP_MotorsHeli_Single(uint16_t       loop_rate,
                          uint16_t       speed_hz = AP_MOTORS_HELI_SPEED_DEFAULT) :
         AP_MotorsHeli(loop_rate, speed_hz),
-        _servo_aux(servo_aux),
-        _main_rotor(RC_Channel_aux::k_heli_rsc, AP_MOTORS_HELI_SINGLE_RSC),
-        _tail_rotor(RC_Channel_aux::k_heli_tail_rsc, AP_MOTORS_HELI_SINGLE_AUX),
-        _swash_servo_1(CH_NONE), _swash_servo_2(CH_NONE), _swash_servo_3(CH_NONE), _yaw_servo(CH_NONE)
+        _main_rotor(SRV_Channel::k_heli_rsc, AP_MOTORS_HELI_SINGLE_RSC),
+        _tail_rotor(SRV_Channel::k_heli_tail_rsc, AP_MOTORS_HELI_SINGLE_AUX)
     {
         AP_Param::setup_object_defaults(this, var_info);
     };
@@ -107,7 +104,7 @@ class AP_MotorsHeli_Single : public AP_MotorsHeli {
 protected:
 
     // init_outputs - initialise Servo/PWM ranges and endpoints
-    void init_outputs();
+    bool init_outputs() override;
 
     // update_motor_controls - sends commands to motor controllers
     void update_motor_control(RotorControlState state);
@@ -128,7 +125,6 @@ class AP_MotorsHeli_Single : public AP_MotorsHeli {
     void servo_test();
 
     // external objects we depend upon
-    RC_Channel&     _servo_aux;                 // output to ext gyro gain and tail direct drive esc (ch7)
     AP_MotorsHeli_RSC   _main_rotor;            // main rotor
     AP_MotorsHeli_RSC   _tail_rotor;            // tail rotor
 
@@ -152,10 +148,12 @@ class AP_MotorsHeli_Single : public AP_MotorsHeli {
     AP_Float        _collective_yaw_effect;     // Feed-forward compensation to automatically add rudder input when collective pitch is increased. Can be positive or negative depending on mechanics.
     AP_Int8         _flybar_mode;               // Flybar present or not.  Affects attitude controller used during ACRO flight mode
     AP_Int16        _direct_drive_tailspeed;    // Direct Drive VarPitch Tail ESC speed (0 ~ 1000)
-    RC_Channel      _swash_servo_1;             // swash plate servo #1
-    RC_Channel      _swash_servo_2;             // swash plate servo #2
-    RC_Channel      _swash_servo_3;             // swash plate servo #3
-    RC_Channel      _yaw_servo;                 // tail servo
 
+    SRV_Channel    *_swash_servo_1;
+    SRV_Channel    *_swash_servo_2;
+    SRV_Channel    *_swash_servo_3;
+    SRV_Channel    *_yaw_servo;
+    SRV_Channel    *_servo_aux;
+    
     bool            _acro_tail = false;
 };
diff --git a/libraries/AP_Motors/AP_MotorsSingle.cpp b/libraries/AP_Motors/AP_MotorsSingle.cpp
index da77d03..dd4c57c 100644
--- a/libraries/AP_Motors/AP_MotorsSingle.cpp
+++ b/libraries/AP_Motors/AP_MotorsSingle.cpp
@@ -22,6 +22,7 @@
 #include <AP_HAL/AP_HAL.h>
 #include <AP_Math/AP_Math.h>
 #include "AP_MotorsSingle.h"
+#include <GCS_MAVLink/GCS.h>
 
 extern const AP_HAL::HAL& hal;
 
@@ -44,19 +45,6 @@ const AP_Param::GroupInfo AP_MotorsSingle::var_info[] = {
     // @Values: 50, 125, 250
     AP_GROUPINFO("SV_SPEED", 43, AP_MotorsSingle, _servo_speed, AP_MOTORS_SINGLE_SPEED_DIGITAL_SERVOS),
 
-    // @Group: SV1_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_servo1, "SV1_", 44, AP_MotorsSingle, RC_Channel),
-    // @Group: SV2_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_servo2, "SV2_", 45, AP_MotorsSingle, RC_Channel),
-    // @Group: SV3_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_servo3, "SV3_", 46, AP_MotorsSingle, RC_Channel),
-    // @Group: SV4_
-    // @Path: ../RC_Channel/RC_Channel.cpp
-    AP_SUBGROUPINFO(_servo4, "SV4_", 47, AP_MotorsSingle, RC_Channel),
-
     AP_GROUPEND
 };
 // init
@@ -69,15 +57,21 @@ void AP_MotorsSingle::init(motor_frame_class frame_class, motor_frame_type frame
     motor_enabled[AP_MOTORS_MOT_5] = true;
     motor_enabled[AP_MOTORS_MOT_6] = true;
 
+    _servo1 = SRV_Channels::get_channel_for(SRV_Channel::k_motor1, CH_1);
+    _servo2 = SRV_Channels::get_channel_for(SRV_Channel::k_motor2, CH_2);
+    _servo3 = SRV_Channels::get_channel_for(SRV_Channel::k_motor3, CH_3);
+    _servo4 = SRV_Channels::get_channel_for(SRV_Channel::k_motor4, CH_4);
+    if (!_servo1 || !_servo2 || !_servo3 || !_servo4) {
+        GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_ERROR, "MotorsSingle: unable to setup output channels");
+        // don't set initialised_ok
+        return;
+    }
+    
     // we set four servos to angle
-    _servo1.set_type(RC_CHANNEL_TYPE_ANGLE);
-    _servo2.set_type(RC_CHANNEL_TYPE_ANGLE);
-    _servo3.set_type(RC_CHANNEL_TYPE_ANGLE);
-    _servo4.set_type(RC_CHANNEL_TYPE_ANGLE);
-    _servo1.set_angle(AP_MOTORS_SINGLE_SERVO_INPUT_RANGE);
-    _servo2.set_angle(AP_MOTORS_SINGLE_SERVO_INPUT_RANGE);
-    _servo3.set_angle(AP_MOTORS_SINGLE_SERVO_INPUT_RANGE);
-    _servo4.set_angle(AP_MOTORS_SINGLE_SERVO_INPUT_RANGE);
+    _servo1->set_angle(AP_MOTORS_SINGLE_SERVO_INPUT_RANGE);
+    _servo2->set_angle(AP_MOTORS_SINGLE_SERVO_INPUT_RANGE);
+    _servo3->set_angle(AP_MOTORS_SINGLE_SERVO_INPUT_RANGE);
+    _servo4->set_angle(AP_MOTORS_SINGLE_SERVO_INPUT_RANGE);
 
     // allow mapping of motor7
     add_motor_num(CH_7);
@@ -89,7 +83,7 @@ void AP_MotorsSingle::init(motor_frame_class frame_class, motor_frame_type frame
 // set frame class (i.e. quad, hexa, heli) and type (i.e. x, plus)
 void AP_MotorsSingle::set_frame_class_and_type(motor_frame_class frame_class, motor_frame_type frame_type)
 {
-    _flags.initialised_ok = (frame_class == MOTOR_FRAME_SINGLE);
+    // nothing to do
 }
 
 // set update rate to motors - a value in hertz
@@ -125,6 +119,9 @@ void AP_MotorsSingle::enable()
 
 void AP_MotorsSingle::output_to_motors()
 {
+    if (!_flags.initialised_ok) {
+        return;
+    }
     switch (_spool_mode) {
         case SHUT_DOWN:
             // sends minimum values out to the motors
diff --git a/libraries/AP_Motors/AP_MotorsSingle.h b/libraries/AP_Motors/AP_MotorsSingle.h
index 4350baf..8aa059e 100644
--- a/libraries/AP_Motors/AP_MotorsSingle.h
+++ b/libraries/AP_Motors/AP_MotorsSingle.h
@@ -4,7 +4,7 @@
 
 #include <AP_Common/AP_Common.h>
 #include <AP_Math/AP_Math.h>        // ArduPilot Mega Vector/Matrix math Library
-#include <RC_Channel/RC_Channel.h>     // RC Channel Library
+#include <SRV_Channel/SRV_Channel.h>
 #include "AP_MotorsMulticopter.h"
 
 // feedback direction
@@ -24,8 +24,7 @@ class AP_MotorsSingle : public AP_MotorsMulticopter {
 
     /// Constructor
     AP_MotorsSingle(uint16_t loop_rate, uint16_t speed_hz = AP_MOTORS_SPEED_DEFAULT) :
-        AP_MotorsMulticopter(loop_rate, speed_hz),
-        _servo1(CH_NONE), _servo2(CH_NONE), _servo3(CH_NONE), _servo4(CH_NONE)
+        AP_MotorsMulticopter(loop_rate, speed_hz)
     {
         AP_Param::setup_object_defaults(this, var_info);
     };
@@ -64,12 +63,11 @@ class AP_MotorsSingle : public AP_MotorsMulticopter {
     // servo speed
     AP_Int16            _servo_speed;
 
-    RC_Channel          _servo1;
-    RC_Channel          _servo2;
-    RC_Channel          _servo3;
-    RC_Channel          _servo4;
-
     int16_t             _throttle_radio_output;   // total throttle pwm value, summed onto throttle channel minimum, typically ~1100-1900
     float               _actuator_out[NUM_ACTUATORS]; // combined roll, pitch, yaw and throttle outputs to motors in 0~1 range
     float               _thrust_out;
+    SRV_Channel         *_servo1;
+    SRV_Channel         *_servo2;
+    SRV_Channel         *_servo3;
+    SRV_Channel         *_servo4;
 };
diff --git a/libraries/AP_Motors/AP_Motors_Class.cpp b/libraries/AP_Motors/AP_Motors_Class.cpp
index 9bd1d84..b4c8785 100644
--- a/libraries/AP_Motors/AP_Motors_Class.cpp
+++ b/libraries/AP_Motors/AP_Motors_Class.cpp
@@ -21,6 +21,8 @@
 
 #include "AP_Motors_Class.h"
 #include <AP_HAL/AP_HAL.h>
+#include <SRV_Channel/SRV_Channel.h>
+
 extern const AP_HAL::HAL& hal;
 
 // Constructor
@@ -153,39 +155,39 @@ uint32_t AP_Motors::rc_map_mask(uint32_t mask) const
 }
 
 // convert input in -1 to +1 range to pwm output
-int16_t AP_Motors::calc_pwm_output_1to1(float input, const RC_Channel& servo)
+int16_t AP_Motors::calc_pwm_output_1to1(float input, const SRV_Channel *servo)
 {
     int16_t ret;
 
     input = constrain_float(input, -1.0f, 1.0f);
 
-    if (servo.get_reverse()) {
+    if (servo->get_reversed()) {
         input = -input;
     }
 
     if (input >= 0.0f) {
-        ret = ((input * (servo.get_radio_max() - servo.get_radio_trim())) + servo.get_radio_trim());
+        ret = ((input * (servo->get_output_max() - servo->get_trim())) + servo->get_trim());
     } else {
-        ret = ((input * (servo.get_radio_trim() - servo.get_radio_min())) + servo.get_radio_trim());
+        ret = ((input * (servo->get_trim() - servo->get_output_min())) + servo->get_trim());
     }
 
-    return constrain_int16(ret, servo.get_radio_min(), servo.get_radio_max());
+    return constrain_int16(ret, servo->get_output_min(), servo->get_output_max());
 }
 
 // convert input in 0 to +1 range to pwm output
-int16_t AP_Motors::calc_pwm_output_0to1(float input, const RC_Channel& servo)
+int16_t AP_Motors::calc_pwm_output_0to1(float input, const SRV_Channel *servo)
 {
     int16_t ret;
 
     input = constrain_float(input, 0.0f, 1.0f);
 
-    if (servo.get_reverse()) {
+    if (servo->get_reversed()) {
         input = 1.0f-input;
     }
 
-    ret = input * (servo.get_radio_max() - servo.get_radio_min()) + servo.get_radio_min();
+    ret = input * (servo->get_output_max() - servo->get_output_min()) + servo->get_output_min();
 
-    return constrain_int16(ret, servo.get_radio_min(), servo.get_radio_max());
+    return constrain_int16(ret, servo->get_output_min(), servo->get_output_max());
 }
 
 /*
@@ -196,13 +198,12 @@ void AP_Motors::add_motor_num(int8_t motor_num)
     // ensure valid motor number is provided
     if( motor_num >= 0 && motor_num < AP_MOTORS_MAX_NUM_MOTORS ) {
         uint8_t chan;
-        if (RC_Channel_aux::find_channel((RC_Channel_aux::Aux_servo_function_t)(RC_Channel_aux::k_motor1+motor_num),
-                                         chan)) {
+        SRV_Channel::Aux_servo_function_t function = (SRV_Channel::Aux_servo_function_t)(SRV_Channel::k_motor1+motor_num);
+        SRV_Channels::set_aux_channel_default(function, motor_num);
+        if (SRV_Channels::find_channel((SRV_Channel::Aux_servo_function_t)(SRV_Channel::k_motor1+motor_num),
+                                       chan) && chan != motor_num) {
             _motor_map[motor_num] = chan;
             _motor_map_mask |= 1U<<motor_num;
-        } else {
-            // disable this channel from being used by RC_Channel_aux
-            RC_Channel_aux::disable_aux_channel(motor_num);
         }
     }
 }
diff --git a/libraries/AP_Motors/AP_Motors_Class.h b/libraries/AP_Motors/AP_Motors_Class.h
index f9b1034..8f490ac 100644
--- a/libraries/AP_Motors/AP_Motors_Class.h
+++ b/libraries/AP_Motors/AP_Motors_Class.h
@@ -3,7 +3,7 @@
 #include <AP_Common/AP_Common.h>
 #include <AP_Math/AP_Math.h>        // ArduPilot Mega Vector/Matrix math Library
 #include <AP_Notify/AP_Notify.h>      // Notify library
-#include <RC_Channel/RC_Channel.h>     // RC Channel Library
+#include <SRV_Channel/SRV_Channel.h>
 #include <Filter/Filter.h>         // filter library
 
 // offsets for motors in motor_out and _motor_filtered arrays
@@ -167,10 +167,10 @@ class AP_Motors {
     virtual void save_params_on_disarm() {}
 
     // convert input in -1 to +1 range to pwm output
-    int16_t calc_pwm_output_1to1(float input, const RC_Channel& servo);
+    int16_t calc_pwm_output_1to1(float input, const SRV_Channel *servo);
 
     // convert input in 0 to +1 range to pwm output
-    int16_t calc_pwm_output_0to1(float input, const RC_Channel& servo);
+    int16_t calc_pwm_output_0to1(float input, const SRV_Channel *servo);
 
     // flag bitmask
     struct AP_Motors_flags {
diff --git a/libraries/AP_Motors/examples/AP_Motors_test/AP_Motors_test.cpp b/libraries/AP_Motors/examples/AP_Motors_test/AP_Motors_test.cpp
index 780c047..cd5fd29 100644
--- a/libraries/AP_Motors/examples/AP_Motors_test/AP_Motors_test.cpp
+++ b/libraries/AP_Motors/examples/AP_Motors_test/AP_Motors_test.cpp
@@ -74,7 +74,7 @@ void setup()
     // set rc channel ranges
     rc1.set_angle(4500);
     rc2.set_angle(4500);
-    rc3.set_range(130, 1000);
+    rc3.set_range(1000);
     rc4.set_angle(4500);
 
     hal.scheduler->delay(1000);

From ee7b9a3f8e03b961d7c724672ab6f6bc9d8cad6b Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 5 Jan 2017 16:12:36 +1100
Subject: [PATCH 035/200] AP_Camera: adapt to new RC_Channel API

---
 libraries/AP_Camera/AP_Camera.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_Camera/AP_Camera.cpp b/libraries/AP_Camera/AP_Camera.cpp
index 58575f9..30b7226 100644
--- a/libraries/AP_Camera/AP_Camera.cpp
+++ b/libraries/AP_Camera/AP_Camera.cpp
@@ -106,7 +106,7 @@ volatile bool   AP_Camera::_camera_triggered;
 void
 AP_Camera::servo_pic()
 {
-	RC_Channel_aux::set_radio(RC_Channel_aux::k_cam_trigger, _servo_on_pwm);
+	SRV_Channels::set_output_pwm(SRV_Channel::k_cam_trigger, _servo_on_pwm);
 
 	// leave a message that it should be active for this many loops (assumes 50hz loops)
 	_trigger_counter = constrain_int16(_trigger_duration*5,0,255);
@@ -169,7 +169,7 @@ AP_Camera::trigger_pic_cleanup()
     } else {
         switch (_trigger_type) {
             case AP_CAMERA_TRIGGER_TYPE_SERVO:
-                RC_Channel_aux::set_radio(RC_Channel_aux::k_cam_trigger, _servo_off_pwm);
+                SRV_Channels::set_output_pwm(SRV_Channel::k_cam_trigger, _servo_off_pwm);
                 break;
             case AP_CAMERA_TRIGGER_TYPE_RELAY:
                 if (_relay_on) {

From 4173432542f1173256d8da9a6bc3d49e0f0a2ddf Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 5 Jan 2017 16:13:02 +1100
Subject: [PATCH 036/200] AP_Mount: adapt to new RC_Channel API

---
 libraries/AP_Mount/AP_Mount.cpp         |  6 +++---
 libraries/AP_Mount/AP_Mount_Backend.cpp |  2 +-
 libraries/AP_Mount/AP_Mount_Servo.cpp   | 24 ++++++++++++------------
 libraries/AP_Mount/AP_Mount_Servo.h     | 22 +++++++++++-----------
 4 files changed, 27 insertions(+), 27 deletions(-)

diff --git a/libraries/AP_Mount/AP_Mount.cpp b/libraries/AP_Mount/AP_Mount.cpp
index 6d37ade..3d429e0 100644
--- a/libraries/AP_Mount/AP_Mount.cpp
+++ b/libraries/AP_Mount/AP_Mount.cpp
@@ -419,9 +419,9 @@ void AP_Mount::init(DataFlash_Class *dataflash, const AP_SerialManager& serial_m
 
     // default mount to servo mount if rc output channels to control roll, tilt or pan have been defined
     if (!state[0]._type.configured()) {
-        if (RC_Channel_aux::function_assigned(RC_Channel_aux::Aux_servo_function_t::k_mount_pan) ||
-            RC_Channel_aux::function_assigned(RC_Channel_aux::Aux_servo_function_t::k_mount_tilt) ||
-            RC_Channel_aux::function_assigned(RC_Channel_aux::Aux_servo_function_t::k_mount_roll)) {
+        if (SRV_Channels::function_assigned(SRV_Channel::Aux_servo_function_t::k_mount_pan) ||
+            SRV_Channels::function_assigned(SRV_Channel::Aux_servo_function_t::k_mount_tilt) ||
+            SRV_Channels::function_assigned(SRV_Channel::Aux_servo_function_t::k_mount_roll)) {
                 state[0]._type.set_and_save(Mount_Type_Servo);
         }
     }
diff --git a/libraries/AP_Mount/AP_Mount_Backend.cpp b/libraries/AP_Mount/AP_Mount_Backend.cpp
index 1394cc0..81a1b22 100644
--- a/libraries/AP_Mount/AP_Mount_Backend.cpp
+++ b/libraries/AP_Mount/AP_Mount_Backend.cpp
@@ -83,7 +83,7 @@ void AP_Mount_Backend::control(int32_t pitch_or_lat, int32_t roll_or_lon, int32_
 // update_targets_from_rc - updates angle targets using input from receiver
 void AP_Mount_Backend::update_targets_from_rc()
 {
-#define rc_ch(i) RC_Channel::rc_channel(i-1)
+#define rc_ch(i) RC_Channels::rc_channel(i-1)
 
     uint8_t roll_rc_in = _state._roll_rc_in;
     uint8_t tilt_rc_in = _state._tilt_rc_in;
diff --git a/libraries/AP_Mount/AP_Mount_Servo.cpp b/libraries/AP_Mount/AP_Mount_Servo.cpp
index 02a467b..0332c47 100644
--- a/libraries/AP_Mount/AP_Mount_Servo.cpp
+++ b/libraries/AP_Mount/AP_Mount_Servo.cpp
@@ -6,16 +6,16 @@ extern const AP_HAL::HAL& hal;
 void AP_Mount_Servo::init(const AP_SerialManager& serial_manager)
 {
     if (_instance == 0) {
-        _roll_idx = RC_Channel_aux::k_mount_roll;
-        _tilt_idx = RC_Channel_aux::k_mount_tilt;
-        _pan_idx  = RC_Channel_aux::k_mount_pan;
-        _open_idx = RC_Channel_aux::k_mount_open;
+        _roll_idx = SRV_Channel::k_mount_roll;
+        _tilt_idx = SRV_Channel::k_mount_tilt;
+        _pan_idx  = SRV_Channel::k_mount_pan;
+        _open_idx = SRV_Channel::k_mount_open;
     } else {
         // this must be the 2nd mount
-        _roll_idx = RC_Channel_aux::k_mount2_roll;
-        _tilt_idx = RC_Channel_aux::k_mount2_tilt;
-        _pan_idx  = RC_Channel_aux::k_mount2_pan;
-        _open_idx = RC_Channel_aux::k_mount2_open;
+        _roll_idx = SRV_Channel::k_mount2_roll;
+        _tilt_idx = SRV_Channel::k_mount2_tilt;
+        _pan_idx  = SRV_Channel::k_mount2_pan;
+        _open_idx = SRV_Channel::k_mount2_open;
     }
 
     // check which servos have been assigned
@@ -107,9 +107,9 @@ void AP_Mount_Servo::set_mode(enum MAV_MOUNT_MODE mode)
 //  should be called periodically (i.e. 1hz or less)
 void AP_Mount_Servo::check_servo_map()
 {
-    _flags.roll_control = RC_Channel_aux::function_assigned(_roll_idx);
-    _flags.tilt_control = RC_Channel_aux::function_assigned(_tilt_idx);
-    _flags.pan_control = RC_Channel_aux::function_assigned(_pan_idx);
+    _flags.roll_control = SRV_Channels::function_assigned(_roll_idx);
+    _flags.tilt_control = SRV_Channels::function_assigned(_tilt_idx);
+    _flags.pan_control = SRV_Channels::function_assigned(_pan_idx);
 }
 
 // status_msg - called to allow mounts to send their status to GCS using the MOUNT_STATUS message
@@ -197,5 +197,5 @@ void AP_Mount_Servo::move_servo(uint8_t function_idx, int16_t angle, int16_t ang
 {
 	// saturate to the closest angle limit if outside of [min max] angle interval
 	int16_t servo_out = closest_limit(angle, angle_min, angle_max);
-	RC_Channel_aux::move_servo((RC_Channel_aux::Aux_servo_function_t)function_idx, servo_out, angle_min, angle_max);
+	SRV_Channels::move_servo((SRV_Channel::Aux_servo_function_t)function_idx, servo_out, angle_min, angle_max);
 }
diff --git a/libraries/AP_Mount/AP_Mount_Servo.h b/libraries/AP_Mount/AP_Mount_Servo.h
index ffd8818..8f9cf28 100644
--- a/libraries/AP_Mount/AP_Mount_Servo.h
+++ b/libraries/AP_Mount/AP_Mount_Servo.h
@@ -8,7 +8,7 @@
 #include <AP_GPS/AP_GPS.h>
 #include <AP_AHRS/AP_AHRS.h>
 #include <GCS_MAVLink/GCS_MAVLink.h>
-#include <RC_Channel/RC_Channel_aux.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include "AP_Mount_Backend.h"
 
 class AP_Mount_Servo : public AP_Mount_Backend
@@ -17,10 +17,10 @@ class AP_Mount_Servo : public AP_Mount_Backend
     // Constructor
     AP_Mount_Servo(AP_Mount &frontend, AP_Mount::mount_state &state, uint8_t instance):
         AP_Mount_Backend(frontend, state, instance),
-        _roll_idx(RC_Channel_aux::k_none),
-        _tilt_idx(RC_Channel_aux::k_none),
-        _pan_idx(RC_Channel_aux::k_none),
-        _open_idx(RC_Channel_aux::k_none),
+        _roll_idx(SRV_Channel::k_none),
+        _tilt_idx(SRV_Channel::k_none),
+        _pan_idx(SRV_Channel::k_none),
+        _open_idx(SRV_Channel::k_none),
         _last_check_servo_map_ms(0)
     {
         // init to no axis being controlled
@@ -53,7 +53,7 @@ class AP_Mount_Servo : public AP_Mount_Backend
         bool pan_control    :1; // true if mount has pan control
     } _flags;
 
-    // check_servo_map - detects which axis we control (i.e. _flags) using the functions assigned to the servos in the RC_Channel_aux
+    // check_servo_map - detects which axis we control (i.e. _flags) using the functions assigned to the servos in the SRV_Channel
     //  should be called periodically (i.e. 1hz or less)
     void    check_servo_map();
 
@@ -66,11 +66,11 @@ class AP_Mount_Servo : public AP_Mount_Backend
     /// move_servo - moves servo with the given id to the specified angle.  all angles are in degrees * 10
     void move_servo(uint8_t rc, int16_t angle, int16_t angle_min, int16_t angle_max);
 
-    // RC_Channel_aux - different id numbers are used depending upon the instance number
-    RC_Channel_aux::Aux_servo_function_t    _roll_idx;  // RC_Channel_aux mount roll function index
-    RC_Channel_aux::Aux_servo_function_t    _tilt_idx;  // RC_Channel_aux mount tilt function index
-    RC_Channel_aux::Aux_servo_function_t    _pan_idx;   // RC_Channel_aux mount pan  function index
-    RC_Channel_aux::Aux_servo_function_t    _open_idx;  // RC_Channel_aux mount open function index
+    // SRV_Channel - different id numbers are used depending upon the instance number
+    SRV_Channel::Aux_servo_function_t    _roll_idx;  // SRV_Channel mount roll function index
+    SRV_Channel::Aux_servo_function_t    _tilt_idx;  // SRV_Channel mount tilt function index
+    SRV_Channel::Aux_servo_function_t    _pan_idx;   // SRV_Channel mount pan  function index
+    SRV_Channel::Aux_servo_function_t    _open_idx;  // SRV_Channel mount open function index
 
     Vector3f _angle_bf_output_deg;  // final body frame output angle in degrees
 

From 7706741b9b8cc2945408063d922ab174dec30451 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 5 Jan 2017 16:13:09 +1100
Subject: [PATCH 037/200] AP_Parachute: adapt to new RC_Channel API

---
 libraries/AP_Parachute/AP_Parachute.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_Parachute/AP_Parachute.cpp b/libraries/AP_Parachute/AP_Parachute.cpp
index 6c7da35..43d064d 100644
--- a/libraries/AP_Parachute/AP_Parachute.cpp
+++ b/libraries/AP_Parachute/AP_Parachute.cpp
@@ -2,6 +2,7 @@
 #include <AP_Relay/AP_Relay.h>
 #include <AP_Math/AP_Math.h>
 #include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include <AP_Notify/AP_Notify.h>
 #include <AP_HAL/AP_HAL.h>
 
@@ -107,7 +108,7 @@ void AP_Parachute::update()
         if (time_diff >= delay_ms) {
             if (_release_type == AP_PARACHUTE_TRIGGER_TYPE_SERVO) {
                 // move servo
-                RC_Channel_aux::set_radio(RC_Channel_aux::k_parachute_release, _servo_on_pwm);
+                SRV_Channels::set_output_pwm(SRV_Channel::k_parachute_release, _servo_on_pwm);
             }else if (_release_type <= AP_PARACHUTE_TRIGGER_TYPE_RELAY_3) {
                 // set relay
                 _relay.on(_release_type);
@@ -118,7 +119,7 @@ void AP_Parachute::update()
     }else if ((_release_time == 0) || time_diff >= delay_ms + AP_PARACHUTE_RELEASE_DURATION_MS) {
         if (_release_type == AP_PARACHUTE_TRIGGER_TYPE_SERVO) {
             // move servo back to off position
-            RC_Channel_aux::set_radio(RC_Channel_aux::k_parachute_release, _servo_off_pwm);
+            SRV_Channels::set_output_pwm(SRV_Channel::k_parachute_release, _servo_off_pwm);
         }else if (_release_type <= AP_PARACHUTE_TRIGGER_TYPE_RELAY_3) {
             // set relay back to zero volts
             _relay.off(_release_type);

From f73f3bedda0b94f67f3370bc337db695cbff42df Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 5 Jan 2017 16:13:15 +1100
Subject: [PATCH 038/200] AP_ServoRelayEvents: adapt to new RC_Channel API

---
 libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp b/libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp
index a912223..8c1429f 100644
--- a/libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp
+++ b/libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp
@@ -21,6 +21,7 @@
 #include <AP_Common/AP_Common.h>
 #include "AP_ServoRelayEvents.h"
 #include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 
 extern const AP_HAL::HAL& hal;
 
@@ -102,13 +103,17 @@ void AP_ServoRelayEvents::update_events(void)
         return;
     }
 
+    if (channel > NUM_SERVO_CHANNELS || channel == 0) {
+        return;
+    }
+
     start_time_ms = AP_HAL::millis();
 
     switch (type) {
     case EVENT_TYPE_SERVO:
         hal.rcout->enable_ch(channel-1);
         if (repeat & 1) {
-            hal.rcout->write(channel-1, RC_Channel::rc_channel(channel-1)->get_radio_trim());
+            hal.rcout->write(channel-1, SRV_Channels::srv_channel(channel-1)->get_output_pwm());
         } else {
             hal.rcout->write(channel-1, servo_value);
         }

From ede66aae17a17231bf8adcb6a11314e5a9571347 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 5 Jan 2017 16:13:19 +1100
Subject: [PATCH 039/200] AP_Tuning: adapt to new RC_Channel API

---
 libraries/AP_Tuning/AP_Tuning.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_Tuning/AP_Tuning.cpp b/libraries/AP_Tuning/AP_Tuning.cpp
index bf8c737..3ed56c5 100644
--- a/libraries/AP_Tuning/AP_Tuning.cpp
+++ b/libraries/AP_Tuning/AP_Tuning.cpp
@@ -64,7 +64,7 @@ void AP_Tuning::check_selector_switch(void)
         // no selector switch enabled
         return;
     }
-    RC_Channel *selchan = RC_Channel::rc_channel(selector-1);
+    RC_Channel *selchan = RC_Channels::rc_channel(selector-1);
     if (selchan == nullptr) {
         return;
     }
@@ -172,7 +172,7 @@ void AP_Tuning::check_input(uint8_t flightmode)
         return;
     }
     
-    RC_Channel *chan = RC_Channel::rc_channel(channel-1);
+    RC_Channel *chan = RC_Channels::rc_channel(channel-1);
     if (chan == nullptr) {
         return;
     }

From 0942291e7498f2ed2eba3bdc090bdcbb9329ebdc Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 5 Jan 2017 16:13:25 +1100
Subject: [PATCH 040/200] GCS_MAVLink: adapt to new RC_Channel API

---
 libraries/GCS_MAVLink/GCS_Common.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/GCS_MAVLink/GCS_Common.cpp b/libraries/GCS_MAVLink/GCS_Common.cpp
index 4939235..b3275c1 100644
--- a/libraries/GCS_MAVLink/GCS_Common.cpp
+++ b/libraries/GCS_MAVLink/GCS_Common.cpp
@@ -1710,7 +1710,7 @@ void GCS_MAVLINK::send_servo_output_raw(bool hil)
     uint16_t values[16] {};
     if (hil) {
         for (uint8_t i=0; i<16; i++) {
-            values[i] = RC_Channel::rc_channel(i)->get_radio_out();
+            values[i] = SRV_Channels::srv_channel(i)->get_output_pwm();
         }
     } else {
         hal.rcout->read(values, 16);

From 39ab1a0abce16436403a7e77a364b26736d08012 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 5 Jan 2017 16:13:35 +1100
Subject: [PATCH 041/200] SITL: adapt to new RC_Channel API

---
 libraries/SITL/SIM_XPlane.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/SITL/SIM_XPlane.cpp b/libraries/SITL/SIM_XPlane.cpp
index ce0403d..51c9cba 100644
--- a/libraries/SITL/SIM_XPlane.cpp
+++ b/libraries/SITL/SIM_XPlane.cpp
@@ -394,8 +394,8 @@ void XPlane::send_data(const struct sitl_input &input)
     throttle = ((uint32_t)(throttle * 1000)) * 1.0e-3f + throttle_magic;
     
     uint8_t flap_chan;
-    if (RC_Channel_aux::find_channel(RC_Channel_aux::k_flap, flap_chan) ||
-        RC_Channel_aux::find_channel(RC_Channel_aux::k_flap_auto, flap_chan)) {
+    if (SRV_Channels::find_channel(SRV_Channel::k_flap, flap_chan) ||
+        SRV_Channels::find_channel(SRV_Channel::k_flap_auto, flap_chan)) {
         float flap = (input.servos[flap_chan]-1000)/1000.0;
         if (flap != last_flap) {
             send_dref("sim/flightmodel/controls/flaprqst", flap);

From 1ac5776b8b296d5bdcbe9209d201e3c435d77aec Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 6 Jan 2017 12:20:26 +1100
Subject: [PATCH 042/200] AC_Sprayer: adapt to new RC_Channel API

---
 libraries/AC_Sprayer/AC_Sprayer.cpp | 13 +++++--------
 libraries/AC_Sprayer/AC_Sprayer.h   |  2 +-
 2 files changed, 6 insertions(+), 9 deletions(-)

diff --git a/libraries/AC_Sprayer/AC_Sprayer.cpp b/libraries/AC_Sprayer/AC_Sprayer.cpp
index 998dd02..5ad97af 100644
--- a/libraries/AC_Sprayer/AC_Sprayer.cpp
+++ b/libraries/AC_Sprayer/AC_Sprayer.cpp
@@ -85,11 +85,8 @@ void AC_Sprayer::run(const bool true_false)
 
 void AC_Sprayer::stop_spraying()
 {
-    // send output to pump channel
-    RC_Channel_aux::set_radio_to_min(RC_Channel_aux::k_sprayer_pump);
-
-    // send output to spinner channel
-    RC_Channel_aux::set_radio_to_min(RC_Channel_aux::k_sprayer_spinner);
+    SRV_Channels::set_servo_limit(SRV_Channel::k_sprayer_pump, SRV_CHANNEL_LIMIT_MIN);
+    SRV_Channels::set_servo_limit(SRV_Channel::k_sprayer_spinner, SRV_CHANNEL_LIMIT_MIN);
 
     _flags.spraying = false;
 }
@@ -105,7 +102,7 @@ AC_Sprayer::update()
     }
 
     // exit immediately if the pump function has not been set-up for any servo
-    if (!RC_Channel_aux::function_assigned(RC_Channel_aux::k_sprayer_pump)) {
+    if (!SRV_Channels::function_assigned(SRV_Channel::k_sprayer_pump)) {
         return;
     }
 
@@ -163,8 +160,8 @@ AC_Sprayer::update()
         float pos = ground_speed * _pump_pct_1ms;
         pos = MAX(pos, 100 *_pump_min_pct); // ensure min pump speed
         pos = MIN(pos,10000); // clamp to range
-        RC_Channel_aux::move_servo(RC_Channel_aux::k_sprayer_pump, pos, 0, 10000);
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_sprayer_spinner, _spinner_pwm);
+        SRV_Channels::move_servo(SRV_Channel::k_sprayer_pump, pos, 0, 10000);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_sprayer_spinner, _spinner_pwm);
         _flags.spraying = true;
     }else{
         stop_spraying();
diff --git a/libraries/AC_Sprayer/AC_Sprayer.h b/libraries/AC_Sprayer/AC_Sprayer.h
index b4771b7..8164c2c 100644
--- a/libraries/AC_Sprayer/AC_Sprayer.h
+++ b/libraries/AC_Sprayer/AC_Sprayer.h
@@ -18,7 +18,7 @@
 #include <AP_Common/AP_Common.h>
 #include <AP_Param/AP_Param.h>
 #include <AP_Math/AP_Math.h>
-#include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include <AP_InertialNav/AP_InertialNav.h>     // Inertial Navigation library
 
 #define AC_SPRAYER_DEFAULT_PUMP_RATE        10.0f   ///< default quantity of spray per meter travelled

From d07d2d9a40f1e4dac5225d4820f6317c70055859 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 6 Jan 2017 17:16:00 +1100
Subject: [PATCH 043/200] Tools: adapt to new RC_Channel API

---
 Tools/ardupilotwaf/ardupilotwaf.py       | 1 +
 Tools/autotest/default_params/plane.parm | 2 --
 2 files changed, 1 insertion(+), 2 deletions(-)

diff --git a/Tools/ardupilotwaf/ardupilotwaf.py b/Tools/ardupilotwaf/ardupilotwaf.py
index de74f73..8ffad48 100644
--- a/Tools/ardupilotwaf/ardupilotwaf.py
+++ b/Tools/ardupilotwaf/ardupilotwaf.py
@@ -49,6 +49,7 @@
     'Filter',
     'GCS_MAVLink',
     'RC_Channel',
+    'SRV_Channel',
     'StorageManager',
     'AP_Tuning',
     'AP_RPM',
diff --git a/Tools/autotest/default_params/plane.parm b/Tools/autotest/default_params/plane.parm
index 7ecf14a..57e27a5 100644
--- a/Tools/autotest/default_params/plane.parm
+++ b/Tools/autotest/default_params/plane.parm
@@ -16,8 +16,6 @@ ARSPD_FBW_MAX   30
 ARSPD_FBW_MIN   10
 KFF_RDDRMIX     0.5
 THR_MAX		100
-RC2_REV		1
-RC4_REV		1
 RC1_MAX         2000
 RC1_MIN         1000
 RC1_TRIM        1500

From a10e8b9b4beaeec111fa62b571094c664dedabc8 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 6 Jan 2017 17:39:58 +1100
Subject: [PATCH 044/200] Tools: fixed quadplane parameters

---
 Tools/autotest/default_params/quadplane.parm | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/Tools/autotest/default_params/quadplane.parm b/Tools/autotest/default_params/quadplane.parm
index eb245fd..f4e08da 100644
--- a/Tools/autotest/default_params/quadplane.parm
+++ b/Tools/autotest/default_params/quadplane.parm
@@ -54,12 +54,9 @@ RALLY_TOTAL      0
 RC1_DZ           30
 RC1_MAX          1886
 RC1_MIN          1087
-RC1_REV          1
 RC1_TRIM         1500
-RC2_REV          1
 RC3_MAX          2000
 RC3_MIN          1000
-RC4_REV          1
 RLL2SRV_D        0.141009
 RLL2SRV_I        0.425000
 RLL2SRV_IMAX     4000

From 5817cc400c864828185511024d1b08a9a5f0606f Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 12:06:40 +1100
Subject: [PATCH 045/200] AC_Sprayer: use new SRV_Channels API

---
 libraries/AC_Sprayer/AC_Sprayer.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/AC_Sprayer/AC_Sprayer.cpp b/libraries/AC_Sprayer/AC_Sprayer.cpp
index 5ad97af..c45a25c 100644
--- a/libraries/AC_Sprayer/AC_Sprayer.cpp
+++ b/libraries/AC_Sprayer/AC_Sprayer.cpp
@@ -85,8 +85,8 @@ void AC_Sprayer::run(const bool true_false)
 
 void AC_Sprayer::stop_spraying()
 {
-    SRV_Channels::set_servo_limit(SRV_Channel::k_sprayer_pump, SRV_CHANNEL_LIMIT_MIN);
-    SRV_Channels::set_servo_limit(SRV_Channel::k_sprayer_spinner, SRV_CHANNEL_LIMIT_MIN);
+    SRV_Channels::set_output_limit(SRV_Channel::k_sprayer_pump, SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
+    SRV_Channels::set_output_limit(SRV_Channel::k_sprayer_spinner, SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
 
     _flags.spraying = false;
 }

From b3d30cbd4b3a45921308f140f2778d8e0333a264 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 12:06:40 +1100
Subject: [PATCH 046/200] AP_Gripper: use new SRV_Channels API

---
 libraries/AP_Gripper/AP_Gripper_EPM.cpp   |  6 +++---
 libraries/AP_Gripper/AP_Gripper_EPM.h     |  2 +-
 libraries/AP_Gripper/AP_Gripper_Servo.cpp | 10 +++++-----
 libraries/AP_Gripper/AP_Gripper_Servo.h   |  2 +-
 4 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/libraries/AP_Gripper/AP_Gripper_EPM.cpp b/libraries/AP_Gripper/AP_Gripper_EPM.cpp
index 8912edf..7d715df 100644
--- a/libraries/AP_Gripper/AP_Gripper_EPM.cpp
+++ b/libraries/AP_Gripper/AP_Gripper_EPM.cpp
@@ -55,7 +55,7 @@ void AP_Gripper_EPM::grab()
 #endif
     {
         // move the servo output to the grab position
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_gripper, config.grab_pwm);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_gripper, config.grab_pwm);
     }
 }
 
@@ -77,7 +77,7 @@ void AP_Gripper_EPM::release()
 #endif
     {
         // move the servo to the release position
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_gripper, config.release_pwm);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_gripper, config.release_pwm);
     }
 }
 
@@ -86,7 +86,7 @@ void AP_Gripper_EPM::neutral()
 {
     if (!should_use_uavcan()) {
         // move the servo to the off position
-        RC_Channel_aux::set_radio(RC_Channel_aux::k_gripper, config.neutral_pwm);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_gripper, config.neutral_pwm);
     }
 }
 
diff --git a/libraries/AP_Gripper/AP_Gripper_EPM.h b/libraries/AP_Gripper/AP_Gripper_EPM.h
index 3d306ac..afac084 100644
--- a/libraries/AP_Gripper/AP_Gripper_EPM.h
+++ b/libraries/AP_Gripper/AP_Gripper_EPM.h
@@ -16,7 +16,7 @@
 #include "AP_Gripper.h"
 #include "AP_Gripper_Backend.h"
 
-#include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 
 #define EPM_RETURN_TO_NEUTRAL_MS    500         // EPM PWM returns to neutral position this many milliseconds after grab or release
 
diff --git a/libraries/AP_Gripper/AP_Gripper_Servo.cpp b/libraries/AP_Gripper/AP_Gripper_Servo.cpp
index 3bc2752..a44d077 100644
--- a/libraries/AP_Gripper/AP_Gripper_Servo.cpp
+++ b/libraries/AP_Gripper/AP_Gripper_Servo.cpp
@@ -11,22 +11,22 @@ void AP_Gripper_Servo::init_gripper()
 void AP_Gripper_Servo::grab()
 {
     // move the servo to the grab position
-    RC_Channel_aux::set_radio(RC_Channel_aux::k_gripper, config.grab_pwm);
+    SRV_Channels::set_output_pwm(SRV_Channel::k_gripper, config.grab_pwm);
     action_timestamp = AP_HAL::millis();
 }
 
 void AP_Gripper_Servo::release()
 {
     // move the servo to the release position
-    RC_Channel_aux::set_radio(RC_Channel_aux::k_gripper, config.release_pwm);
+    SRV_Channels::set_output_pwm(SRV_Channel::k_gripper, config.release_pwm);
     action_timestamp = AP_HAL::millis();
 }
 
 bool AP_Gripper_Servo::has_state_pwm(const uint16_t pwm) const
 {
     // return true if servo is in position represented by pwm
-    int16_t current_pwm;
-    if (!RC_Channel_aux::get_radio(RC_Channel_aux::k_gripper, current_pwm)) {
+    uint16_t current_pwm;
+    if (!SRV_Channels::get_output_pwm(SRV_Channel::k_gripper, current_pwm)) {
         // function not assigned to a channel, perhaps?
         return false;
     }
@@ -61,7 +61,7 @@ bool AP_Gripper_Servo::valid() const
     if (!AP_Gripper_Backend::valid()) {
         return false;
     }
-    if (!RC_Channel_aux::function_assigned(RC_Channel_aux::k_gripper)) {
+    if (!SRV_Channels::function_assigned(SRV_Channel::k_gripper)) {
         return false;
     }
     return true;
diff --git a/libraries/AP_Gripper/AP_Gripper_Servo.h b/libraries/AP_Gripper/AP_Gripper_Servo.h
index 1db0977..071906a 100644
--- a/libraries/AP_Gripper/AP_Gripper_Servo.h
+++ b/libraries/AP_Gripper/AP_Gripper_Servo.h
@@ -16,7 +16,7 @@
 #pragma once
 
 #include <AP_Gripper/AP_Gripper_Backend.h>
-#include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 
 class AP_Gripper_Servo : public AP_Gripper_Backend {
 public:

From 929fbce2c231c84f3c2a949258c0b4958256c099 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 12:06:40 +1100
Subject: [PATCH 047/200] AP_LandingGear: use new SRV_Channels API

---
 libraries/AP_LandingGear/AP_LandingGear.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/libraries/AP_LandingGear/AP_LandingGear.cpp b/libraries/AP_LandingGear/AP_LandingGear.cpp
index 9dec25d..e450c75 100644
--- a/libraries/AP_LandingGear/AP_LandingGear.cpp
+++ b/libraries/AP_LandingGear/AP_LandingGear.cpp
@@ -1,7 +1,7 @@
 #include "AP_LandingGear.h"
 #include <AP_Relay/AP_Relay.h>
 #include <AP_Math/AP_Math.h>
-#include <RC_Channel/RC_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include <AP_HAL/AP_HAL.h>
 
 extern const AP_HAL::HAL& hal;
@@ -39,7 +39,7 @@ void AP_LandingGear::enable(bool on_off)
 void AP_LandingGear::deploy()
 {
     // set servo PWM to deployed position
-    RC_Channel_aux::set_radio(RC_Channel_aux::k_landing_gear_control, _servo_deploy_pwm);
+    SRV_Channels::set_output_pwm(SRV_Channel::k_landing_gear_control, _servo_deploy_pwm);
 
     // set deployed flag
     _deployed = true;    
@@ -49,7 +49,7 @@ void AP_LandingGear::deploy()
 void AP_LandingGear::retract()
 {    
     // set servo PWM to retracted position
-    RC_Channel_aux::set_radio(RC_Channel_aux::k_landing_gear_control, _servo_retract_pwm);
+    SRV_Channels::set_output_pwm(SRV_Channel::k_landing_gear_control, _servo_retract_pwm);
 
     // reset deployed flag
     _deployed = false;   

From 4cb9f772f228bf0874d88425ceac8b9d3fbf6a83 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 12:02:32 +1100
Subject: [PATCH 048/200] mk: link SRV_Channel library

---
 mk/make.inc | 1 +
 1 file changed, 1 insertion(+)

diff --git a/mk/make.inc b/mk/make.inc
index 314d166..001b74e 100644
--- a/mk/make.inc
+++ b/mk/make.inc
@@ -3,3 +3,4 @@ LIBRARIES += AP_Module
 LIBRARIES += AP_Button
 LIBRARIES += AP_ICEngine
 LIBRARIES += AP_FlashStorage
+LIBRARIES += SRV_Channel

From b83f50be0f3b2d3333dd3f5c1ce7ffecf77b3a73 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 22 Oct 2016 21:27:57 +1100
Subject: [PATCH 049/200] Plane: use new SRV_Channels API

---
 ArduPlane/ArduPlane.cpp     |  12 +-
 ArduPlane/Attitude.cpp      |  78 +++++------
 ArduPlane/GCS_Mavlink.cpp   |   8 +-
 ArduPlane/Log.cpp           |   4 +-
 ArduPlane/Parameters.cpp    |  86 +++---------
 ArduPlane/Parameters.h      |  78 +++--------
 ArduPlane/Plane.h           |  15 +--
 ArduPlane/afs_plane.cpp     |  58 +++-----
 ArduPlane/control_modes.cpp |   2 +-
 ArduPlane/failsafe.cpp      |  39 +++---
 ArduPlane/px4_mixer.cpp     |  44 +++---
 ArduPlane/quadplane.cpp     |  19 ++-
 ArduPlane/radio.cpp         |  57 ++++----
 ArduPlane/sensors.cpp       |   2 +-
 ArduPlane/servos.cpp        | 321 +++++++++++++++++---------------------------
 ArduPlane/system.cpp        |  28 +---
 ArduPlane/test.cpp          | 254 -----------------------------------
 ArduPlane/tiltrotor.cpp     |   6 +-
 18 files changed, 309 insertions(+), 802 deletions(-)

diff --git a/ArduPlane/ArduPlane.cpp b/ArduPlane/ArduPlane.cpp
index e6c65e9..311c9ed 100644
--- a/ArduPlane/ArduPlane.cpp
+++ b/ArduPlane/ArduPlane.cpp
@@ -311,7 +311,7 @@ void Plane::afs_fs_check(void)
  */
 void Plane::update_aux(void)
 {
-    RC_Channel_aux::enable_aux_servos();
+    SRV_Channels::enable_aux_servos();
 }
 
 void Plane::one_second_loop()
@@ -558,7 +558,7 @@ void Plane::handle_auto_mode(void)
 
             // we are in the final stage of a landing - force
             // zero throttle
-            channel_throttle->set_servo_out(0);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);
         } else {
             calc_throttle();
         }
@@ -685,7 +685,7 @@ void Plane::update_flight_mode(void)
             // FBWA failsafe glide
             nav_roll_cd = 0;
             nav_pitch_cd = 0;
-            channel_throttle->set_servo_out(0);
+            SRV_Channels::set_output_limit(SRV_Channel::k_throttle, SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
         }
         if (g.fbwa_tdrag_chan > 0) {
             // check for the user enabling FBWA taildrag takeoff mode
@@ -748,10 +748,8 @@ void Plane::update_flight_mode(void)
         break;
 
     case MANUAL:
-        // servo_out is for Sim control only
-        // ---------------------------------
-        channel_roll->set_servo_out(channel_roll->pwm_to_angle());
-        channel_pitch->set_servo_out(channel_pitch->pwm_to_angle());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, channel_roll->pwm_to_angle());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, channel_pitch->pwm_to_angle());
         steering_control.steering = steering_control.rudder = channel_rudder->pwm_to_angle();
         break;
         //roll: -13788.000,  pitch: -13698.000,   thr: 0.000, rud: -13742.000
diff --git a/ArduPlane/Attitude.cpp b/ArduPlane/Attitude.cpp
index 4d9a332..996b931 100644
--- a/ArduPlane/Attitude.cpp
+++ b/ArduPlane/Attitude.cpp
@@ -19,8 +19,8 @@ float Plane::get_speed_scaler(void)
         }
         speed_scaler = constrain_float(speed_scaler, 0.5f, 2.0f);
     } else {
-        if (channel_throttle->get_servo_out() > 0) {
-            speed_scaler = 0.5f + ((float)THROTTLE_CRUISE / channel_throttle->get_servo_out() / 2.0f);                 // First order taylor expansion of square root
+        if (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) > 0) {
+            speed_scaler = 0.5f + ((float)THROTTLE_CRUISE / SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) / 2.0f);                 // First order taylor expansion of square root
             // Should maybe be to the 2/7 power, but we aren't going to implement that...
         }else{
             speed_scaler = 1.67f;
@@ -80,9 +80,9 @@ void Plane::stabilize_roll(float speed_scaler)
     if (control_mode == STABILIZE && channel_roll->get_control_in() != 0) {
         disable_integrator = true;
     }
-    channel_roll->set_servo_out(rollController.get_servo_out(nav_roll_cd - ahrs.roll_sensor, 
-                                                           speed_scaler, 
-                                                           disable_integrator));
+    SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, rollController.get_servo_out(nav_roll_cd - ahrs.roll_sensor, 
+                                                                                         speed_scaler, 
+                                                                                         disable_integrator));
 }
 
 /*
@@ -96,17 +96,17 @@ void Plane::stabilize_pitch(float speed_scaler)
     if (force_elevator != 0) {
         // we are holding the tail down during takeoff. Just convert
         // from a percentage to a -4500..4500 centidegree angle
-        channel_pitch->set_servo_out(45*force_elevator);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, 45*force_elevator);
         return;
     }
-    int32_t demanded_pitch = nav_pitch_cd + g.pitch_trim_cd + channel_throttle->get_servo_out() * g.kff_throttle_to_pitch;
+    int32_t demanded_pitch = nav_pitch_cd + g.pitch_trim_cd + SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) * g.kff_throttle_to_pitch;
     bool disable_integrator = false;
     if (control_mode == STABILIZE && channel_pitch->get_control_in() != 0) {
         disable_integrator = true;
     }
-    channel_pitch->set_servo_out(pitchController.get_servo_out(demanded_pitch - ahrs.pitch_sensor, 
-                                                             speed_scaler, 
-                                                             disable_integrator));
+    SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, pitchController.get_servo_out(demanded_pitch - ahrs.pitch_sensor, 
+                                                                                           speed_scaler, 
+                                                                                           disable_integrator));
 }
 
 /*
@@ -128,17 +128,6 @@ void Plane::stick_mix_channel(RC_Channel *channel, int16_t &servo_out)
 }
 
 /*
-  One argument version for when the servo out in the rc channel 
-  is the target
- */
-void Plane::stick_mix_channel(RC_Channel * channel)
-{
-   int16_t servo_out = channel->get_servo_out();
-   stick_mix_channel(channel,servo_out);
-   channel->set_servo_out(servo_out);
-}
-
-/*
   this gives the user control of the aircraft in stabilization modes
  */
 void Plane::stabilize_stick_mixing_direct()
@@ -157,8 +146,13 @@ void Plane::stabilize_stick_mixing_direct()
         control_mode == TRAINING) {
         return;
     }
-    stick_mix_channel(channel_roll);
-    stick_mix_channel(channel_pitch);
+    int16_t aileron = SRV_Channels::get_output_scaled(SRV_Channel::k_aileron);
+    stick_mix_channel(channel_roll, aileron);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, aileron);
+
+    int16_t elevator = SRV_Channels::get_output_scaled(SRV_Channel::k_elevator);
+    stick_mix_channel(channel_pitch, elevator);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, elevator);
 }
 
 /*
@@ -268,25 +262,25 @@ void Plane::stabilize_yaw(float speed_scaler)
 void Plane::stabilize_training(float speed_scaler)
 {
     if (training_manual_roll) {
-        channel_roll->set_servo_out(channel_roll->get_control_in());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, channel_roll->get_control_in());
     } else {
         // calculate what is needed to hold
         stabilize_roll(speed_scaler);
-        if ((nav_roll_cd > 0 && channel_roll->get_control_in() < channel_roll->get_servo_out()) ||
-            (nav_roll_cd < 0 && channel_roll->get_control_in() > channel_roll->get_servo_out())) {
+        if ((nav_roll_cd > 0 && channel_roll->get_control_in() < SRV_Channels::get_output_scaled(SRV_Channel::k_aileron)) ||
+            (nav_roll_cd < 0 && channel_roll->get_control_in() > SRV_Channels::get_output_scaled(SRV_Channel::k_aileron))) {
             // allow user to get out of the roll
-            channel_roll->set_servo_out(channel_roll->get_control_in());            
+            SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, channel_roll->get_control_in());
         }
     }
 
     if (training_manual_pitch) {
-        channel_pitch->set_servo_out(channel_pitch->get_control_in());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, channel_pitch->get_control_in());
     } else {
         stabilize_pitch(speed_scaler);
-        if ((nav_pitch_cd > 0 && channel_pitch->get_control_in() < channel_pitch->get_servo_out()) ||
-            (nav_pitch_cd < 0 && channel_pitch->get_control_in() > channel_pitch->get_servo_out())) {
+        if ((nav_pitch_cd > 0 && channel_pitch->get_control_in() < SRV_Channels::get_output_scaled(SRV_Channel::k_elevator)) ||
+            (nav_pitch_cd < 0 && channel_pitch->get_control_in() > SRV_Channels::get_output_scaled(SRV_Channel::k_elevator))) {
             // allow user to get back to level
-            channel_pitch->set_servo_out(channel_pitch->get_control_in());            
+            SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, channel_pitch->get_control_in());
         }
     }
 
@@ -321,16 +315,16 @@ void Plane::stabilize_acro(float speed_scaler)
         nav_roll_cd = ahrs.roll_sensor + roll_error_cd;
         // try to reduce the integrated angular error to zero. We set
         // 'stabilze' to true, which disables the roll integrator
-        channel_roll->set_servo_out(rollController.get_servo_out(roll_error_cd,
-                                                                speed_scaler,
-                                                                true));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, rollController.get_servo_out(roll_error_cd,
+                                                                                             speed_scaler,
+                                                                                             true));
     } else {
         /*
           aileron stick is non-zero, use pure rate control until the
           user releases the stick
          */
         acro_state.locked_roll = false;
-        channel_roll->set_servo_out(rollController.get_rate_out(roll_rate,  speed_scaler));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, rollController.get_rate_out(roll_rate,  speed_scaler));
     }
 
     if (g.acro_locking && is_zero(pitch_rate)) {
@@ -345,15 +339,15 @@ void Plane::stabilize_acro(float speed_scaler)
         // try to hold the locked pitch. Note that we have the pitch
         // integrator enabled, which helps with inverted flight
         nav_pitch_cd = acro_state.locked_pitch_cd;
-        channel_pitch->set_servo_out(pitchController.get_servo_out(nav_pitch_cd - ahrs.pitch_sensor,
-                                                                  speed_scaler,
-                                                                  false));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, pitchController.get_servo_out(nav_pitch_cd - ahrs.pitch_sensor,
+                                                                                               speed_scaler,
+                                                                                               false));
     } else {
         /*
           user has non-zero pitch input, use a pure rate controller
          */
         acro_state.locked_pitch = false;
-        channel_pitch->set_servo_out( pitchController.get_rate_out(pitch_rate, speed_scaler));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, pitchController.get_rate_out(pitch_rate, speed_scaler));
     }
 
     /*
@@ -423,7 +417,7 @@ void Plane::calc_throttle()
         // user has asked for zero throttle - this may be done by a
         // mission which wants to turn off the engine for a parachute
         // landing
-        channel_throttle->set_servo_out(0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);
         return;
     }
 
@@ -436,7 +430,7 @@ void Plane::calc_throttle()
         commanded_throttle = plane.guided_state.forced_throttle;
     }
 
-    channel_throttle->set_servo_out(commanded_throttle);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, commanded_throttle);
 }
 
 /*****************************************
@@ -464,7 +458,7 @@ void Plane::calc_nav_yaw_coordinated(float speed_scaler)
         commanded_rudder = yawController.get_servo_out(speed_scaler, disable_integrator);
 
         // add in rudder mixing from roll
-        commanded_rudder += channel_roll->get_servo_out() * g.kff_rudder_mix;
+        commanded_rudder += SRV_Channels::get_output_scaled(SRV_Channel::k_aileron) * g.kff_rudder_mix;
         commanded_rudder += rudder_input;
     }
 
diff --git a/ArduPlane/GCS_Mavlink.cpp b/ArduPlane/GCS_Mavlink.cpp
index 03090c2..a0e6dc3 100644
--- a/ArduPlane/GCS_Mavlink.cpp
+++ b/ArduPlane/GCS_Mavlink.cpp
@@ -216,10 +216,10 @@ void Plane::send_servo_out(mavlink_channel_t chan)
         chan,
         millis(),
         0, // port 0
-        10000 * channel_roll->norm_output() * (channel_roll->get_reverse()?-1:1),
-        10000 * channel_pitch->norm_output() * (channel_pitch->get_reverse()?-1:1),
-        10000 * channel_throttle->norm_output() * (channel_throttle->get_reverse()?-1:1),
-        10000 * channel_rudder->norm_output() * (channel_rudder->get_reverse()?-1:1),
+        10000 * (SRV_Channels::get_output_scaled(SRV_Channel::k_aileron) / 4500.0f),
+        10000 * (SRV_Channels::get_output_scaled(SRV_Channel::k_elevator) / 4500.0f),
+        10000 * (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) / 100.0f),
+        10000 * (SRV_Channels::get_output_scaled(SRV_Channel::k_rudder) / 4500.0f),
         0,
         0,
         0,
diff --git a/ArduPlane/Log.cpp b/ArduPlane/Log.cpp
index 84dd99c..41ee4de 100644
--- a/ArduPlane/Log.cpp
+++ b/ArduPlane/Log.cpp
@@ -263,8 +263,8 @@ void Plane::Log_Write_Control_Tuning()
         roll            : (int16_t)ahrs.roll_sensor,
         nav_pitch_cd    : (int16_t)nav_pitch_cd,
         pitch           : (int16_t)ahrs.pitch_sensor,
-        throttle_out    : (int16_t)channel_throttle->get_servo_out(),
-        rudder_out      : (int16_t)channel_rudder->get_servo_out(),
+        throttle_out    : (int16_t)SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
+        rudder_out      : (int16_t)SRV_Channels::get_output_scaled(SRV_Channel::k_rudder),
         throttle_dem    : (int16_t)SpdHgt_Controller->get_throttle_demand()
     };
     DataFlash.WriteBlock(&pkt, sizeof(pkt));
diff --git a/ArduPlane/Parameters.cpp b/ArduPlane/Parameters.cpp
index 9c58b49..042ffec 100644
--- a/ArduPlane/Parameters.cpp
+++ b/ArduPlane/Parameters.cpp
@@ -1047,72 +1047,6 @@ const AP_Param::Info Plane::var_info[] = {
       (const void *)&plane.quadplane.attitude_control,
       {group_info : AC_AttitudeControl_Multi::var_info}, AP_PARAM_FLAG_POINTER },
     
-    // RC channel
-    //-----------
-    // @Group: RC1_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_1,                    "RC1_", RC_Channel),
-
-    // @Group: RC2_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_2,                    "RC2_", RC_Channel),
-
-    // @Group: RC3_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_3,                    "RC3_", RC_Channel),
-
-    // @Group: RC4_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_4,                    "RC4_", RC_Channel),
-
-    // @Group: RC5_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_5,                    "RC5_", RC_Channel_aux),
-
-    // @Group: RC6_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_6,                    "RC6_", RC_Channel_aux),
-
-    // @Group: RC7_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_7,                    "RC7_", RC_Channel_aux),
-
-    // @Group: RC8_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_8,                    "RC8_", RC_Channel_aux),
-
-    // @Group: RC9_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_9,                    "RC9_", RC_Channel_aux),
-
-    // @Group: RC10_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_10,                    "RC10_", RC_Channel_aux),
-
-    // @Group: RC11_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_11,                    "RC11_", RC_Channel_aux),
-
-    // @Group: RC12_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_12,                    "RC12_", RC_Channel_aux),
-
-    // @Group: RC13_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_13,                    "RC13_", RC_Channel_aux),
-
-    // @Group: RC14_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_14,                    "RC14_", RC_Channel_aux),
-
-    // @Group: RC15_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_15,                    "RC15_", RC_Channel_aux),
-
-    // @Group: RC16_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_16,                    "RC16_", RC_Channel_aux),
-    
     // @Group: RLL2SRV_
     // @Path: ../libraries/APM_Control/AP_RollController.cpp
 	GOBJECT(rollController,         "RLL2SRV_",   AP_RollController),
@@ -1267,10 +1201,8 @@ const AP_Param::GroupInfo ParametersG2::var_info[] = {
     // @Path: ../libraries/AP_ICEngine/AP_ICEngine.cpp
     AP_SUBGROUPINFO(ice_control, "ICE_", 2, ParametersG2, AP_ICEngine),
 
-    // @Group: SERVO_
-    // @Path: ../libraries/RC_Channel/SRV_Channel.cpp
-    AP_SUBGROUPINFO(servo_channels, "SERVO", 3, ParametersG2, SRV_Channels),
-
+    // 3 was used by prototype for servo_channels
+    
     // @Group: SYSID_ENFORCE
     // @DisplayName: GCS sysid enforcement
     // @Description: This controls whether packets from other than the expected GCS system ID will be accepted
@@ -1282,6 +1214,14 @@ const AP_Param::GroupInfo ParametersG2::var_info[] = {
     // @Path: ../libraries/AP_Stats/AP_Stats.cpp
     AP_SUBGROUPINFO(stats, "STAT", 5, ParametersG2, AP_Stats),
 
+    // @Group: SERVO
+    // @Path: ../libraries/SRV_Channel/SRV_Channel.cpp
+    AP_SUBGROUPINFO(servo_channels, "SERVO", 6, ParametersG2, SRV_Channels),
+
+    // @Group: RC
+    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
+    AP_SUBGROUPINFO(rc_channels, "RC", 7, ParametersG2, RC_Channels),
+    
     AP_GROUPEND
 };
 
@@ -1387,6 +1327,12 @@ void Plane::load_parameters(void)
         // quadplanes needs a higher loop rate
         AP_Param::set_default_by_name("SCHED_LOOP_RATE", 300);
     }
+
+    // setup defaults in SRV_Channels
+    g2.servo_channels.set_default_function(CH_1, SRV_Channel::k_aileron);
+    g2.servo_channels.set_default_function(CH_2, SRV_Channel::k_elevator);
+    g2.servo_channels.set_default_function(CH_3, SRV_Channel::k_throttle);
+    g2.servo_channels.set_default_function(CH_4, SRV_Channel::k_rudder);
     
     cliSerial->printf("load_all took %uus\n", (unsigned)(micros() - before));
 }
diff --git a/ArduPlane/Parameters.h b/ArduPlane/Parameters.h
index 627aac1..5f97779 100644
--- a/ArduPlane/Parameters.h
+++ b/ArduPlane/Parameters.h
@@ -244,19 +244,19 @@ class Parameters {
         k_param_battery_curr_pin,       // unused - 169
 
         //
-        // 170: Radio settings
+        // 170: Radio settings - all unused now
         //
-        k_param_rc_1 = 170,
-        k_param_rc_2,
-        k_param_rc_3,
-        k_param_rc_4,
-        k_param_rc_5,
-        k_param_rc_6,
-        k_param_rc_7,
-        k_param_rc_8,
-        k_param_rc_9,
-        k_param_rc_10,
-        k_param_rc_11,
+        k_param_rc_1_old = 170,
+        k_param_rc_2_old,
+        k_param_rc_3_old,
+        k_param_rc_4_old,
+        k_param_rc_5_old,
+        k_param_rc_6_old,
+        k_param_rc_7_old,
+        k_param_rc_8_old,
+        k_param_rc_9_old,
+        k_param_rc_10_old,
+        k_param_rc_11_old,
 
         k_param_throttle_min,
         k_param_throttle_max,
@@ -270,13 +270,13 @@ class Parameters {
         k_param_throttle_slewrate,
         k_param_throttle_suppress_manual,
         k_param_throttle_passthru_stabilize,
-        k_param_rc_12,
+        k_param_rc_12_old,
         k_param_fs_batt_voltage,
         k_param_fs_batt_mah,
         k_param_short_fs_timeout,
         k_param_long_fs_timeout,
-        k_param_rc_13,
-        k_param_rc_14,
+        k_param_rc_13_old,
+        k_param_rc_14_old,
         k_param_tuning,
 
         //
@@ -290,8 +290,8 @@ class Parameters {
         k_param_quadplane,
         k_param_rtl_radius,
         k_param_land_then_servos_neutral,   // unused - moved to AP_Landing
-        k_param_rc_15,
-        k_param_rc_16,
+        k_param_rc_15_old,
+        k_param_rc_16_old,
 
         //
         // 210: flight modes
@@ -515,47 +515,6 @@ class Parameters {
 #endif
     AP_Int16 gcs_pid_mask;
     AP_Int8 parachute_channel;
-
-    // RC channels
-    RC_Channel rc_1;
-    RC_Channel rc_2;
-    RC_Channel rc_3;
-    RC_Channel rc_4;
-    RC_Channel_aux rc_5;
-    RC_Channel_aux rc_6;
-    RC_Channel_aux rc_7;
-    RC_Channel_aux rc_8;
-    RC_Channel_aux rc_9;
-    RC_Channel_aux rc_10;
-    RC_Channel_aux rc_11;
-    RC_Channel_aux rc_12;
-    RC_Channel_aux rc_13;
-    RC_Channel_aux rc_14;
-    RC_Channel_aux rc_15;
-    RC_Channel_aux rc_16;
-    uint8_t _dummy;
-
-    Parameters() :
-        // variable				default
-        //----------------------------------------
-        rc_1                                    (CH_1),
-        rc_2                                    (CH_2),
-        rc_3                                    (CH_3),
-        rc_4                                    (CH_4),
-        rc_5                                    (CH_5),
-        rc_6                                    (CH_6),
-        rc_7                                    (CH_7),
-        rc_8                                    (CH_8),
-        rc_9                                    (CH_9),
-        rc_10                                   (CH_10),
-        rc_11                                   (CH_11),
-        rc_12                                   (CH_12),
-        rc_13                                   (CH_13),
-        rc_14                                   (CH_14),
-        rc_15                                   (CH_15),
-        rc_16                                   (CH_16),
-        _dummy(0)
-        {}
 };
 
 /*
@@ -577,6 +536,9 @@ class ParametersG2 {
     // internal combustion engine control
     AP_ICEngine ice_control;
 
+    // RC input channels
+    RC_Channels rc_channels;
+    
     // control over servo output ranges
     SRV_Channels servo_channels;
 
diff --git a/ArduPlane/Plane.h b/ArduPlane/Plane.h
index 690b7d4..4ec640a 100644
--- a/ArduPlane/Plane.h
+++ b/ArduPlane/Plane.h
@@ -43,7 +43,7 @@
 #include <AP_AccelCal/AP_AccelCal.h>                // interface and maths for accelerometer calibration
 #include <AP_AHRS/AP_AHRS.h>         // ArduPilot Mega DCM Library
 #include <RC_Channel/RC_Channel.h>     // RC Channel Library
-#include <RC_Channel/SRV_Channel.h>
+#include <SRV_Channel/SRV_Channel.h>
 #include <AP_RangeFinder/AP_RangeFinder.h>     // Range finder library
 #include <Filter/Filter.h>                     // Filter library
 #include <AP_Buffer/AP_Buffer.h>      // APM FIFO Buffer
@@ -189,7 +189,7 @@ class Plane : public AP_HAL::HAL::Callbacks {
     // board specific config
     AP_BoardConfig BoardConfig;
 
-    // primary control channels
+    // primary input channels
     RC_Channel *channel_roll;
     RC_Channel *channel_pitch;
     RC_Channel *channel_throttle;
@@ -983,7 +983,6 @@ class Plane : public AP_HAL::HAL::Callbacks {
     void resetPerfData(void);
     void check_usb_mux(void);
     void print_comma(void);
-    void servo_write(uint8_t ch, uint16_t pwm);
     bool should_log(uint32_t mask);
     int8_t throttle_percentage(void);
     void change_arm_state(void);
@@ -1047,7 +1046,6 @@ class Plane : public AP_HAL::HAL::Callbacks {
     bool stick_mixing_enabled(void);
     void stabilize_roll(float speed_scaler);
     void stabilize_pitch(float speed_scaler);
-    static void stick_mix_channel(RC_Channel *channel);
     static void stick_mix_channel(RC_Channel *channel, int16_t &servo_out);
     void stabilize_stick_mixing_direct();
     void stabilize_stick_mixing_fbw();
@@ -1057,11 +1055,10 @@ class Plane : public AP_HAL::HAL::Callbacks {
     void calc_nav_yaw_coordinated(float speed_scaler);
     void calc_nav_yaw_course(void);
     void calc_nav_yaw_ground(void);
-    void throttle_slew_limit(int16_t last_throttle);
-    void flap_slew_limit(int8_t &last_value, int8_t &new_value);
+    void throttle_slew_limit(void);
     bool suppress_throttle(void);
-    void channel_output_mixer(uint8_t mixing_type, int16_t & chan1, int16_t & chan2)const;
-    void channel_output_mixer(uint8_t mixing_type, RC_Channel* chan1, RC_Channel* chan2)const;
+    void channel_output_mixer_pwm(uint8_t mixing_type, uint16_t & chan1, uint16_t & chan2)const;
+    void channel_output_mixer(uint8_t mixing_type, SRV_Channel::Aux_servo_function_t servo1, SRV_Channel::Aux_servo_function_t servo2);
     void flaperon_update(int8_t flap_percent);
     bool start_command(const AP_Mission::Mission_Command& cmd);
     bool verify_command(const AP_Mission::Mission_Command& cmd);
@@ -1091,7 +1088,6 @@ class Plane : public AP_HAL::HAL::Callbacks {
     void log_init();
     void init_capabilities(void);
     void dataflash_periodic(void);
-    uint16_t throttle_min(void) const;
     void parachute_check();
 #if PARACHUTE == ENABLED
     void do_parachute(const AP_Mission::Mission_Command& cmd);
@@ -1120,7 +1116,6 @@ class Plane : public AP_HAL::HAL::Callbacks {
     int8_t reboot_board(uint8_t argc, const Menu::arg *argv);
     int8_t main_menu_help(uint8_t argc, const Menu::arg *argv);
     int8_t test_radio_pwm(uint8_t argc, const Menu::arg *argv);
-    int8_t test_passthru(uint8_t argc, const Menu::arg *argv);
     int8_t test_radio(uint8_t argc, const Menu::arg *argv);
     int8_t test_failsafe(uint8_t argc, const Menu::arg *argv);
     int8_t test_relay(uint8_t argc, const Menu::arg *argv);
diff --git a/ArduPlane/afs_plane.cpp b/ArduPlane/afs_plane.cpp
index 13f5de0..d2f039e 100644
--- a/ArduPlane/afs_plane.cpp
+++ b/ArduPlane/afs_plane.cpp
@@ -15,30 +15,19 @@ AP_AdvancedFailsafe_Plane::AP_AdvancedFailsafe_Plane(AP_Mission &_mission, AP_Ba
  */
 void AP_AdvancedFailsafe_Plane::terminate_vehicle(void)
 {
-    // we are terminating. Setup primary output channels radio_out values
-    RC_Channel *ch_roll     = RC_Channel::rc_channel(rcmap.roll()-1);
-    RC_Channel *ch_pitch    = RC_Channel::rc_channel(rcmap.pitch()-1);
-    RC_Channel *ch_yaw      = RC_Channel::rc_channel(rcmap.yaw()-1);
-    RC_Channel *ch_throttle = RC_Channel::rc_channel(rcmap.throttle()-1);
-
-    ch_roll->set_radio_out(ch_roll->get_limit_pwm(RC_Channel::RC_CHANNEL_LIMIT_MIN));
-    ch_pitch->set_radio_out(ch_pitch->get_limit_pwm(RC_Channel::RC_CHANNEL_LIMIT_MAX));
-    ch_yaw->set_radio_out(ch_yaw->get_limit_pwm(RC_Channel::RC_CHANNEL_LIMIT_MAX));
-    ch_throttle->set_radio_out(ch_throttle->get_limit_pwm(RC_Channel::RC_CHANNEL_LIMIT_MIN));
-
-    RC_Channel_aux::disable_passthrough(true);
+    plane.g2.servo_channels.disable_passthrough(true);
     
     plane.servos_output();
 
     // and all aux channels
-    RC_Channel_aux::set_servo_limit(RC_Channel_aux::k_flap_auto, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_limit(RC_Channel_aux::k_flap, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_limit(RC_Channel_aux::k_aileron, RC_Channel::RC_CHANNEL_LIMIT_MIN);
-    RC_Channel_aux::set_servo_limit(RC_Channel_aux::k_rudder, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_limit(RC_Channel_aux::k_elevator, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_limit(RC_Channel_aux::k_elevator_with_input, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_limit(RC_Channel_aux::k_manual, RC_Channel::RC_CHANNEL_LIMIT_TRIM);
-    RC_Channel_aux::set_servo_limit(RC_Channel_aux::k_none, RC_Channel::RC_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_output_limit(SRV_Channel::k_flap_auto, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_output_limit(SRV_Channel::k_flap, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_output_limit(SRV_Channel::k_aileron, SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
+    SRV_Channels::set_output_limit(SRV_Channel::k_rudder, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_output_limit(SRV_Channel::k_elevator, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_output_limit(SRV_Channel::k_elevator_with_input, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_output_limit(SRV_Channel::k_manual, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_output_limit(SRV_Channel::k_none, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
 
     plane.quadplane.afs_terminate();
     
@@ -48,26 +37,15 @@ void AP_AdvancedFailsafe_Plane::terminate_vehicle(void)
 
 void AP_AdvancedFailsafe_Plane::setup_IO_failsafe(void)
 {
-    const RC_Channel *ch_roll     = RC_Channel::rc_channel(rcmap.roll()-1);
-    const RC_Channel *ch_pitch    = RC_Channel::rc_channel(rcmap.pitch()-1);
-    const RC_Channel *ch_yaw      = RC_Channel::rc_channel(rcmap.yaw()-1);
-    const RC_Channel *ch_throttle = RC_Channel::rc_channel(rcmap.throttle()-1);
-
-    // setup primary channel output values
-    hal.rcout->set_failsafe_pwm(1U<<(rcmap.roll()-1),     ch_roll->get_limit_pwm(RC_Channel::RC_CHANNEL_LIMIT_MIN));
-    hal.rcout->set_failsafe_pwm(1U<<(rcmap.pitch()-1),    ch_pitch->get_limit_pwm(RC_Channel::RC_CHANNEL_LIMIT_MAX));
-    hal.rcout->set_failsafe_pwm(1U<<(rcmap.yaw()-1),      ch_yaw->get_limit_pwm(RC_Channel::RC_CHANNEL_LIMIT_MAX));
-    hal.rcout->set_failsafe_pwm(1U<<(rcmap.throttle()-1), ch_throttle->get_limit_pwm(RC_Channel::RC_CHANNEL_LIMIT_MIN));
-
-    // and all aux channels
-    RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::k_flap_auto, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::k_flap, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::k_aileron, RC_Channel::RC_CHANNEL_LIMIT_MIN);
-    RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::k_rudder, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::k_elevator, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::k_elevator_with_input, RC_Channel::RC_CHANNEL_LIMIT_MAX);
-    RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::k_manual, RC_Channel::RC_CHANNEL_LIMIT_TRIM);
-    RC_Channel_aux::set_servo_failsafe(RC_Channel_aux::k_none, RC_Channel::RC_CHANNEL_LIMIT_TRIM);
+    // all aux channels
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_flap_auto, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_flap, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_aileron, SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_rudder, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_elevator, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_elevator_with_input, SRV_Channel::SRV_CHANNEL_LIMIT_MAX);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_manual, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_none, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
 
     if (plane.quadplane.available()) {
         // setup AP_Motors outputs for failsafe
diff --git a/ArduPlane/control_modes.cpp b/ArduPlane/control_modes.cpp
index 1bff875..926cb97 100644
--- a/ArduPlane/control_modes.cpp
+++ b/ArduPlane/control_modes.cpp
@@ -83,7 +83,7 @@ void Plane::read_control_switch()
             }
         } else if (!override_requested && px4io_override_enabled) {
             px4io_override_enabled = false;
-            RC_Channel_aux::enable_aux_servos();
+            SRV_Channels::enable_aux_servos();
             gcs_send_text(MAV_SEVERITY_WARNING, "PX4IO override disabled");
         }
         if (px4io_override_enabled && 
diff --git a/ArduPlane/failsafe.cpp b/ArduPlane/failsafe.cpp
index b6185e4..5c18dfc 100644
--- a/ArduPlane/failsafe.cpp
+++ b/ArduPlane/failsafe.cpp
@@ -53,26 +53,23 @@ void Plane::failsafe_check(void)
 
         // pass RC inputs to outputs every 20ms
         hal.rcin->clear_overrides();
-        channel_roll->set_radio_out(channel_roll->read());
-        channel_pitch->set_radio_out(channel_pitch->read());
-        if (hal.util->get_soft_armed()) {
-            channel_throttle->set_radio_out(channel_throttle->read());
-        } else {
-            channel_throttle->set_servo_out(0);
-            channel_throttle->calc_pwm();
-        }
-        channel_rudder->set_radio_out(channel_rudder->read());
 
-        int16_t roll = channel_roll->pwm_to_angle_dz(0);
-        int16_t pitch = channel_pitch->pwm_to_angle_dz(0);
-        int16_t rudder = channel_rudder->pwm_to_angle_dz(0);
+        int16_t roll = channel_roll->get_control_in_zero_dz();
+        int16_t pitch = channel_pitch->get_control_in_zero_dz();
+        int16_t throttle = channel_throttle->get_control_in_zero_dz();
+        int16_t rudder = channel_rudder->get_control_in_zero_dz();
 
+        if (!hal.util->get_soft_armed()) {
+            throttle = 0;
+        }
+        
         // setup secondary output channels that don't have
         // corresponding input channels
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_aileron, roll);
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_elevator, pitch);
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_rudder, rudder);
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_steering, rudder);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, roll);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, pitch);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_rudder, rudder);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, rudder);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, throttle);
 
         // this is to allow the failsafe module to deliberately crash 
         // the plane. Only used in extreme circumstances to meet the
@@ -84,11 +81,11 @@ void Plane::failsafe_check(void)
 
         // setup secondary output channels that do have
         // corresponding input channels
-        RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::k_manual, true);
-        RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::k_aileron_with_input, true);
-        RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::k_elevator_with_input, true);
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_flap, 0);
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_flap_auto, 0);
+        SRV_Channels::copy_radio_in_out(SRV_Channel::k_manual, true);
+        SRV_Channels::copy_radio_in_out(SRV_Channel::k_aileron_with_input, true);
+        SRV_Channels::copy_radio_in_out(SRV_Channel::k_elevator_with_input, true);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_flap, 0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_flap_auto, 0);
 
         servos_output();
         
diff --git a/ArduPlane/px4_mixer.cpp b/ArduPlane/px4_mixer.cpp
index 0394284..bb1e8ba 100644
--- a/ArduPlane/px4_mixer.cpp
+++ b/ArduPlane/px4_mixer.cpp
@@ -71,7 +71,7 @@ uint16_t Plane::create_mixer(char *buf, uint16_t buf_size, const char *filename)
     for (uint8_t i=0; i<8; i++) {
         int32_t c1, c2, mix=0;
         bool rev = false;
-        RC_Channel_aux::Aux_servo_function_t function = RC_Channel_aux::channel_function(i);
+        SRV_Channel::Aux_servo_function_t function = SRV_Channels::channel_function(i);
         if (i == rcmap.pitch()-1 && g.vtail_output > MIXING_DISABLED && g.vtail_output <= MIXING_DNDN) {
             // first channel of VTAIL mix
             c1 = rcmap.yaw()-1;
@@ -98,27 +98,27 @@ uint16_t Plane::create_mixer(char *buf, uint16_t buf_size, const char *filename)
             c2 = rcmap.roll()-1;
             rev = false;
             mix = mix_max*mixmul[g.elevon_output][0];
-        } else if (function == RC_Channel_aux::k_aileron || 
-                   function == RC_Channel_aux::k_flaperon1 || 
-                   function == RC_Channel_aux::k_flaperon2) {
+        } else if (function == SRV_Channel::k_aileron || 
+                   function == SRV_Channel::k_flaperon1 || 
+                   function == SRV_Channel::k_flaperon2) {
             // a secondary aileron. We don't mix flap input in yet for flaperons
             c1 = rcmap.roll()-1;
-        } else if (function == RC_Channel_aux::k_elevator) {
+        } else if (function == SRV_Channel::k_elevator) {
             // a secondary elevator
             c1 = rcmap.pitch()-1;
-        } else if (function == RC_Channel_aux::k_rudder || 
-                   function == RC_Channel_aux::k_steering) {
+        } else if (function == SRV_Channel::k_rudder || 
+                   function == SRV_Channel::k_steering) {
             // a secondary rudder or wheel
             c1 = rcmap.yaw()-1;
         } else if (g.flapin_channel > 0 &&
-                   (function == RC_Channel_aux::k_flap ||
-                    function == RC_Channel_aux::k_flap_auto)) {
+                   (function == SRV_Channel::k_flap ||
+                    function == SRV_Channel::k_flap_auto)) {
             // a flap output channel, and we have a manual flap input channel
             c1 = g.flapin_channel-1;
         } else if (i < 4 ||
-                   function == RC_Channel_aux::k_elevator_with_input ||
-                   function == RC_Channel_aux::k_aileron_with_input ||
-                   function == RC_Channel_aux::k_manual) {
+                   function == SRV_Channel::k_elevator_with_input ||
+                   function == SRV_Channel::k_aileron_with_input ||
+                   function == SRV_Channel::k_manual) {
             // a pass-thru channel
             c1 = i;
         } else {
@@ -132,8 +132,8 @@ uint16_t Plane::create_mixer(char *buf, uint16_t buf_size, const char *filename)
             // pass through channel, possibly with reversal. We also
             // adjust the gain based on the range of input and output
             // channels and adjust for trims
-            const RC_Channel *chan1 = RC_Channel::rc_channel(i);
-            const RC_Channel *chan2 = RC_Channel::rc_channel(c1);
+            const RC_Channel *chan1 = RC_Channels::rc_channel(i);
+            const RC_Channel *chan2 = RC_Channels::rc_channel(c1);
             int16_t chan1_trim = (i==rcmap.throttle()-1?1500:chan1->get_radio_trim());
             int16_t chan2_trim = (c1==rcmap.throttle()-1?1500:chan2->get_radio_trim());
             chan1_trim = constrain_int16(chan1_trim, PX4_LIM_RC_MIN+1, PX4_LIM_RC_MAX-1);
@@ -171,8 +171,8 @@ uint16_t Plane::create_mixer(char *buf, uint16_t buf_size, const char *filename)
                 return 0;
             }
         } else {
-            const RC_Channel *chan1 = RC_Channel::rc_channel(c1);
-            const RC_Channel *chan2 = RC_Channel::rc_channel(c2);
+            const RC_Channel *chan1 = RC_Channels::rc_channel(c1);
+            const RC_Channel *chan2 = RC_Channels::rc_channel(c2);
             int16_t chan1_trim = (c1==rcmap.throttle()-1?1500:chan1->get_radio_trim());
             int16_t chan2_trim = (c2==rcmap.throttle()-1?1500:chan2->get_radio_trim());
             chan1_trim = constrain_int16(chan1_trim, PX4_LIM_RC_MIN+1, PX4_LIM_RC_MAX-1);
@@ -268,7 +268,7 @@ bool Plane::setup_failsafe_mixing(void)
     if (old_state == AP_HAL::Util::SAFETY_ARMED) {
         // make sure the throttle has a non-zero failsafe value before we
         // disable safety. This prevents sending zero PWM during switch over
-        hal.rcout->set_safety_pwm(1UL<<(rcmap.throttle()-1), throttle_min());
+        SRV_Channels::set_safety_limit(SRV_Channel::k_throttle, aparm.throttle_min<0?SRV_Channel::SRV_CHANNEL_LIMIT_TRIM:SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
     }
 
     // we need to force safety on to allow us to load a mixer. We call
@@ -294,7 +294,7 @@ bool Plane::setup_failsafe_mixing(void)
     // mix/max/trim. We only do the first 8 channels due to 
     // a RC config limitation in px4io.c limiting to PX4IO_RC_MAPPED_CONTROL_CHANNELS
     for (uint8_t i=0; i<8; i++) {
-        RC_Channel *ch = RC_Channel::rc_channel(i);
+        RC_Channel *ch = RC_Channels::rc_channel(i);
         if (ch == nullptr) {
             continue;
         }
@@ -354,8 +354,8 @@ bool Plane::setup_failsafe_mixing(void)
     }
 
     for (uint8_t i = 0; i < pwm_values.channel_count; i++) {
-        if (RC_Channel_aux::channel_function(i) >= RC_Channel_aux::k_motor1 &&
-            RC_Channel_aux::channel_function(i) <= RC_Channel_aux::k_motor8) {
+        if (SRV_Channels::channel_function(i) >= SRV_Channel::k_motor1 &&
+            SRV_Channels::channel_function(i) <= SRV_Channel::k_motor8) {
             pwm_values.values[i] = quadplane.thr_min_pwm;
         } else {
             pwm_values.values[i] = 900;
@@ -367,8 +367,8 @@ bool Plane::setup_failsafe_mixing(void)
     }
 
     for (uint8_t i = 0; i < pwm_values.channel_count; i++) {
-        if (RC_Channel_aux::channel_function(i) >= RC_Channel_aux::k_motor1 &&
-            RC_Channel_aux::channel_function(i) <= RC_Channel_aux::k_motor8) {
+        if (SRV_Channels::channel_function(i) >= SRV_Channel::k_motor1 &&
+            SRV_Channels::channel_function(i) <= SRV_Channel::k_motor8) {
             hal.rcout->write(i, quadplane.thr_min_pwm);
             pwm_values.values[i] = quadplane.thr_min_pwm;
         } else {
diff --git a/ArduPlane/quadplane.cpp b/ArduPlane/quadplane.cpp
index 1d40b67..edafc16 100644
--- a/ArduPlane/quadplane.cpp
+++ b/ArduPlane/quadplane.cpp
@@ -354,7 +354,7 @@ QuadPlane::QuadPlane(AP_AHRS_NavEKF &_ahrs) :
 void QuadPlane::setup_default_channels(uint8_t num_motors)
 {
     for (uint8_t i=0; i<num_motors; i++) {
-        RC_Channel_aux::set_aux_channel_default((RC_Channel_aux::Aux_servo_function_t)(RC_Channel_aux::k_motor1+i), CH_5+i);
+        SRV_Channels::set_aux_channel_default((SRV_Channel::Aux_servo_function_t)(SRV_Channel::k_motor1+i), CH_5+i);
     }
 }
     
@@ -406,10 +406,10 @@ bool QuadPlane::setup(void)
     }
 
 #if FRAME_CONFIG == TRI_FRAME
-    RC_Channel_aux::set_aux_channel_default(RC_Channel_aux::k_motor1, CH_5);
-    RC_Channel_aux::set_aux_channel_default(RC_Channel_aux::k_motor2, CH_6);
-    RC_Channel_aux::set_aux_channel_default(RC_Channel_aux::k_motor4, CH_8);
-    RC_Channel_aux::set_aux_channel_default(RC_Channel_aux::k_motor7, CH_11);
+    SRV_Channels::set_default_function(CH_5, SRV_Channel::k_motor1);
+    SRV_Channels::set_default_function(CH_6, SRV_Channel::k_motor2);
+    SRV_Channels::set_default_function(CH_8, SRV_Channel::k_motor4);
+    SRV_Channels::set_default_function(CH_11, SRV_Channel::k_motor7);
     frame_class.set(AP_Motors::MOTOR_FRAME_TRI);
     motors = new AP_MOTORS_CLASS(plane.scheduler.get_loop_rate_hz());
 #else
@@ -477,12 +477,9 @@ bool QuadPlane::setup(void)
     // setup the trim of any motors used by AP_Motors so px4io
     // failsafe will disable motors
     for (uint8_t i=0; i<8; i++) {
-        RC_Channel_aux::Aux_servo_function_t func = (RC_Channel_aux::Aux_servo_function_t)(RC_Channel_aux::k_motor1+i);
-        RC_Channel_aux::set_servo_failsafe_pwm(func, thr_min_pwm);
-        uint8_t chan;
-        if (RC_Channel_aux::find_channel(func, chan)) {
-            RC_Channel::rc_channel(chan)->set_radio_trim(thr_min_pwm);
-        }
+        SRV_Channel::Aux_servo_function_t func = (SRV_Channel::Aux_servo_function_t)(SRV_Channel::k_motor1+i);
+        SRV_Channels::set_failsafe_pwm(func, thr_min_pwm);
+        SRV_Channels::set_trim_to_pwm_for(func, thr_min_pwm);
     }
 
 #if HAVE_PX4_MIXER
diff --git a/ArduPlane/radio.cpp b/ArduPlane/radio.cpp
index 0e6cb77..9199e9e 100644
--- a/ArduPlane/radio.cpp
+++ b/ArduPlane/radio.cpp
@@ -11,13 +11,13 @@ void Plane::set_control_channels(void)
     if (g.rudder_only) {
         // in rudder only mode the roll and rudder channels are the
         // same.
-        channel_roll     = RC_Channel::rc_channel(rcmap.yaw()-1);
+        channel_roll = RC_Channels::rc_channel(rcmap.yaw()-1);
     } else {
-        channel_roll     = RC_Channel::rc_channel(rcmap.roll()-1);
+        channel_roll = RC_Channels::rc_channel(rcmap.roll()-1);
     }
-    channel_pitch    = RC_Channel::rc_channel(rcmap.pitch()-1);
-    channel_throttle = RC_Channel::rc_channel(rcmap.throttle()-1);
-    channel_rudder   = RC_Channel::rc_channel(rcmap.yaw()-1);
+    channel_pitch    = RC_Channels::rc_channel(rcmap.pitch()-1);
+    channel_throttle = RC_Channels::rc_channel(rcmap.throttle()-1);
+    channel_rudder   = RC_Channels::rc_channel(rcmap.yaw()-1);
 
     // set rc channel ranges
     channel_roll->set_angle(SERVO_MAX);
@@ -25,19 +25,19 @@ void Plane::set_control_channels(void)
     channel_rudder->set_angle(SERVO_MAX);
     if (aparm.throttle_min >= 0) {
         // normal operation
-        channel_throttle->set_range(0, 100);
+        channel_throttle->set_range(100);
     } else {
         // reverse thrust
         channel_throttle->set_angle(100);
     }
 
     if (!arming.is_armed() && arming.arming_required() == AP_Arming::YES_MIN_PWM) {
-        hal.rcout->set_safety_pwm(1UL<<(rcmap.throttle()-1), throttle_min());
+        SRV_Channels::set_safety_limit(SRV_Channel::k_throttle, aparm.throttle_min<0?SRV_Channel::SRV_CHANNEL_LIMIT_TRIM:SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
     }
 
     // setup correct scaling for ESCs like the UAVCAN PX4ESC which
     // take a proportion of speed
-    g2.servo_channels.set_esc_scaling(channel_throttle->get_ch_out());
+    g2.servo_channels.set_esc_scaling_for(SRV_Channel::k_throttle);
 }
 
 /*
@@ -58,29 +58,24 @@ void Plane::init_rc_in()
  */
 void Plane::init_rc_out_main()
 {
-    // setup failsafe for bottom 4 channels. We don't do all channels
-    // yet as some may be for VTOL motors in a quadplane
-    RC_Channel::setup_failsafe_trim_mask(0x000F);
-    
     /*
       change throttle trim to minimum throttle. This prevents a
       configuration error where the user sets CH3_TRIM incorrectly and
       the motor may start on power up
      */
-    channel_throttle->set_radio_trim(throttle_min());
-
-    channel_roll->enable_out();
-    channel_pitch->enable_out();
-    
-    if (arming.arming_required() != AP_Arming::YES_ZERO_PWM) {
-        channel_throttle->enable_out();
+    if (aparm.throttle_min >= 0) {
+        SRV_Channels::set_trim_to_min_for(SRV_Channel::k_throttle);
     }
-    channel_rudder->enable_out();
 
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_aileron, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_elevator, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_throttle, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_failsafe_limit(SRV_Channel::k_rudder, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    
     // setup PX4 to output the min throttle when safety off if arming
     // is setup for min on disarm
     if (arming.arming_required() == AP_Arming::YES_MIN_PWM) {
-        hal.rcout->set_safety_pwm(1UL<<(rcmap.throttle()-1), throttle_min());
+        SRV_Channels::set_safety_limit(SRV_Channel::k_throttle, aparm.throttle_min<0?SRV_Channel::SRV_CHANNEL_LIMIT_TRIM:SRV_Channel::SRV_CHANNEL_LIMIT_MIN);
     }
 }
 
@@ -90,17 +85,17 @@ void Plane::init_rc_out_main()
 void Plane::init_rc_out_aux()
 {
     update_aux();
-    RC_Channel_aux::enable_aux_servos();
+    SRV_Channels::enable_aux_servos();
 
     hal.rcout->cork();
     
     // Initialization of servo outputs
-    RC_Channel::output_trim_all();
+    SRV_Channels::output_trim_all();
 
     servos_output();
     
     // setup PWM values to send if the FMU firmware dies
-    RC_Channel::setup_failsafe_trim_all();  
+    SRV_Channels::setup_failsafe_trim_all();  
 }
 
 /*
@@ -199,7 +194,7 @@ void Plane::read_radio()
          + BOOL_TO_SIGN(g.reverse_ch1_elevon) * int16_t(elevon.ch1_temp - elevon.trim1)) / 2 + 1500;
     }
 
-    RC_Channel::set_pwm_all();
+    RC_Channels::set_pwm_all();
     
     if (control_mode == TRAINING) {
         // in training mode we don't want to use a deadzone, as we
@@ -215,10 +210,10 @@ void Plane::read_radio()
 
     control_failsafe(channel_throttle->get_radio_in());
 
-    channel_throttle->set_servo_out(channel_throttle->get_control_in());
+    SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, channel_throttle->get_control_in());
 
-    if (g.throttle_nudge && channel_throttle->get_servo_out() > 50 && geofence_stickmixing()) {
-        float nudge = (channel_throttle->get_servo_out() - 50) * 0.02f;
+    if (g.throttle_nudge && SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) > 50 && geofence_stickmixing()) {
+        float nudge = (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) - 50) * 0.02f;
         if (ahrs.airspeed_sensor_enabled()) {
             airspeed_nudge_cm = (aparm.airspeed_max * 100 - aparm.airspeed_cruise_cm) * nudge;
         } else {
@@ -326,8 +321,8 @@ void Plane::trim_control_surfaces()
         // the secondary aileron/elevator is trimmed only if it has a
         // corresponding transmitter input channel, which k_aileron
         // doesn't have
-        RC_Channel_aux::set_trim_to_radio_in_for(RC_Channel_aux::k_aileron_with_input);
-        RC_Channel_aux::set_trim_to_radio_in_for(RC_Channel_aux::k_elevator_with_input);
+        SRV_Channels::set_trim_to_radio_in_for(SRV_Channel::k_aileron_with_input);
+        SRV_Channels::set_trim_to_radio_in_for(SRV_Channel::k_elevator_with_input);
     } else{
         if (elevon.ch1_temp != 0) {
             elevon.trim1 = elevon.ch1_temp;
@@ -349,8 +344,6 @@ void Plane::trim_control_surfaces()
     channel_roll->save_eeprom();
     channel_pitch->save_eeprom();
     channel_rudder->save_eeprom();
-
-    g2.servo_channels.set_trim();
 }
 
 void Plane::trim_radio()
diff --git a/ArduPlane/sensors.cpp b/ArduPlane/sensors.cpp
index c730dac..eb7dded 100644
--- a/ArduPlane/sensors.cpp
+++ b/ArduPlane/sensors.cpp
@@ -351,7 +351,7 @@ void Plane::update_sensor_status_flags(void)
         }
     }
 
-    if (aparm.throttle_min < 0 && channel_throttle->get_servo_out() < 0) {
+    if (aparm.throttle_min < 0 && SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) < 0) {
         control_sensors_enabled |= MAV_SYS_STATUS_REVERSE_MOTOR;
         control_sensors_health |= MAV_SYS_STATUS_REVERSE_MOTOR;
     }
diff --git a/ArduPlane/servos.cpp b/ArduPlane/servos.cpp
index 2058adf..00e81fe 100644
--- a/ArduPlane/servos.cpp
+++ b/ArduPlane/servos.cpp
@@ -22,7 +22,7 @@
 /*****************************************
 * Throttle slew limit
 *****************************************/
-void Plane::throttle_slew_limit(int16_t last_throttle)
+void Plane::throttle_slew_limit(void)
 {
     uint8_t slewrate = aparm.throttle_slewrate;
     if (control_mode==AUTO) {
@@ -34,34 +34,8 @@ void Plane::throttle_slew_limit(int16_t last_throttle)
     }
     // if slew limit rate is set to zero then do not slew limit
     if (slewrate) {                   
-        // limit throttle change by the given percentage per second
-        float temp = slewrate * G_Dt * 0.01f * fabsf(channel_throttle->get_radio_max() - channel_throttle->get_radio_min());
-        // allow a minimum change of 1 PWM per cycle
-        if (temp < 1) {
-            temp = 1;
-        }
-        channel_throttle->set_radio_out(constrain_int16(channel_throttle->get_radio_out(), last_throttle - temp, last_throttle + temp));
-    }
-}
-
-/*****************************************
-Flap slew limit
-*****************************************/
-void Plane::flap_slew_limit(int8_t &last_value, int8_t &new_value)
-{
-    uint8_t slewrate = g.flap_slewrate;
-    // if slew limit rate is set to zero then do not slew limit
-    if (slewrate) {                   
-        // limit flap change by the given percentage per second
-        float temp = slewrate * G_Dt;
-        // allow a minimum change of 1% per cycle. This means the
-        // slowest flaps we can do is full change over 2 seconds
-        if (temp < 1) {
-            temp = 1;
-        }
-        new_value = constrain_int16(new_value, last_value - temp, last_value + temp);
+        SRV_Channels::limit_slew_rate(SRV_Channel::k_throttle, slewrate);
     }
-    last_value = new_value;
 }
 
 /* We want to suppress the throttle if we think we are on the ground and in an autopilot controlled throttle mode.
@@ -156,7 +130,7 @@ bool Plane::suppress_throttle(void)
 /*
   implement a software VTail or elevon mixer. There are 4 different mixing modes
  */
-void Plane::channel_output_mixer(uint8_t mixing_type, int16_t & chan1_out, int16_t & chan2_out)const
+void Plane::channel_output_mixer_pwm(uint8_t mixing_type, uint16_t & chan1_out, uint16_t & chan2_out) const
 {
     int16_t c1, c2;
     int16_t v1, v2;
@@ -227,27 +201,38 @@ void Plane::channel_output_mixer(uint8_t mixing_type, int16_t & chan1_out, int16
     chan2_out = 1500 + v2;
 }
 
-void Plane::channel_output_mixer(uint8_t mixing_type, RC_Channel* chan1, RC_Channel* chan2)const
+/*
+  output mixer based on two channel output types
+ */
+void Plane::channel_output_mixer(uint8_t mixing_type, SRV_Channel::Aux_servo_function_t func1, SRV_Channel::Aux_servo_function_t func2)
 {
-   int16_t ch1 = chan1->get_radio_out();
-   int16_t ch2 = chan2->get_radio_out();
+    SRV_Channel *chan1, *chan2;
+    if (!(chan1 = SRV_Channels::get_channel_for(func1)) ||
+        !(chan2 = SRV_Channels::get_channel_for(func2))) {
+        return;
+    }
 
-   channel_output_mixer(mixing_type,ch1,ch2);
+    uint16_t chan1_out, chan2_out;
+    chan1_out = chan1->get_output_pwm();
+    chan2_out = chan2->get_output_pwm();
+    
+    channel_output_mixer_pwm(mixing_type, chan1_out, chan2_out);
 
-   chan1->set_radio_out(ch1);
-   chan2->set_radio_out(ch2);
+    chan1->set_output_pwm(chan1_out);
+    chan2->set_output_pwm(chan2_out);
 }
 
+
 /*
   setup flaperon output channels
  */
 void Plane::flaperon_update(int8_t flap_percent)
 {
-    if (!RC_Channel_aux::function_assigned(RC_Channel_aux::k_flaperon1) ||
-        !RC_Channel_aux::function_assigned(RC_Channel_aux::k_flaperon2)) {
+    if (!SRV_Channels::function_assigned(SRV_Channel::k_flaperon1) ||
+        !SRV_Channels::function_assigned(SRV_Channel::k_flaperon2)) {
         return;
     }
-    int16_t ch1, ch2;
+    uint16_t ch1, ch2;
     /*
       flaperons are implemented as a mixer between aileron and a
       percentage of flaps. Flap input can come from a manual channel
@@ -258,12 +243,14 @@ void Plane::flaperon_update(int8_t flap_percent)
       by mixing gain). flapin_channel's trim is not used.
      */
      
-    ch1 = channel_roll->get_radio_out();
+    if (!SRV_Channels::get_output_pwm(SRV_Channel::k_aileron, ch1)) {
+        return;
+    }
     // The *5 is to take a percentage to a value from -500 to 500 for the mixer
     ch2 = 1500 - flap_percent * 5;
-    channel_output_mixer(g.flaperon_output, ch1, ch2);
-    RC_Channel_aux::set_radio_trimmed(RC_Channel_aux::k_flaperon1, ch1);
-    RC_Channel_aux::set_radio_trimmed(RC_Channel_aux::k_flaperon2, ch2);
+    channel_output_mixer_pwm(g.flaperon_output, ch1, ch2);
+    SRV_Channels::set_output_pwm_trimmed(SRV_Channel::k_flaperon1, ch1);
+    SRV_Channels::set_output_pwm_trimmed(SRV_Channel::k_flaperon2, ch2);
 }
 
 /*
@@ -273,9 +260,8 @@ void Plane::flaperon_update(int8_t flap_percent)
  */
 void Plane::set_servos_idle(void)
 {
-    RC_Channel_aux::output_ch_all();
     if (auto_state.idle_wiggle_stage == 0) {
-        RC_Channel::output_trim_all();
+        SRV_Channels::output_trim_all();
         return;
     }
     int16_t servo_value = 0;
@@ -292,57 +278,29 @@ void Plane::set_servos_idle(void)
     } else {
         auto_state.idle_wiggle_stage = 0;
     }
-    channel_roll->set_servo_out(servo_value);
-    channel_pitch->set_servo_out(servo_value);
-    channel_rudder->set_servo_out(servo_value);
-    channel_roll->calc_pwm();
-    channel_pitch->calc_pwm();
-    channel_rudder->calc_pwm();
-    channel_throttle->output_trim();
-}
-
-/*
-  return minimum throttle PWM value, taking account of throttle reversal. For reverse thrust you get the throttle off position
- */
-uint16_t Plane::throttle_min(void) const
-{
-    if (aparm.throttle_min < 0) {
-        return channel_throttle->get_radio_trim();
-    }
-    return channel_throttle->get_reverse() ? channel_throttle->get_radio_max() : channel_throttle->get_radio_min();
-};
+    SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, servo_value);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, servo_value);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_rudder, servo_value);
+    SRV_Channels::set_output_to_trim(SRV_Channel::k_throttle);
 
+    SRV_Channels::output_ch_all();
+}
 
 /*
   pass through channels in manual mode
  */
 void Plane::set_servos_manual_passthrough(void)
 {
-    // do a direct pass through of radio values
-    if (g.mix_mode == 0 || g.elevon_output != MIXING_DISABLED) {
-        channel_roll->set_radio_out(channel_roll->get_radio_in());
-        channel_pitch->set_radio_out(channel_pitch->get_radio_in());
-    } else {
-        channel_roll->set_radio_out(channel_roll->read());
-        channel_pitch->set_radio_out(channel_pitch->read());
-    }
-    channel_throttle->set_radio_out(channel_throttle->get_radio_in());
-    channel_rudder->set_radio_out(channel_rudder->get_radio_in());
-    
-    // setup extra channels. We want this to come from the
-    // main input channel, but using the 2nd channels dead
-    // zone, reverse and min/max settings. We need to use
-    // pwm_to_angle_dz() to ensure we don't trim the value for the
-    // deadzone of the main aileron channel, otherwise the 2nd
-    // aileron won't quite follow the first one
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_aileron, channel_roll->pwm_to_angle_dz(0));
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_elevator, channel_pitch->pwm_to_angle_dz(0));
+    SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, channel_roll->get_control_in_zero_dz());
+    SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, channel_pitch->get_control_in_zero_dz());
+    SRV_Channels::set_output_scaled(SRV_Channel::k_rudder, channel_rudder->get_control_in_zero_dz());
+    SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, channel_throttle->get_control_in_zero_dz());
     
     // this variant assumes you have the corresponding
     // input channel setup in your transmitter for manual control
     // of the 2nd aileron
-    RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::k_aileron_with_input);
-    RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::k_elevator_with_input);
+    SRV_Channels::copy_radio_in_out(SRV_Channel::k_aileron_with_input);
+    SRV_Channels::copy_radio_in_out(SRV_Channel::k_elevator_with_input);
 }
 
 /*
@@ -353,8 +311,10 @@ void Plane::set_servos_old_elevons(void)
     /*Elevon mode*/
     float ch1;
     float ch2;
-    ch1 = channel_pitch->get_servo_out() - (BOOL_TO_SIGN(g.reverse_elevons) * channel_roll->get_servo_out());
-    ch2 = channel_pitch->get_servo_out() + (BOOL_TO_SIGN(g.reverse_elevons) * channel_roll->get_servo_out());
+    int16_t roll  = SRV_Channels::get_output_scaled(SRV_Channel::k_aileron);
+    int16_t pitch = SRV_Channels::get_output_scaled(SRV_Channel::k_elevator);
+    ch1 = pitch - (BOOL_TO_SIGN(g.reverse_elevons) * roll);
+    ch2 = pitch + (BOOL_TO_SIGN(g.reverse_elevons) * roll);
     
     /* Differential Spoilers
        If differential spoilers are setup, then we translate
@@ -362,23 +322,24 @@ void Plane::set_servos_old_elevons(void)
        the side of the aircraft where we want to induce
        additional drag.
     */
-    if (RC_Channel_aux::function_assigned(RC_Channel_aux::k_dspoiler1) && RC_Channel_aux::function_assigned(RC_Channel_aux::k_dspoiler2)) {
+    if (SRV_Channels::function_assigned(SRV_Channel::k_dspoiler1) && SRV_Channels::function_assigned(SRV_Channel::k_dspoiler2)) {
         float ch3 = ch1;
         float ch4 = ch2;
-        if ( BOOL_TO_SIGN(g.reverse_elevons) * channel_rudder->get_servo_out() < 0) {
-            ch1 += abs(channel_rudder->get_servo_out());
-            ch3 -= abs(channel_rudder->get_servo_out());
+        int16_t rudder = SRV_Channels::get_output_scaled(SRV_Channel::k_rudder);
+        if (BOOL_TO_SIGN(g.reverse_elevons) * rudder < 0) {
+            ch1 += abs(rudder);
+            ch3 -= abs(rudder);
         } else {
-            ch2 += abs(channel_rudder->get_servo_out());
-            ch4 -= abs(channel_rudder->get_servo_out());
+            ch2 += abs(rudder);
+            ch4 -= abs(rudder);
         }
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_dspoiler1, ch3);
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_dspoiler2, ch4);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_dspoiler1, ch3);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_dspoiler2, ch4);
     }
     
     // directly set the radio_out values for elevon mode
-    channel_roll->set_radio_out(elevon.trim1 + (BOOL_TO_SIGN(g.reverse_ch1_elevon) * (ch1 * 500.0f/ SERVO_MAX)));
-    channel_pitch->set_radio_out(elevon.trim2 + (BOOL_TO_SIGN(g.reverse_ch2_elevon) * (ch2 * 500.0f/ SERVO_MAX)));
+    SRV_Channels::set_output_pwm_first(SRV_Channel::k_aileron, elevon.trim1 + (BOOL_TO_SIGN(g.reverse_ch1_elevon) * (ch1 * 500.0f/ SERVO_MAX)));
+    SRV_Channels::set_output_pwm_first(SRV_Channel::k_elevator, elevon.trim2 + (BOOL_TO_SIGN(g.reverse_ch2_elevon) * (ch2 * 500.0f/ SERVO_MAX)));
 }
 
 
@@ -392,14 +353,14 @@ void Plane::throttle_watt_limiter(int8_t &min_throttle, int8_t &max_throttle)
         // overpower detected, cut back on the throttle if we're maxing it out by calculating a limiter value
         // throttle limit will attack by 10% per second
         
-        if (channel_throttle->get_servo_out() > 0 && // demanding too much positive thrust
+        if (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) > 0 && // demanding too much positive thrust
             throttle_watt_limit_max < max_throttle - 25 &&
             now - throttle_watt_limit_timer_ms >= 1) {
             // always allow for 25% throttle available regardless of battery status
             throttle_watt_limit_timer_ms = now;
             throttle_watt_limit_max++;
             
-        } else if (channel_throttle->get_servo_out() < 0 &&
+        } else if (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) < 0 &&
                    min_throttle < 0 && // reverse thrust is available
                    throttle_watt_limit_min < -(min_throttle) - 25 &&
                    now - throttle_watt_limit_timer_ms >= 1) {
@@ -412,12 +373,12 @@ void Plane::throttle_watt_limiter(int8_t &min_throttle, int8_t &max_throttle)
         // it has been 1 second since last over-current, check if we can resume higher throttle.
         // this throttle release is needed to allow raising the max_throttle as the battery voltage drains down
         // throttle limit will release by 1% per second
-        if (channel_throttle->get_servo_out() > throttle_watt_limit_max && // demanding max forward thrust
+        if (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) > throttle_watt_limit_max && // demanding max forward thrust
             throttle_watt_limit_max > 0) { // and we're currently limiting it
             throttle_watt_limit_timer_ms = now;
             throttle_watt_limit_max--;
             
-        } else if (channel_throttle->get_servo_out() < throttle_watt_limit_min && // demanding max negative thrust
+        } else if (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) < throttle_watt_limit_min && // demanding max negative thrust
                    throttle_watt_limit_min > 0) { // and we're limiting it
             throttle_watt_limit_timer_ms = now;
             throttle_watt_limit_min--;
@@ -441,20 +402,12 @@ void Plane::set_servos_controlled(void)
         set_servos_old_elevons();
     } else {
         // both types of secondary aileron are slaved to the roll servo out
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_aileron, channel_roll->get_servo_out());
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_aileron_with_input, channel_roll->get_servo_out());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_aileron_with_input, SRV_Channels::get_output_scaled(SRV_Channel::k_aileron));
         
         // both types of secondary elevator are slaved to the pitch servo out
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_elevator, channel_pitch->get_servo_out());
-        RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_elevator_with_input, channel_pitch->get_servo_out());
-
-        // push out the PWM values
-        channel_roll->calc_pwm();
-        channel_pitch->calc_pwm();
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator_with_input, SRV_Channels::get_output_scaled(SRV_Channel::k_elevator));
     }
 
-    channel_rudder->calc_pwm();
-    
     // convert 0 to 100% (or -100 to +100) into PWM
     int8_t min_throttle = aparm.throttle_min.get();
     int8_t max_throttle = aparm.throttle_max.get();
@@ -477,25 +430,25 @@ void Plane::set_servos_controlled(void)
             }
         }
     }
-
+    
     // apply watt limiter
     throttle_watt_limiter(min_throttle, max_throttle);
-
-    channel_throttle->set_servo_out(constrain_int16(channel_throttle->get_servo_out(), 
-                                                    min_throttle,
-                                                    max_throttle));
+    
+    SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,
+                                    constrain_int16(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle), min_throttle, max_throttle));
     
     if (!hal.util->get_soft_armed()) {
-        channel_throttle->set_servo_out(0);
-        channel_throttle->calc_pwm();
+        if (arming.arming_required() == AP_Arming::YES_ZERO_PWM) {
+            SRV_Channels::set_output_limit(SRV_Channel::k_throttle, SRV_Channel::SRV_CHANNEL_LIMIT_ZERO_PWM);
+        } else {
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);
+        }
     } else if (suppress_throttle()) {
         // throttle is suppressed in auto mode
-        channel_throttle->set_servo_out(0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);
         if (g.throttle_suppress_manual) {
             // manual pass through of throttle while throttle is suppressed
-            channel_throttle->set_radio_out(channel_throttle->get_radio_in());
-        } else {
-            channel_throttle->calc_pwm();
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, channel_throttle->get_control_in_zero_dz());
         }
     } else if (g.throttle_passthru_stabilize && 
                (control_mode == STABILIZE || 
@@ -506,18 +459,14 @@ void Plane::set_servos_controlled(void)
                !failsafe.ch3_counter) {
         // manual pass through of throttle while in FBWA or
         // STABILIZE mode with THR_PASS_STAB set
-        channel_throttle->set_radio_out(channel_throttle->get_radio_in());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, channel_throttle->get_control_in_zero_dz());
     } else if ((control_mode == GUIDED || control_mode == AVOID_ADSB) &&
                guided_throttle_passthru) {
         // manual pass through of throttle while in GUIDED
-        channel_throttle->set_radio_out(channel_throttle->get_radio_in());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, channel_throttle->get_control_in_zero_dz());
     } else if (quadplane.in_vtol_mode()) {
         // ask quadplane code for forward throttle
-        channel_throttle->set_servo_out(quadplane.forward_throttle_pct());
-        channel_throttle->calc_pwm();
-    } else {
-        // normal throttle calculation based on servo_out
-        channel_throttle->calc_pwm();
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, quadplane.forward_throttle_pct());
     }
 }
 
@@ -529,11 +478,9 @@ void Plane::set_servos_flaps(void)
     // Auto flap deployment
     int8_t auto_flap_percent = 0;
     int8_t manual_flap_percent = 0;
-    static int8_t last_auto_flap;
-    static int8_t last_manual_flap;
 
     // work out any manual flap input
-    RC_Channel *flapin = RC_Channel::rc_channel(g.flapin_channel-1);
+    RC_Channel *flapin = RC_Channels::rc_channel(g.flapin_channel-1);
     if (flapin != nullptr && !failsafe.ch3_failsafe && failsafe.ch3_counter == 0) {
         flapin->input();
         manual_flap_percent = flapin->percent_input();
@@ -589,11 +536,13 @@ void Plane::set_servos_flaps(void)
         auto_flap_percent = manual_flap_percent;
     }
 
-    flap_slew_limit(last_auto_flap, auto_flap_percent);
-    flap_slew_limit(last_manual_flap, manual_flap_percent);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_flap_auto, auto_flap_percent);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_flap, manual_flap_percent);
 
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_flap_auto, auto_flap_percent);
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_flap, manual_flap_percent);
+    if (g.flap_slewrate) {
+        SRV_Channels::limit_slew_rate(SRV_Channel::k_flap_auto, g.flap_slewrate);
+        SRV_Channels::limit_slew_rate(SRV_Channel::k_flap, g.flap_slewrate);
+    }    
 
     if (g.flaperon_output != MIXING_DISABLED && g.elevon_output == MIXING_DISABLED && g.mix_mode == 0) {
         flaperon_update(auto_flap_percent);
@@ -608,20 +557,22 @@ void Plane::set_servos_flaps(void)
 void Plane::servo_output_mixers(void)
 {
     if (g.vtail_output != MIXING_DISABLED) {
-        channel_output_mixer(g.vtail_output, channel_pitch, channel_rudder);
+        channel_output_mixer(g.vtail_output, SRV_Channel::k_elevator, SRV_Channel::k_rudder);
     } else if (g.elevon_output != MIXING_DISABLED) {
-        channel_output_mixer(g.elevon_output, channel_pitch, channel_roll);
+        channel_output_mixer(g.elevon_output, SRV_Channel::k_elevator, SRV_Channel::k_aileron);
         // if (both) differential spoilers setup then apply rudder
         //  control into splitting the two elevons on the side of
         //  the aircraft where we want to induce additional drag:
-        if (RC_Channel_aux::function_assigned(RC_Channel_aux::k_dspoiler1) &&
-            RC_Channel_aux::function_assigned(RC_Channel_aux::k_dspoiler2)) {
-            int16_t ch3 = channel_roll->get_radio_out();    //diff spoiler 1
-            int16_t ch4 = channel_pitch->get_radio_out();   //diff spoiler 2
+        uint16_t ch3, ch4;
+        
+        if (SRV_Channels::function_assigned(SRV_Channel::k_dspoiler1) &&
+            SRV_Channels::function_assigned(SRV_Channel::k_dspoiler2) &&
+            SRV_Channels::get_output_pwm(SRV_Channel::k_aileron, ch3) &&
+            SRV_Channels::get_output_pwm(SRV_Channel::k_elevator, ch4)) {
             // convert rudder-servo output (-4500 to 4500) to PWM offset
             //  value (-500 to 500) and multiply by DSPOILR_RUD_RATE/100
             //  (rudder->servo_out * 500 / SERVO_MAX * dspoiler_rud_rate/100):
-            int16_t ruddVal = (int16_t)((int32_t)(channel_rudder->get_servo_out()) *
+            int16_t ruddVal = (int16_t)(int32_t(SRV_Channels::get_output_scaled(SRV_Channel::k_rudder)) *
                                         g.dspoiler_rud_rate / (SERVO_MAX/5));
             if (ruddVal != 0) {   //if nonzero rudder then apply to spoilers
                 int16_t ch1 = ch3;          //elevon 1
@@ -634,8 +585,8 @@ void Plane::servo_output_mixers(void)
                     ch4 -= ruddVal;
                 }
                 // change elevon 1 & 2 positions; constrain min/max:
-                channel_roll->set_radio_out(constrain_int16(ch1, 900, 2100));
-                channel_pitch->set_radio_out(constrain_int16(ch2, 900, 2100));
+                SRV_Channels::set_output_pwm_first(SRV_Channel::k_aileron, constrain_int16(ch1, 900, 2100));
+                SRV_Channels::set_output_pwm_first(SRV_Channel::k_elevator, constrain_int16(ch2, 900, 2100));
                 // constrain min/max for intermediate dspoiler positions:
                 ch3 = constrain_int16(ch3, 900, 2100);
                 ch4 = constrain_int16(ch4, 900, 2100);
@@ -643,10 +594,10 @@ void Plane::servo_output_mixers(void)
             // set positions of differential spoilers (convert PWM
             //  900-2100 range to servo output (-4500 to 4500)
             //  and use function that supports rev/min/max/trim):
-            RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_dspoiler1,
-                                              (ch3-(int16_t)1500) * (int16_t)(SERVO_MAX/300) / (int16_t)2);
-            RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_dspoiler2,
-                                              (ch4-(int16_t)1500) * (int16_t)(SERVO_MAX/300) / (int16_t)2);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_dspoiler1,
+                                                (int16_t(ch3)-1500) * (int16_t)(SERVO_MAX/300) / (int16_t)2);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_dspoiler2,
+                                                (int16_t(ch4)-1500) * (int16_t)(SERVO_MAX/300) / (int16_t)2);
         }
     }
 }
@@ -679,8 +630,6 @@ void Plane::set_servos(void)
         return;
     }
 
-    int16_t last_throttle = channel_throttle->get_radio_out();
-
     // do any transition updates for quadplane
     quadplane.update();    
 
@@ -699,19 +648,23 @@ void Plane::set_servos(void)
         // wheel to the rudder just in case the barometer has drifted
         // a lot
         steering_control.steering = steering_control.rudder;
-    } else if (!RC_Channel_aux::function_assigned(RC_Channel_aux::k_steering)) {
+    } else if (!SRV_Channels::function_assigned(SRV_Channel::k_steering)) {
         // we are within the ground steering altitude but don't have a
         // dedicated steering channel. Set the rudder to the ground
         // steering output
         steering_control.rudder = steering_control.steering;
     }
-    channel_rudder->set_servo_out(steering_control.rudder);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_rudder, steering_control.rudder);
 
     // clear ground_steering to ensure manual control if the yaw stabilizer doesn't run
     steering_control.ground_steering = false;
 
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_rudder, steering_control.rudder);
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_steering, steering_control.steering);
+    if (control_mode == TRAINING) {
+        steering_control.rudder = channel_rudder->get_control_in();
+    }
+    
+    SRV_Channels::set_output_scaled(SRV_Channel::k_rudder, steering_control.rudder);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_steering, steering_control.steering);
 
     if (control_mode == MANUAL) {
         set_servos_manual_passthrough();
@@ -727,12 +680,7 @@ void Plane::set_servos(void)
         quadplane.in_vtol_mode()) {
         /* only do throttle slew limiting in modes where throttle
          *  control is automatic */
-        throttle_slew_limit(last_throttle);
-    }
-
-    if (control_mode == TRAINING) {
-        // copy rudder in training mode
-        channel_rudder->set_radio_out(channel_rudder->get_radio_in());
+        throttle_slew_limit();
     }
 
     if (!arming.is_armed()) {
@@ -745,14 +693,12 @@ void Plane::set_servos(void)
             break;
 
         case AP_Arming::YES_ZERO_PWM:
-            channel_throttle->set_servo_out(0);
-            channel_throttle->set_radio_out(0);
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle, 0);
             break;
 
         case AP_Arming::YES_MIN_PWM:
         default:
-            channel_throttle->set_servo_out(0);
-            channel_throttle->set_radio_out(throttle_min());
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);
             break;
         }
     }
@@ -778,26 +724,22 @@ void Plane::set_servos(void)
         // after an auto land and auto disarm, set the servos to be neutral just
         // in case we're upside down or some crazy angle and straining the servos.
         if (landing.get_then_servos_neutral() == 1) {
-            channel_roll->set_radio_out(channel_roll->get_radio_trim());
-            channel_pitch->set_radio_out(channel_pitch->get_radio_trim());
-            channel_rudder->set_radio_out(channel_rudder->get_radio_trim());
+            SRV_Channels::set_output_limit(SRV_Channel::k_aileron, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+            SRV_Channels::set_output_limit(SRV_Channel::k_elevator, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+            SRV_Channels::set_output_limit(SRV_Channel::k_rudder, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
         } else if (landing.get_then_servos_neutral() == 2) {
-            channel_roll->disable_out();
-            channel_pitch->disable_out();
-            channel_rudder->disable_out();
+            SRV_Channels::set_output_limit(SRV_Channel::k_aileron, SRV_Channel::SRV_CHANNEL_LIMIT_ZERO_PWM);
+            SRV_Channels::set_output_limit(SRV_Channel::k_elevator, SRV_Channel::SRV_CHANNEL_LIMIT_ZERO_PWM);
+            SRV_Channels::set_output_limit(SRV_Channel::k_rudder, SRV_Channel::SRV_CHANNEL_LIMIT_ZERO_PWM);
         }
     }
 
     uint8_t override_pct;
     if (g2.ice_control.throttle_override(override_pct)) {
         // the ICE controller wants to override the throttle for starting
-        channel_throttle->set_servo_out(override_pct);
-        channel_throttle->calc_pwm();
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, override_pct);
     }
 
-    // allow for secondary throttle
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_throttle, channel_throttle->get_servo_out());
-    
     // run output mixer and send values to the hal for output
     servos_output();
 }
@@ -812,30 +754,15 @@ void Plane::servos_output(void)
 {
     hal.rcout->cork();
 
-    // to enable the throttle slew rate to work we need to remember
-    // and restore the throttle radio_out
-    uint16_t thr_radio_out_saved = channel_throttle->get_radio_out();
-    
-    // remap servo output to SERVO* ranges if enabled
-    g2.servo_channels.remap_servo_output();
-
     // run vtail and elevon mixers
     servo_output_mixers();
 
-    channel_roll->output();
-    channel_pitch->output();
-    channel_throttle->output();
-    channel_rudder->output();
-
-    if (!afs.should_crash_vehicle()) {
-        RC_Channel_aux::output_ch_all();
-    }
+    SRV_Channels::calc_pwm();
+    
+    SRV_Channels::output_ch_all();
     
     hal.rcout->push();
 
-    // restore throttle radio out
-    channel_throttle->set_radio_out(thr_radio_out_saved);
-    
     if (g2.servo_channels.auto_trim_enabled()) {
         servos_auto_trim();
     }
@@ -848,10 +775,6 @@ void Plane::servos_output(void)
  */
 void Plane::servos_auto_trim(void)
 {
-    if (!g2.servo_channels.enabled()) {
-        // only possible with SERVO_RNG_ENABLE=1
-        return;
-    }
     // only in auto modes and FBWA
     if (!auto_throttle_mode && control_mode != FLY_BY_WIRE_A) {
         return;
@@ -881,8 +804,8 @@ void Plane::servos_auto_trim(void)
     }
 
     // adjust trim on channels by a small amount according to I value
-    g2.servo_channels.adjust_trim(channel_roll->get_ch_out(), rollController.get_pid_info().I);
-    g2.servo_channels.adjust_trim(channel_pitch->get_ch_out(), pitchController.get_pid_info().I);
+    g2.servo_channels.adjust_trim(SRV_Channel::k_aileron, rollController.get_pid_info().I);
+    g2.servo_channels.adjust_trim(SRV_Channel::k_elevator, pitchController.get_pid_info().I);
 
     auto_trim.last_trim_check = now;
 
diff --git a/ArduPlane/system.cpp b/ArduPlane/system.cpp
index 4017582..d47a327 100644
--- a/ArduPlane/system.cpp
+++ b/ArduPlane/system.cpp
@@ -742,23 +742,6 @@ void Plane::print_comma(void)
 #endif
 
 /*
-  write to a servo
- */
-void Plane::servo_write(uint8_t ch, uint16_t pwm)
-{
-#if HIL_SUPPORT
-    if (g.hil_mode==1 && !g.hil_servos) {
-        if (ch < 8) {
-            RC_Channel::rc_channel(ch)->set_radio_out(pwm);
-        }
-        return;
-    }
-#endif
-    hal.rcout->enable_ch(ch);
-    hal.rcout->write(ch, pwm);
-}
-
-/*
   should we log a message type now?
  */
 bool Plane::should_log(uint32_t mask)
@@ -787,11 +770,12 @@ int8_t Plane::throttle_percentage(void)
     }
     // to get the real throttle we need to use norm_output() which
     // returns a number from -1 to 1.
+    float throttle = SRV_Channels::get_output_norm(SRV_Channel::k_throttle);
     if (aparm.throttle_min >= 0) {
-        return constrain_int16(50*(channel_throttle->norm_output()+1), 0, 100);
+        return constrain_int16(100*throttle, 0, 100);
     } else {
         // reverse thrust
-        return constrain_int16(100*channel_throttle->norm_output(), -100, 100);
+        return constrain_int16(100*throttle, -100, 100);
     }
 }
 
@@ -814,9 +798,6 @@ bool Plane::arm_motors(AP_Arming::ArmingMethod method)
         return false;
     }
 
-    // only log if arming was successful
-    channel_throttle->enable_out();
-
     change_arm_state();
     return true;
 }
@@ -829,9 +810,6 @@ bool Plane::disarm_motors(void)
     if (!arming.disarm()) {
         return false;
     }
-    if (arming.arming_required() == AP_Arming::YES_ZERO_PWM) {
-        channel_throttle->disable_out();  
-    }
     if (control_mode != AUTO) {
         // reset the mission on disarm if we are not in auto
         mission.reset();
diff --git a/ArduPlane/test.cpp b/ArduPlane/test.cpp
index 6234855..ef70ffc 100644
--- a/ArduPlane/test.cpp
+++ b/ArduPlane/test.cpp
@@ -7,15 +7,6 @@
 // User enters the string in the console to call the functions on the right.
 // See class Menu in AP_Common for implementation details
 static const struct Menu::command test_menu_commands[] = {
-    {"pwm",                 MENU_FUNC(test_radio_pwm)},
-    {"radio",               MENU_FUNC(test_radio)},
-    {"passthru",            MENU_FUNC(test_passthru)},
-    {"failsafe",            MENU_FUNC(test_failsafe)},
-    {"relay",               MENU_FUNC(test_relay)},
-    {"waypoints",           MENU_FUNC(test_wp)},
-    {"xbee",                MENU_FUNC(test_xbee)},
-    {"modeswitch",          MENU_FUNC(test_modeswitch)},
-
     // Tests below here are for hardware sensors only present
     // when real sensors are attached or they are emulated
     {"gps",                 MENU_FUNC(test_gps)},
@@ -45,251 +36,6 @@ void Plane::print_hit_enter()
     cliSerial->printf("Hit Enter to exit.\n\n");
 }
 
-int8_t Plane::test_radio_pwm(uint8_t argc, const Menu::arg *argv)
-{
-    print_hit_enter();
-    hal.scheduler->delay(1000);
-
-    while(1) {
-        hal.scheduler->delay(20);
-
-        // Filters radio input - adjust filters in the radio.cpp file
-        // ----------------------------------------------------------
-        read_radio();
-
-        cliSerial->printf("IN:\t1: %d\t2: %d\t3: %d\t4: %d\t5: %d\t6: %d\t7: %d\t8: %d\n",
-                        (int)channel_roll->get_radio_in(),
-                        (int)channel_pitch->get_radio_in(),
-                        (int)channel_throttle->get_radio_in(),
-                        (int)channel_rudder->get_radio_in(),
-                        (int)g.rc_5.get_radio_in(),
-                        (int)g.rc_6.get_radio_in(),
-                        (int)g.rc_7.get_radio_in(),
-                        (int)g.rc_8.get_radio_in());
-
-        if(cliSerial->available() > 0) {
-            return (0);
-        }
-    }
-}
-
-
-int8_t Plane::test_passthru(uint8_t argc, const Menu::arg *argv)
-{
-    print_hit_enter();
-    hal.scheduler->delay(1000);
-
-    while(1) {
-        hal.scheduler->delay(20);
-
-        // New radio frame? (we could use also if((millis()- timer) > 20)
-        if (hal.rcin->new_input()) {
-            cliSerial->print("CH:");
-            for(int16_t i = 0; i < 8; i++) {
-                cliSerial->print(hal.rcin->read(i));        // Print channel values
-                print_comma();
-                servo_write(i, hal.rcin->read(i)); // Copy input to Servos
-            }
-            cliSerial->println();
-        }
-        if (cliSerial->available() > 0) {
-            return (0);
-        }
-    }
-    return 0;
-}
-
-int8_t Plane::test_radio(uint8_t argc, const Menu::arg *argv)
-{
-    print_hit_enter();
-    hal.scheduler->delay(1000);
-
-    // read the radio to set trims
-    // ---------------------------
-    trim_radio();
-
-    while(1) {
-        hal.scheduler->delay(20);
-        read_radio();
-
-        channel_roll->calc_pwm();
-        channel_pitch->calc_pwm();
-        channel_throttle->calc_pwm();
-        channel_rudder->calc_pwm();
-
-        // write out the servo PWM values
-        // ------------------------------
-        set_servos();
-
-        cliSerial->printf("IN 1: %d\t2: %d\t3: %d\t4: %d\t5: %d\t6: %d\t7: %d\t8: %d\n",
-                        (int)channel_roll->get_control_in(),
-                        (int)channel_pitch->get_control_in(),
-                        (int)channel_throttle->get_control_in(),
-                        (int)channel_rudder->get_control_in(),
-                        (int)g.rc_5.get_control_in(),
-                        (int)g.rc_6.get_control_in(),
-                        (int)g.rc_7.get_control_in(),
-                        (int)g.rc_8.get_control_in() );
-
-        if(cliSerial->available() > 0) {
-            return (0);
-        }
-    }
-}
-
-int8_t Plane::test_failsafe(uint8_t argc, const Menu::arg *argv)
-{
-    uint8_t fail_test = 0;
-    print_hit_enter();
-    for(int16_t i = 0; i < 50; i++) {
-        hal.scheduler->delay(20);
-        read_radio();
-    }
-
-    // read the radio to set trims
-    // ---------------------------
-    trim_radio();
-
-    oldSwitchPosition = readSwitch();
-
-    cliSerial->println("Unplug battery, throttle in neutral, turn off radio.");
-    while(channel_throttle->get_control_in() > 0) {
-        hal.scheduler->delay(20);
-        read_radio();
-    }
-
-    while(1) {
-        hal.scheduler->delay(20);
-        read_radio();
-
-        if(channel_throttle->get_control_in() > 0) {
-            cliSerial->printf("THROTTLE CHANGED %d \n", (int)channel_throttle->get_control_in());
-            fail_test++;
-        }
-
-        if(oldSwitchPosition != readSwitch()) {
-            cliSerial->print("CONTROL MODE CHANGED: ");
-            print_flight_mode(cliSerial, readSwitch());
-            cliSerial->println();
-            fail_test++;
-        }
-
-        if(rc_failsafe_active()) {
-            cliSerial->printf("THROTTLE FAILSAFE ACTIVATED: %d, ", (int)channel_throttle->get_radio_in());
-            print_flight_mode(cliSerial, readSwitch());
-            cliSerial->println();
-            fail_test++;
-        }
-
-        if(fail_test > 0) {
-            return (0);
-        }
-        if(cliSerial->available() > 0) {
-            cliSerial->println("LOS caused no change in APM.");
-            return (0);
-        }
-    }
-}
-
-int8_t Plane::test_relay(uint8_t argc, const Menu::arg *argv)
-{
-    print_hit_enter();
-    hal.scheduler->delay(1000);
-
-    while(1) {
-        cliSerial->println("Relay on");
-        relay.on(0);
-        hal.scheduler->delay(3000);
-        if(cliSerial->available() > 0) {
-            return (0);
-        }
-
-        cliSerial->println("Relay off");
-        relay.off(0);
-        hal.scheduler->delay(3000);
-        if(cliSerial->available() > 0) {
-            return (0);
-        }
-    }
-}
-
-int8_t Plane::test_wp(uint8_t argc, const Menu::arg *argv)
-{
-    hal.scheduler->delay(1000);
-
-    // save the alitude above home option
-    if (g.RTL_altitude_cm < 0) {
-        cliSerial->println("Hold current altitude");
-    }else{
-        cliSerial->printf("Hold altitude of %dm\n", (int)g.RTL_altitude_cm/100);
-    }
-
-    cliSerial->printf("%d waypoints\n", (int)mission.num_commands());
-    cliSerial->printf("Hit radius: %d\n", (int)g.waypoint_radius);
-    cliSerial->printf("Loiter radius: %d\n\n", (int)g.loiter_radius);
-
-    for(uint8_t i = 0; i <= mission.num_commands(); i++) {
-        AP_Mission::Mission_Command temp_cmd;
-        if (mission.read_cmd_from_storage(i,temp_cmd)) {
-            test_wp_print(temp_cmd);
-        }
-    }
-
-    return (0);
-}
-
-void Plane::test_wp_print(const AP_Mission::Mission_Command& cmd)
-{
-    cliSerial->printf("command #: %d id:%d options:%d p1:%d p2:%ld p3:%ld p4:%ld \n",
-                    (int)cmd.index,
-                    (int)cmd.id,
-                    (int)cmd.content.location.options,
-                    (int)cmd.p1,
-                    (long)cmd.content.location.alt,
-                    (long)cmd.content.location.lat,
-                    (long)cmd.content.location.lng);
-}
-
-int8_t Plane::test_xbee(uint8_t argc, const Menu::arg *argv)
-{
-    print_hit_enter();
-    hal.scheduler->delay(1000);
-    cliSerial->println("Begin XBee X-CTU Range and RSSI Test:");
-
-    while(1) {
-
-        if (hal.uartC->available())
-            hal.uartC->write(hal.uartC->read());
-
-        if(cliSerial->available() > 0) {
-            return (0);
-        }
-    }
-}
-
-
-int8_t Plane::test_modeswitch(uint8_t argc, const Menu::arg *argv)
-{
-    print_hit_enter();
-    hal.scheduler->delay(1000);
-
-    cliSerial->print("Control CH ");
-
-    cliSerial->println(FLIGHT_MODE_CHANNEL, BASE_DEC);
-
-    while(1) {
-        hal.scheduler->delay(20);
-        uint8_t switchPosition = readSwitch();
-        if (oldSwitchPosition != switchPosition) {
-            cliSerial->printf("Position %d\n",  (int)switchPosition);
-            oldSwitchPosition = switchPosition;
-        }
-        if(cliSerial->available() > 0) {
-            return (0);
-        }
-    }
-}
-
 /*
  *  test the dataflash is working
  */
diff --git a/ArduPlane/tiltrotor.cpp b/ArduPlane/tiltrotor.cpp
index 316c914..d5309c36 100644
--- a/ArduPlane/tiltrotor.cpp
+++ b/ArduPlane/tiltrotor.cpp
@@ -15,7 +15,7 @@ void QuadPlane::tiltrotor_slew(float newtilt)
     tilt.current_tilt = constrain_float(newtilt, tilt.current_tilt-max_change, tilt.current_tilt+max_change);
 
     // translate to 0..1000 range and output
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_motor_tilt, 1000 * tilt.current_tilt);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_motor_tilt, 1000 * tilt.current_tilt);
 
     // setup tilt compensation
     motors->set_thrust_compensation_callback(FUNCTOR_BIND_MEMBER(&QuadPlane::tilt_compensate, void, float *, uint8_t));
@@ -42,7 +42,7 @@ void QuadPlane::tiltrotor_update(void)
         // a forward motor
         tiltrotor_slew(1);
 
-        float new_throttle = plane.channel_throttle->get_servo_out()*0.01f;
+        float new_throttle = constrain_float(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle)*0.01, 0, 1);
         if (tilt.current_tilt < 1) {
             tilt.current_throttle = constrain_float(new_throttle,
                                                     tilt.current_throttle-max_change,
@@ -96,7 +96,7 @@ void QuadPlane::tiltrotor_update(void)
         // Q_TILT_MAX. Anything above 50% throttle gets
         // Q_TILT_MAX. Below 50% throttle we decrease linearly. This
         // relies heavily on Q_VFWD_GAIN being set appropriately.
-        float settilt = constrain_float(plane.channel_throttle->get_servo_out() / 50.0f, 0, 1);
+        float settilt = constrain_float(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) / 50.0f, 0, 1);
         tiltrotor_slew(settilt * tilt.max_angle_deg / 90.0f);
     }
 }

From 5a87ae3f014f863d482fe66fcc84c60142a56389 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 12:06:40 +1100
Subject: [PATCH 050/200] Copter: use new SRV_Channels API

---
 ArduCopter/ArduCopter.cpp         |  2 +-
 ArduCopter/Copter.cpp             |  4 ---
 ArduCopter/Copter.h               |  3 +-
 ArduCopter/GCS_Mavlink.cpp        | 44 +-------------------------
 ArduCopter/Parameters.cpp         | 60 ++++++-----------------------------
 ArduCopter/Parameters.h           | 66 ++++++++++++---------------------------
 ArduCopter/baro_ground_effect.cpp |  2 +-
 ArduCopter/heli.cpp               |  2 +-
 ArduCopter/heli_control_acro.cpp  |  8 ++---
 ArduCopter/motors.cpp             |  4 +--
 ArduCopter/radio.cpp              | 37 +++++++++-------------
 ArduCopter/setup.cpp              | 12 +++----
 ArduCopter/switches.cpp           | 42 +++++++++++++------------
 ArduCopter/tuning.cpp             | 25 ++++++++-------
 14 files changed, 95 insertions(+), 216 deletions(-)

diff --git a/ArduCopter/ArduCopter.cpp b/ArduCopter/ArduCopter.cpp
index 1c6f329..e74bda4 100644
--- a/ArduCopter/ArduCopter.cpp
+++ b/ArduCopter/ArduCopter.cpp
@@ -500,7 +500,7 @@ void Copter::one_hz_loop()
     }
 
     // update assigned functions and enable auxiliary servos
-    RC_Channel_aux::enable_aux_servos();
+    SRV_Channels::enable_aux_servos();
 
     check_usb_mux();
 
diff --git a/ArduCopter/Copter.cpp b/ArduCopter/Copter.cpp
index 432667e..329eee0 100644
--- a/ArduCopter/Copter.cpp
+++ b/ArduCopter/Copter.cpp
@@ -28,11 +28,7 @@ Copter::Copter(void) :
             FUNCTOR_BIND_MEMBER(&Copter::verify_command_callback, bool, const AP_Mission::Mission_Command &),
             FUNCTOR_BIND_MEMBER(&Copter::exit_mission, void)),
     control_mode(STABILIZE),
-#if FRAME_CONFIG == HELI_FRAME  // helicopter constructor requires more arguments
-    motors(g.rc_7, MAIN_LOOP_RATE),
-#else
     motors(MAIN_LOOP_RATE),
-#endif
     scaleLongDown(1),
     wp_bearing(0),
     home_bearing(0),
diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index 25369ff..6f51717 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -694,7 +694,6 @@ class Copter : public AP_HAL::HAL::Callbacks {
     void send_nav_controller_output(mavlink_channel_t chan);
     void send_simstate(mavlink_channel_t chan);
     void send_hwstatus(mavlink_channel_t chan);
-    void send_servo_out(mavlink_channel_t chan);
     void send_vfr_hud(mavlink_channel_t chan);
     void send_current_waypoint(mavlink_channel_t chan);
     void send_rangefinder(mavlink_channel_t chan);
@@ -1069,7 +1068,7 @@ class Copter : public AP_HAL::HAL::Callbacks {
     bool check_if_auxsw_mode_used(uint8_t auxsw_mode_check);
     bool check_duplicate_auxsw(void);
     void reset_control_switch();
-    uint8_t read_3pos_switch(int16_t radio_in);
+    uint8_t read_3pos_switch(uint8_t chan);
     void read_aux_switches();
     void init_aux_switches();
     void init_aux_switch_function(int8_t ch_option, uint8_t ch_flag);
diff --git a/ArduCopter/GCS_Mavlink.cpp b/ArduCopter/GCS_Mavlink.cpp
index 080eb02..8032719 100644
--- a/ArduCopter/GCS_Mavlink.cpp
+++ b/ArduCopter/GCS_Mavlink.cpp
@@ -190,44 +190,6 @@ void NOINLINE Copter::send_hwstatus(mavlink_channel_t chan)
         0);
 }
 
-void NOINLINE Copter::send_servo_out(mavlink_channel_t chan)
-{
-#if HIL_MODE != HIL_MODE_DISABLED
-    // normalized values scaled to -10000 to 10000
-    // This is used for HIL.  Do not change without discussing with HIL maintainers
-
-#if FRAME_CONFIG == HELI_FRAME
-    mavlink_msg_rc_channels_scaled_send(
-        chan,
-        millis(),
-        0, // port 0
-        g.rc_1.get_servo_out(),
-        g.rc_2.get_servo_out(),
-        g.rc_3.get_radio_out(),
-        g.rc_4.get_servo_out(),
-        0,
-        0,
-        0,
-        0,
-        receiver_rssi);
-#else
-    mavlink_msg_rc_channels_scaled_send(
-        chan,
-        millis(),
-        0,         // port 0
-        g.rc_1.get_servo_out(),
-        g.rc_2.get_servo_out(),
-        g.rc_3.get_radio_out(),
-        g.rc_4.get_servo_out(),
-        10000 * g.rc_1.norm_output(),
-        10000 * g.rc_2.norm_output(),
-        10000 * g.rc_3.norm_output(),
-        10000 * g.rc_4.norm_output(),
-        receiver_rssi);
-#endif
-#endif // HIL_MODE
-}
-
 void NOINLINE Copter::send_vfr_hud(mavlink_channel_t chan)
 {
     mavlink_msg_vfr_hud_send(
@@ -443,11 +405,6 @@ bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
         send_system_time(copter.gps);
         break;
 
-    case MSG_SERVO_OUT:
-        CHECK_PAYLOAD_SIZE(RC_CHANNELS_SCALED);
-        copter.send_servo_out(chan);
-        break;
-
     case MSG_RADIO_IN:
         CHECK_PAYLOAD_SIZE(RC_CHANNELS);
         send_radio_in(copter.receiver_rssi);
@@ -585,6 +542,7 @@ bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
     case MSG_LIMITS_STATUS:
     case MSG_WIND:
     case MSG_POSITION_TARGET_GLOBAL_INT:
+    case MSG_SERVO_OUT:
         // unused
         break;
 
diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index 0ec7d25..c5f5cb6 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -513,56 +513,6 @@ const AP_Param::Info Copter::var_info[] = {
     // @User: Advanced
     GSCALAR(fs_crash_check, "FS_CRASH_CHECK",    1),
 
-    // RC channel
-    //-----------
-    // @Group: RC1_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_1,    "RC1_", RC_Channel),
-    // @Group: RC2_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_2,    "RC2_", RC_Channel),
-    // @Group: RC3_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_3,    "RC3_", RC_Channel),
-    // @Group: RC4_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_4,    "RC4_", RC_Channel),
-    // @Group: RC5_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_5,    "RC5_", RC_Channel_aux),
-    // @Group: RC6_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_6,    "RC6_", RC_Channel_aux),
-    // @Group: RC7_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_7,    "RC7_", RC_Channel_aux),
-    // @Group: RC8_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_8,    "RC8_", RC_Channel_aux),
-
-    // @Group: RC9_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_9,                    "RC9_", RC_Channel_aux),
-
-    // @Group: RC10_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_10,                    "RC10_", RC_Channel_aux),
-    // @Group: RC11_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_11,                    "RC11_", RC_Channel_aux),
-
-    // @Group: RC12_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_12,                   "RC12_", RC_Channel_aux),
-
-    // @Group: RC13_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_13,                   "RC13_", RC_Channel_aux),
-
-    // @Group: RC14_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_14,                   "RC14_", RC_Channel_aux),
-
     // @Param: RC_SPEED
     // @DisplayName: ESC Update Speed
     // @Description: This is the speed in Hertz that your ESCs will receive updates
@@ -1052,6 +1002,14 @@ const AP_Param::GroupInfo ParametersG2::var_info[] = {
     // @User: Standard
     AP_GROUPINFO("FRAME_CLASS", 15, ParametersG2, frame_class, 0),
 
+    // @Group: SERVO
+    // @Path: ../libraries/SRV_Channel/SRV_Channel.cpp
+    AP_SUBGROUPINFO(servo_channels, "SERVO", 16, ParametersG2, SRV_Channels),
+
+    // @Group: RC
+    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
+    AP_SUBGROUPINFO(rc_channels, "RC", 17, ParametersG2, RC_Channels),
+    
     AP_GROUPEND
 };
 
@@ -1065,7 +1023,7 @@ ParametersG2::ParametersG2(void)
     , proximity(copter.serial_manager)
 #endif
 #if ADVANCED_FAILSAFE == ENABLED
-     ,afs(copter.mission, copter.barometer, copter.gps, copter.rcmap)
+    ,afs(copter.mission, copter.barometer, copter.gps, copter.rcmap)
 #endif
 {
     AP_Param::setup_object_defaults(this, var_info);
diff --git a/ArduCopter/Parameters.h b/ArduCopter/Parameters.h
index 7565e17..101c2ab 100644
--- a/ArduCopter/Parameters.h
+++ b/ArduCopter/Parameters.h
@@ -113,8 +113,8 @@ class Parameters {
         k_param_rc_feel_rp,
         k_param_NavEKF,                 // deprecated - remove
         k_param_mission,                // mission library
-        k_param_rc_13,
-        k_param_rc_14,
+        k_param_rc_13_old,
+        k_param_rc_14_old,
         k_param_rally,
         k_param_poshold_brake_rate,
         k_param_poshold_brake_angle_max,
@@ -273,16 +273,16 @@ class Parameters {
         //
         // 170: Radio settings
         //
-        k_param_rc_1 = 170,
-        k_param_rc_2,
-        k_param_rc_3,
-        k_param_rc_4,
-        k_param_rc_5,
-        k_param_rc_6,
-        k_param_rc_7,
-        k_param_rc_8,
-        k_param_rc_10,
-        k_param_rc_11,
+        k_param_rc_1_old = 170,
+        k_param_rc_2_old,
+        k_param_rc_3_old,
+        k_param_rc_4_old,
+        k_param_rc_5_old,
+        k_param_rc_6_old,
+        k_param_rc_7_old,
+        k_param_rc_8_old,
+        k_param_rc_10_old,
+        k_param_rc_11_old,
         k_param_throttle_min,           // remove
         k_param_throttle_max,           // remove
         k_param_failsafe_throttle,
@@ -297,8 +297,8 @@ class Parameters {
         k_param_failsafe_battery_enabled,
         k_param_throttle_mid,           // remove
         k_param_failsafe_gps_enabled,   // remove
-        k_param_rc_9,
-        k_param_rc_12,
+        k_param_rc_9_old,
+        k_param_rc_12_old,
         k_param_failsafe_gcs,
         k_param_rcmap, // 199
 
@@ -460,22 +460,6 @@ class Parameters {
     AP_Int8         throw_motor_start;
     AP_Int8         terrain_follow;
 
-    // RC channels
-    RC_Channel              rc_1;
-    RC_Channel              rc_2;
-    RC_Channel              rc_3;
-    RC_Channel              rc_4;
-    RC_Channel_aux          rc_5;
-    RC_Channel_aux          rc_6;
-    RC_Channel_aux          rc_7;
-    RC_Channel_aux          rc_8;
-    RC_Channel_aux          rc_9;
-    RC_Channel_aux          rc_10;
-    RC_Channel_aux          rc_11;
-    RC_Channel_aux          rc_12;
-    RC_Channel_aux          rc_13;
-    RC_Channel_aux          rc_14;
-
     AP_Int16                rc_speed; // speed of fast RC Channels in Hz
 
     // Acro parameters
@@ -503,22 +487,6 @@ class Parameters {
     // Note: keep initializers here in the same order as they are declared
     // above.
     Parameters() :
-
-        rc_1                (CH_1),
-        rc_2                (CH_2),
-        rc_3                (CH_3),
-        rc_4                (CH_4),
-        rc_5                (CH_5),
-        rc_6                (CH_6),
-        rc_7                (CH_7),
-        rc_8                (CH_8),
-        rc_9                (CH_9),
-        rc_10               (CH_10),
-        rc_11               (CH_11),
-        rc_12               (CH_12),
-        rc_13               (CH_13),
-        rc_14               (CH_14),
-
         // PID controller	    initial P	      initial I         initial D       initial imax        initial filt hz     pid rate
         //---------------------------------------------------------------------------------------------------------------------------------
         pi_vel_xy               (VEL_XY_P,        VEL_XY_I,                         VEL_XY_IMAX,        VEL_XY_FILT_HZ,     WPNAV_LOITER_UPDATE_TIME),
@@ -590,6 +558,12 @@ class ParametersG2 {
 
     // frame class
     AP_Int8 frame_class;
+
+    // RC input channels
+    RC_Channels rc_channels;
+    
+    // control over servo output ranges
+    SRV_Channels servo_channels;
 };
 
 extern const AP_Param::Info        var_info[];
diff --git a/ArduCopter/baro_ground_effect.cpp b/ArduCopter/baro_ground_effect.cpp
index 427f208..9f26adb 100644
--- a/ArduCopter/baro_ground_effect.cpp
+++ b/ArduCopter/baro_ground_effect.cpp
@@ -37,7 +37,7 @@ void Copter::update_ground_effect_detector(void)
     }
 
     // if we aren't taking off yet, reset the takeoff timer, altitude and complete flag
-    bool throttle_up = mode_has_manual_throttle(control_mode) && g.rc_3.get_control_in() > 0;
+    bool throttle_up = mode_has_manual_throttle(control_mode) && channel_throttle->get_control_in() > 0;
     if (!throttle_up && ap.land_complete) {
         gndeffect_state.takeoff_time_ms = tnow_ms;
         gndeffect_state.takeoff_alt_cm = inertial_nav.get_altitude();
diff --git a/ArduCopter/heli.cpp b/ArduCopter/heli.cpp
index b8c9074..06f42af 100644
--- a/ArduCopter/heli.cpp
+++ b/ArduCopter/heli.cpp
@@ -139,7 +139,7 @@ void Copter::heli_update_rotor_speed_targets()
     // get rotor control method
     uint8_t rsc_control_mode = motors.get_rsc_mode();
 
-    float rsc_control_deglitched = rotor_speed_deglitch_filter.apply((float)g.rc_8.get_control_in()) * 0.001f;
+    float rsc_control_deglitched = rotor_speed_deglitch_filter.apply((float)RC_Channels::rc_channel(CH_8)->get_control_in()) * 0.001f;
 
     switch (rsc_control_mode) {
         case ROTOR_CONTROL_MODE_SPEED_PASSTHROUGH:
diff --git a/ArduCopter/heli_control_acro.cpp b/ArduCopter/heli_control_acro.cpp
index 40f5f95..efc97ec 100644
--- a/ArduCopter/heli_control_acro.cpp
+++ b/ArduCopter/heli_control_acro.cpp
@@ -58,7 +58,7 @@ void Copter::heli_acro_run()
             // if the tail on a flybar heli has an external gyro then
             // also use no deadzone for the yaw control and
             // pass-through the input direct to output.
-            target_yaw = channel_yaw->pwm_to_angle_dz(0);
+            target_yaw = channel_yaw->get_control_in_zero_dz();
         }
 
         // run attitude controller
@@ -68,15 +68,15 @@ void Copter::heli_acro_run()
           for fly-bar passthrough use control_in values with no
           deadzone. This gives true pass-through.
          */
-        float roll_in = channel_roll->pwm_to_angle_dz(0);
-        float pitch_in = channel_pitch->pwm_to_angle_dz(0);
+        float roll_in = channel_roll->get_control_in_zero_dz();
+        float pitch_in = channel_pitch->get_control_in_zero_dz();
         float yaw_in;
         
         if (motors.supports_yaw_passthrough()) {
             // if the tail on a flybar heli has an external gyro then
             // also use no deadzone for the yaw control and
             // pass-through the input direct to output.
-            yaw_in = channel_yaw->pwm_to_angle_dz(0);
+            yaw_in = channel_yaw->get_control_in_zero_dz();
         } else {
             // if there is no external gyro then run the usual
             // ACRO_YAW_P gain on the input control, including
diff --git a/ArduCopter/motors.cpp b/ArduCopter/motors.cpp
index 1ea260e..b1db229 100644
--- a/ArduCopter/motors.cpp
+++ b/ArduCopter/motors.cpp
@@ -101,8 +101,8 @@ void Copter::auto_disarm_check()
         if (mode_has_manual_throttle(control_mode) || !sprung_throttle_stick) {
             thr_low = ap.throttle_zero;
         } else {
-            float deadband_top = g.rc_3.get_control_mid() + g.throttle_deadzone;
-            thr_low = g.rc_3.get_control_in() <= deadband_top;
+            float deadband_top = channel_throttle->get_control_mid() + g.throttle_deadzone;
+            thr_low = channel_throttle->get_control_in() <= deadband_top;
         }
 
         if (!thr_low || !ap.land_complete) {
diff --git a/ArduCopter/radio.cpp b/ArduCopter/radio.cpp
index 0b386c3..972b830 100644
--- a/ArduCopter/radio.cpp
+++ b/ArduCopter/radio.cpp
@@ -11,36 +11,32 @@ void Copter::default_dead_zones()
 #if FRAME_CONFIG == HELI_FRAME
     channel_throttle->set_default_dead_zone(10);
     channel_yaw->set_default_dead_zone(15);
-    g.rc_8.set_default_dead_zone(10);
+    RC_Channels::rc_channel(CH_6)->set_default_dead_zone(10);
 #else
     channel_throttle->set_default_dead_zone(30);
     channel_yaw->set_default_dead_zone(10);
 #endif
-    g.rc_6.set_default_dead_zone(0);
+    RC_Channels::rc_channel(CH_6)->set_default_dead_zone(0);
 }
 
 void Copter::init_rc_in()
 {
-    channel_roll     = RC_Channel::rc_channel(rcmap.roll()-1);
-    channel_pitch    = RC_Channel::rc_channel(rcmap.pitch()-1);
-    channel_throttle = RC_Channel::rc_channel(rcmap.throttle()-1);
-    channel_yaw      = RC_Channel::rc_channel(rcmap.yaw()-1);
+    channel_roll     = RC_Channels::rc_channel(rcmap.roll()-1);
+    channel_pitch    = RC_Channels::rc_channel(rcmap.pitch()-1);
+    channel_throttle = RC_Channels::rc_channel(rcmap.throttle()-1);
+    channel_yaw      = RC_Channels::rc_channel(rcmap.yaw()-1);
 
     // set rc channel ranges
     channel_roll->set_angle(ROLL_PITCH_YAW_INPUT_MAX);
     channel_pitch->set_angle(ROLL_PITCH_YAW_INPUT_MAX);
     channel_yaw->set_angle(ROLL_PITCH_YAW_INPUT_MAX);
-    channel_throttle->set_range(0, 1000);
-
-    channel_roll->set_type(RC_CHANNEL_TYPE_ANGLE_RAW);
-    channel_pitch->set_type(RC_CHANNEL_TYPE_ANGLE_RAW);
-    channel_yaw->set_type(RC_CHANNEL_TYPE_ANGLE_RAW);
+    channel_throttle->set_range(1000);
 
     //set auxiliary servo ranges
-    g.rc_5.set_range_in(0,1000);
-    g.rc_6.set_range_in(0,1000);
-    g.rc_7.set_range_in(0,1000);
-    g.rc_8.set_range_in(0,1000);
+    RC_Channels::rc_channel(CH_5)->set_range(1000);
+    RC_Channels::rc_channel(CH_6)->set_range(1000);
+    RC_Channels::rc_channel(CH_7)->set_range(1000);
+    RC_Channels::rc_channel(CH_8)->set_range(1000);
 
     // set default dead zones
     default_dead_zones();
@@ -67,9 +63,6 @@ void Copter::init_rc_out()
         read_radio();
     }
 
-    // we want the input to be scaled correctly
-    channel_throttle->set_range_out(0,1000);
-
     // setup correct scaling for ESCs like the UAVCAN PX4ESC which
     // take a proportion of speed. 
     hal.rcout->set_esc_scaling(channel_throttle->get_radio_min(), channel_throttle->get_radio_max());
@@ -84,7 +77,7 @@ void Copter::init_rc_out()
     }
 
     // refresh auxiliary channel to function map
-    RC_Channel_aux::update_aux_servo_function();
+    SRV_Channels::update_aux_servo_function();
 
 #if FRAME_CONFIG != HELI_FRAME
     /*
@@ -110,7 +103,7 @@ void Copter::read_radio()
 
     if (hal.rcin->new_input()) {
         ap.new_radio_frame = true;
-        RC_Channel::set_pwm_all();
+        RC_Channels::set_pwm_all();
 
         set_throttle_and_failsafe(channel_throttle->get_radio_in());
         set_throttle_zero_flag(channel_throttle->get_control_in());
@@ -121,13 +114,13 @@ void Copter::read_radio()
         }
 
         // update output on any aux channels, for manual passthru
-        RC_Channel_aux::output_ch_all();
+        SRV_Channels::output_ch_all();
 
         // pass pilot input through to motors (used to allow wiggling servos while disarmed on heli, single, coax copters)
         radio_passthrough_to_motors();
 
         float dt = (tnow_ms - last_radio_update_ms)*1.0e-3f;
-        rc_throttle_control_in_filter.apply(g.rc_3.get_control_in(), dt);
+        rc_throttle_control_in_filter.apply(channel_throttle->get_control_in(), dt);
         last_radio_update_ms = tnow_ms;
     }else{
         uint32_t elapsed = tnow_ms - last_radio_update_ms;
diff --git a/ArduCopter/setup.cpp b/ArduCopter/setup.cpp
index 51158f2..a49eec7 100644
--- a/ArduCopter/setup.cpp
+++ b/ArduCopter/setup.cpp
@@ -369,14 +369,10 @@ void Copter::report_optflow()
 
 void Copter::print_radio_values()
 {
-    cliSerial->printf("CH1: %d | %d\n", (int)channel_roll->get_radio_min(), (int)channel_roll->get_radio_max());
-    cliSerial->printf("CH2: %d | %d\n", (int)channel_pitch->get_radio_min(), (int)channel_pitch->get_radio_max());
-    cliSerial->printf("CH3: %d | %d\n", (int)channel_throttle->get_radio_min(), (int)channel_throttle->get_radio_max());
-    cliSerial->printf("CH4: %d | %d\n", (int)channel_yaw->get_radio_min(), (int)channel_yaw->get_radio_max());
-    cliSerial->printf("CH5: %d | %d\n", (int)g.rc_5.get_radio_min(), (int)g.rc_5.get_radio_max());
-    cliSerial->printf("CH6: %d | %d\n", (int)g.rc_6.get_radio_min(), (int)g.rc_6.get_radio_max());
-    cliSerial->printf("CH7: %d | %d\n", (int)g.rc_7.get_radio_min(), (int)g.rc_7.get_radio_max());
-    cliSerial->printf("CH8: %d | %d\n", (int)g.rc_8.get_radio_min(), (int)g.rc_8.get_radio_max());
+    for (uint8_t i=0; i<8; i++) {
+        RC_Channel *rc = RC_Channels::rc_channel(i);
+        cliSerial->printf("CH%u: %d | %d\n", (unsigned)i, rc->get_radio_min(), rc->get_radio_max());
+    }
 }
 
 void Copter::print_switch(uint8_t p, uint8_t m, bool b)
diff --git a/ArduCopter/switches.cpp b/ArduCopter/switches.cpp
index 7aaafd5..aab68c9 100644
--- a/ArduCopter/switches.cpp
+++ b/ArduCopter/switches.cpp
@@ -19,11 +19,12 @@ void Copter::read_control_switch()
 
     // calculate position of flight mode switch
     int8_t switch_position;
-    if      (g.rc_5.get_radio_in() < 1231) switch_position = 0;
-    else if (g.rc_5.get_radio_in() < 1361) switch_position = 1;
-    else if (g.rc_5.get_radio_in() < 1491) switch_position = 2;
-    else if (g.rc_5.get_radio_in() < 1621) switch_position = 3;
-    else if (g.rc_5.get_radio_in() < 1750) switch_position = 4;
+    uint16_t rc5_in = RC_Channels::rc_channel(CH_5)->get_radio_in();
+    if      (rc5_in < 1231) switch_position = 0;
+    else if (rc5_in < 1361) switch_position = 1;
+    else if (rc5_in < 1491) switch_position = 2;
+    else if (rc5_in < 1621) switch_position = 3;
+    else if (rc5_in < 1750) switch_position = 4;
     else switch_position = 5;
 
     // store time that switch last moved
@@ -107,17 +108,18 @@ void Copter::reset_control_switch()
 }
 
 // read_3pos_switch
-uint8_t Copter::read_3pos_switch(int16_t radio_in)
+uint8_t Copter::read_3pos_switch(uint8_t chan)
 {
+    uint16_t radio_in = RC_Channels::rc_channel(chan)->get_radio_in();
     if (radio_in < AUX_SWITCH_PWM_TRIGGER_LOW) return AUX_SWITCH_LOW;      // switch is in low position
     if (radio_in > AUX_SWITCH_PWM_TRIGGER_HIGH) return AUX_SWITCH_HIGH;    // switch is in high position
     return AUX_SWITCH_MIDDLE;                                       // switch is in middle position
 }
 
 // can't take reference to a bitfield member, thus a #define:
-#define read_aux_switch(rc, flag, option)                           \
+#define read_aux_switch(chan, flag, option)                           \
     do {                                                            \
-        switch_position = read_3pos_switch(rc.get_radio_in());      \
+        switch_position = read_3pos_switch(chan); \
         if (flag != switch_position) {                              \
             flag = switch_position;                                 \
             do_aux_switch_function(option, flag);                   \
@@ -134,14 +136,14 @@ void Copter::read_aux_switches()
         return;
     }
 
-    read_aux_switch(g.rc_7, aux_con.CH7_flag, g.ch7_option);
-    read_aux_switch(g.rc_8, aux_con.CH8_flag, g.ch8_option);
-    read_aux_switch(g.rc_9, aux_con.CH9_flag, g.ch9_option);
-    read_aux_switch(g.rc_10, aux_con.CH10_flag, g.ch10_option);
-    read_aux_switch(g.rc_11, aux_con.CH11_flag, g.ch11_option);
+    read_aux_switch(CH_7, aux_con.CH7_flag, g.ch7_option);
+    read_aux_switch(CH_8, aux_con.CH8_flag, g.ch8_option);
+    read_aux_switch(CH_9, aux_con.CH9_flag, g.ch9_option);
+    read_aux_switch(CH_10, aux_con.CH10_flag, g.ch10_option);
+    read_aux_switch(CH_11, aux_con.CH11_flag, g.ch11_option);
 
 #if CONFIG_HAL_BOARD == HAL_BOARD_PX4 || CONFIG_HAL_BOARD == HAL_BOARD_VRBRAIN
-    read_aux_switch(g.rc_12, aux_con.CH12_flag, g.ch12_option);
+    read_aux_switch(CH_12, aux_con.CH12_flag, g.ch12_option);
 #endif
 }
 
@@ -151,14 +153,14 @@ void Copter::read_aux_switches()
 void Copter::init_aux_switches()
 {
     // set the CH7 ~ CH12 flags
-    aux_con.CH7_flag = read_3pos_switch(g.rc_7.get_radio_in());
-    aux_con.CH8_flag = read_3pos_switch(g.rc_8.get_radio_in());
-    aux_con.CH10_flag = read_3pos_switch(g.rc_10.get_radio_in());
-    aux_con.CH11_flag = read_3pos_switch(g.rc_11.get_radio_in());
+    aux_con.CH7_flag = read_3pos_switch(CH_7);
+    aux_con.CH8_flag = read_3pos_switch(CH_8);
+    aux_con.CH10_flag = read_3pos_switch(CH_10);
+    aux_con.CH11_flag = read_3pos_switch(CH_11);
 
     // ch9, ch12 only supported on some boards
-    aux_con.CH9_flag = read_3pos_switch(g.rc_9.get_radio_in());
-    aux_con.CH12_flag = read_3pos_switch(g.rc_12.get_radio_in());
+    aux_con.CH9_flag = read_3pos_switch(CH_9);
+    aux_con.CH12_flag = read_3pos_switch(CH_12);
 
     // initialise functions assigned to switches
     init_aux_switch_function(g.ch7_option, aux_con.CH7_flag);
diff --git a/ArduCopter/tuning.cpp b/ArduCopter/tuning.cpp
index 06b3d86..686b4e9 100644
--- a/ArduCopter/tuning.cpp
+++ b/ArduCopter/tuning.cpp
@@ -8,19 +8,22 @@
 // tuning - updates parameters based on the ch6 tuning knob's position
 //  should be called at 3.3hz
 void Copter::tuning() {
+    RC_Channel *rc6 = RC_Channels::rc_channel(CH_6);
 
-    // exit immediately if not using tuning function, or when radio failsafe is invoked, so tuning values are not set to zero
-    if ((g.radio_tuning <= 0) || failsafe.radio || failsafe.radio_counter != 0 || g.rc_6.get_radio_in() == 0) {
+    // exit immediately if not using tuning function, or when radio failsafe is invoked, so tuning values are not set to zero    
+    if ((g.radio_tuning <= 0) || failsafe.radio || failsafe.radio_counter != 0 || rc6->get_radio_in() == 0) {
         return;
     }
 
-    // set tuning range and then get new value
-    g.rc_6.set_range_in(g.radio_tuning_low,g.radio_tuning_high);
-    float tuning_value = (float)g.rc_6.get_control_in() / 1000.0f;
+    uint16_t radio_in = rc6->get_radio_in();
+    float v = constrain_float((radio_in - rc6->get_radio_min()) / float(rc6->get_radio_max() - rc6->get_radio_min()), 0, 1);
+    int16_t control_in = g.radio_tuning_low + v * (g.radio_tuning_high - g.radio_tuning_low);
+    float tuning_value = control_in / 1000.0f;
+    
     // Tuning Value should never be outside the bounds of the specified low and high value
     tuning_value = constrain_float(tuning_value, g.radio_tuning_low/1000.0f, g.radio_tuning_high/1000.0f);
 
-    Log_Write_Parameter_Tuning(g.radio_tuning, tuning_value, g.rc_6.get_control_in(), g.radio_tuning_low, g.radio_tuning_high);
+    Log_Write_Parameter_Tuning(g.radio_tuning, tuning_value, control_in, g.radio_tuning_low, g.radio_tuning_high);
 
     switch(g.radio_tuning) {
 
@@ -94,7 +97,7 @@ void Copter::tuning() {
 
     case TUNING_WP_SPEED:
         // set waypoint navigation horizontal speed to 0 ~ 1000 cm/s
-        wp_nav.set_speed_xy(g.rc_6.get_control_in());
+        wp_nav.set_speed_xy(control_in);
         break;
 
     // Acro roll pitch gain
@@ -109,7 +112,7 @@ void Copter::tuning() {
 
 #if FRAME_CONFIG == HELI_FRAME
     case TUNING_HELI_EXTERNAL_GYRO:
-        motors.ext_gyro_gain((float)g.rc_6.get_control_in() / 1000.0f);
+        motors.ext_gyro_gain((float)control_in / 1000.0f);
         break;
 
     case TUNING_RATE_PITCH_FF:
@@ -127,12 +130,12 @@ void Copter::tuning() {
 
     case TUNING_DECLINATION:
         // set declination to +-20degrees
-        compass.set_declination(ToRad((2.0f * g.rc_6.get_control_in() - g.radio_tuning_high)/100.0f), false);     // 2nd parameter is false because we do not want to save to eeprom because this would have a performance impact
+        compass.set_declination(ToRad((2.0f * control_in - g.radio_tuning_high)/100.0f), false);     // 2nd parameter is false because we do not want to save to eeprom because this would have a performance impact
         break;
 
     case TUNING_CIRCLE_RATE:
         // set circle rate up to approximately 45 deg/sec in either direction
-        circle_nav.set_rate((float)g.rc_6.get_control_in()/25.0f-20.0f);
+        circle_nav.set_rate((float)control_in/25.0f-20.0f);
         break;
 
     case TUNING_RANGEFINDER_GAIN:
@@ -173,7 +176,7 @@ void Copter::tuning() {
 
     case TUNING_RC_FEEL_RP:
         // roll-pitch input smoothing
-        g.rc_feel_rp = g.rc_6.get_control_in() / 10;
+        g.rc_feel_rp = control_in / 10;
         break;
 
     case TUNING_RATE_PITCH_KP:

From 93d6b012c2615780ed46140934f05af3c6908182 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 6 Jan 2017 21:31:10 +1100
Subject: [PATCH 051/200] Rover: convert to new SRV_Channel API

---
 APMrover2/APMrover2.cpp      | 27 ++++++++--------
 APMrover2/GCS_Mavlink.cpp    |  4 +--
 APMrover2/Log.cpp            |  8 ++---
 APMrover2/Parameters.cpp     | 69 ++++++++--------------------------------
 APMrover2/Parameters.h       | 68 ++++++++++++---------------------------
 APMrover2/Rover.h            |  1 +
 APMrover2/Steering.cpp       | 76 ++++++++++++++++++++------------------------
 APMrover2/commands_logic.cpp |  6 ++--
 APMrover2/control_modes.cpp  |  2 +-
 APMrover2/crash_check.cpp    |  2 +-
 APMrover2/failsafe.cpp       |  2 +-
 APMrover2/radio.cpp          | 36 ++++++++++-----------
 APMrover2/system.cpp         |  9 ------
 APMrover2/test.cpp           | 66 --------------------------------------
 14 files changed, 112 insertions(+), 264 deletions(-)

diff --git a/APMrover2/APMrover2.cpp b/APMrover2/APMrover2.cpp
index 72bf125..03f93c8 100644
--- a/APMrover2/APMrover2.cpp
+++ b/APMrover2/APMrover2.cpp
@@ -300,7 +300,7 @@ void Rover::update_logging2(void)
  */
 void Rover::update_aux(void)
 {
-    RC_Channel_aux::enable_aux_servos();
+    SRV_Channels::enable_aux_servos();
 }
 
 /*
@@ -452,17 +452,18 @@ void Rover::update_current_mode(void)
         case Guided_WP:
             if (rtl_complete || verify_RTL()) {
                 // we have reached destination so stop where we are
-                if (channel_throttle->get_servo_out() != g.throttle_min.get()) {
+                if (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) != g.throttle_min.get()) {
                     gcs_send_mission_item_reached_message(0);
                 }
-                channel_throttle->set_servo_out(g.throttle_min.get());
-                channel_steer->set_servo_out(0);
+                SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,g.throttle_min.get());
+                SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
                 lateral_acceleration = 0;
             } else {
                 calc_lateral_acceleration();
                 calc_nav_steer();
                 calc_throttle(g.speed_cruise);
-                Log_Write_GuidedTarget(guided_mode, Vector3f(guided_WP.lat, guided_WP.lng, guided_WP.alt), Vector3f(g.speed_cruise, channel_throttle->get_servo_out(), 0));
+                Log_Write_GuidedTarget(guided_mode, Vector3f(guided_WP.lat, guided_WP.lng, guided_WP.alt),
+                                       Vector3f(g.speed_cruise, SRV_Channels::get_output_scaled(SRV_Channel::k_throttle), 0));
             }
             break;
 
@@ -510,18 +511,18 @@ void Rover::update_current_mode(void)
           we set the exact value in set_servos(), but it helps for
           logging
          */
-        channel_throttle->set_servo_out(channel_throttle->get_control_in());
-        channel_steer->set_servo_out(channel_steer->pwm_to_angle());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,channel_throttle->get_control_in());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,channel_steer->pwm_to_angle());
 
         // mark us as in_reverse when using a negative throttle to
         // stop AHRS getting off
-        set_reverse(channel_throttle->get_servo_out() < 0);
+        set_reverse(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) < 0);
         break;
 
     case HOLD:
         // hold position - stop motors and center steering
-        channel_throttle->set_servo_out(0);
-        channel_steer->set_servo_out(0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
         break;
 
     case INITIALISING:
@@ -548,7 +549,7 @@ void Rover::update_navigation()
         calc_lateral_acceleration();
         calc_nav_steer();
         if (verify_RTL()) {
-            channel_throttle->set_servo_out(g.throttle_min.get());
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,g.throttle_min.get());
             set_mode(HOLD);
         }
         break;
@@ -565,8 +566,8 @@ void Rover::update_navigation()
             calc_nav_steer();
             if (rtl_complete || verify_RTL()) {
                 // we have reached destination so stop where we are
-                channel_throttle->set_servo_out(g.throttle_min.get());
-                channel_steer->set_servo_out(0);
+                SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,g.throttle_min.get());
+                SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
                 lateral_acceleration = 0;
             }
             break;
diff --git a/APMrover2/GCS_Mavlink.cpp b/APMrover2/GCS_Mavlink.cpp
index 19bd9df..e266f1a 100644
--- a/APMrover2/GCS_Mavlink.cpp
+++ b/APMrover2/GCS_Mavlink.cpp
@@ -162,7 +162,7 @@ void Rover::send_servo_out(mavlink_channel_t chan)
         0,  // port 0
         10000 * channel_steer->norm_output(),
         0,
-        10000 * channel_throttle->norm_output(),
+        10000 * SRV_Channels::get_output_norm(SRV_Channel::k_throttle),
         0,
         0,
         0,
@@ -179,7 +179,7 @@ void Rover::send_vfr_hud(mavlink_channel_t chan)
         gps.ground_speed(),
         ahrs.groundspeed(),
         (ahrs.yaw_sensor / 100) % 360,
-        (uint16_t)(100 * fabsf(channel_throttle->norm_output())),
+        (uint16_t)(100 * fabsf(SRV_Channels::get_output_norm(SRV_Channel::k_throttle))),
         current_loc.alt / 100.0,
         0);
 }
diff --git a/APMrover2/Log.cpp b/APMrover2/Log.cpp
index e05c423..1869b0e 100644
--- a/APMrover2/Log.cpp
+++ b/APMrover2/Log.cpp
@@ -238,10 +238,10 @@ void Rover::Log_Write_Control_Tuning()
     struct log_Control_Tuning pkt = {
         LOG_PACKET_HEADER_INIT(LOG_CTUN_MSG),
         time_us         : AP_HAL::micros64(),
-        steer_out       : (int16_t)channel_steer->get_servo_out(),
+        steer_out       : (int16_t)SRV_Channels::get_output_scaled(SRV_Channel::k_steering),
         roll            : (int16_t)ahrs.roll_sensor,
         pitch           : (int16_t)ahrs.pitch_sensor,
-        throttle_out    : (int16_t)channel_throttle->get_servo_out(),
+        throttle_out    : (int16_t)SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
         accel_y         : accel.y
     };
     DataFlash.WriteBlock(&pkt, sizeof(pkt));
@@ -268,7 +268,7 @@ void Rover::Log_Write_Nav_Tuning()
         wp_distance         : wp_distance,
         target_bearing_cd   : (uint16_t)nav_controller->target_bearing_cd(),
         nav_bearing_cd      : (uint16_t)nav_controller->nav_bearing_cd(),
-        throttle            : (int8_t)(100 * channel_throttle->norm_output()),
+        throttle            : (int8_t)(100 * SRV_Channels::get_output_norm(SRV_Channel::k_throttle)),
         xtrack_error        : nav_controller->crosstrack_error()
     };
     DataFlash.WriteBlock(&pkt, sizeof(pkt));
@@ -326,7 +326,7 @@ void Rover::Log_Write_Sonar()
         turn_angle      : (int8_t)obstacle.turn_angle,
         turn_time       : turn_time,
         ground_speed    : (uint16_t)(ground_speed*100),
-        throttle        : (int8_t)(100 * channel_throttle->norm_output())
+        throttle        : (int8_t)(100 * SRV_Channels::get_output_norm(SRV_Channel::k_throttle))
     };
     DataFlash.WriteBlock(&pkt, sizeof(pkt));
 }
diff --git a/APMrover2/Parameters.cpp b/APMrover2/Parameters.cpp
index e350be4..707420a 100644
--- a/APMrover2/Parameters.cpp
+++ b/APMrover2/Parameters.cpp
@@ -174,62 +174,6 @@ const AP_Param::Info Rover::var_info[] = {
     // @User: Standard
     GSCALAR(ch7_option,             "CH7_OPTION",          CH7_OPTION),
 
-    // @Group: RC1_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_1,                    "RC1_", RC_Channel),
-
-    // @Group: RC2_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_2,                    "RC2_", RC_Channel_aux),
-
-    // @Group: RC3_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GGROUP(rc_3,                    "RC3_", RC_Channel),
-
-    // @Group: RC4_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_4,                    "RC4_", RC_Channel_aux),
-
-    // @Group: RC5_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_5,                    "RC5_", RC_Channel_aux),
-
-    // @Group: RC6_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_6,                    "RC6_", RC_Channel_aux),
-
-    // @Group: RC7_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_7,                    "RC7_", RC_Channel_aux),
-
-    // @Group: RC8_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_8,                    "RC8_", RC_Channel_aux),
-
-    // @Group: RC9_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_9,                    "RC9_", RC_Channel_aux),
-
-    // @Group: RC10_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_10,                    "RC10_", RC_Channel_aux),
-
-    // @Group: RC11_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_11,                    "RC11_", RC_Channel_aux),
-
-    // @Group: RC12_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_12,                    "RC12_", RC_Channel_aux),
-
-    // @Group: RC13_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_13,                    "RC13_", RC_Channel_aux),
-
-    // @Group: RC14_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp,../libraries/RC_Channel/RC_Channel_aux.cpp
-    GGROUP(rc_14,                    "RC14_", RC_Channel_aux),
-
     // @Param: THR_MIN
     // @DisplayName: Minimum Throttle
     // @Description: The minimum throttle setting to which the autopilot will apply. This is mostly useful for rovers with internal combustion motors, to prevent the motor from cutting out in auto mode.
@@ -585,10 +529,23 @@ const AP_Param::GroupInfo ParametersG2::var_info[] = {
     // @User: Advanced
     AP_GROUPINFO("SYSID_ENFORCE", 2, ParametersG2, sysid_enforce, 0),
 
+    // @Group: SERVO
+    // @Path: ../libraries/SRV_Channel/SRV_Channel.cpp
+    AP_SUBGROUPINFO(servo_channels, "SERVO", 3, ParametersG2, SRV_Channels),
+
+    // @Group: RC
+    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
+    AP_SUBGROUPINFO(rc_channels, "RC", 4, ParametersG2, RC_Channels),
+    
     AP_GROUPEND
 };
 
 
+ParametersG2::ParametersG2(void)
+{
+    AP_Param::setup_object_defaults(this, var_info);
+}
+
 
 /*
   This is a conversion table from old parameter values to new
diff --git a/APMrover2/Parameters.h b/APMrover2/Parameters.h
index 19ec647..42742db 100644
--- a/APMrover2/Parameters.h
+++ b/APMrover2/Parameters.h
@@ -33,8 +33,8 @@ class Parameters {
         k_param_relay,
         k_param_BoardConfig,
         k_param_pivot_turn_angle,
-        k_param_rc_13,
-        k_param_rc_14,
+        k_param_rc_13_old,
+        k_param_rc_14_old,
 
         // IO pins
         k_param_rssi_pin = 20,  // unused, replaced by rssi_ library parameters
@@ -113,14 +113,14 @@ class Parameters {
         //
         // 160: Radio settings
         //
-        k_param_rc_1 = 160,
-        k_param_rc_2,
-        k_param_rc_3,
-        k_param_rc_4,
-        k_param_rc_5,
-        k_param_rc_6,
-        k_param_rc_7,
-        k_param_rc_8,
+        k_param_rc_1_old = 160,
+        k_param_rc_2_old,
+        k_param_rc_3_old,
+        k_param_rc_4_old,
+        k_param_rc_5_old,
+        k_param_rc_6_old,
+        k_param_rc_7_old,
+        k_param_rc_8_old,
 
         // throttle control
         k_param_throttle_min = 170,
@@ -182,10 +182,10 @@ class Parameters {
         k_param_pidSpeedThrottle,
 
         // high RC channels
-        k_param_rc_9 = 235,
-        k_param_rc_10,
-        k_param_rc_11,
-        k_param_rc_12,
+        k_param_rc_9_old = 235,
+        k_param_rc_10_old,
+        k_param_rc_11_old,
+        k_param_rc_12_old,
 
         // other objects
         k_param_sitl = 240,
@@ -242,22 +242,6 @@ class Parameters {
     AP_Int16    pivot_turn_angle;
     AP_Int16    gcs_pid_mask;
 
-    // RC channels
-    RC_Channel      rc_1;
-    RC_Channel_aux  rc_2;
-    RC_Channel      rc_3;
-    RC_Channel_aux  rc_4;
-    RC_Channel_aux  rc_5;
-    RC_Channel_aux  rc_6;
-    RC_Channel_aux  rc_7;
-    RC_Channel_aux  rc_8;
-    RC_Channel_aux  rc_9;
-    RC_Channel_aux  rc_10;
-    RC_Channel_aux  rc_11;
-    RC_Channel_aux  rc_12;
-    RC_Channel_aux  rc_13;
-    RC_Channel_aux  rc_14;
-
     // Throttle
     //
     AP_Int8     throttle_min;
@@ -302,22 +286,6 @@ class Parameters {
     PID         pidSpeedThrottle;
 
     Parameters() :
-        // RC channels
-        rc_1(CH_1),
-        rc_2(CH_2),
-        rc_3(CH_3),
-        rc_4(CH_4),
-        rc_5(CH_5),
-        rc_6(CH_6),
-        rc_7(CH_7),
-        rc_8(CH_8),
-        rc_9(CH_9),
-        rc_10(CH_10),
-        rc_11(CH_11),
-        rc_12(CH_12),
-        rc_13(CH_13),
-        rc_14(CH_14),
-
         // PID controller    initial P        initial I        initial D        initial imax
         //-----------------------------------------------------------------------------------
         pidSpeedThrottle    (0.7,             0.2,             0.2,             4000)
@@ -329,7 +297,7 @@ class Parameters {
  */
 class ParametersG2 {
 public:
-    ParametersG2(void) { AP_Param::setup_object_defaults(this, var_info); }
+    ParametersG2(void);
 
     // var_info for holding Parameter information
     static const struct AP_Param::GroupInfo var_info[];
@@ -339,6 +307,12 @@ class ParametersG2 {
 
     // whether to enforce acceptance of packets only from sysid_my_gcs
     AP_Int8 sysid_enforce;
+
+    // RC input channels
+    RC_Channels rc_channels;
+    
+    // control over servo output ranges
+    SRV_Channels servo_channels;
 };
 
 extern const AP_Param::Info var_info[];
diff --git a/APMrover2/Rover.h b/APMrover2/Rover.h
index 6703a63..36e5c35 100644
--- a/APMrover2/Rover.h
+++ b/APMrover2/Rover.h
@@ -92,6 +92,7 @@ class Rover : public AP_HAL::HAL::Callbacks {
 public:
     friend class GCS_MAVLINK_Rover;
     friend class Parameters;
+    friend class ParametersG2;
     friend class AP_Arming;
 
     Rover(void);
diff --git a/APMrover2/Steering.cpp b/APMrover2/Steering.cpp
index 018e53c..f40b925 100644
--- a/APMrover2/Steering.cpp
+++ b/APMrover2/Steering.cpp
@@ -12,7 +12,10 @@ void Rover::throttle_slew_limit(int16_t last_throttle) {
         if (temp < 1) {
             temp = 1;
         }
-        channel_throttle->set_radio_out(constrain_int16(channel_throttle->get_radio_out(), last_throttle - temp, last_throttle + temp));
+        uint16_t pwm;
+        if (SRV_Channels::get_output_pwm(SRV_Channel::k_throttle, pwm)) {
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,constrain_int16(pwm, last_throttle - temp, last_throttle + temp));
+        }
     }
 }
 
@@ -100,10 +103,10 @@ void Rover::calc_throttle(float target_speed) {
     // If not autostarting OR we are loitering at a waypoint
     // then set the throttle to minimum
     if (!auto_check_trigger() || in_stationary_loiter()) {
-        channel_throttle->set_servo_out(g.throttle_min.get());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,g.throttle_min.get());
         // Stop rotation in case of loitering and skid steering
         if (g.skid_steer_out) {
-            channel_steer->set_servo_out(0);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
         }
         return;
     }
@@ -146,9 +149,9 @@ void Rover::calc_throttle(float target_speed) {
     throttle *= reduction;
 
     if (in_reverse) {
-        channel_throttle->set_servo_out(constrain_int16(-throttle, -g.throttle_max, -g.throttle_min));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(-throttle, -g.throttle_max, -g.throttle_min));
     } else {
-        channel_throttle->set_servo_out(constrain_int16(throttle, g.throttle_min, g.throttle_max));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(throttle, g.throttle_min, g.throttle_max));
     }
 
     if (!in_reverse && g.braking_percent != 0 && groundspeed_error < -g.braking_speederr) {
@@ -161,7 +164,7 @@ void Rover::calc_throttle(float target_speed) {
         // is 2*braking_speederr
         float brake_gain = constrain_float(((-groundspeed_error)-g.braking_speederr)/g.braking_speederr, 0, 1);
         int16_t braking_throttle = g.throttle_max * (g.braking_percent * 0.01f) * brake_gain;
-        channel_throttle->set_servo_out(constrain_int16(-braking_throttle, -g.throttle_max, -g.throttle_min));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(-braking_throttle, -g.throttle_max, -g.throttle_min));
 
         // temporarily set us in reverse to allow the PWM setting to
         // go negative
@@ -169,7 +172,7 @@ void Rover::calc_throttle(float target_speed) {
     }
 
     if (use_pivot_steering()) {
-        channel_throttle->set_servo_out(0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,0);
     }
 }
 
@@ -219,7 +222,7 @@ void Rover::calc_lateral_acceleration() {
 void Rover::calc_nav_steer() {
     // check to see if the rover is loitering
     if (in_stationary_loiter()) {
-        channel_steer->set_servo_out(0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
         return;
     }
 
@@ -231,68 +234,61 @@ void Rover::calc_nav_steer() {
     // constrain to max G force
     lateral_acceleration = constrain_float(lateral_acceleration, -g.turn_max_g*GRAVITY_MSS, g.turn_max_g*GRAVITY_MSS);
 
-    channel_steer->set_servo_out(steerController.get_steering_out_lat_accel(lateral_acceleration));
+    SRV_Channels::set_output_scaled(SRV_Channel::k_steering,steerController.get_steering_out_lat_accel(lateral_acceleration));
 }
 
 /*****************************************
     Set the flight control servos based on the current calculated values
 *****************************************/
 void Rover::set_servos(void) {
-    static int16_t last_throttle;
-
-    // support a separate steering channel
-    RC_Channel_aux::set_servo_out_for(RC_Channel_aux::k_steering, channel_steer->pwm_to_angle_dz(0));
+    static uint16_t last_throttle;
 
     if (control_mode == MANUAL || control_mode == LEARNING) {
         // do a direct pass through of radio values
-        channel_steer->set_radio_out(channel_steer->read());
-        channel_throttle->set_radio_out(channel_throttle->read());
+        SRV_Channels::set_output_pwm(SRV_Channel::k_steering,channel_steer->read());
+        SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,channel_throttle->read());
         if (failsafe.bits & FAILSAFE_EVENT_THROTTLE) {
             // suppress throttle if in failsafe and manual
-            channel_throttle->set_radio_out(channel_throttle->get_radio_trim());
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,channel_throttle->get_radio_trim());
             // suppress steer if in failsafe and manual and skid steer mode
             if (g.skid_steer_out) {
-                channel_steer->set_radio_out(channel_steer->get_radio_trim());
+                SRV_Channels::set_output_pwm(SRV_Channel::k_steering,channel_steer->get_radio_trim());
             }
         }
     } else {
-        channel_steer->calc_pwm();
         if (in_reverse) {
-            channel_throttle->set_servo_out(constrain_int16(channel_throttle->get_servo_out(),
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
                                           -g.throttle_max,
                                           -g.throttle_min));
         } else {
-            channel_throttle->set_servo_out(constrain_int16(channel_throttle->get_servo_out(),
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
                                           g.throttle_min.get(),
                                           g.throttle_max.get()));
         }
 
         if ((failsafe.bits & FAILSAFE_EVENT_THROTTLE) && control_mode < AUTO) {
             // suppress throttle if in failsafe
-            channel_throttle->set_servo_out(0);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,0);
             // suppress steer if in failsafe and skid steer mode
             if (g.skid_steer_out) {
-                channel_steer->set_servo_out(0);
+                SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
             }
         }
 
         if (!hal.util->get_soft_armed()) {
-            channel_throttle->set_servo_out(0);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,0);
             // suppress steer if in failsafe and skid steer mode
             if (g.skid_steer_out) {
-                channel_steer->set_servo_out(0);
+                SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
             }
         }
 
-        // convert 0 to 100% into PWM
-        channel_throttle->calc_pwm();
-
         // limit throttle movement speed
         throttle_slew_limit(last_throttle);
     }
 
     // record last throttle before we apply skid steering
-    last_throttle = channel_throttle->get_radio_out();
+    SRV_Channels::get_output_pwm(SRV_Channel::k_throttle, last_throttle);
 
     if (g.skid_steer_out) {
         // convert the two radio_out values to skid steering values
@@ -303,14 +299,12 @@ void Rover::set_servos(void) {
             motor1 = throttle + 0.5*steering
             motor2 = throttle - 0.5*steering
         */
-        float steering_scaled = channel_steer->norm_output();
-        float throttle_scaled = channel_throttle->norm_output();
+        float steering_scaled = SRV_Channels::get_output_norm(SRV_Channel::k_steering);
+        float throttle_scaled = SRV_Channels::get_output_norm(SRV_Channel::k_throttle);
         float motor1 = throttle_scaled + 0.5f*steering_scaled;
         float motor2 = throttle_scaled - 0.5f*steering_scaled;
-        channel_steer->set_servo_out(4500*motor1);
-        channel_throttle->set_servo_out(100*motor2);
-        channel_steer->calc_pwm();
-        channel_throttle->calc_pwm();
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,4500*motor1);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,100*motor2);
     }
 
     if (!arming.is_armed()) {
@@ -323,28 +317,28 @@ void Rover::set_servos(void) {
             break;
 
         case AP_Arming::YES_ZERO_PWM:
-            channel_throttle->set_radio_out(0);
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,0);
             if (g.skid_steer_out) {
-                channel_steer->set_radio_out(0);
+                SRV_Channels::set_output_pwm(SRV_Channel::k_steering,0);
             }
             break;
 
         case AP_Arming::YES_MIN_PWM:
         default:
-            channel_throttle->set_radio_out(channel_throttle->get_radio_trim());
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,channel_throttle->get_radio_trim());
             if (g.skid_steer_out) {
-                channel_steer->set_radio_out(channel_steer->get_radio_trim());
+                SRV_Channels::set_output_pwm(SRV_Channel::k_steering,channel_steer->get_radio_trim());
             }
             break;
         }
     }
 
+    SRV_Channels::calc_pwm();
+
 #if HIL_MODE == HIL_MODE_DISABLED || HIL_SERVOS
     // send values to the PWM timers for output
     // ----------------------------------------
-    channel_steer->output();
-    channel_throttle->output();
-    RC_Channel_aux::output_ch_all();
+    SRV_Channels::output_ch_all();
 #endif
 }
 
diff --git a/APMrover2/commands_logic.cpp b/APMrover2/commands_logic.cpp
index 822892c..1874a44 100644
--- a/APMrover2/commands_logic.cpp
+++ b/APMrover2/commands_logic.cpp
@@ -370,14 +370,14 @@ void Rover::nav_set_yaw_speed()
     // if we haven't received a MAV_CMD_NAV_SET_YAW_SPEED message within the last 3 seconds bring the rover to a halt
     if ((millis() - guided_yaw_speed.msg_time_ms) > 3000) {
         gcs_send_text(MAV_SEVERITY_WARNING, "NAV_SET_YAW_SPEED not recvd last 3secs, stopping");
-        channel_throttle->set_servo_out(g.throttle_min.get());
-        channel_steer->set_servo_out(0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,g.throttle_min.get());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
         lateral_acceleration = 0;
         return;
     }
 
     int32_t steering = steerController.get_steering_out_angle_error(guided_yaw_speed.turn_angle);
-    channel_steer->set_servo_out(steering);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_steering,steering);
 
     // speed param in the message gives speed as a proportion of cruise speed.
     // 0.5 would set speed to the cruise speed
diff --git a/APMrover2/control_modes.cpp b/APMrover2/control_modes.cpp
index 4377115..a9925f8 100644
--- a/APMrover2/control_modes.cpp
+++ b/APMrover2/control_modes.cpp
@@ -140,7 +140,7 @@ bool Rover::motor_active()
 {
     // Check if armed and throttle is not neutral
     if (hal.util->get_soft_armed()) {
-        if (channel_throttle->get_servo_out() != channel_throttle->get_radio_trim()) {
+        if (SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) != channel_throttle->get_radio_trim()) {
             return true;
         }
     }
diff --git a/APMrover2/crash_check.cpp b/APMrover2/crash_check.cpp
index e532829..b8f15fd 100644
--- a/APMrover2/crash_check.cpp
+++ b/APMrover2/crash_check.cpp
@@ -21,7 +21,7 @@ void Rover::crash_check()
   // TODO : Check if min vel can be calculated
   // min_vel = ( CRASH_CHECK_THROTTLE_MIN * g.speed_cruise) / g.throttle_cruise;
 
-  if ((ahrs.groundspeed() >= CRASH_CHECK_VEL_MIN)|| ((100 * fabsf(channel_throttle->norm_output())) < CRASH_CHECK_THROTTLE_MIN)) {
+  if ((ahrs.groundspeed() >= CRASH_CHECK_VEL_MIN)|| ((100 * fabsf(SRV_Channels::get_output_norm(SRV_Channel::k_throttle))) < CRASH_CHECK_THROTTLE_MIN)) {
     crash_counter = 0;
     return;
   }
diff --git a/APMrover2/failsafe.cpp b/APMrover2/failsafe.cpp
index 0001f0d..b749bc9 100644
--- a/APMrover2/failsafe.cpp
+++ b/APMrover2/failsafe.cpp
@@ -46,7 +46,7 @@ void Rover::failsafe_check()
         for (uint8_t ch=start_ch; ch < 4; ch++) {
             hal.rcout->write(ch, hal.rcin->read(ch));
         }
-        RC_Channel_aux::copy_radio_in_out(RC_Channel_aux::k_manual, true);
+        SRV_Channels::copy_radio_in_out(SRV_Channel::k_manual, true);
     }
 }
 
diff --git a/APMrover2/radio.cpp b/APMrover2/radio.cpp
index 58bc970..c18c209 100644
--- a/APMrover2/radio.cpp
+++ b/APMrover2/radio.cpp
@@ -5,14 +5,20 @@
  */
 void Rover::set_control_channels(void)
 {
-    channel_steer    = RC_Channel::rc_channel(rcmap.roll()-1);
-    channel_throttle = RC_Channel::rc_channel(rcmap.throttle()-1);
-    channel_learn    = RC_Channel::rc_channel(g.learn_channel-1);
+    channel_steer    = RC_Channels::rc_channel(rcmap.roll()-1);
+    channel_throttle = RC_Channels::rc_channel(rcmap.throttle()-1);
+    channel_learn    = RC_Channels::rc_channel(g.learn_channel-1);
 
+    SRV_Channels::set_default_function(CH_1, SRV_Channel::k_steering);
+    SRV_Channels::set_default_function(CH_3, SRV_Channel::k_throttle);
+    
     // set rc channel ranges
     channel_steer->set_angle(SERVO_MAX);
     channel_throttle->set_angle(100);
 
+    SRV_Channels::set_angle(SRV_Channel::k_steering, SERVO_MAX);
+    SRV_Channels::set_angle(SRV_Channel::k_throttle, 100);
+
     // For a rover safety is TRIM throttle
     if (!arming.is_armed() && arming.arming_required() == AP_Arming::YES_MIN_PWM) {
         hal.rcout->set_safety_pwm(1UL<<(rcmap.throttle()-1), channel_throttle->get_radio_trim());
@@ -37,20 +43,10 @@ void Rover::init_rc_in()
 
 void Rover::init_rc_out()
 {
-    RC_Channel::rc_channel(CH_1)->enable_out();
-    RC_Channel::rc_channel(CH_3)->enable_out();
-
-    if (arming.arming_required() != AP_Arming::YES_ZERO_PWM) {
-        channel_throttle->enable_out();
-        if (g.skid_steer_out) {
-            channel_steer->enable_out();
-        }
-    }
-
-    RC_Channel::output_trim_all();
+    SRV_Channels::output_trim_all();
 
     // setup PWM values to send if the FMU firmware dies
-    RC_Channel::setup_failsafe_trim_all();
+    SRV_Channels::setup_failsafe_trim_all();
 
     // output throttle trim when safety off if arming
     // is setup for min on disarm.  MIN is from plane where MIN is effectively no throttle.
@@ -134,17 +130,17 @@ void Rover::read_radio()
 
     failsafe.last_valid_rc_ms = AP_HAL::millis();
 
-    RC_Channel::set_pwm_all();
+    RC_Channels::set_pwm_all();
 
     control_failsafe(channel_throttle->get_radio_in());
 
-    channel_throttle->set_servo_out(channel_throttle->get_control_in());
+    SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,channel_throttle->get_control_in());
 
     // Check if the throttle value is above 50% and we need to nudge
     // Make sure its above 50% in the direction we are travelling
-    if ((abs(channel_throttle->get_servo_out()) > 50) &&
-        (((channel_throttle->get_servo_out() < 0) && in_reverse) ||
-         ((channel_throttle->get_servo_out() > 0) && !in_reverse))) {
+    if ((abs(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle)) > 50) &&
+        (((SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) < 0) && in_reverse) ||
+         ((SRV_Channels::get_output_scaled(SRV_Channel::k_throttle) > 0) && !in_reverse))) {
             throttle_nudge = (g.throttle_max - g.throttle_cruise) *
                 ((fabsf(channel_throttle->norm_input())-0.5f) / 0.5f);
     } else {
diff --git a/APMrover2/system.cpp b/APMrover2/system.cpp
index 190280e..b4c8301 100644
--- a/APMrover2/system.cpp
+++ b/APMrover2/system.cpp
@@ -510,9 +510,6 @@ bool Rover::arm_motors(AP_Arming::ArmingMethod method)
         return false;
     }
 
-    // only log if arming was successful
-    channel_throttle->enable_out();
-
     change_arm_state();
     return true;
 }
@@ -525,12 +522,6 @@ bool Rover::disarm_motors(void)
     if (!arming.disarm()) {
         return false;
     }
-    if (arming.arming_required() == AP_Arming::YES_ZERO_PWM) {
-        channel_throttle->disable_out();
-        if (g.skid_steer_out) {
-            channel_steer->disable_out();
-        }
-    }
     if (control_mode != AUTO) {
         // reset the mission on disarm if we are not in auto
         mission.reset();
diff --git a/APMrover2/test.cpp b/APMrover2/test.cpp
index 81e07bf..7c1ecce 100644
--- a/APMrover2/test.cpp
+++ b/APMrover2/test.cpp
@@ -7,8 +7,6 @@
 // User enters the string in the console to call the functions on the right.
 // See class Menu in AP_Common for implementation details
 static const struct Menu::command test_menu_commands[] = {
-    {"pwm",             MENU_FUNC(test_radio_pwm)},
-    {"radio",           MENU_FUNC(test_radio)},
     {"passthru",        MENU_FUNC(test_passthru)},
     {"failsafe",        MENU_FUNC(test_failsafe)},
     {"relay",           MENU_FUNC(test_relay)},
@@ -42,35 +40,6 @@ void Rover::print_hit_enter()
     cliSerial->printf("Hit Enter to exit.\n\n");
 }
 
-int8_t Rover::test_radio_pwm(uint8_t argc, const Menu::arg *argv)
-{
-    print_hit_enter();
-    delay(1000);
-
-    while (1) {
-        delay(20);
-
-        // Filters radio input - adjust filters in the radio.cpp file
-        // ----------------------------------------------------------
-        read_radio();
-
-        cliSerial->printf("IN:\t1: %d\t2: %d\t3: %d\t4: %d\t5: %d\t6: %d\t7: %d\t8: %d\n",
-                            channel_steer->get_radio_in(),
-                            g.rc_2.get_radio_in(),
-                            channel_throttle->get_radio_in(),
-                            g.rc_4.get_radio_in(),
-                            g.rc_5.get_radio_in(),
-                            g.rc_6.get_radio_in(),
-                            g.rc_7.get_radio_in(),
-                            g.rc_8.get_radio_in());
-
-        if (cliSerial->available() > 0) {
-            return (0);
-        }
-    }
-}
-
-
 int8_t Rover::test_passthru(uint8_t argc, const Menu::arg *argv)
 {
     print_hit_enter();
@@ -96,41 +65,6 @@ int8_t Rover::test_passthru(uint8_t argc, const Menu::arg *argv)
     return 0;
 }
 
-int8_t Rover::test_radio(uint8_t argc, const Menu::arg *argv)
-{
-    print_hit_enter();
-    delay(1000);
-
-    // read the radio to set trims
-    // ---------------------------
-    trim_radio();
-
-    while (1) {
-        delay(20);
-        read_radio();
-
-        channel_steer->calc_pwm();
-        channel_throttle->calc_pwm();
-
-        // write out the servo PWM values
-        // ------------------------------
-        set_servos();
-
-        cliSerial->printf("IN 1: %d\t2: %d\t3: %d\t4: %d\t5: %d\t6: %d\t7: %d\t8: %d\n",
-                            channel_steer->get_control_in(),
-                            g.rc_2.get_control_in(),
-                            channel_throttle->get_control_in(),
-                            g.rc_4.get_control_in(),
-                            g.rc_5.get_control_in(),
-                            g.rc_6.get_control_in(),
-                            g.rc_7.get_control_in(),
-                            g.rc_8.get_control_in());
-
-        if (cliSerial->available() > 0) {
-            return (0);
-        }
-    }
-}
 
 int8_t Rover::test_failsafe(uint8_t argc, const Menu::arg *argv)
 {

From 3f71fd98a0cc4b92550514402de35560405576b2 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 13:51:56 +1100
Subject: [PATCH 052/200] AntennaTracker: adapted to new SRV_Channel API

---
 AntennaTracker/Parameters.cpp         | 12 +++------
 AntennaTracker/Parameters.h           |  6 +++--
 AntennaTracker/Tracker.h              |  4 +--
 AntennaTracker/control_manual.cpp     | 14 +++++-----
 AntennaTracker/control_servo_test.cpp | 11 +++++---
 AntennaTracker/radio.cpp              |  3 +--
 AntennaTracker/servos.cpp             | 51 ++++++++++++++++++-----------------
 AntennaTracker/system.cpp             | 16 +++++------
 8 files changed, 59 insertions(+), 58 deletions(-)

diff --git a/AntennaTracker/Parameters.cpp b/AntennaTracker/Parameters.cpp
index 816c429..ea25f3e 100644
--- a/AntennaTracker/Parameters.cpp
+++ b/AntennaTracker/Parameters.cpp
@@ -302,16 +302,12 @@ const AP_Param::Info Tracker::var_info[] = {
     // @Path: ../libraries/AP_Notify/AP_Notify.cpp
     GOBJECT(notify, "NTF_",  AP_Notify),
 
-    // RC channel
-    //-----------
-    // @Group: RC1_
     // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GOBJECT(channel_yaw,       "RC1_", RC_Channel),
-
-    // @Group: RC2_
-    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
-    GOBJECT(channel_pitch,     "RC2_", RC_Channel),
+    GOBJECT(rc_channels,     "RC", RC_Channels),
 
+    // @Path: ../libraries/SRV_Channel/SRV_Channel.cpp
+    GOBJECT(servo_channels,     "SERVO", SRV_Channels),
+    
     // @Group: SERIAL
     // @Path: ../libraries/AP_SerialManager/AP_SerialManager.cpp
     GOBJECT(serial_manager,    "SERIAL",   AP_SerialManager),
diff --git a/AntennaTracker/Parameters.h b/AntennaTracker/Parameters.h
index 1ebae78..5bc388b 100644
--- a/AntennaTracker/Parameters.h
+++ b/AntennaTracker/Parameters.h
@@ -106,10 +106,12 @@ class Parameters {
         //
         // 200 : Radio settings
         //
-        k_param_channel_yaw = 200,
-        k_param_channel_pitch,
+        k_param_channel_yaw_old = 200,
+        k_param_channel_pitch_old,
         k_param_pidPitch2Srv,
         k_param_pidYaw2Srv,
+        k_param_rc_channels,
+        k_param_servo_channels,
 
         //
         // 220: Waypoint data
diff --git a/AntennaTracker/Tracker.h b/AntennaTracker/Tracker.h
index a2b5430..f16319a 100644
--- a/AntennaTracker/Tracker.h
+++ b/AntennaTracker/Tracker.h
@@ -128,8 +128,8 @@ class Tracker : public AP_HAL::HAL::Callbacks {
     /**
        antenna control channels
     */
-    RC_Channel channel_yaw{CH_YAW};
-    RC_Channel channel_pitch{CH_PITCH};
+    RC_Channels rc_channels;
+    SRV_Channels servo_channels;
 
     LowPassFilterFloat yaw_servo_out_filt;
     LowPassFilterFloat pitch_servo_out_filt;
diff --git a/AntennaTracker/control_manual.cpp b/AntennaTracker/control_manual.cpp
index 3322bdc..00335d9 100644
--- a/AntennaTracker/control_manual.cpp
+++ b/AntennaTracker/control_manual.cpp
@@ -11,10 +11,12 @@
 void Tracker::update_manual(void)
 {
     // copy yaw and pitch input to output
-    channel_yaw.set_radio_out(constrain_int16(channel_yaw.get_radio_in(), channel_yaw.get_radio_min(), channel_yaw.get_radio_max()));
-    channel_pitch.set_radio_out(constrain_int16(channel_pitch.get_radio_in(), channel_pitch.get_radio_min(), channel_pitch.get_radio_max()));
-
-    // send output to servos
-    channel_yaw.output();
-    channel_pitch.output();
+    SRV_Channels::set_output_pwm(SRV_Channel::k_steering, RC_Channels::rc_channel(CH_YAW)->get_radio_in());
+    SRV_Channels::constrain_pwm(SRV_Channel::k_steering);
+    
+    SRV_Channels::set_output_pwm(SRV_Channel::k_elevator, RC_Channels::rc_channel(CH_PITCH)->get_radio_in());
+    SRV_Channels::constrain_pwm(SRV_Channel::k_elevator);
+    
+    SRV_Channels::calc_pwm();
+    SRV_Channels::output_ch_all();
 }
diff --git a/AntennaTracker/control_servo_test.cpp b/AntennaTracker/control_servo_test.cpp
index 4aba496..a0508b6 100644
--- a/AntennaTracker/control_servo_test.cpp
+++ b/AntennaTracker/control_servo_test.cpp
@@ -25,16 +25,19 @@ bool Tracker::servo_test_set_servo(uint8_t servo_num, uint16_t pwm)
 
     // set yaw servo pwm and send output to servo
     if (servo_num == CH_YAW) {
-        channel_yaw.set_radio_out(constrain_int16(pwm, channel_yaw.get_radio_min(), channel_yaw.get_radio_max()));
-        channel_yaw.output();
+        SRV_Channels::set_output_pwm(SRV_Channel::k_steering, pwm);
+        SRV_Channels::constrain_pwm(SRV_Channel::k_steering);
     }
 
     // set pitch servo pwm and send output to servo
     if (servo_num == CH_PITCH) {
-        channel_pitch.set_radio_out(constrain_int16(pwm, channel_pitch.get_radio_min(), channel_pitch.get_radio_max()));
-        channel_pitch.output();
+        SRV_Channels::set_output_pwm(SRV_Channel::k_elevator, pwm);
+        SRV_Channels::constrain_pwm(SRV_Channel::k_elevator);
     }
 
+    SRV_Channels::calc_pwm();
+    SRV_Channels::output_ch_all();
+    
     // return success
     return true;
 }
diff --git a/AntennaTracker/radio.cpp b/AntennaTracker/radio.cpp
index 65bd569..8c85bef 100644
--- a/AntennaTracker/radio.cpp
+++ b/AntennaTracker/radio.cpp
@@ -5,7 +5,6 @@
 void Tracker::read_radio()
 {
     if (hal.rcin->new_input()) {
-        channel_yaw.set_pwm(hal.rcin->read(CH_YAW));
-        channel_pitch.set_pwm(hal.rcin->read(CH_PITCH));
+        RC_Channels::set_pwm_all();
     }
 }
diff --git a/AntennaTracker/servos.cpp b/AntennaTracker/servos.cpp
index 89d5871..4d850f3 100644
--- a/AntennaTracker/servos.cpp
+++ b/AntennaTracker/servos.cpp
@@ -7,18 +7,19 @@
 // init_servos - initialises the servos
 void Tracker::init_servos()
 {
-    // setup antenna control PWM channels
-    channel_yaw.set_angle(g.yaw_range * 100/2);        // yaw range is +/- (YAW_RANGE parameter/2) converted to centi-degrees
-    channel_pitch.set_angle((-g.pitch_min+g.pitch_max) * 100/2);    // pitch range is +/- (PITCH_MIN/MAX parameters/2) converted to centi-degrees
+    SRV_Channels::set_default_function(CH_YAW, SRV_Channel::k_steering);
+    SRV_Channels::set_default_function(CH_PITCH, SRV_Channel::k_elevator);
 
-    // move servos to mid position
-    channel_yaw.output_trim();
-    channel_pitch.output_trim();
+    // yaw range is +/- (YAW_RANGE parameter/2) converted to centi-degrees
+    SRV_Channels::set_angle(SRV_Channel::k_steering, g.yaw_range * 100/2);        
 
-    // initialise output to servos
-    channel_yaw.calc_pwm();
-    channel_pitch.calc_pwm();
+    // pitch range is +/- (PITCH_MIN/MAX parameters/2) converted to centi-degrees
+    SRV_Channels::set_angle(SRV_Channel::k_elevator, (-g.pitch_min+g.pitch_max) * 100/2);
 
+    SRV_Channels::output_trim_all();
+    SRV_Channels::calc_pwm();
+    SRV_Channels::output_ch_all();
+    
     yaw_servo_out_filt.set_cutoff_frequency(SERVO_OUT_FILT_HZ);
     pitch_servo_out_filt.set_cutoff_frequency(SERVO_OUT_FILT_HZ);
 }
@@ -45,8 +46,8 @@ void Tracker::update_pitch_servo(float pitch)
     }
 
     // convert servo_out to radio_out and send to servo
-    channel_pitch.calc_pwm();
-    channel_pitch.output();
+    SRV_Channels::calc_pwm();
+    SRV_Channels::output_ch_all();
 }
 
 /**
@@ -76,7 +77,7 @@ void Tracker::update_pitch_position_servo()
 
     // calculate new servo position
     g.pidPitch2Srv.set_input_filter_all(nav_status.angle_error_pitch);
-    int32_t new_servo_out = channel_pitch.get_servo_out() + g.pidPitch2Srv.get_pid();
+    int32_t new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_elevator) + g.pidPitch2Srv.get_pid();
 
     // position limit pitch servo
     if (new_servo_out <= pitch_min_cd) {
@@ -88,7 +89,7 @@ void Tracker::update_pitch_position_servo()
         g.pidPitch2Srv.reset_I();
     }
     // rate limit pitch servo
-    channel_pitch.set_servo_out(new_servo_out);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, new_servo_out);
 
     if (pitch_servo_out_filt_init) {
         pitch_servo_out_filt.apply(new_servo_out, G_Dt);
@@ -110,15 +111,15 @@ void Tracker::update_pitch_onoff_servo(float pitch)
 
     float acceptable_error = g.onoff_pitch_rate * g.onoff_pitch_mintime;
     if (fabsf(nav_status.angle_error_pitch) < acceptable_error) {
-        channel_pitch.set_servo_out(0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, 0);
     } else if ((nav_status.angle_error_pitch > 0) && (pitch*100>pitch_min_cd)) {
         // positive error means we are pointing too low, so push the
         // servo up
-        channel_pitch.set_servo_out(-9000);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, -9000);
     } else if (pitch*100<pitch_max_cd) {
         // negative error means we are pointing too high, so push the
         // servo down
-        channel_pitch.set_servo_out(9000);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, 9000);
     }
 }
 
@@ -131,7 +132,7 @@ void Tracker::update_pitch_cr_servo(float pitch)
     int32_t pitch_max_cd = g.pitch_max*100;
     if ((pitch>pitch_min_cd) && (pitch<pitch_max_cd)) {
         g.pidPitch2Srv.set_input_filter_all(nav_status.angle_error_pitch);
-        channel_pitch.set_servo_out(g.pidPitch2Srv.get_pid());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, g.pidPitch2Srv.get_pid());
     }
 }
 
@@ -156,8 +157,8 @@ void Tracker::update_yaw_servo(float yaw)
     }
 
     // convert servo_out to radio_out and send to servo
-    channel_yaw.calc_pwm();
-    channel_yaw.output();
+    SRV_Channels::calc_pwm();
+    SRV_Channels::output_ch_all();
 }
 
 /**
@@ -200,7 +201,7 @@ void Tracker::update_yaw_position_servo()
     g.pidYaw2Srv.set_input_filter_all(nav_status.angle_error_yaw);
     float servo_change = g.pidYaw2Srv.get_pid();
     servo_change = constrain_float(servo_change, -18000, 18000);
-    float new_servo_out = constrain_float(channel_yaw.get_servo_out() + servo_change, -18000, 18000);
+    float new_servo_out = constrain_float(SRV_Channels::get_output_scaled(SRV_Channel::k_steering) + servo_change, -18000, 18000);
 
     // position limit yaw servo
     if (new_servo_out <= -yaw_limit_cd) {
@@ -212,7 +213,7 @@ void Tracker::update_yaw_position_servo()
         g.pidYaw2Srv.reset_I();
     }
 
-    channel_yaw.set_servo_out(new_servo_out);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_steering, new_servo_out);
 
     if (yaw_servo_out_filt_init) {
         yaw_servo_out_filt.apply(new_servo_out, G_Dt);
@@ -232,15 +233,15 @@ void Tracker::update_yaw_onoff_servo(float yaw)
 {
     float acceptable_error = g.onoff_yaw_rate * g.onoff_yaw_mintime;
     if (fabsf(nav_status.angle_error_yaw * 0.01f) < acceptable_error) {
-        channel_yaw.set_servo_out(0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);
     } else if (nav_status.angle_error_yaw * 0.01f > 0) {
         // positive error means we are counter-clockwise of the target, so
         // move clockwise
-        channel_yaw.set_servo_out(18000);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 18000);
     } else {
         // negative error means we are clockwise of the target, so
         // move counter-clockwise
-        channel_yaw.set_servo_out(-18000);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, -18000);
     }
 }
 
@@ -250,5 +251,5 @@ void Tracker::update_yaw_onoff_servo(float yaw)
 void Tracker::update_yaw_cr_servo(float yaw)
 {
     g.pidYaw2Srv.set_input_filter_all(nav_status.angle_error_yaw);
-    channel_yaw.set_servo_out(-g.pidYaw2Srv.get_pid());
+    SRV_Channels::set_output_scaled(SRV_Channel::k_steering, -g.pidYaw2Srv.get_pid());
 }
diff --git a/AntennaTracker/system.cpp b/AntennaTracker/system.cpp
index 96aef6e..27bef68 100644
--- a/AntennaTracker/system.cpp
+++ b/AntennaTracker/system.cpp
@@ -162,15 +162,13 @@ void Tracker::set_home(struct Location temp)
 }
 
 void Tracker::arm_servos()
-{    
-    channel_yaw.enable_out();
-    channel_pitch.enable_out();
+{
+    hal.util->set_soft_armed(true);
 }
 
 void Tracker::disarm_servos()
 {
-    channel_yaw.disable_out();
-    channel_pitch.disable_out();
+    hal.util->set_soft_armed(false);
 }
 
 /*
@@ -179,10 +177,10 @@ void Tracker::disarm_servos()
 void Tracker::prepare_servos()
 {
     start_time_ms = AP_HAL::millis();
-    channel_yaw.set_radio_out(channel_yaw.get_radio_trim());
-    channel_pitch.set_radio_out(channel_pitch.get_radio_trim());
-    channel_yaw.output();
-    channel_pitch.output();
+    SRV_Channels::set_output_limit(SRV_Channel::k_steering, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_output_limit(SRV_Channel::k_elevator, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::calc_pwm();
+    SRV_Channels::output_ch_all();
 }
 
 void Tracker::set_mode(enum ControlMode mode)

From c638be54a310173f4a25ca07762671c408ca6432 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 16:36:16 +1100
Subject: [PATCH 053/200] Rover: removed use of pwm_to_angle()

---
 APMrover2/APMrover2.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/APMrover2/APMrover2.cpp b/APMrover2/APMrover2.cpp
index 03f93c8..7067f9f 100644
--- a/APMrover2/APMrover2.cpp
+++ b/APMrover2/APMrover2.cpp
@@ -487,12 +487,12 @@ void Rover::update_current_mode(void)
         // constrain to user set TURN_MAX_G
         max_g_force = constrain_float(max_g_force, 0.1f, g.turn_max_g * GRAVITY_MSS);
 
-        lateral_acceleration = max_g_force * (channel_steer->pwm_to_angle()/4500.0f);
+        lateral_acceleration = max_g_force * (channel_steer->get_control_in()/4500.0f);
         calc_nav_steer();
 
         // and throttle gives speed in proportion to cruise speed, up
         // to 50% throttle, then uses nudging above that.
-        float target_speed = channel_throttle->pwm_to_angle() * 0.01f * 2 * g.speed_cruise;
+        float target_speed = channel_throttle->get_control_in() * 0.01f * 2 * g.speed_cruise;
         set_reverse(target_speed < 0);
         if (in_reverse) {
             target_speed = constrain_float(target_speed, -g.speed_cruise, 0);
@@ -512,7 +512,7 @@ void Rover::update_current_mode(void)
           logging
          */
         SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,channel_throttle->get_control_in());
-        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,channel_steer->pwm_to_angle());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,channel_steer->get_control_in());
 
         // mark us as in_reverse when using a negative throttle to
         // stop AHRS getting off

From 081909bf6acd91574db0c41338654e30a6ae4bf3 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 16:36:30 +1100
Subject: [PATCH 054/200] Plane: removed use of pwm_to_angle()

---
 ArduPlane/ArduPlane.cpp | 8 +++-----
 ArduPlane/Attitude.cpp  | 2 +-
 2 files changed, 4 insertions(+), 6 deletions(-)

diff --git a/ArduPlane/ArduPlane.cpp b/ArduPlane/ArduPlane.cpp
index 311c9ed..a12bbf2 100644
--- a/ArduPlane/ArduPlane.cpp
+++ b/ArduPlane/ArduPlane.cpp
@@ -748,12 +748,10 @@ void Plane::update_flight_mode(void)
         break;
 
     case MANUAL:
-        SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, channel_roll->pwm_to_angle());
-        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, channel_pitch->pwm_to_angle());
-        steering_control.steering = steering_control.rudder = channel_rudder->pwm_to_angle();
+        SRV_Channels::set_output_scaled(SRV_Channel::k_aileron, channel_roll->get_control_in_zero_dz());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, channel_pitch->get_control_in_zero_dz());
+        steering_control.steering = steering_control.rudder = channel_rudder->get_control_in_zero_dz();
         break;
-        //roll: -13788.000,  pitch: -13698.000,   thr: 0.000, rud: -13742.000
-
 
     case QSTABILIZE:
     case QHOVER:
diff --git a/ArduPlane/Attitude.cpp b/ArduPlane/Attitude.cpp
index 996b931..17665fd 100644
--- a/ArduPlane/Attitude.cpp
+++ b/ArduPlane/Attitude.cpp
@@ -124,7 +124,7 @@ void Plane::stick_mix_channel(RC_Channel *channel, int16_t &servo_out)
     ch_inf = MIN(ch_inf, 400.0f);
     ch_inf = ((400.0f - ch_inf) / 400.0f);
     servo_out *= ch_inf;
-    servo_out += channel->pwm_to_angle();
+    servo_out += channel->get_control_in();
 }
 
 /*

From cf636a2ea5ea9a58521501bad5430693ee3364ee Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 16:36:42 +1100
Subject: [PATCH 055/200] autotest: fixed default parms for more vehicles

---
 Tools/autotest/default_params/copter-tri.parm        | 6 +++---
 Tools/autotest/default_params/firefly.parm           | 3 ---
 Tools/autotest/default_params/plane-elevons.parm     | 2 --
 Tools/autotest/default_params/plane-jsbsim.parm      | 4 ++--
 Tools/autotest/default_params/plane-vtail.parm       | 2 --
 Tools/autotest/default_params/quadplane-tilttri.parm | 3 ---
 Tools/autotest/default_params/quadplane-tri.parm     | 3 ---
 7 files changed, 5 insertions(+), 18 deletions(-)

diff --git a/Tools/autotest/default_params/copter-tri.parm b/Tools/autotest/default_params/copter-tri.parm
index d4ca6f5..8ab2371 100644
--- a/Tools/autotest/default_params/copter-tri.parm
+++ b/Tools/autotest/default_params/copter-tri.parm
@@ -1,6 +1,6 @@
-MOT_YAW_SV_REV  -1
-MOT_YAW_SV_MIN  1000
-MOT_YAW_SV_MAX  2000
+SERVO7_REVERSED 1
+SERVO7_MIN      1000
+SERVO7_MAX      2000
 EK2_ENABLE      1
 FRAME_TYPE	0
 MAG_ENABLE	1
diff --git a/Tools/autotest/default_params/firefly.parm b/Tools/autotest/default_params/firefly.parm
index 4456c58..8eafe6a 100644
--- a/Tools/autotest/default_params/firefly.parm
+++ b/Tools/autotest/default_params/firefly.parm
@@ -53,12 +53,9 @@ RALLY_TOTAL      0
 RC1_DZ           30
 RC1_MAX          1886
 RC1_MIN          1087
-RC1_REV          1
 RC1_TRIM         1500
-RC2_REV          1
 RC3_MAX          2000
 RC3_MIN          1000
-RC4_REV          1
 RLL2SRV_D        0.141009
 RLL2SRV_I        0.425000
 RLL2SRV_IMAX     4000
diff --git a/Tools/autotest/default_params/plane-elevons.parm b/Tools/autotest/default_params/plane-elevons.parm
index 33354ec..a5e6f5f 100644
--- a/Tools/autotest/default_params/plane-elevons.parm
+++ b/Tools/autotest/default_params/plane-elevons.parm
@@ -18,8 +18,6 @@ KFF_RDDRMIX     0.5
 THR_MAX		100
 ELEVON_OUTPUT   4
 KFF_RDDRMIX     0
-RC2_REV		1
-RC4_REV		1
 RC1_MAX         2000
 RC1_MIN         1000
 RC1_TRIM        1500
diff --git a/Tools/autotest/default_params/plane-jsbsim.parm b/Tools/autotest/default_params/plane-jsbsim.parm
index e9e0fb2..391ff24 100644
--- a/Tools/autotest/default_params/plane-jsbsim.parm
+++ b/Tools/autotest/default_params/plane-jsbsim.parm
@@ -16,8 +16,8 @@ ARSPD_FBW_MAX   30
 ARSPD_FBW_MIN   10
 KFF_RDDRMIX     0.5
 THR_MAX		100
-RC2_REV		-1
-RC4_REV		-1
+RC2_REVERSED	1
+RC4_REVERSED	1
 RC1_MAX         2000
 RC1_MIN         1000
 RC1_TRIM        1500
diff --git a/Tools/autotest/default_params/plane-vtail.parm b/Tools/autotest/default_params/plane-vtail.parm
index 27eafbe..041c00f 100644
--- a/Tools/autotest/default_params/plane-vtail.parm
+++ b/Tools/autotest/default_params/plane-vtail.parm
@@ -16,8 +16,6 @@ ARSPD_FBW_MAX   30
 ARSPD_FBW_MIN   10
 KFF_RDDRMIX     0.5
 THR_MAX		100
-RC2_REV		1
-RC4_REV		1
 RC1_MAX         2000
 RC1_MIN         1000
 RC1_TRIM        1500
diff --git a/Tools/autotest/default_params/quadplane-tilttri.parm b/Tools/autotest/default_params/quadplane-tilttri.parm
index 726e663..de51137 100644
--- a/Tools/autotest/default_params/quadplane-tilttri.parm
+++ b/Tools/autotest/default_params/quadplane-tilttri.parm
@@ -55,12 +55,9 @@ RALLY_TOTAL      0
 RC1_DZ           30
 RC1_MAX          1886
 RC1_MIN          1087
-RC1_REV          1
 RC1_TRIM         1500
-RC2_REV          1
 RC3_MAX          2000
 RC3_MIN          1000
-RC4_REV          1
 RLL2SRV_D        0.141009
 RLL2SRV_I        0.425000
 RLL2SRV_IMAX     4000
diff --git a/Tools/autotest/default_params/quadplane-tri.parm b/Tools/autotest/default_params/quadplane-tri.parm
index ab43c00..f76f2d4 100644
--- a/Tools/autotest/default_params/quadplane-tri.parm
+++ b/Tools/autotest/default_params/quadplane-tri.parm
@@ -55,12 +55,9 @@ RALLY_TOTAL      0
 RC1_DZ           30
 RC1_MAX          1886
 RC1_MIN          1087
-RC1_REV          1
 RC1_TRIM         1500
-RC2_REV          1
 RC3_MAX          2000
 RC3_MIN          1000
-RC4_REV          1
 RLL2SRV_D        0.141009
 RLL2SRV_I        0.425000
 RLL2SRV_IMAX     4000

From b6aa4205b46d4283f6569665a4c55915d7ec6483 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 16:37:00 +1100
Subject: [PATCH 056/200] RC_Channel: cleanup API and comments a bit

---
 libraries/RC_Channel/RC_Channel.h | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/libraries/RC_Channel/RC_Channel.h b/libraries/RC_Channel/RC_Channel.h
index ec81539..3e561e51 100644
--- a/libraries/RC_Channel/RC_Channel.h
+++ b/libraries/RC_Channel/RC_Channel.h
@@ -40,15 +40,13 @@ class RC_Channel {
     // get the center stick position expressed as a control_in value
     int16_t     get_control_mid() const;
 
-    // read input from APM_RC - create a control_in value
+    // read input from hal.rcin - create a control_in value
     void        set_pwm(int16_t pwm);
     void        set_pwm_no_deadzone(int16_t pwm);
 
-    // call after first set_pwm
-    void        trim();
-
+    // calculate an angle given dead_zone and trim. This is used by the quadplane code
+    // for hover throttle
     int16_t     pwm_to_angle_dz_trim(uint16_t dead_zone, uint16_t trim);
-    int16_t     pwm_to_angle();
 
     /*
       return a normalised input for a channel, in range -1 to 1,
@@ -65,11 +63,16 @@ class RC_Channel {
     uint8_t     percent_input();
     int16_t     pwm_to_range();
     int16_t     pwm_to_range_dz(uint16_t dead_zone);
+
+    // read the input value from hal.rcin for this channel
     uint16_t    read() const;
+
+    // read input from hal.rcin and set as pwm input for channel
     void        input();
 
     static const struct AP_Param::GroupInfo var_info[];
 
+    // return true if input is within deadzone of trim
     bool       in_trim_dz();
 
     int16_t    get_radio_in() const { return radio_in;}
@@ -117,6 +120,7 @@ class RC_Channel {
     // the input channel this corresponds to
     uint8_t     ch_in;
 
+    int16_t pwm_to_angle();
     int16_t pwm_to_angle_dz(uint16_t dead_zone);
 };
 

From 51864b23eba7334b7fd093ddbcdd846e89ba9747 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 16:53:40 +1100
Subject: [PATCH 057/200] SRV_Channel: cleanup header

---
 libraries/SRV_Channel/SRV_Channel.h | 22 +++++-----------------
 1 file changed, 5 insertions(+), 17 deletions(-)

diff --git a/libraries/SRV_Channel/SRV_Channel.h b/libraries/SRV_Channel/SRV_Channel.h
index 244ffcb..a3786a9 100644
--- a/libraries/SRV_Channel/SRV_Channel.h
+++ b/libraries/SRV_Channel/SRV_Channel.h
@@ -110,9 +110,6 @@ class SRV_Channel {
         SRV_CHANNEL_LIMIT_ZERO_PWM
     };
 
-    // a special scaled output value that is recognised as meaning no pwm output
-    static const int16_t ZERO_PWM = INT16_MIN;
-
     // set the output value as a pwm value
     void set_output_pwm(uint16_t pwm);
 
@@ -240,10 +237,6 @@ class SRV_Channels {
     // call output_ch() on all channels
     static void output_ch_all(void);
 
-    // take current radio_out for first 4 channels and remap using
-    // servo ranges if enabled
-    void remap_servo_output(void);
-
     // setup output ESC scaling based on a channels MIN/MAX
     void set_esc_scaling_for(SRV_Channel::Aux_servo_function_t function);
 
@@ -313,9 +306,6 @@ class SRV_Channels {
     // assign and enable auxiliary channels
     static void enable_aux_servos(void);
 
-    // prevent a channel from being used for auxiliary functions
-    static void disable_aux_channel(uint8_t channel);
-
     // return the current function for a channel
     static SRV_Channel::Aux_servo_function_t channel_function(uint8_t channel);
 
@@ -342,10 +332,6 @@ class SRV_Channels {
         disabled_passthrough = disable;
     }
 
-    static bool passthrough_disabled(void) {
-        return disabled_passthrough;
-    }
-
     // constrain to output min/max for function
     static void constrain_pwm(SRV_Channel::Aux_servo_function_t function);
     
@@ -363,7 +349,7 @@ class SRV_Channels {
 
     static bool disabled_passthrough;
 
-    uint16_t trimmed_mask;
+    SRV_Channel::servo_mask_t trimmed_mask;
 
     static Bitmask function_mask;
     static bool initialised;
@@ -382,6 +368,8 @@ class SRV_Channels {
 
     AP_Int8 auto_trim;
 
-    // initialise parameters from RC_Channel
-    void initialise_parameters(void);
+    // return true if passthrough is disabled
+    static bool passthrough_disabled(void) {
+        return disabled_passthrough;
+    }
 };

From ea2e32c102b02d137175d44420031d91f985179a Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 17:13:54 +1100
Subject: [PATCH 058/200] SRV_Channel: implement limit_slew_rate()

---
 libraries/SRV_Channel/SRV_Channel.h       |  4 +++-
 libraries/SRV_Channel/SRV_Channel_aux.cpp | 22 +++++++++++++++++++---
 2 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/libraries/SRV_Channel/SRV_Channel.h b/libraries/SRV_Channel/SRV_Channel.h
index a3786a9..6d73959 100644
--- a/libraries/SRV_Channel/SRV_Channel.h
+++ b/libraries/SRV_Channel/SRV_Channel.h
@@ -203,6 +203,8 @@ class SRV_Channel {
 */
 class SRV_Channels {
 public:
+    friend class SRV_Channel;
+    
     // constructor
     SRV_Channels(void);
 
@@ -232,7 +234,7 @@ class SRV_Channels {
     static float get_output_norm(SRV_Channel::Aux_servo_function_t function);
 
     // limit slew rate to given limit in percent per second
-    static void limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate);
+    static void limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate, float dt);
 
     // call output_ch() on all channels
     static void output_ch_all(void);
diff --git a/libraries/SRV_Channel/SRV_Channel_aux.cpp b/libraries/SRV_Channel/SRV_Channel_aux.cpp
index 2bf4ddf..697b808 100644
--- a/libraries/SRV_Channel/SRV_Channel_aux.cpp
+++ b/libraries/SRV_Channel/SRV_Channel_aux.cpp
@@ -542,11 +542,27 @@ float SRV_Channels::get_output_norm(SRV_Channel::Aux_servo_function_t function)
 }
 
 /*
-  limit slew rate for an output function to given rate in percent per second
+  limit slew rate for an output function to given rate in percent per
+  second. This assumes output has not yet done to the hal
  */
-void SRV_Channels::limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate)
+void SRV_Channels::limit_slew_rate(SRV_Channel::Aux_servo_function_t function, float slew_rate, float dt)
 {
-    // NOT IMPLEMENTED YET
+    for (uint8_t i=0; i<NUM_SERVO_CHANNELS; i++) {
+        SRV_Channel &ch = channels[i];
+        if (ch.function == function) {
+            ch.calc_pwm(functions[function].output_scaled);
+            uint16_t last_pwm = hal.rcout->read(ch.ch_num);
+            if (last_pwm == ch.output_pwm) {
+                continue;
+            }
+            uint16_t max_change = (ch.get_output_max() - ch.get_output_min()) * slew_rate * dt * 0.01f;
+            if (max_change == 0) {
+                // always allow some change
+                max_change = 1;
+            }
+            ch.output_pwm = constrain_int16(ch.output_pwm, last_pwm-max_change, last_pwm+max_change);
+        }
+    }
 }
 
 // call set_angle() on matching channels

From 1879eddfa04673063ae03d818adfe421009ebd20 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 7 Jan 2017 17:14:08 +1100
Subject: [PATCH 059/200] Plane: adjust for limit_slew_rate API change

---
 ArduPlane/servos.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/ArduPlane/servos.cpp b/ArduPlane/servos.cpp
index 00e81fe..81a8a0d 100644
--- a/ArduPlane/servos.cpp
+++ b/ArduPlane/servos.cpp
@@ -34,7 +34,7 @@ void Plane::throttle_slew_limit(void)
     }
     // if slew limit rate is set to zero then do not slew limit
     if (slewrate) {                   
-        SRV_Channels::limit_slew_rate(SRV_Channel::k_throttle, slewrate);
+        SRV_Channels::limit_slew_rate(SRV_Channel::k_throttle, slewrate, G_Dt);
     }
 }
 
@@ -540,8 +540,8 @@ void Plane::set_servos_flaps(void)
     SRV_Channels::set_output_scaled(SRV_Channel::k_flap, manual_flap_percent);
 
     if (g.flap_slewrate) {
-        SRV_Channels::limit_slew_rate(SRV_Channel::k_flap_auto, g.flap_slewrate);
-        SRV_Channels::limit_slew_rate(SRV_Channel::k_flap, g.flap_slewrate);
+        SRV_Channels::limit_slew_rate(SRV_Channel::k_flap_auto, g.flap_slewrate, G_Dt);
+        SRV_Channels::limit_slew_rate(SRV_Channel::k_flap, g.flap_slewrate, G_Dt);
     }    
 
     if (g.flaperon_output != MIXING_DISABLED && g.elevon_output == MIXING_DISABLED && g.mix_mode == 0) {

From 6b4e5304cfaae1f529d5f4009a1dc01b68a1bd6b Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sun, 8 Jan 2017 09:29:12 +1100
Subject: [PATCH 060/200] Plane: fixed mixer outputs

---
 ArduPlane/servos.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/ArduPlane/servos.cpp b/ArduPlane/servos.cpp
index 81a8a0d..3b0ba5d 100644
--- a/ArduPlane/servos.cpp
+++ b/ArduPlane/servos.cpp
@@ -754,6 +754,9 @@ void Plane::servos_output(void)
 {
     hal.rcout->cork();
 
+    // the mixers need pwm to be calculated now
+    SRV_Channels::calc_pwm();
+    
     // run vtail and elevon mixers
     servo_output_mixers();
 

From 1bd9d0b7f9d55acea49f8eba7376f32a175bfc40 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sun, 8 Jan 2017 12:19:55 +1100
Subject: [PATCH 061/200] HAL_PX4: cleanup whitespace

---
 libraries/AP_HAL_PX4/RCInput.cpp | 128 +++++++++++++++++++--------------------
 1 file changed, 64 insertions(+), 64 deletions(-)

diff --git a/libraries/AP_HAL_PX4/RCInput.cpp b/libraries/AP_HAL_PX4/RCInput.cpp
index 6d745b1..37ef159 100644
--- a/libraries/AP_HAL_PX4/RCInput.cpp
+++ b/libraries/AP_HAL_PX4/RCInput.cpp
@@ -14,16 +14,16 @@ extern const AP_HAL::HAL& hal;
 
 void PX4RCInput::init()
 {
-	_perf_rcin = perf_alloc(PC_ELAPSED, "APM_rcin");
-	_rc_sub = orb_subscribe(ORB_ID(input_rc));
-	if (_rc_sub == -1) {
-		AP_HAL::panic("Unable to subscribe to input_rc");
-	}
-	clear_overrides();
-        pthread_mutex_init(&rcin_mutex, nullptr);
+    _perf_rcin = perf_alloc(PC_ELAPSED, "APM_rcin");
+    _rc_sub = orb_subscribe(ORB_ID(input_rc));
+    if (_rc_sub == -1) {
+        AP_HAL::panic("Unable to subscribe to input_rc");
+    }
+    clear_overrides();
+    pthread_mutex_init(&rcin_mutex, nullptr);
 }
 
-bool PX4RCInput::new_input() 
+bool PX4RCInput::new_input()
 {
     pthread_mutex_lock(&rcin_mutex);
     bool valid = _rcin.timestamp_last_signal != _last_read || _override_valid;
@@ -33,7 +33,7 @@ bool PX4RCInput::new_input()
     return valid;
 }
 
-uint8_t PX4RCInput::num_channels() 
+uint8_t PX4RCInput::num_channels()
 {
     pthread_mutex_lock(&rcin_mutex);
     uint8_t n = _rcin.channel_count;
@@ -41,80 +41,80 @@ uint8_t PX4RCInput::num_channels()
     return n;
 }
 
-uint16_t PX4RCInput::read(uint8_t ch) 
+uint16_t PX4RCInput::read(uint8_t ch)
 {
-	if (ch >= RC_INPUT_MAX_CHANNELS) {
-		return 0;
-	}
-        pthread_mutex_lock(&rcin_mutex);
-	if (_override[ch]) {
-            uint16_t v = _override[ch];
-            pthread_mutex_unlock(&rcin_mutex);
-            return v;
-	}
-	if (ch >= _rcin.channel_count) {
-            pthread_mutex_unlock(&rcin_mutex);
-            return 0;
-	}
-	uint16_t v = _rcin.values[ch];
+    if (ch >= RC_INPUT_MAX_CHANNELS) {
+        return 0;
+    }
+    pthread_mutex_lock(&rcin_mutex);
+    if (_override[ch]) {
+        uint16_t v = _override[ch];
         pthread_mutex_unlock(&rcin_mutex);
         return v;
+    }
+    if (ch >= _rcin.channel_count) {
+        pthread_mutex_unlock(&rcin_mutex);
+        return 0;
+    }
+    uint16_t v = _rcin.values[ch];
+    pthread_mutex_unlock(&rcin_mutex);
+    return v;
 }
 
-uint8_t PX4RCInput::read(uint16_t* periods, uint8_t len) 
+uint8_t PX4RCInput::read(uint16_t* periods, uint8_t len)
 {
-	if (len > RC_INPUT_MAX_CHANNELS) {
-		len = RC_INPUT_MAX_CHANNELS;
-	}
-	for (uint8_t i = 0; i < len; i++){
-		periods[i] = read(i);
-	}
-	return len;
+    if (len > RC_INPUT_MAX_CHANNELS) {
+        len = RC_INPUT_MAX_CHANNELS;
+    }
+    for (uint8_t i = 0; i < len; i++){
+        periods[i] = read(i);
+    }
+    return len;
 }
 
-bool PX4RCInput::set_overrides(int16_t *overrides, uint8_t len) 
+bool PX4RCInput::set_overrides(int16_t *overrides, uint8_t len)
 {
-	bool res = false;
-	for (uint8_t i = 0; i < len; i++) {
-		res |= set_override(i, overrides[i]);
-	}
-	return res;
+    bool res = false;
+    for (uint8_t i = 0; i < len; i++) {
+        res |= set_override(i, overrides[i]);
+    }
+    return res;
 }
 
 bool PX4RCInput::set_override(uint8_t channel, int16_t override) {
-	if (override < 0) {
-		return false; /* -1: no change. */
-	}
-	if (channel >= RC_INPUT_MAX_CHANNELS) {
-		return false;
-	}
-	_override[channel] = override;
-	if (override != 0) {
-		_override_valid = true;
-		return true;
-	}
-	return false;
+    if (override < 0) {
+        return false; /* -1: no change. */
+    }
+    if (channel >= RC_INPUT_MAX_CHANNELS) {
+        return false;
+    }
+    _override[channel] = override;
+    if (override != 0) {
+        _override_valid = true;
+        return true;
+    }
+    return false;
 }
 
 void PX4RCInput::clear_overrides()
 {
-	for (uint8_t i = 0; i < RC_INPUT_MAX_CHANNELS; i++) {
-		set_override(i, 0);
-	}
+    for (uint8_t i = 0; i < RC_INPUT_MAX_CHANNELS; i++) {
+        set_override(i, 0);
+    }
 }
 
 void PX4RCInput::_timer_tick(void)
 {
-	perf_begin(_perf_rcin);
-	bool rc_updated = false;
-	if (orb_check(_rc_sub, &rc_updated) == 0 && rc_updated) {
-            pthread_mutex_lock(&rcin_mutex);
-            orb_copy(ORB_ID(input_rc), _rc_sub, &_rcin);
-            pthread_mutex_unlock(&rcin_mutex);
-	}
-        // note, we rely on the vehicle code checking new_input() 
-        // and a timeout for the last valid input to handle failsafe
-	perf_end(_perf_rcin);
+    perf_begin(_perf_rcin);
+    bool rc_updated = false;
+    if (orb_check(_rc_sub, &rc_updated) == 0 && rc_updated) {
+        pthread_mutex_lock(&rcin_mutex);
+        orb_copy(ORB_ID(input_rc), _rc_sub, &_rcin);
+        pthread_mutex_unlock(&rcin_mutex);
+    }
+    // note, we rely on the vehicle code checking new_input()
+    // and a timeout for the last valid input to handle failsafe
+    perf_end(_perf_rcin);
 }
 
 bool PX4RCInput::rc_bind(int dsmMode)
@@ -127,7 +127,7 @@ bool PX4RCInput::rc_bind(int dsmMode)
         hal.console->printf("RCInput: failed to open /dev/px4io or /dev/px4fmu\n");
         return false;
     }
-    
+
     uint32_t mode = (dsmMode == 0) ? DSM2_BIND_PULSES : ((dsmMode == 1) ? DSMX_BIND_PULSES : DSMX8_BIND_PULSES);
     int ret = ioctl(fd, DSM_BIND_START, mode);
     close(fd);

From 37c6bec902877f511ceaa57d306f9aca97419529 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sun, 8 Jan 2017 12:37:32 +1100
Subject: [PATCH 062/200] HAL_QURT: fixed a bug in new_input()

same as for HAL_Linux
---
 libraries/AP_HAL_QURT/RCInput.cpp | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_HAL_QURT/RCInput.cpp b/libraries/AP_HAL_QURT/RCInput.cpp
index cd10521..9ebcb64 100644
--- a/libraries/AP_HAL_QURT/RCInput.cpp
+++ b/libraries/AP_HAL_QURT/RCInput.cpp
@@ -64,7 +64,11 @@ void RCInput::read_callback(char *buf, size_t size)
 
 bool RCInput::new_input() 
 {
-    return new_rc_input;
+    bool ret = new_rc_input;
+    if (ret) {
+        new_rc_input = false;
+    }
+    return ret;
 }
 
 uint8_t RCInput::num_channels() 
@@ -74,7 +78,6 @@ uint8_t RCInput::num_channels()
 
 uint16_t RCInput::read(uint8_t ch) 
 {
-    new_rc_input = false;
     if (_override[ch]) {
         return _override[ch];
     }

From 26f9a5569f5293fbc69fc6fc10050129f6e0629d Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 09:29:00 +1100
Subject: [PATCH 063/200] SRV_Channel: added tracker_yaw and tracker_pitch for
 antenna tracker channels

---
 libraries/SRV_Channel/SRV_Channel.cpp | 2 +-
 libraries/SRV_Channel/SRV_Channel.h   | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/libraries/SRV_Channel/SRV_Channel.cpp b/libraries/SRV_Channel/SRV_Channel.cpp
index 0cf796c..84ebda0 100644
--- a/libraries/SRV_Channel/SRV_Channel.cpp
+++ b/libraries/SRV_Channel/SRV_Channel.cpp
@@ -69,7 +69,7 @@ const AP_Param::GroupInfo SRV_Channel::var_info[] = {
     // @Param: FUNCTION
     // @DisplayName: Servo output function
     // @Description: Function assigned to this servo. Seeing this to Disabled(0) will setup this output for control by auto missions or MAVLink servo set commands. any other value will enable the corresponding function
-    // @Values: 0:Disabled,1:RCPassThru,2:Flap,3:Flap_auto,4:Aileron,6:mount_pan,7:mount_tilt,8:mount_roll,9:mount_open,10:camera_trigger,11:release,12:mount2_pan,13:mount2_tilt,14:mount2_roll,15:mount2_open,16:DifferentialSpoiler1,17:DifferentialSpoiler2,18:AileronWithInput,19:Elevator,20:ElevatorWithInput,21:Rudder,24:Flaperon1,25:Flaperon2,26:GroundSteering,27:Parachute,28:EPM,29:LandingGear,30:EngineRunEnable,31:HeliRSC,32:HeliTailRSC,33:Motor1,34:Motor2,35:Motor3,36:Motor4,37:Motor5,38:Motor6,39:Motor7,40:Motor8,51:RCIN1,52:RCIN2,53:RCIN3,54:RCIN4,55:RCIN5,56:RCIN6,57:RCIN7,58:RCIN8,59:RCIN9,60:RCIN10,61:RCIN11,62:RCIN12,63:RCIN13,64:RCIN14,65:RCIN15,66:RCIN16,67:Ignition,68:Choke,69:Starter,70:Throttle
+    // @Values: 0:Disabled,1:RCPassThru,2:Flap,3:Flap_auto,4:Aileron,6:mount_pan,7:mount_tilt,8:mount_roll,9:mount_open,10:camera_trigger,11:release,12:mount2_pan,13:mount2_tilt,14:mount2_roll,15:mount2_open,16:DifferentialSpoiler1,17:DifferentialSpoiler2,18:AileronWithInput,19:Elevator,20:ElevatorWithInput,21:Rudder,24:Flaperon1,25:Flaperon2,26:GroundSteering,27:Parachute,28:EPM,29:LandingGear,30:EngineRunEnable,31:HeliRSC,32:HeliTailRSC,33:Motor1,34:Motor2,35:Motor3,36:Motor4,37:Motor5,38:Motor6,39:Motor7,40:Motor8,51:RCIN1,52:RCIN2,53:RCIN3,54:RCIN4,55:RCIN5,56:RCIN6,57:RCIN7,58:RCIN8,59:RCIN9,60:RCIN10,61:RCIN11,62:RCIN12,63:RCIN13,64:RCIN14,65:RCIN15,66:RCIN16,67:Ignition,68:Choke,69:Starter,70:Throttle,71:TrackerYaw,72:TrackerPitch
     // @User: Standard
     AP_GROUPINFO("FUNCTION",  5, SRV_Channel, function, 0),
     
diff --git a/libraries/SRV_Channel/SRV_Channel.h b/libraries/SRV_Channel/SRV_Channel.h
index 6d73959..1648f1f 100644
--- a/libraries/SRV_Channel/SRV_Channel.h
+++ b/libraries/SRV_Channel/SRV_Channel.h
@@ -99,6 +99,8 @@ class SRV_Channel {
         k_choke                 = 68,
         k_starter               = 69,
         k_throttle              = 70,
+        k_tracker_yaw           = 71,            ///< antennatracker yaw
+        k_tracker_pitch         = 72,            ///< antennatracker pitch
         k_nr_aux_servo_functions         ///< This must be the last enum value (only add new values _before_ this one)
     } Aux_servo_function_t;
 

From 2513b27058350433ebc68b4ec6de23a8f94620bd Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 09:30:37 +1100
Subject: [PATCH 064/200] Tracker: use k_tracker_yaw and k_tracker_pitch

thanks to review by Buzz
---
 AntennaTracker/control_manual.cpp     |  8 ++++----
 AntennaTracker/control_servo_test.cpp |  8 ++++----
 AntennaTracker/servos.cpp             | 32 ++++++++++++++++----------------
 AntennaTracker/system.cpp             |  4 ++--
 4 files changed, 26 insertions(+), 26 deletions(-)

diff --git a/AntennaTracker/control_manual.cpp b/AntennaTracker/control_manual.cpp
index 00335d9..5cc87a5 100644
--- a/AntennaTracker/control_manual.cpp
+++ b/AntennaTracker/control_manual.cpp
@@ -11,11 +11,11 @@
 void Tracker::update_manual(void)
 {
     // copy yaw and pitch input to output
-    SRV_Channels::set_output_pwm(SRV_Channel::k_steering, RC_Channels::rc_channel(CH_YAW)->get_radio_in());
-    SRV_Channels::constrain_pwm(SRV_Channel::k_steering);
+    SRV_Channels::set_output_pwm(SRV_Channel::k_tracker_yaw, RC_Channels::rc_channel(CH_YAW)->get_radio_in());
+    SRV_Channels::constrain_pwm(SRV_Channel::k_tracker_yaw);
     
-    SRV_Channels::set_output_pwm(SRV_Channel::k_elevator, RC_Channels::rc_channel(CH_PITCH)->get_radio_in());
-    SRV_Channels::constrain_pwm(SRV_Channel::k_elevator);
+    SRV_Channels::set_output_pwm(SRV_Channel::k_tracker_pitch, RC_Channels::rc_channel(CH_PITCH)->get_radio_in());
+    SRV_Channels::constrain_pwm(SRV_Channel::k_tracker_pitch);
     
     SRV_Channels::calc_pwm();
     SRV_Channels::output_ch_all();
diff --git a/AntennaTracker/control_servo_test.cpp b/AntennaTracker/control_servo_test.cpp
index a0508b6..d8f4deb 100644
--- a/AntennaTracker/control_servo_test.cpp
+++ b/AntennaTracker/control_servo_test.cpp
@@ -25,14 +25,14 @@ bool Tracker::servo_test_set_servo(uint8_t servo_num, uint16_t pwm)
 
     // set yaw servo pwm and send output to servo
     if (servo_num == CH_YAW) {
-        SRV_Channels::set_output_pwm(SRV_Channel::k_steering, pwm);
-        SRV_Channels::constrain_pwm(SRV_Channel::k_steering);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_tracker_yaw, pwm);
+        SRV_Channels::constrain_pwm(SRV_Channel::k_tracker_yaw);
     }
 
     // set pitch servo pwm and send output to servo
     if (servo_num == CH_PITCH) {
-        SRV_Channels::set_output_pwm(SRV_Channel::k_elevator, pwm);
-        SRV_Channels::constrain_pwm(SRV_Channel::k_elevator);
+        SRV_Channels::set_output_pwm(SRV_Channel::k_tracker_pitch, pwm);
+        SRV_Channels::constrain_pwm(SRV_Channel::k_tracker_pitch);
     }
 
     SRV_Channels::calc_pwm();
diff --git a/AntennaTracker/servos.cpp b/AntennaTracker/servos.cpp
index 4d850f3..d8d47c3 100644
--- a/AntennaTracker/servos.cpp
+++ b/AntennaTracker/servos.cpp
@@ -7,14 +7,14 @@
 // init_servos - initialises the servos
 void Tracker::init_servos()
 {
-    SRV_Channels::set_default_function(CH_YAW, SRV_Channel::k_steering);
-    SRV_Channels::set_default_function(CH_PITCH, SRV_Channel::k_elevator);
+    SRV_Channels::set_default_function(CH_YAW, SRV_Channel::k_tracker_yaw);
+    SRV_Channels::set_default_function(CH_PITCH, SRV_Channel::k_tracker_pitch);
 
     // yaw range is +/- (YAW_RANGE parameter/2) converted to centi-degrees
-    SRV_Channels::set_angle(SRV_Channel::k_steering, g.yaw_range * 100/2);        
+    SRV_Channels::set_angle(SRV_Channel::k_tracker_yaw, g.yaw_range * 100/2);        
 
     // pitch range is +/- (PITCH_MIN/MAX parameters/2) converted to centi-degrees
-    SRV_Channels::set_angle(SRV_Channel::k_elevator, (-g.pitch_min+g.pitch_max) * 100/2);
+    SRV_Channels::set_angle(SRV_Channel::k_tracker_pitch, (-g.pitch_min+g.pitch_max) * 100/2);
 
     SRV_Channels::output_trim_all();
     SRV_Channels::calc_pwm();
@@ -77,7 +77,7 @@ void Tracker::update_pitch_position_servo()
 
     // calculate new servo position
     g.pidPitch2Srv.set_input_filter_all(nav_status.angle_error_pitch);
-    int32_t new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_elevator) + g.pidPitch2Srv.get_pid();
+    int32_t new_servo_out = SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_pitch) + g.pidPitch2Srv.get_pid();
 
     // position limit pitch servo
     if (new_servo_out <= pitch_min_cd) {
@@ -89,7 +89,7 @@ void Tracker::update_pitch_position_servo()
         g.pidPitch2Srv.reset_I();
     }
     // rate limit pitch servo
-    SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, new_servo_out);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, new_servo_out);
 
     if (pitch_servo_out_filt_init) {
         pitch_servo_out_filt.apply(new_servo_out, G_Dt);
@@ -111,15 +111,15 @@ void Tracker::update_pitch_onoff_servo(float pitch)
 
     float acceptable_error = g.onoff_pitch_rate * g.onoff_pitch_mintime;
     if (fabsf(nav_status.angle_error_pitch) < acceptable_error) {
-        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, 0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 0);
     } else if ((nav_status.angle_error_pitch > 0) && (pitch*100>pitch_min_cd)) {
         // positive error means we are pointing too low, so push the
         // servo up
-        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, -9000);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, -9000);
     } else if (pitch*100<pitch_max_cd) {
         // negative error means we are pointing too high, so push the
         // servo down
-        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, 9000);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, 9000);
     }
 }
 
@@ -132,7 +132,7 @@ void Tracker::update_pitch_cr_servo(float pitch)
     int32_t pitch_max_cd = g.pitch_max*100;
     if ((pitch>pitch_min_cd) && (pitch<pitch_max_cd)) {
         g.pidPitch2Srv.set_input_filter_all(nav_status.angle_error_pitch);
-        SRV_Channels::set_output_scaled(SRV_Channel::k_elevator, g.pidPitch2Srv.get_pid());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_pitch, g.pidPitch2Srv.get_pid());
     }
 }
 
@@ -201,7 +201,7 @@ void Tracker::update_yaw_position_servo()
     g.pidYaw2Srv.set_input_filter_all(nav_status.angle_error_yaw);
     float servo_change = g.pidYaw2Srv.get_pid();
     servo_change = constrain_float(servo_change, -18000, 18000);
-    float new_servo_out = constrain_float(SRV_Channels::get_output_scaled(SRV_Channel::k_steering) + servo_change, -18000, 18000);
+    float new_servo_out = constrain_float(SRV_Channels::get_output_scaled(SRV_Channel::k_tracker_yaw) + servo_change, -18000, 18000);
 
     // position limit yaw servo
     if (new_servo_out <= -yaw_limit_cd) {
@@ -213,7 +213,7 @@ void Tracker::update_yaw_position_servo()
         g.pidYaw2Srv.reset_I();
     }
 
-    SRV_Channels::set_output_scaled(SRV_Channel::k_steering, new_servo_out);
+    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, new_servo_out);
 
     if (yaw_servo_out_filt_init) {
         yaw_servo_out_filt.apply(new_servo_out, G_Dt);
@@ -233,15 +233,15 @@ void Tracker::update_yaw_onoff_servo(float yaw)
 {
     float acceptable_error = g.onoff_yaw_rate * g.onoff_yaw_mintime;
     if (fabsf(nav_status.angle_error_yaw * 0.01f) < acceptable_error) {
-        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, 0);
     } else if (nav_status.angle_error_yaw * 0.01f > 0) {
         // positive error means we are counter-clockwise of the target, so
         // move clockwise
-        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 18000);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, 18000);
     } else {
         // negative error means we are clockwise of the target, so
         // move counter-clockwise
-        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, -18000);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, -18000);
     }
 }
 
@@ -251,5 +251,5 @@ void Tracker::update_yaw_onoff_servo(float yaw)
 void Tracker::update_yaw_cr_servo(float yaw)
 {
     g.pidYaw2Srv.set_input_filter_all(nav_status.angle_error_yaw);
-    SRV_Channels::set_output_scaled(SRV_Channel::k_steering, -g.pidYaw2Srv.get_pid());
+    SRV_Channels::set_output_scaled(SRV_Channel::k_tracker_yaw, -g.pidYaw2Srv.get_pid());
 }
diff --git a/AntennaTracker/system.cpp b/AntennaTracker/system.cpp
index 27bef68..60706ab 100644
--- a/AntennaTracker/system.cpp
+++ b/AntennaTracker/system.cpp
@@ -177,8 +177,8 @@ void Tracker::disarm_servos()
 void Tracker::prepare_servos()
 {
     start_time_ms = AP_HAL::millis();
-    SRV_Channels::set_output_limit(SRV_Channel::k_steering, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
-    SRV_Channels::set_output_limit(SRV_Channel::k_elevator, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_output_limit(SRV_Channel::k_tracker_yaw, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
+    SRV_Channels::set_output_limit(SRV_Channel::k_tracker_pitch, SRV_Channel::SRV_CHANNEL_LIMIT_TRIM);
     SRV_Channels::calc_pwm();
     SRV_Channels::output_ch_all();
 }

From cb4ebdd7b4e7d4547a9651cbc3e9e243782afb2d Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 10:20:38 +1100
Subject: [PATCH 065/200] Plane: fixed throttle_percentage()

thanks to Buzz for noticing!
---
 ArduPlane/system.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ArduPlane/system.cpp b/ArduPlane/system.cpp
index d47a327..8ed0e55 100644
--- a/ArduPlane/system.cpp
+++ b/ArduPlane/system.cpp
@@ -772,7 +772,7 @@ int8_t Plane::throttle_percentage(void)
     // returns a number from -1 to 1.
     float throttle = SRV_Channels::get_output_norm(SRV_Channel::k_throttle);
     if (aparm.throttle_min >= 0) {
-        return constrain_int16(100*throttle, 0, 100);
+        return constrain_int16(50*(throttle+1), 0, 100);
     } else {
         // reverse thrust
         return constrain_int16(100*throttle, -100, 100);

From c133b515e050edf370ea83f3f080b8570f4cd6cc Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 10:22:56 +1100
Subject: [PATCH 066/200] AP_ServoRelayEvents: fixed trim bug

thanks to Buzz for noticing!
---
 libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp b/libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp
index 8c1429f..88edaa7 100644
--- a/libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp
+++ b/libraries/AP_ServoRelayEvents/AP_ServoRelayEvents.cpp
@@ -113,7 +113,7 @@ void AP_ServoRelayEvents::update_events(void)
     case EVENT_TYPE_SERVO:
         hal.rcout->enable_ch(channel-1);
         if (repeat & 1) {
-            hal.rcout->write(channel-1, SRV_Channels::srv_channel(channel-1)->get_output_pwm());
+            hal.rcout->write(channel-1, SRV_Channels::srv_channel(channel-1)->get_trim());
         } else {
             hal.rcout->write(channel-1, servo_value);
         }

From 77a7e7ca01d8ebdedef4bcf2d806ec0578e6ee45 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 11:47:26 +1100
Subject: [PATCH 067/200] RC_Channel: give access to internals to SRV_Channel

needed for parameter upgrade
---
 libraries/RC_Channel/RC_Channel.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libraries/RC_Channel/RC_Channel.h b/libraries/RC_Channel/RC_Channel.h
index 3e561e51..0e44341 100644
--- a/libraries/RC_Channel/RC_Channel.h
+++ b/libraries/RC_Channel/RC_Channel.h
@@ -14,6 +14,7 @@
 /// @brief	Object managing one RC channel
 class RC_Channel {
 public:
+    friend class SRV_Channels;
     friend class RC_Channels;
     // Constructor
     RC_Channel(void);
@@ -130,6 +131,7 @@ class RC_Channel {
 */
 class RC_Channels {
 public:
+    friend class SRV_Channels;
     // constructor
     RC_Channels(void);
 

From 86e0b8a91f53bc42d8f3ab462af9f86403219b14 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 11:47:43 +1100
Subject: [PATCH 068/200] SRV_Channel: added automatic parameter upgrade

---
 libraries/SRV_Channel/SRV_Channel.h       |   3 +
 libraries/SRV_Channel/SRV_Channel_aux.cpp | 115 ++++++++++++++++++++++++++++++
 2 files changed, 118 insertions(+)

diff --git a/libraries/SRV_Channel/SRV_Channel.h b/libraries/SRV_Channel/SRV_Channel.h
index 1648f1f..4151bea 100644
--- a/libraries/SRV_Channel/SRV_Channel.h
+++ b/libraries/SRV_Channel/SRV_Channel.h
@@ -346,6 +346,9 @@ class SRV_Channels {
         return i<NUM_SERVO_CHANNELS?&channels[i]:nullptr;
     }
 
+    // upgrade RC* parameters into SERVO* parameters
+    static bool upgrade_parameters(const uint8_t old_keys[14], uint16_t aux_channel_mask, RCMapper *rcmap);
+    
 private:
     struct {
         bool k_throttle_reversible:1;
diff --git a/libraries/SRV_Channel/SRV_Channel_aux.cpp b/libraries/SRV_Channel/SRV_Channel_aux.cpp
index 697b808..91ceef8 100644
--- a/libraries/SRV_Channel/SRV_Channel_aux.cpp
+++ b/libraries/SRV_Channel/SRV_Channel_aux.cpp
@@ -20,6 +20,7 @@
 #include <AP_Math/AP_Math.h>
 #include <AP_HAL/AP_HAL.h>
 #include <RC_Channel/RC_Channel.h>
+#include <AP_RCMapper/AP_RCMapper.h>
 
 extern const AP_HAL::HAL& hal;
 
@@ -595,3 +596,117 @@ void SRV_Channels::constrain_pwm(SRV_Channel::Aux_servo_function_t function)
         }
     }
 }
+
+/*
+  upgrade RC* parameters into SERVO* parameters. This does the following:
+
+  - copies MIN/MAX/TRIM values from old RC parameters into new RC* parameters and SERVO* parameters. 
+  - copies RCn_FUNCTION to SERVOn_FUNCTION
+  - maps old RCn_REV to SERVOn_REVERSE and RCn_REVERSE
+
+  aux_channel_mask is a bitmask of which channels were RC_Channel_aux channels
+
+  Note that this code is highly dependent on the parameter indexing of
+  the old RC_Channel and RC_Channel_aux objects.
+
+  If rcmap is passed in then the vehicle code also wants functions for
+  the first 4 output channels to be remapped
+
+  We return true if an upgrade has been done. This allows the caller
+  to make any vehicle specific upgrades that may be needed
+*/
+bool SRV_Channels::upgrade_parameters(const uint8_t rc_keys[14], uint16_t aux_channel_mask, RCMapper *rcmap)
+{
+    // use SERVO16_FUNCTION as a marker to say that we have run the upgrade already
+    if (channels[15].function.configured_in_storage()) {
+        // upgrade already done
+        return false;
+    }
+    
+    // old system had 14 RC channels
+    for (uint8_t i=0; i<14; i++) {
+        uint8_t k = rc_keys[i];
+        if (k == 0) {
+            // missing parameter. Some vehicle types didn't have all parameters
+            continue;
+        }
+        SRV_Channel &srv_chan = channels[i];
+        RC_Channel &rc_chan = RC_Channels::channels[i];
+        const struct mapping {
+            uint8_t old_index;
+            AP_Param *new_srv_param;
+            AP_Param *new_rc_param;
+            enum ap_var_type type;
+            bool is_reverse;
+        } mapping[] = {
+            { 0, &srv_chan.servo_min,  &rc_chan.radio_min,  AP_PARAM_INT16, false },
+            { 1, &srv_chan.servo_trim, &rc_chan.radio_trim, AP_PARAM_INT16, false },
+            { 2, &srv_chan.servo_max,  &rc_chan.radio_max,  AP_PARAM_INT16, false },
+            { 3, &srv_chan.reversed,   &rc_chan.reversed,   AP_PARAM_INT8,  true },
+            { 1, &srv_chan.function,   nullptr,             AP_PARAM_INT8,  false },
+        };
+        bool is_aux = aux_channel_mask & (1U<<i);
+        
+        for (uint8_t j=0; j<ARRAY_SIZE(mapping); j++) {
+            const struct mapping &m = mapping[j];
+            AP_Param::ConversionInfo info;
+            AP_Int8 v8;
+            AP_Int16 v16;
+            AP_Param *v = m.type == AP_PARAM_INT16?(AP_Param*)&v16:(AP_Param*)&v8;
+            info.old_key = k;
+            info.type = m.type;
+            info.new_name = nullptr;
+            // if this was an aux channel we need to shift by 6 bits, but not for RCn_FUNCTION
+            info.old_group_element = (is_aux && m.new_rc_param)?(m.old_index<<6):m.old_index;
+            
+            if (!AP_Param::find_old_parameter(&info, v)) {
+                // the parameter wasn't set in the old eeprom
+                continue;
+            }
+
+            if (m.is_reverse) {
+                // special mapping from RCn_REV to RCn_REVERSED
+                v8.set(v8.get() == -1?1:0);
+            }
+            
+            if (!m.new_srv_param->configured_in_storage()) {
+                // not configured yet in new eeprom
+                if (m.type == AP_PARAM_INT16) {
+                    ((AP_Int16 *)m.new_srv_param)->set_and_save_ifchanged(v16.get());
+                } else {
+                    ((AP_Int8 *)m.new_srv_param)->set_and_save_ifchanged(v8.get());
+                }
+            }
+            if (m.new_rc_param && !m.new_rc_param->configured_in_storage()) {
+                // not configured yet in new eeprom
+                if (m.type == AP_PARAM_INT16) {
+                    ((AP_Int16 *)m.new_rc_param)->set_and_save_ifchanged(v16.get());
+                } else {
+                    ((AP_Int8 *)m.new_rc_param)->set_and_save_ifchanged(v8.get());
+                }
+            }
+        }
+    }
+
+    if (rcmap != nullptr) {
+        // we need to make the output functions from the rcmapped inputs
+        const int8_t func_map[4] = { channels[0].function.get(),
+                                     channels[1].function.get(),
+                                     channels[2].function.get(),
+                                     channels[3].function.get() };
+        const uint8_t map[4] = { rcmap->roll(), rcmap->pitch(), rcmap->throttle(), rcmap->yaw() };
+        for (uint8_t i=0; i<4; i++) {
+            uint8_t m = uint8_t(map[i]-1);
+            if (m != i && m < 4) {
+                channels[m].function.set_and_save_ifchanged(func_map[i]);
+            }
+        }
+    }
+
+    
+    // mark the upgrade as having been done
+    channels[15].function.set_and_save(channels[15].function.get());
+
+    return true;
+}
+

From 68504dbcbb6d76efe5fc91c49cdd4351d3bcaf23 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 11:47:58 +1100
Subject: [PATCH 069/200] Plane: auto-upgrade old parameters for SRV_Channel
 split

---
 ArduPlane/Parameters.cpp | 22 ++++++++++++++++------
 1 file changed, 16 insertions(+), 6 deletions(-)

diff --git a/ArduPlane/Parameters.cpp b/ArduPlane/Parameters.cpp
index 042ffec..782d9e3 100644
--- a/ArduPlane/Parameters.cpp
+++ b/ArduPlane/Parameters.cpp
@@ -1323,16 +1323,26 @@ void Plane::load_parameters(void)
     AP_Param::load_all();
     AP_Param::convert_old_parameters(&conversion_table[0], ARRAY_SIZE(conversion_table));
 
-    if (quadplane.enable) {
-        // quadplanes needs a higher loop rate
-        AP_Param::set_default_by_name("SCHED_LOOP_RATE", 300);
-    }
-
     // setup defaults in SRV_Channels
     g2.servo_channels.set_default_function(CH_1, SRV_Channel::k_aileron);
     g2.servo_channels.set_default_function(CH_2, SRV_Channel::k_elevator);
     g2.servo_channels.set_default_function(CH_3, SRV_Channel::k_throttle);
     g2.servo_channels.set_default_function(CH_4, SRV_Channel::k_rudder);
-    
+        
+    const uint8_t old_rc_keys[14] = { Parameters::k_param_rc_1_old,  Parameters::k_param_rc_2_old,
+                                      Parameters::k_param_rc_3_old,  Parameters::k_param_rc_4_old,
+                                      Parameters::k_param_rc_5_old,  Parameters::k_param_rc_6_old,
+                                      Parameters::k_param_rc_7_old,  Parameters::k_param_rc_8_old,
+                                      Parameters::k_param_rc_9_old,  Parameters::k_param_rc_10_old,
+                                      Parameters::k_param_rc_11_old, Parameters::k_param_rc_12_old,
+                                      Parameters::k_param_rc_13_old, Parameters::k_param_rc_14_old };
+    const uint16_t old_aux_chan_mask = 0x3FF0;
+    SRV_Channels::upgrade_parameters(old_rc_keys, old_aux_chan_mask, &rcmap);
+
+    if (quadplane.enable) {
+        // quadplanes needs a higher loop rate
+        AP_Param::set_default_by_name("SCHED_LOOP_RATE", 300);
+    }
+
     cliSerial->printf("load_all took %uus\n", (unsigned)(micros() - before));
 }

From 9fe3eba2a03fa51d1bc9e4926021558e1a1464fa Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 12:43:57 +1100
Subject: [PATCH 070/200] Rover: added automatic parameter upgrade for
 SRV_Channel

---
 APMrover2/Parameters.cpp | 13 +++++++++++++
 APMrover2/radio.cpp      |  3 ---
 2 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/APMrover2/Parameters.cpp b/APMrover2/Parameters.cpp
index 707420a..cd75e7f 100644
--- a/APMrover2/Parameters.cpp
+++ b/APMrover2/Parameters.cpp
@@ -594,6 +594,19 @@ void Rover::load_parameters(void)
     // Load all auto-loaded EEPROM variables
     AP_Param::load_all();
 
+    SRV_Channels::set_default_function(CH_1, SRV_Channel::k_steering);
+    SRV_Channels::set_default_function(CH_3, SRV_Channel::k_throttle);
+    
+    const uint8_t old_rc_keys[14] = { Parameters::k_param_rc_1_old,  Parameters::k_param_rc_2_old,
+                                      Parameters::k_param_rc_3_old,  Parameters::k_param_rc_4_old,
+                                      Parameters::k_param_rc_5_old,  Parameters::k_param_rc_6_old,
+                                      Parameters::k_param_rc_7_old,  Parameters::k_param_rc_8_old,
+                                      Parameters::k_param_rc_9_old,  Parameters::k_param_rc_10_old,
+                                      Parameters::k_param_rc_11_old, Parameters::k_param_rc_12_old,
+                                      Parameters::k_param_rc_13_old, Parameters::k_param_rc_14_old };
+    const uint16_t old_aux_chan_mask = 0x3FFA;
+    SRV_Channels::upgrade_parameters(old_rc_keys, old_aux_chan_mask, &rcmap);
+    
     cliSerial->printf("load_all took %luus\n", micros() - before);
 
     // set a more reasonable default NAVL1_PERIOD for rovers
diff --git a/APMrover2/radio.cpp b/APMrover2/radio.cpp
index c18c209..19f4feb 100644
--- a/APMrover2/radio.cpp
+++ b/APMrover2/radio.cpp
@@ -9,9 +9,6 @@ void Rover::set_control_channels(void)
     channel_throttle = RC_Channels::rc_channel(rcmap.throttle()-1);
     channel_learn    = RC_Channels::rc_channel(g.learn_channel-1);
 
-    SRV_Channels::set_default_function(CH_1, SRV_Channel::k_steering);
-    SRV_Channels::set_default_function(CH_3, SRV_Channel::k_throttle);
-    
     // set rc channel ranges
     channel_steer->set_angle(SERVO_MAX);
     channel_throttle->set_angle(100);

From 3c1517f5830b1d17e7556a87f9543dd49a7d6183 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 12:48:13 +1100
Subject: [PATCH 071/200] Copter: added automatic SRV_Channel parameter upgrade

---
 ArduCopter/Parameters.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index c5f5cb6..28779e9 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -1162,4 +1162,15 @@ void Copter::convert_pid_parameters(void)
     for (uint8_t i=0; i<table_size; i++) {
         AP_Param::convert_old_parameter(&throttle_conversion_info[i], 0.001f);
     }
+
+    const uint8_t old_rc_keys[14] = { Parameters::k_param_rc_1_old,  Parameters::k_param_rc_2_old,
+                                      Parameters::k_param_rc_3_old,  Parameters::k_param_rc_4_old,
+                                      Parameters::k_param_rc_5_old,  Parameters::k_param_rc_6_old,
+                                      Parameters::k_param_rc_7_old,  Parameters::k_param_rc_8_old,
+                                      Parameters::k_param_rc_9_old,  Parameters::k_param_rc_10_old,
+                                      Parameters::k_param_rc_11_old, Parameters::k_param_rc_12_old,
+                                      Parameters::k_param_rc_13_old, Parameters::k_param_rc_14_old };
+    const uint16_t old_aux_chan_mask = 0x3FF0;
+    // note that we don't pass in rcmap as we don't want output channel functions changed based on rcmap
+    SRV_Channels::upgrade_parameters(old_rc_keys, old_aux_chan_mask, nullptr);
 }

From 8799094278c1f495905c902ef2356e723e86efa1 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 15:01:30 +1100
Subject: [PATCH 072/200] AP_Motors: use SRV_Channel for tri tail servo

---
 libraries/AP_Motors/AP_MotorsTri.cpp | 53 ++++++++++--------------------------
 libraries/AP_Motors/AP_MotorsTri.h   |  8 ++----
 2 files changed, 17 insertions(+), 44 deletions(-)

diff --git a/libraries/AP_Motors/AP_MotorsTri.cpp b/libraries/AP_Motors/AP_MotorsTri.cpp
index 9e14bb7..d577b58 100644
--- a/libraries/AP_Motors/AP_MotorsTri.cpp
+++ b/libraries/AP_Motors/AP_MotorsTri.cpp
@@ -20,6 +20,7 @@
  */
 #include <AP_HAL/AP_HAL.h>
 #include <AP_Math/AP_Math.h>
+#include <GCS_MAVLink/GCS.h>
 #include "AP_MotorsTri.h"
 
 extern const AP_HAL::HAL& hal;
@@ -32,40 +33,6 @@ const AP_Param::GroupInfo AP_MotorsTri::var_info[] = {
     // parameters 30 ~ 39 reserved for tricopter
     // parameters 40 ~ 49 for single copter and coax copter (these have identical parameter files)
 
-    // @Param: YAW_SV_REV
-    // @DisplayName: Yaw Servo Reverse
-    // @Description: Yaw servo reversing. Set to 1 for normal (forward) operation. Set to -1 to reverse this channel.
-    // @Values: -1:Reversed,1:Normal
-    // @User: Standard
-    AP_GROUPINFO("YAW_SV_REV", 31,     AP_MotorsTri,  _yaw_reverse, 1),
-
-    // @Param: YAW_SV_TRIM
-    // @DisplayName: Yaw Servo Trim/Center
-    // @Description: Trim or center position of yaw servo
-    // @Range: 1250 1750
-    // @Units: PWM
-    // @Increment: 1
-    // @User: Standard
-    AP_GROUPINFO("YAW_SV_TRIM", 32,     AP_MotorsTri,  _yaw_servo_trim, 1500),
-
-    // @Param: YAW_SV_MIN
-    // @DisplayName: Yaw Servo Min PWM
-    // @Description: Yaw servo's minimum pwm value
-    // @Range: 1000 1400
-    // @Units: PWM
-    // @Increment: 1
-    // @User: Standard
-    AP_GROUPINFO("YAW_SV_MIN", 33,     AP_MotorsTri,  _yaw_servo_min, 1250),
-
-    // @Param: YAW_SV_MAX
-    // @DisplayName: Yaw Servo Max PWM
-    // @Description: Yaw servo's maximum pwm value
-    // @Range: 1600 2000
-    // @Units: PWM
-    // @Increment: 1
-    // @User: Standard
-    AP_GROUPINFO("YAW_SV_MAX", 34,     AP_MotorsTri,  _yaw_servo_max, 1750),
-
     // @Param: YAW_SV_ANGLE
     // @DisplayName: Yaw Servo Max Lean Angle
     // @Description: Yaw servo's maximum lean angle
@@ -93,6 +60,14 @@ void AP_MotorsTri::init(motor_frame_class frame_class, motor_frame_type frame_ty
     motor_enabled[AP_MOTORS_MOT_2] = true;
     motor_enabled[AP_MOTORS_MOT_4] = true;
 
+    // find the yaw servo
+    _yaw_servo = SRV_Channels::get_channel_for(SRV_Channel::k_motor7, AP_MOTORS_CH_TRI_YAW);
+    if (!_yaw_servo) {
+        GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_ERROR, "MotorsTri: unable to setup yaw channel");
+        // don't set initialised_ok
+        return;
+    }
+    
     // allow mapping of motor7
     add_motor_num(AP_MOTORS_CH_TRI_YAW);
 
@@ -139,7 +114,7 @@ void AP_MotorsTri::output_to_motors()
             rc_write(AP_MOTORS_MOT_1, get_pwm_output_min());
             rc_write(AP_MOTORS_MOT_2, get_pwm_output_min());
             rc_write(AP_MOTORS_MOT_4, get_pwm_output_min());
-            rc_write(AP_MOTORS_CH_TRI_YAW, _yaw_servo_trim);
+            rc_write(AP_MOTORS_CH_TRI_YAW, _yaw_servo->get_trim());
             hal.rcout->push();
             break;
         case SPIN_WHEN_ARMED:
@@ -148,7 +123,7 @@ void AP_MotorsTri::output_to_motors()
             rc_write(AP_MOTORS_MOT_1, calc_spin_up_to_pwm());
             rc_write(AP_MOTORS_MOT_2, calc_spin_up_to_pwm());
             rc_write(AP_MOTORS_MOT_4, calc_spin_up_to_pwm());
-            rc_write(AP_MOTORS_CH_TRI_YAW, _yaw_servo_trim);
+            rc_write(AP_MOTORS_CH_TRI_YAW, _yaw_servo->get_trim());
             hal.rcout->push();
             break;
         case SPOOL_UP:
@@ -338,14 +313,14 @@ int16_t AP_MotorsTri::calc_yaw_radio_output(float yaw_input, float yaw_input_max
 {
     int16_t ret;
 
-    if (_yaw_reverse < 0) {
+    if (_yaw_servo->get_reversed()) {
         yaw_input = -yaw_input;
     }
 
     if (yaw_input >= 0){
-        ret = (_yaw_servo_trim + (yaw_input/yaw_input_max * (_yaw_servo_max - _yaw_servo_trim)));
+        ret = (_yaw_servo->get_trim() + (yaw_input/yaw_input_max * (_yaw_servo->get_output_max() - _yaw_servo->get_trim())));
     } else {
-        ret = (_yaw_servo_trim + (yaw_input/yaw_input_max * (_yaw_servo_trim - _yaw_servo_min)));
+        ret = (_yaw_servo->get_trim() + (yaw_input/yaw_input_max * (_yaw_servo->get_trim() - _yaw_servo->get_output_min())));
     }
 
     return ret;
diff --git a/libraries/AP_Motors/AP_MotorsTri.h b/libraries/AP_Motors/AP_MotorsTri.h
index 9751981..75d7ff1 100644
--- a/libraries/AP_Motors/AP_MotorsTri.h
+++ b/libraries/AP_Motors/AP_MotorsTri.h
@@ -4,7 +4,7 @@
 
 #include <AP_Common/AP_Common.h>
 #include <AP_Math/AP_Math.h>        // ArduPilot Mega Vector/Matrix math Library
-#include <RC_Channel/RC_Channel.h>     // RC Channel Library
+#include <SRV_Channel/SRV_Channel.h>
 #include "AP_MotorsMulticopter.h"
 
 // tail servo uses channel 7
@@ -62,10 +62,8 @@ class AP_MotorsTri : public AP_MotorsMulticopter {
     int16_t             calc_yaw_radio_output(float yaw_input, float yaw_input_max);        // calculate radio output for yaw servo, typically in range of 1100-1900
 
     // parameters
-    AP_Int8         _yaw_reverse;                       // Reverse yaw output
-    AP_Int16        _yaw_servo_trim;                    // Trim or center position of yaw servo
-    AP_Int16        _yaw_servo_min;                     // Minimum pwm of yaw servo
-    AP_Int16        _yaw_servo_max;                     // Maximum pwm of yaw servo
+
+    SRV_Channel     *_yaw_servo; // yaw output channel
     AP_Float        _yaw_servo_angle_max_deg;           // Maximum lean angle of yaw servo in degrees
     float           _pivot_angle;                       // Angle of yaw pivot
     float           _thrust_right;

From 3df55b575f68171eb36b97943f66363c829b8b92 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 15:19:43 +1100
Subject: [PATCH 073/200] Tools: fixed copter tri reverse default

SITL tricopter doesn't need reversed tail servo
---
 Tools/autotest/default_params/copter-tri.parm | 1 -
 1 file changed, 1 deletion(-)

diff --git a/Tools/autotest/default_params/copter-tri.parm b/Tools/autotest/default_params/copter-tri.parm
index 8ab2371..ccbc34f 100644
--- a/Tools/autotest/default_params/copter-tri.parm
+++ b/Tools/autotest/default_params/copter-tri.parm
@@ -1,4 +1,3 @@
-SERVO7_REVERSED 1
 SERVO7_MIN      1000
 SERVO7_MAX      2000
 EK2_ENABLE      1

From 5cf1c0869dba2ba2f3add7249ea827fc7eef1287 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 18:30:34 +1100
Subject: [PATCH 074/200] AC_AttitudeControl: expose all functions via abstract
 class

this allows for a single class to be used for heli and multicopter
---
 libraries/AC_AttitudeControl/AC_AttitudeControl.h    | 20 ++++++++++++++++++++
 .../AC_AttitudeControl/AC_AttitudeControl_Heli.h     | 13 ++++---------
 .../AC_AttitudeControl/AC_AttitudeControl_Multi.h    | 10 +++++-----
 3 files changed, 29 insertions(+), 14 deletions(-)

diff --git a/libraries/AC_AttitudeControl/AC_AttitudeControl.h b/libraries/AC_AttitudeControl/AC_AttitudeControl.h
index de2bef9..96781db 100644
--- a/libraries/AC_AttitudeControl/AC_AttitudeControl.h
+++ b/libraries/AC_AttitudeControl/AC_AttitudeControl.h
@@ -238,6 +238,26 @@ class AC_AttitudeControl {
     // sanity check parameters.  should be called once before take-off
     virtual void parameter_sanity_check() {}
 
+    // return true if the rpy mix is at lowest value
+    virtual bool is_throttle_mix_min() const { return true; }
+
+    // control rpy throttle mix
+    virtual void set_throttle_mix_min() {}
+    virtual void set_throttle_mix_mid() {}
+    virtual void set_throttle_mix_max() {}
+
+    // enable use of flybass passthrough on heli
+    virtual void use_flybar_passthrough(bool passthrough, bool tail_passthrough) {}
+
+	// use_leaky_i - controls whether we use leaky i term for body-frame to motor output stage on heli
+	virtual void use_leaky_i(bool leaky_i) {}
+
+    // set_hover_roll_scalar - scales Hover Roll Trim parameter. To be used by vehicle code according to vehicle condition.
+    virtual void set_hover_roll_trim_scalar(float scalar) {}
+
+    // passthrough_bf_roll_pitch_rate_yaw - roll and pitch are passed through directly, body-frame rate target for yaw
+    virtual void passthrough_bf_roll_pitch_rate_yaw(float roll_passthrough, float pitch_passthrough, float yaw_rate_bf_cds) {};
+    
     // User settable parameters
     static const struct AP_Param::GroupInfo var_info[];
 
diff --git a/libraries/AC_AttitudeControl/AC_AttitudeControl_Heli.h b/libraries/AC_AttitudeControl/AC_AttitudeControl_Heli.h
index f26b7b1..4e1eb72 100644
--- a/libraries/AC_AttitudeControl/AC_AttitudeControl_Heli.h
+++ b/libraries/AC_AttitudeControl/AC_AttitudeControl_Heli.h
@@ -60,13 +60,8 @@ class AC_AttitudeControl_Heli : public AC_AttitudeControl {
     AC_PID& get_rate_pitch_pid() { return _pid_rate_pitch; }
     AC_PID& get_rate_yaw_pid() { return _pid_rate_yaw; }
 
-    // same as above but allows accessing heli specific pid methods - used only by Copter's tuning.cpp
-    AC_HELI_PID& get_heli_rate_roll_pid() { return _pid_rate_roll; }
-    AC_HELI_PID& get_heli_rate_pitch_pid() { return _pid_rate_pitch; }
-    AC_HELI_PID& get_heli_rate_yaw_pid() { return _pid_rate_yaw; }
-
     // passthrough_bf_roll_pitch_rate_yaw - roll and pitch are passed through directly, body-frame rate target for yaw
-    void passthrough_bf_roll_pitch_rate_yaw(float roll_passthrough, float pitch_passthrough, float yaw_rate_bf_cds);
+    void passthrough_bf_roll_pitch_rate_yaw(float roll_passthrough, float pitch_passthrough, float yaw_rate_bf_cds) override;
 
     // Integrate vehicle rate into _att_error_rot_vec_rad
     void integrate_bf_rate_error_to_angle_errors();
@@ -82,11 +77,11 @@ class AC_AttitudeControl_Heli : public AC_AttitudeControl {
     void update_althold_lean_angle_max(float throttle_in) override;
 
 	// use_leaky_i - controls whether we use leaky i term for body-frame to motor output stage
-	void use_leaky_i(bool leaky_i) {  _flags_heli.leaky_i = leaky_i; }
+	void use_leaky_i(bool leaky_i) override {  _flags_heli.leaky_i = leaky_i; }
     
     // use_flybar_passthrough - controls whether we pass-through
     // control inputs to swash-plate and tail
-    void use_flybar_passthrough(bool passthrough, bool tail_passthrough) {  
+    void use_flybar_passthrough(bool passthrough, bool tail_passthrough) override {  
         _flags_heli.flybar_passthrough = passthrough; 
         _flags_heli.tail_passthrough = tail_passthrough; 
     }
@@ -95,7 +90,7 @@ class AC_AttitudeControl_Heli : public AC_AttitudeControl {
     void do_piro_comp(bool piro_comp) { _flags_heli.do_piro_comp = piro_comp; }
 
     // set_hover_roll_scalar - scales Hover Roll Trim parameter. To be used by vehicle code according to vehicle condition.
-    void set_hover_roll_trim_scalar(float scalar) {_hover_roll_trim_scalar = constrain_float(scalar, 0.0f, 1.0f);}
+    void set_hover_roll_trim_scalar(float scalar) override {_hover_roll_trim_scalar = constrain_float(scalar, 0.0f, 1.0f);}
 
     // Set output throttle
     void set_throttle_out(float throttle_in, bool apply_angle_boost, float filt_cutoff) override;
diff --git a/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.h b/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.h
index 9524612..18c3977 100644
--- a/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.h
+++ b/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.h
@@ -63,12 +63,12 @@ class AC_AttitudeControl_Multi : public AC_AttitudeControl {
     // set desired throttle vs attitude mixing (actual mix is slewed towards this value over 1~2 seconds)
     //  low values favour pilot/autopilot throttle over attitude control, high values favour attitude control over throttle
     //  has no effect when throttle is above hover throttle
-    void set_throttle_mix_min() { _throttle_rpy_mix_desired = _thr_mix_min; }
-    void set_throttle_mix_mid() { _throttle_rpy_mix_desired = AC_ATTITUDE_CONTROL_MID_DEFAULT; }
-    void set_throttle_mix_max() { _throttle_rpy_mix_desired = _thr_mix_max; }
+    void set_throttle_mix_min() override { _throttle_rpy_mix_desired = _thr_mix_min; }
+    void set_throttle_mix_mid() override { _throttle_rpy_mix_desired = AC_ATTITUDE_CONTROL_MID_DEFAULT; }
+    void set_throttle_mix_max() override { _throttle_rpy_mix_desired = _thr_mix_max; }
 
-    // get_throttle_rpy_mix - get low throttle compensation value
-    bool is_throttle_mix_min() const { return (_throttle_rpy_mix < 1.25f*_thr_mix_min); }
+    // are we producing min throttle?
+    bool is_throttle_mix_min() const override { return (_throttle_rpy_mix < 1.25f*_thr_mix_min); }
 
     // run lowest level body-frame rate controller and send outputs to the motors
     void rate_controller_run();

From 0f6d0c5ba956030cde14d4c428d4ff568baf8e40 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 18:31:26 +1100
Subject: [PATCH 075/200] Copter: combined tri, single, coax and multicopter
 into a single build

this allows copter to be just 2 builds, one for heli, and one for
everything else
---
 ArduCopter/ArduCopter.cpp             |  28 +--
 ArduCopter/Attitude.cpp               |  24 +--
 ArduCopter/Copter.cpp                 |   7 -
 ArduCopter/Copter.h                   |  27 +--
 ArduCopter/GCS_Mavlink.cpp            |  36 ++--
 ArduCopter/Log.cpp                    |  32 +--
 ArduCopter/afs_copter.cpp             |   8 +-
 ArduCopter/arming_checks.cpp          |  10 +-
 ArduCopter/avoidance_adsb.cpp         |  16 +-
 ArduCopter/baro_ground_effect.cpp     |  18 +-
 ArduCopter/commands.cpp               |   2 +-
 ArduCopter/commands_logic.cpp         |  32 +--
 ArduCopter/compassmot.cpp             |  10 +-
 ArduCopter/control_acro.cpp           |  18 +-
 ArduCopter/control_althold.cpp        |  70 +++----
 ArduCopter/control_auto.cpp           | 178 ++++++++---------
 ArduCopter/control_autotune.cpp       | 360 +++++++++++++++++-----------------
 ArduCopter/control_brake.cpp          |  40 ++--
 ArduCopter/control_circle.cpp         |  46 ++---
 ArduCopter/control_drift.cpp          |  12 +-
 ArduCopter/control_flip.cpp           |  18 +-
 ArduCopter/control_guided.cpp         | 176 ++++++++---------
 ArduCopter/control_land.cpp           |  74 +++----
 ArduCopter/control_loiter.cpp         |  94 ++++-----
 ArduCopter/control_poshold.cpp        |  76 +++----
 ArduCopter/control_rtl.cpp            | 106 +++++-----
 ArduCopter/control_sport.cpp          |  68 +++----
 ArduCopter/control_stabilize.cpp      |  16 +-
 ArduCopter/control_throw.cpp          |  58 +++---
 ArduCopter/crash_check.cpp            |   8 +-
 ArduCopter/ekf_check.cpp              |   6 +-
 ArduCopter/esc_calibration.cpp        |  30 +--
 ArduCopter/events.cpp                 |   6 +-
 ArduCopter/failsafe.cpp               |  12 +-
 ArduCopter/fence.cpp                  |   2 +-
 ArduCopter/flight_mode.cpp            |   8 +-
 ArduCopter/heli.cpp                   |  40 ++--
 ArduCopter/heli_control_acro.cpp      |  28 +--
 ArduCopter/heli_control_stabilize.cpp |  18 +-
 ArduCopter/land_detector.cpp          |  30 +--
 ArduCopter/motor_test.cpp             |  12 +-
 ArduCopter/motors.cpp                 |  36 ++--
 ArduCopter/navigation.cpp             |  12 +-
 ArduCopter/radio.cpp                  |  25 ++-
 ArduCopter/sensors.cpp                |  10 +-
 ArduCopter/setup.cpp                  |   8 +-
 ArduCopter/switches.cpp               |   8 +-
 ArduCopter/system.cpp                 | 124 ++++++++----
 ArduCopter/takeoff.cpp                |  16 +-
 ArduCopter/tuning.cpp                 |  50 ++---
 50 files changed, 1087 insertions(+), 1062 deletions(-)

diff --git a/ArduCopter/ArduCopter.cpp b/ArduCopter/ArduCopter.cpp
index e74bda4..2d472b0 100644
--- a/ArduCopter/ArduCopter.cpp
+++ b/ArduCopter/ArduCopter.cpp
@@ -261,7 +261,7 @@ void Copter::fast_loop()
     read_AHRS();
 
     // run low level rate controllers that only require IMU data
-    attitude_control.rate_controller_run();
+    attitude_control->rate_controller_run();
     
 #if FRAME_CONFIG == HELI_FRAME
     update_heli_control_dynamics();
@@ -362,7 +362,7 @@ void Copter::update_batt_compass(void)
 
     if(g.compass_enabled) {
         // update compass with throttle value - used for compassmot
-        compass.set_throttle(motors.get_throttle());
+        compass.set_throttle(motors->get_throttle());
         compass.read();
         // log compass information
         if (should_log(MASK_LOG_COMPASS) && !ahrs.have_ekf_logging()) {
@@ -378,11 +378,11 @@ void Copter::ten_hz_logging_loop()
     // log attitude data if we're not already logging at the higher rate
     if (should_log(MASK_LOG_ATTITUDE_MED) && !should_log(MASK_LOG_ATTITUDE_FAST)) {
         Log_Write_Attitude();
-        DataFlash.Log_Write_Rate(ahrs, motors, attitude_control, pos_control);
+        DataFlash.Log_Write_Rate(ahrs, *motors, *attitude_control, *pos_control);
         if (should_log(MASK_LOG_PID)) {
-            DataFlash.Log_Write_PID(LOG_PIDR_MSG, attitude_control.get_rate_roll_pid().get_pid_info());
-            DataFlash.Log_Write_PID(LOG_PIDP_MSG, attitude_control.get_rate_pitch_pid().get_pid_info());
-            DataFlash.Log_Write_PID(LOG_PIDY_MSG, attitude_control.get_rate_yaw_pid().get_pid_info());
+            DataFlash.Log_Write_PID(LOG_PIDR_MSG, attitude_control->get_rate_roll_pid().get_pid_info());
+            DataFlash.Log_Write_PID(LOG_PIDP_MSG, attitude_control->get_rate_pitch_pid().get_pid_info());
+            DataFlash.Log_Write_PID(LOG_PIDY_MSG, attitude_control->get_rate_yaw_pid().get_pid_info());
             DataFlash.Log_Write_PID(LOG_PIDA_MSG, g.pid_accel_z.get_pid_info() );
         }
     }
@@ -405,7 +405,7 @@ void Copter::ten_hz_logging_loop()
         DataFlash.Log_Write_Vibration(ins);
     }
     if (should_log(MASK_LOG_CTUN)) {
-        attitude_control.control_monitor_log();
+        attitude_control->control_monitor_log();
         Log_Write_Proximity();
         Log_Write_Beacon();
     }
@@ -425,11 +425,11 @@ void Copter::twentyfive_hz_logging()
 #if HIL_MODE == HIL_MODE_DISABLED
     if (should_log(MASK_LOG_ATTITUDE_FAST)) {
         Log_Write_Attitude();
-        DataFlash.Log_Write_Rate(ahrs, motors, attitude_control, pos_control);
+        DataFlash.Log_Write_Rate(ahrs, *motors, *attitude_control, *pos_control);
         if (should_log(MASK_LOG_PID)) {
-            DataFlash.Log_Write_PID(LOG_PIDR_MSG, attitude_control.get_rate_roll_pid().get_pid_info());
-            DataFlash.Log_Write_PID(LOG_PIDP_MSG, attitude_control.get_rate_pitch_pid().get_pid_info());
-            DataFlash.Log_Write_PID(LOG_PIDY_MSG, attitude_control.get_rate_yaw_pid().get_pid_info());
+            DataFlash.Log_Write_PID(LOG_PIDR_MSG, attitude_control->get_rate_roll_pid().get_pid_info());
+            DataFlash.Log_Write_PID(LOG_PIDP_MSG, attitude_control->get_rate_pitch_pid().get_pid_info());
+            DataFlash.Log_Write_PID(LOG_PIDY_MSG, attitude_control->get_rate_yaw_pid().get_pid_info());
             DataFlash.Log_Write_PID(LOG_PIDA_MSG, g.pid_accel_z.get_pid_info() );
         }
     }
@@ -484,18 +484,18 @@ void Copter::one_hz_loop()
 
     update_arming_checks();
 
-    if (!motors.armed()) {
+    if (!motors->armed()) {
         // make it possible to change ahrs orientation at runtime during initial config
         ahrs.set_orientation();
 
         update_using_interlock();
 
         // check the user hasn't updated the frame class or type
-        motors.set_frame_class_and_type((AP_Motors::motor_frame_class)g2.frame_class.get(), (AP_Motors::motor_frame_type)g.frame_type.get());
+        motors->set_frame_class_and_type((AP_Motors::motor_frame_class)g2.frame_class.get(), (AP_Motors::motor_frame_type)g.frame_type.get());
 
 #if FRAME_CONFIG != HELI_FRAME
         // set all throttle channel settings
-        motors.set_throttle_range(channel_throttle->get_radio_min(), channel_throttle->get_radio_max());
+        motors->set_throttle_range(channel_throttle->get_radio_min(), channel_throttle->get_radio_max());
 #endif
     }
 
diff --git a/ArduCopter/Attitude.cpp b/ArduCopter/Attitude.cpp
index 8ecea48..03c6ce7 100644
--- a/ArduCopter/Attitude.cpp
+++ b/ArduCopter/Attitude.cpp
@@ -1,6 +1,6 @@
 #include "Copter.h"
 
-// get_smoothing_gain - returns smoothing gain to be passed into attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw
+// get_smoothing_gain - returns smoothing gain to be passed into attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw
 //      result is a number from 2 to 12 with 2 being very sluggish and 12 being very crisp
 float Copter::get_smoothing_gain()
 {
@@ -107,7 +107,7 @@ void Copter::update_throttle_hover()
 {
 #if FRAME_CONFIG != HELI_FRAME
     // if not armed or landed exit
-    if (!motors.armed() || ap.land_complete) {
+    if (!motors->armed() || ap.land_complete) {
         return;
     }
 
@@ -117,17 +117,17 @@ void Copter::update_throttle_hover()
     }
 
     // do not update while climbing or descending
-    if (!is_zero(pos_control.get_desired_velocity().z)) {
+    if (!is_zero(pos_control->get_desired_velocity().z)) {
         return;
     }
 
     // get throttle output
-    float throttle = motors.get_throttle();
+    float throttle = motors->get_throttle();
 
     // calc average throttle if we are in a level hover
     if (throttle > 0.0f && abs(climb_rate) < 60 && labs(ahrs.roll_sensor) < 500 && labs(ahrs.pitch_sensor) < 500) {
         // Can we set the time constant automatically
-        motors.update_throttle_hover(0.01f);
+        motors->update_throttle_hover(0.01f);
     }
 #endif
 }
@@ -136,7 +136,7 @@ void Copter::update_throttle_hover()
 void Copter::set_throttle_takeoff()
 {
     // tell position controller to reset alt target and reset I terms
-    pos_control.init_takeoff();
+    pos_control->init_takeoff();
 }
 
 // transform pilot's manual throttle input to make hover throttle mid stick
@@ -146,7 +146,7 @@ void Copter::set_throttle_takeoff()
 float Copter::get_pilot_desired_throttle(int16_t throttle_control, float thr_mid)
 {
     if (thr_mid <= 0.0f) {
-        thr_mid = motors.get_throttle_hover();
+        thr_mid = motors->get_throttle_hover();
     }
 
     int16_t mid_stick = channel_throttle->get_control_mid();
@@ -218,7 +218,7 @@ float Copter::get_pilot_desired_climb_rate(float throttle_control)
 // get_non_takeoff_throttle - a throttle somewhere between min and mid throttle which should not lead to a takeoff
 float Copter::get_non_takeoff_throttle()
 {
-    return MAX(0,motors.get_throttle_hover()/2.0f);
+    return MAX(0,motors->get_throttle_hover()/2.0f);
 }
 
 // get_surface_tracking_climb_rate - hold copter at the desired distance above the ground
@@ -240,7 +240,7 @@ float Copter::get_surface_tracking_climb_rate(int16_t target_rate, float current
     last_call_ms = now;
 
     // adjust rangefinder target alt if motors have not hit their limits
-    if ((target_rate<0 && !motors.limit.throttle_lower) || (target_rate>0 && !motors.limit.throttle_upper)) {
+    if ((target_rate<0 && !motors->limit.throttle_lower) || (target_rate>0 && !motors->limit.throttle_upper)) {
         target_rangefinder_alt += target_rate * dt;
     }
 
@@ -286,9 +286,9 @@ float Copter::get_surface_tracking_climb_rate(int16_t target_rate, float current
 void Copter::set_accel_throttle_I_from_pilot_throttle()
 {
     // get last throttle input sent to attitude controller
-    float pilot_throttle = constrain_float(attitude_control.get_throttle_in(), 0.0f, 1.0f);
+    float pilot_throttle = constrain_float(attitude_control->get_throttle_in(), 0.0f, 1.0f);
     // shift difference between pilot's throttle and hover throttle into accelerometer I
-    g.pid_accel_z.set_integrator((pilot_throttle-motors.get_throttle_hover()) * 1000.0f);
+    g.pid_accel_z.set_integrator((pilot_throttle-motors->get_throttle_hover()) * 1000.0f);
 }
 
 // updates position controller's maximum altitude using fence and EKF limits
@@ -312,7 +312,7 @@ void Copter::update_poscon_alt_max()
     }
 
     // pass limit to pos controller
-    pos_control.set_alt_max(alt_limit_cm);
+    pos_control->set_alt_max(alt_limit_cm);
 }
 
 // rotate vector from vehicle's perspective to North-East frame
diff --git a/ArduCopter/Copter.cpp b/ArduCopter/Copter.cpp
index 329eee0..d922946 100644
--- a/ArduCopter/Copter.cpp
+++ b/ArduCopter/Copter.cpp
@@ -28,7 +28,6 @@ Copter::Copter(void) :
             FUNCTOR_BIND_MEMBER(&Copter::verify_command_callback, bool, const AP_Mission::Mission_Command &),
             FUNCTOR_BIND_MEMBER(&Copter::exit_mission, void)),
     control_mode(STABILIZE),
-    motors(MAIN_LOOP_RATE),
     scaleLongDown(1),
     wp_bearing(0),
     home_bearing(0),
@@ -66,12 +65,6 @@ Copter::Copter(void) :
     condition_start(0),
     G_Dt(MAIN_LOOP_SECONDS),
     inertial_nav(ahrs),
-    attitude_control(ahrs, aparm, motors, MAIN_LOOP_SECONDS),
-    pos_control(ahrs, inertial_nav, motors, attitude_control,
-                g.p_alt_hold, g.p_vel_z, g.pid_accel_z,
-                g.p_pos_xy, g.pi_vel_xy),
-    wp_nav(inertial_nav, ahrs, pos_control, attitude_control),
-    circle_nav(inertial_nav, ahrs, pos_control),
     pmTest1(0),
     fast_loopTimer(0),
     mainLoop_count(0),
diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index 6f51717..926b55d 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -326,21 +326,13 @@ class Copter : public AP_HAL::HAL::Callbacks {
     } sensor_health;
 
     // Motor Output
-#if FRAME_CONFIG == QUAD_FRAME || FRAME_CONFIG == HEXA_FRAME || FRAME_CONFIG == Y6_FRAME || FRAME_CONFIG == OCTA_FRAME || FRAME_CONFIG == OCTA_QUAD_FRAME
- #define MOTOR_CLASS AP_MotorsMatrix
-#elif FRAME_CONFIG == TRI_FRAME
- #define MOTOR_CLASS AP_MotorsTri
-#elif FRAME_CONFIG == HELI_FRAME
+#if FRAME_CONFIG == HELI_FRAME
  #define MOTOR_CLASS AP_MotorsHeli_Single
-#elif FRAME_CONFIG == SINGLE_FRAME
- #define MOTOR_CLASS AP_MotorsSingle
-#elif FRAME_CONFIG == COAX_FRAME
- #define MOTOR_CLASS AP_MotorsCoax
 #else
- #error Unrecognised frame type
+ #define MOTOR_CLASS AP_MotorsMulticopter
 #endif
 
-    MOTOR_CLASS motors;
+    MOTOR_CLASS *motors;
 
     // GPS variables
     // Sometimes we need to remove the scaling for distance calcs
@@ -491,14 +483,10 @@ class Copter : public AP_HAL::HAL::Callbacks {
 
     // Attitude, Position and Waypoint navigation objects
     // To-Do: move inertial nav up or other navigation variables down here
-#if FRAME_CONFIG == HELI_FRAME
-    AC_AttitudeControl_Heli attitude_control;
-#else
-    AC_AttitudeControl_Multi attitude_control;
-#endif
-    AC_PosControl pos_control;
-    AC_WPNav wp_nav;
-    AC_Circle circle_nav;
+    AC_AttitudeControl *attitude_control;
+    AC_PosControl *pos_control;
+    AC_WPNav *wp_nav;
+    AC_Circle *circle_nav;
 
     // Performance monitoring
     int16_t pmTest1;
@@ -1085,6 +1073,7 @@ class Copter : public AP_HAL::HAL::Callbacks {
     void check_usb_mux(void);
     bool should_log(uint32_t mask);
     void set_default_frame_class();
+    void allocate_motors(void);
     uint8_t get_frame_mav_type();
     const char* get_frame_string();
     bool current_mode_has_user_takeoff(bool must_navigate);
diff --git a/ArduCopter/GCS_Mavlink.cpp b/ArduCopter/GCS_Mavlink.cpp
index 8032719..204ede9 100644
--- a/ArduCopter/GCS_Mavlink.cpp
+++ b/ArduCopter/GCS_Mavlink.cpp
@@ -71,7 +71,7 @@ NOINLINE void Copter::send_heartbeat(mavlink_channel_t chan)
 #endif
 
     // we are armed if we are not initialising
-    if (motors.armed()) {
+    if (motors->armed()) {
         base_mode |= MAV_MODE_FLAG_SAFETY_ARMED;
     }
 
@@ -161,7 +161,7 @@ void NOINLINE Copter::send_location(mavlink_channel_t chan)
 
 void NOINLINE Copter::send_nav_controller_output(mavlink_channel_t chan)
 {
-    const Vector3f &targets = attitude_control.get_att_target_euler_cd();
+    const Vector3f &targets = attitude_control->get_att_target_euler_cd();
     mavlink_msg_nav_controller_output_send(
         chan,
         targets.x / 1.0e2f,
@@ -169,7 +169,7 @@ void NOINLINE Copter::send_nav_controller_output(mavlink_channel_t chan)
         targets.z / 1.0e2f,
         wp_bearing / 1.0e2f,
         wp_distance / 1.0e2f,
-        pos_control.get_alt_error() / 1.0e2f,
+        pos_control->get_alt_error() / 1.0e2f,
         0,
         0);
 }
@@ -197,7 +197,7 @@ void NOINLINE Copter::send_vfr_hud(mavlink_channel_t chan)
         gps.ground_speed(),
         ahrs.groundspeed(),
         (ahrs.yaw_sensor / 100) % 360,
-        (int16_t)(motors.get_throttle() * 100),
+        (int16_t)(motors->get_throttle() * 100),
         current_loc.alt / 100.0f,
         climb_rate / 100.0f);
 }
@@ -279,7 +279,7 @@ void Copter::send_pid_tuning(mavlink_channel_t chan)
 {
     const Vector3f &gyro = ahrs.get_gyro();
     if (g.gcs_pid_mask & 1) {
-        const DataFlash_Class::PID_Info &pid_info = attitude_control.get_rate_roll_pid().get_pid_info();
+        const DataFlash_Class::PID_Info &pid_info = attitude_control->get_rate_roll_pid().get_pid_info();
         mavlink_msg_pid_tuning_send(chan, PID_TUNING_ROLL, 
                                     pid_info.desired*0.01f,
                                     degrees(gyro.x),
@@ -292,7 +292,7 @@ void Copter::send_pid_tuning(mavlink_channel_t chan)
         }
     }
     if (g.gcs_pid_mask & 2) {
-        const DataFlash_Class::PID_Info &pid_info = attitude_control.get_rate_pitch_pid().get_pid_info();
+        const DataFlash_Class::PID_Info &pid_info = attitude_control->get_rate_pitch_pid().get_pid_info();
         mavlink_msg_pid_tuning_send(chan, PID_TUNING_PITCH, 
                                     pid_info.desired*0.01f,
                                     degrees(gyro.y),
@@ -305,7 +305,7 @@ void Copter::send_pid_tuning(mavlink_channel_t chan)
         }
     }
     if (g.gcs_pid_mask & 4) {
-        const DataFlash_Class::PID_Info &pid_info = attitude_control.get_rate_yaw_pid().get_pid_info();
+        const DataFlash_Class::PID_Info &pid_info = attitude_control->get_rate_yaw_pid().get_pid_info();
         mavlink_msg_pid_tuning_send(chan, PID_TUNING_YAW, 
                                     pid_info.desired*0.01f,
                                     degrees(gyro.z),
@@ -348,7 +348,7 @@ bool GCS_MAVLINK_Copter::try_send_message(enum ap_message id)
     // if we don't have at least 250 micros remaining before the main loop
     // wants to fire then don't send a mavlink message. We want to
     // prioritise the main flight control loop over communications
-    if (copter.scheduler.time_available_usec() < 250 && copter.motors.armed()) {
+    if (copter.scheduler.time_available_usec() < 250 && copter.motors->armed()) {
         copter.gcs_out_of_time = true;
         return false;
     }
@@ -683,7 +683,7 @@ GCS_MAVLINK_Copter::data_stream_send(void)
         return;
     }
 
-    if (!copter.in_mavlink_delay && !copter.motors.armed()) {
+    if (!copter.in_mavlink_delay && !copter.motors->armed()) {
         handle_log_send(copter.DataFlash);
     }
 
@@ -1089,7 +1089,7 @@ void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
             // param3 : unused
             // param4 : unused
             if (packet.param2 > 0.0f) {
-                copter.wp_nav.set_speed_xy(packet.param2 * 100.0f);
+                copter.wp_nav->set_speed_xy(packet.param2 * 100.0f);
                 result = MAV_RESULT_ACCEPTED;
             } else {
                 result = MAV_RESULT_FAILED;
@@ -1182,7 +1182,7 @@ void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
             break;
 
         case MAV_CMD_MISSION_START:
-            if (copter.motors.armed() && copter.set_mode(AUTO, MODE_REASON_GCS_COMMAND)) {
+            if (copter.motors->armed() && copter.set_mode(AUTO, MODE_REASON_GCS_COMMAND)) {
                 copter.set_auto_armed(true);
                 if (copter.mission.state() != AP_Mission::MISSION_RUNNING) {
                     copter.mission.start_or_resume();
@@ -1193,7 +1193,7 @@ void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
 
         case MAV_CMD_PREFLIGHT_CALIBRATION:
             // exit immediately if armed
-            if (copter.motors.armed()) {
+            if (copter.motors->armed()) {
                 result = MAV_RESULT_FAILED;
                 break;
             }
@@ -1449,7 +1449,7 @@ void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
                 break;
             }
 
-            if (!copter.motors.armed()) {
+            if (!copter.motors->armed()) {
                 // if disarmed, arm motors
                 copter.init_arm_motors(true);
             } else if (copter.ap.land_complete) {
@@ -1472,7 +1472,7 @@ void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
                 break;
             }
 
-            if (copter.motors.armed()) {
+            if (copter.motors->armed()) {
                 if (copter.ap.land_complete) {
                     // if landed, disarm motors
                     copter.init_disarm_motors();
@@ -1543,10 +1543,10 @@ void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
             climb_rate_cms = 0.0f;
         } else if (packet.thrust > 0.5f) {
             // climb at up to WPNAV_SPEED_UP
-            climb_rate_cms = (packet.thrust - 0.5f) * 2.0f * copter.wp_nav.get_speed_up();
+            climb_rate_cms = (packet.thrust - 0.5f) * 2.0f * copter.wp_nav->get_speed_up();
         } else {
             // descend at up to WPNAV_SPEED_DN
-            climb_rate_cms = (0.5f - packet.thrust) * 2.0f * -fabsf(copter.wp_nav.get_speed_down());
+            climb_rate_cms = (0.5f - packet.thrust) * 2.0f * -fabsf(copter.wp_nav->get_speed_down());
         }
 
         // if the body_yaw_rate field is ignored, use the commanded yaw position
@@ -1797,13 +1797,13 @@ void GCS_MAVLINK_Copter::handleMessage(mavlink_message_t* msg)
         copter.in_log_download = true;
         /* no break */
     case MAVLINK_MSG_ID_LOG_REQUEST_LIST:
-        if (!copter.in_mavlink_delay && !copter.motors.armed()) {
+        if (!copter.in_mavlink_delay && !copter.motors->armed()) {
             handle_log_message(msg, copter.DataFlash);
         }
         break;
     case MAVLINK_MSG_ID_LOG_REQUEST_END:
         copter.in_log_download = false;
-        if (!copter.in_mavlink_delay && !copter.motors.armed()) {
+        if (!copter.in_mavlink_delay && !copter.motors->armed()) {
             handle_log_message(msg, copter.DataFlash);
         }
         break;
diff --git a/ArduCopter/Log.cpp b/ArduCopter/Log.cpp
index af4c68e..d38f926 100644
--- a/ArduCopter/Log.cpp
+++ b/ArduCopter/Log.cpp
@@ -271,9 +271,9 @@ struct PACKED log_Nav_Tuning {
 // Write an Nav Tuning packet
 void Copter::Log_Write_Nav_Tuning()
 {
-    const Vector3f &pos_target = pos_control.get_pos_target();
-    const Vector3f &vel_target = pos_control.get_vel_target();
-    const Vector3f &accel_target = pos_control.get_accel_target();
+    const Vector3f &pos_target = pos_control->get_pos_target();
+    const Vector3f &vel_target = pos_control->get_vel_target();
+    const Vector3f &accel_target = pos_control->get_accel_target();
     const Vector3f &position = inertial_nav.get_position();
     const Vector3f &velocity = inertial_nav.get_velocity();
 
@@ -325,17 +325,17 @@ void Copter::Log_Write_Control_Tuning()
     struct log_Control_Tuning pkt = {
         LOG_PACKET_HEADER_INIT(LOG_CONTROL_TUNING_MSG),
         time_us             : AP_HAL::micros64(),
-        throttle_in         : attitude_control.get_throttle_in(),
-        angle_boost         : attitude_control.angle_boost(),
-        throttle_out        : motors.get_throttle(),
-        throttle_hover      : motors.get_throttle_hover(),
-        desired_alt         : pos_control.get_alt_target() / 100.0f,
+        throttle_in         : attitude_control->get_throttle_in(),
+        angle_boost         : attitude_control->angle_boost(),
+        throttle_out        : motors->get_throttle(),
+        throttle_hover      : motors->get_throttle_hover(),
+        desired_alt         : pos_control->get_alt_target() / 100.0f,
         inav_alt            : inertial_nav.get_altitude() / 100.0f,
         baro_alt            : baro_alt,
         desired_rangefinder_alt : (int16_t)target_rangefinder_alt,
         rangefinder_alt     : rangefinder_state.alt_cm,
         terr_alt            : terr_alt,
-        target_climb_rate   : (int16_t)pos_control.get_vel_target_z(),
+        target_climb_rate   : (int16_t)pos_control->get_vel_target_z(),
         climb_rate          : climb_rate
     };
     DataFlash.WriteBlock(&pkt, sizeof(pkt));
@@ -373,7 +373,7 @@ void Copter::Log_Write_Performance()
 // Write an attitude packet
 void Copter::Log_Write_Attitude()
 {
-    Vector3f targets = attitude_control.get_att_target_euler_cd();
+    Vector3f targets = attitude_control->get_att_target_euler_cd();
     targets.z = wrap_360_cd(targets.z);
     DataFlash.Log_Write_Attitude(ahrs, targets);
 
@@ -405,10 +405,10 @@ void Copter::Log_Write_MotBatt()
     struct log_MotBatt pkt_mot = {
         LOG_PACKET_HEADER_INIT(LOG_MOTBATT_MSG),
         time_us         : AP_HAL::micros64(),
-        lift_max        : (float)(motors.get_lift_max()),
-        bat_volt        : (float)(motors.get_batt_voltage_filt()),
-        bat_res         : (float)(motors.get_batt_resistance()),
-        th_limit        : (float)(motors.get_throttle_limit())
+        lift_max        : (float)(motors->get_lift_max()),
+        bat_volt        : (float)(motors->get_batt_voltage_filt()),
+        bat_res         : (float)(motors->get_batt_resistance()),
+        th_limit        : (float)(motors->get_throttle_limit())
     };
     DataFlash.WriteBlock(&pkt_mot, sizeof(pkt_mot));
 #endif
@@ -637,8 +637,8 @@ void Copter::Log_Write_Heli()
     struct log_Heli pkt_heli = {
         LOG_PACKET_HEADER_INIT(LOG_HELI_MSG),
         time_us                 : AP_HAL::micros64(),
-        desired_rotor_speed     : motors.get_desired_rotor_speed(),
-        main_rotor_speed        : motors.get_main_rotor_speed(),
+        desired_rotor_speed     : motors->get_desired_rotor_speed(),
+        main_rotor_speed        : motors->get_main_rotor_speed(),
     };
     DataFlash.WriteBlock(&pkt_heli, sizeof(pkt_heli));
 }
diff --git a/ArduCopter/afs_copter.cpp b/ArduCopter/afs_copter.cpp
index 278bc36..6f76d74 100644
--- a/ArduCopter/afs_copter.cpp
+++ b/ArduCopter/afs_copter.cpp
@@ -18,8 +18,8 @@ AP_AdvancedFailsafe_Copter::AP_AdvancedFailsafe_Copter(AP_Mission &_mission, AP_
 void AP_AdvancedFailsafe_Copter::terminate_vehicle(void)
 {
     // stop motors
-    copter.motors.set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
-    copter.motors.output();
+    copter.motors->set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
+    copter.motors->output();
 
     // disarm as well
     copter.init_disarm_motors();
@@ -47,8 +47,8 @@ void AP_AdvancedFailsafe_Copter::setup_IO_failsafe(void)
 
 #if FRAME_CONFIG != HELI_FRAME
     // setup AP_Motors outputs for failsafe
-    uint16_t mask = copter.motors.get_motor_mask();
-    hal.rcout->set_failsafe_pwm(mask, copter.motors.get_pwm_output_min());
+    uint16_t mask = copter.motors->get_motor_mask();
+    hal.rcout->set_failsafe_pwm(mask, copter.motors->get_pwm_output_min());
 #endif
 }
 
diff --git a/ArduCopter/arming_checks.cpp b/ArduCopter/arming_checks.cpp
index 47b30f9..0493150 100644
--- a/ArduCopter/arming_checks.cpp
+++ b/ArduCopter/arming_checks.cpp
@@ -34,7 +34,7 @@ bool Copter::all_arming_checks_passing(bool arming_from_gcs)
 bool Copter::pre_arm_checks(bool display_failure)
 {
     // exit immediately if already armed
-    if (motors.armed()) {
+    if (motors->armed()) {
         return true;
     }
 
@@ -360,7 +360,7 @@ bool Copter::parameter_checks(bool display_failure)
         }
 
         // acro balance parameter check
-        if ((g.acro_balance_roll > attitude_control.get_angle_roll_p().kP()) || (g.acro_balance_pitch > attitude_control.get_angle_pitch_p().kP())) {
+        if ((g.acro_balance_roll > attitude_control->get_angle_roll_p().kP()) || (g.acro_balance_pitch > attitude_control->get_angle_pitch_p().kP())) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: ACRO_BAL_ROLL/PITCH");
             }
@@ -379,7 +379,7 @@ bool Copter::parameter_checks(bool display_failure)
 
         #if FRAME_CONFIG == HELI_FRAME
         // check helicopter parameters
-        if (!motors.parameter_check(display_failure)) {
+        if (!motors->parameter_check(display_failure)) {
             return false;
         }
         #endif // HELI_FRAME
@@ -410,7 +410,7 @@ bool Copter::parameter_checks(bool display_failure)
 bool Copter::motor_checks(bool display_failure)
 {
     // check motors initialised  correctly
-    if (!motors.initialised_ok()) {
+    if (!motors->initialised_ok()) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check firmware or FRAME_CLASS");
         }
@@ -746,7 +746,7 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
 
     // if we are using motor interlock switch and it's enabled, fail to arm
     // skip check in Throw mode which takes control of the motor interlock
-    if (ap.using_interlock && motors.get_interlock()) {
+    if (ap.using_interlock && motors->get_interlock()) {
         gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Motor Interlock Enabled");
         return false;
     }
diff --git a/ArduCopter/avoidance_adsb.cpp b/ArduCopter/avoidance_adsb.cpp
index 89cb56b..579be71 100644
--- a/ArduCopter/avoidance_adsb.cpp
+++ b/ArduCopter/avoidance_adsb.cpp
@@ -172,9 +172,9 @@ bool AP_Avoidance_Copter::handle_avoidance_vertical(const AP_Avoidance::Obstacle
     // get best vector away from obstacle
     Vector3f velocity_neu;
     if (should_climb) {
-        velocity_neu.z = copter.wp_nav.get_speed_up();
+        velocity_neu.z = copter.wp_nav->get_speed_up();
     } else {
-        velocity_neu.z = -copter.wp_nav.get_speed_down();
+        velocity_neu.z = -copter.wp_nav->get_speed_down();
         // do not descend if below RTL alt
         if (copter.current_loc.alt < copter.g.rtl_altitude) {
             velocity_neu.z = 0.0f;
@@ -205,8 +205,8 @@ bool AP_Avoidance_Copter::handle_avoidance_horizontal(const AP_Avoidance::Obstac
         // re-normalise
         velocity_neu.normalize();
         // convert horizontal components to velocities
-        velocity_neu.x *= copter.wp_nav.get_speed_xy();
-        velocity_neu.y *= copter.wp_nav.get_speed_xy();
+        velocity_neu.x *= copter.wp_nav->get_speed_xy();
+        velocity_neu.y *= copter.wp_nav->get_speed_xy();
         // send target velocity
         copter.avoid_adsb_set_velocity(velocity_neu);
         return true;
@@ -227,13 +227,13 @@ bool AP_Avoidance_Copter::handle_avoidance_perpendicular(const AP_Avoidance::Obs
     Vector3f velocity_neu;
     if (get_vector_perpendicular(obstacle, velocity_neu)) {
         // convert horizontal components to velocities
-        velocity_neu.x *= copter.wp_nav.get_speed_xy();
-        velocity_neu.y *= copter.wp_nav.get_speed_xy();
+        velocity_neu.x *= copter.wp_nav->get_speed_xy();
+        velocity_neu.y *= copter.wp_nav->get_speed_xy();
         // use up and down waypoint speeds
         if (velocity_neu.z > 0.0f) {
-            velocity_neu.z *= copter.wp_nav.get_speed_up();
+            velocity_neu.z *= copter.wp_nav->get_speed_up();
         } else {
-            velocity_neu.z *= copter.wp_nav.get_speed_down();
+            velocity_neu.z *= copter.wp_nav->get_speed_down();
             // do not descend if below RTL alt
             if (copter.current_loc.alt < copter.g.rtl_altitude) {
                 velocity_neu.z = 0.0f;
diff --git a/ArduCopter/baro_ground_effect.cpp b/ArduCopter/baro_ground_effect.cpp
index 9f26adb..313c120 100644
--- a/ArduCopter/baro_ground_effect.cpp
+++ b/ArduCopter/baro_ground_effect.cpp
@@ -2,7 +2,7 @@
 
 void Copter::update_ground_effect_detector(void)
 {
-    if(!g2.gndeffect_comp_enabled || !motors.armed()) {
+    if(!g2.gndeffect_comp_enabled || !motors->armed()) {
         // disarmed - disable ground effect and return
         gndeffect_state.takeoff_expected = false;
         gndeffect_state.touchdown_expected = false;
@@ -15,10 +15,10 @@ void Copter::update_ground_effect_detector(void)
     uint32_t tnow_ms = millis();
     float xy_des_speed_cms = 0.0f;
     float xy_speed_cms = 0.0f;
-    float des_climb_rate_cms = pos_control.get_desired_velocity().z;
+    float des_climb_rate_cms = pos_control->get_desired_velocity().z;
 
-    if (pos_control.is_active_xy()) {
-        Vector3f vel_target = pos_control.get_vel_target();
+    if (pos_control->is_active_xy()) {
+        Vector3f vel_target = pos_control->get_vel_target();
         vel_target.z = 0.0f;
         xy_des_speed_cms = vel_target.length();
     }
@@ -32,7 +32,7 @@ void Copter::update_ground_effect_detector(void)
     // takeoff logic
 
     // if we are armed and haven't yet taken off
-    if (motors.armed() && ap.land_complete && !gndeffect_state.takeoff_expected) {
+    if (motors->armed() && ap.land_complete && !gndeffect_state.takeoff_expected) {
         gndeffect_state.takeoff_expected = true;
     }
 
@@ -50,13 +50,13 @@ void Copter::update_ground_effect_detector(void)
     }
 
     // landing logic
-    Vector3f angle_target_rad = attitude_control.get_att_target_euler_cd() * radians(0.01f);
+    Vector3f angle_target_rad = attitude_control->get_att_target_euler_cd() * radians(0.01f);
     bool small_angle_request = cosf(angle_target_rad.x)*cosf(angle_target_rad.y) > cosf(radians(7.5f));
     bool xy_speed_low = (position_ok() || optflow_position_ok()) && xy_speed_cms <= 125.0f;
-    bool xy_speed_demand_low = pos_control.is_active_xy() && xy_des_speed_cms <= 125.0f;
-    bool slow_horizontal = xy_speed_demand_low || (xy_speed_low && !pos_control.is_active_xy()) || (control_mode == ALT_HOLD && small_angle_request);
+    bool xy_speed_demand_low = pos_control->is_active_xy() && xy_des_speed_cms <= 125.0f;
+    bool slow_horizontal = xy_speed_demand_low || (xy_speed_low && !pos_control->is_active_xy()) || (control_mode == ALT_HOLD && small_angle_request);
 
-    bool descent_demanded = pos_control.is_active_z() && des_climb_rate_cms < 0.0f;
+    bool descent_demanded = pos_control->is_active_z() && des_climb_rate_cms < 0.0f;
     bool slow_descent_demanded = descent_demanded && des_climb_rate_cms >= -100.0f;
     bool z_speed_low = abs(inertial_nav.get_velocity_z()) <= 60.0f;
     bool slow_descent = (slow_descent_demanded || (z_speed_low && descent_demanded));
diff --git a/ArduCopter/commands.cpp b/ArduCopter/commands.cpp
index 91dfb67..e80d7de 100644
--- a/ArduCopter/commands.cpp
+++ b/ArduCopter/commands.cpp
@@ -16,7 +16,7 @@ void Copter::update_home_from_EKF()
     }
 
     // special logic if home is set in-flight
-    if (motors.armed()) {
+    if (motors->armed()) {
         set_home_to_current_location_inflight();
     } else {
         // move home to current ekf location (this will set home_state to HOME_SET)
diff --git a/ArduCopter/commands_logic.cpp b/ArduCopter/commands_logic.cpp
index efcafd7..29c9f29 100644
--- a/ArduCopter/commands_logic.cpp
+++ b/ArduCopter/commands_logic.cpp
@@ -336,7 +336,7 @@ void Copter::do_nav_wp(const AP_Mission::Mission_Command& cmd)
 
     // if no delay set the waypoint as "fast"
     if (loiter_time_max == 0 ) {
-        wp_nav.set_fast_waypoint(true);
+        wp_nav->set_fast_waypoint(true);
     }
 }
 
@@ -414,7 +414,7 @@ void Copter::do_loiter_unlimited(const AP_Mission::Mission_Command& cmd)
     if (target_loc.lat == 0 && target_loc.lng == 0) {
         // To-Do: make this simpler
         Vector3f temp_pos;
-        wp_nav.get_wp_stopping_point_xy(temp_pos);
+        wp_nav->get_wp_stopping_point_xy(temp_pos);
         Location_Class temp_loc(temp_pos);
         target_loc.lat = temp_loc.lat;
         target_loc.lng = temp_loc.lng;
@@ -646,7 +646,7 @@ void Copter::do_guided_limits(const AP_Mission::Mission_Command& cmd)
 bool Copter::verify_takeoff()
 {
     // have we reached our target altitude?
-    return wp_nav.reached_wp_destination();
+    return wp_nav->reached_wp_destination();
 }
 
 // verify_land - returns true if landing has been completed
@@ -657,9 +657,9 @@ bool Copter::verify_land()
     switch (land_state) {
         case LandStateType_FlyToLocation:
             // check if we've reached the location
-            if (wp_nav.reached_wp_destination()) {
+            if (wp_nav->reached_wp_destination()) {
                 // get destination so we can use it for loiter target
-                Vector3f dest = wp_nav.get_wp_destination();
+                Vector3f dest = wp_nav->get_wp_destination();
 
                 // initialise landing controller
                 auto_land_start(dest);
@@ -703,7 +703,7 @@ bool Copter::verify_payload_place()
     const float descent_throttle_placed_fraction = 0.9; // i.e. if throttle is less than 90% of descent throttle we have placed
     const uint16_t placed_time = 500; // how long we have to be below a throttle threshold before considering placed
 
-    const float current_throttle_level = motors.get_throttle();
+    const float current_throttle_level = motors->get_throttle();
     const uint32_t now =  AP_HAL::millis();
 
     // if we discover we've landed then immediately release the load:
@@ -729,11 +729,11 @@ bool Copter::verify_payload_place()
 
     switch (nav_payload_place.state) {
     case PayloadPlaceStateType_FlyToLocation:
-        if (!wp_nav.reached_wp_destination()) {
+        if (!wp_nav->reached_wp_destination()) {
             return false;
         }
         // we're there; set loiter target
-        auto_payload_place_start(wp_nav.get_wp_destination());
+        auto_payload_place_start(wp_nav->get_wp_destination());
         nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start;
         // no break
     case PayloadPlaceStateType_Calibrating_Hover_Start:
@@ -751,7 +751,7 @@ bool Copter::verify_payload_place()
         }
         // we have a valid calibration.  Hopefully.
         nav_payload_place.hover_throttle_level = current_throttle_level;
-        const float hover_throttle_delta = fabsf(nav_payload_place.hover_throttle_level - motors.get_throttle_hover());
+        const float hover_throttle_delta = fabsf(nav_payload_place.hover_throttle_level - motors->get_throttle_hover());
         gcs_send_text_fmt(MAV_SEVERITY_INFO, "hover throttle delta: %f", static_cast<double>(hover_throttle_delta));
         nav_payload_place.state = PayloadPlaceStateType_Descending_Start;
         }
@@ -831,7 +831,7 @@ bool Copter::verify_payload_place()
         }
         // no break
     case PayloadPlaceStateType_Ascending:
-        if (!wp_nav.reached_wp_destination()) {
+        if (!wp_nav->reached_wp_destination()) {
             return false;
         }
         nav_payload_place.state = PayloadPlaceStateType_Done;
@@ -852,7 +852,7 @@ bool Copter::verify_payload_place()
 bool Copter::verify_nav_wp(const AP_Mission::Mission_Command& cmd)
 {
     // check if we have reached the waypoint
-    if( !wp_nav.reached_wp_destination() ) {
+    if( !wp_nav->reached_wp_destination() ) {
         return false;
     }
 
@@ -882,7 +882,7 @@ bool Copter::verify_loiter_unlimited()
 bool Copter::verify_loiter_time()
 {
     // return immediately if we haven't reached our destination
-    if (!wp_nav.reached_wp_destination()) {
+    if (!wp_nav->reached_wp_destination()) {
         return false;
     }
 
@@ -900,7 +900,7 @@ bool Copter::verify_circle(const AP_Mission::Mission_Command& cmd)
 {
     // check if we've reached the edge
     if (auto_mode == Auto_CircleMoveToEdge) {
-        if (wp_nav.reached_wp_destination()) {
+        if (wp_nav->reached_wp_destination()) {
             Vector3f curr_pos = inertial_nav.get_position();
             Vector3f circle_center = pv_location_to_vector(cmd.content.location);
 
@@ -922,7 +922,7 @@ bool Copter::verify_circle(const AP_Mission::Mission_Command& cmd)
     }
 
     // check if we have completed circling
-    return fabsf(circle_nav.get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);
+    return fabsf(circle_nav->get_angle_total()/M_2PI) >= LOWBYTE(cmd.p1);
 }
 
 // verify_RTL - handles any state changes required to implement RTL
@@ -937,7 +937,7 @@ bool Copter::verify_RTL()
 bool Copter::verify_spline_wp(const AP_Mission::Mission_Command& cmd)
 {
     // check if we have reached the waypoint
-    if( !wp_nav.reached_wp_destination() ) {
+    if( !wp_nav->reached_wp_destination() ) {
         return false;
     }
 
@@ -1082,7 +1082,7 @@ bool Copter::do_guided(const AP_Mission::Mission_Command& cmd)
 void Copter::do_change_speed(const AP_Mission::Mission_Command& cmd)
 {
     if (cmd.content.speed.target_ms > 0) {
-        wp_nav.set_speed_xy(cmd.content.speed.target_ms * 100.0f);
+        wp_nav->set_speed_xy(cmd.content.speed.target_ms * 100.0f);
     }
 }
 
diff --git a/ArduCopter/compassmot.cpp b/ArduCopter/compassmot.cpp
index 87f5571..bf9aeef 100644
--- a/ArduCopter/compassmot.cpp
+++ b/ArduCopter/compassmot.cpp
@@ -134,14 +134,14 @@ MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
     // enable motors and pass through throttle
     init_rc_out();
     enable_motor_output();
-    motors.armed(true);
+    motors->armed(true);
 
     // initialise run time
     last_run_time = millis();
     last_send_time = millis();
 
     // main run while there is no user input and the compass is healthy
-    while (command_ack_start == command_ack_counter && compass.healthy(compass.get_primary()) && motors.armed()) {
+    while (command_ack_start == command_ack_counter && compass.healthy(compass.get_primary()) && motors->armed()) {
         // 50hz loop
         if (millis() - last_run_time < 20) {
             // grab some compass values
@@ -155,7 +155,7 @@ MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
         read_radio();
         
         // pass through throttle to motors
-        motors.set_throttle_passthrough_for_esc_calibration(channel_throttle->get_control_in() / 1000.0f);
+        motors->set_throttle_passthrough_for_esc_calibration(channel_throttle->get_control_in() / 1000.0f);
         
         // read some compass values
         compass.read();
@@ -237,8 +237,8 @@ MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
     }
 
     // stop motors
-    motors.output_min();
-    motors.armed(false);
+    motors->output_min();
+    motors->armed(false);
 
     // set and save motor compensation
     if (updated) {
diff --git a/ArduCopter/control_acro.cpp b/ArduCopter/control_acro.cpp
index 6519937..01ee6e7 100644
--- a/ArduCopter/control_acro.cpp
+++ b/ArduCopter/control_acro.cpp
@@ -9,12 +9,12 @@
 bool Copter::acro_init(bool ignore_checks)
 {
    // if landed and the mode we're switching from does not have manual throttle and the throttle stick is too high
-   if (motors.armed() && ap.land_complete && !mode_has_manual_throttle(control_mode) &&
+   if (motors->armed() && ap.land_complete && !mode_has_manual_throttle(control_mode) &&
            (get_pilot_desired_throttle(channel_throttle->get_control_in(), g2.acro_thr_mid) > get_non_takeoff_throttle())) {
        return false;
    }
    // set target altitude to zero for reporting
-   pos_control.set_alt_target(0);
+   pos_control->set_alt_target(0);
 
    return true;
 }
@@ -27,16 +27,16 @@ void Copter::acro_run()
     float pilot_throttle_scaled;
 
     // if not armed set throttle to zero and exit immediately
-    if (!motors.armed() || ap.throttle_zero || !motors.get_interlock()) {
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+    if (!motors->armed() || ap.throttle_zero || !motors->get_interlock()) {
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
         return;
     }
 
     // clear landing flag
     set_land_complete(false);
 
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // convert the input to the desired body frame rate
     get_pilot_desired_angle_rates(channel_roll->get_control_in(), channel_pitch->get_control_in(), channel_yaw->get_control_in(), target_roll, target_pitch, target_yaw);
@@ -45,10 +45,10 @@ void Copter::acro_run()
     pilot_throttle_scaled = get_pilot_desired_throttle(channel_throttle->get_control_in(), g2.acro_thr_mid);
 
     // run attitude controller
-    attitude_control.input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw);
+    attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw);
 
     // output pilot's throttle without angle boost
-    attitude_control.set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt);
+    attitude_control->set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt);
 }
 
 
@@ -127,7 +127,7 @@ void Copter::get_pilot_desired_angle_rates(int16_t roll_in, int16_t pitch_in, in
         }
 
         // convert earth-frame level rates to body-frame level rates
-        attitude_control.euler_rate_to_ang_vel(attitude_control.get_att_target_euler_cd()*radians(0.01f), rate_ef_level, rate_bf_level);
+        attitude_control->euler_rate_to_ang_vel(attitude_control->get_att_target_euler_cd()*radians(0.01f), rate_ef_level, rate_bf_level);
 
         // combine earth frame rate corrections with rate requests
         if (g.acro_trainer == ACRO_TRAINER_LIMITED) {
diff --git a/ArduCopter/control_althold.cpp b/ArduCopter/control_althold.cpp
index 45f0dee..1a31481 100644
--- a/ArduCopter/control_althold.cpp
+++ b/ArduCopter/control_althold.cpp
@@ -10,19 +10,19 @@ bool Copter::althold_init(bool ignore_checks)
 {
 #if FRAME_CONFIG == HELI_FRAME
     // do not allow helis to enter Alt Hold if the Rotor Runup is not complete
-    if (!ignore_checks && !motors.rotor_runup_complete()){
+    if (!ignore_checks && !motors->rotor_runup_complete()){
         return false;
     }
 #endif
 
     // initialize vertical speeds and leash lengths
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target_to_current_alt();
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target_to_current_alt();
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
     // stop takeoff if running
@@ -39,15 +39,15 @@ void Copter::althold_run()
     float takeoff_climb_rate = 0.0f;
 
     // initialize vertical speeds and acceleration
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // apply SIMPLE mode transform to pilot inputs
     update_simple_mode();
 
     // get pilot desired lean angles
     float target_roll, target_pitch;
-    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, attitude_control.get_althold_lean_angle_max());
+    get_pilot_desired_lean_angles(channel_roll->get_control_in(), channel_pitch->get_control_in(), target_roll, target_pitch, attitude_control->get_althold_lean_angle_max());
 
     // get pilot's desired yaw rate
     float target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());
@@ -58,13 +58,13 @@ void Copter::althold_run()
 
 #if FRAME_CONFIG == HELI_FRAME
     // helicopters are held on the ground until rotor speed runup has finished
-    bool takeoff_triggered = (ap.land_complete && (target_climb_rate > 0.0f) && motors.rotor_runup_complete());
+    bool takeoff_triggered = (ap.land_complete && (target_climb_rate > 0.0f) && motors->rotor_runup_complete());
 #else
     bool takeoff_triggered = ap.land_complete && (target_climb_rate > 0.0f);
 #endif
 
     // Alt Hold State Machine Determination
-    if (!motors.armed() || !motors.get_interlock()) {
+    if (!motors->armed() || !motors->get_interlock()) {
         althold_state = AltHold_MotorStopped;
     } else if (takeoff_state.running || takeoff_triggered) {
         althold_state = AltHold_Takeoff;
@@ -79,22 +79,22 @@ void Copter::althold_run()
 
     case AltHold_MotorStopped:
 
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
 #if FRAME_CONFIG == HELI_FRAME    
         // force descent rate and call position controller
-        pos_control.set_alt_target_from_climb_rate(-abs(g.land_speed), G_Dt, false);
+        pos_control->set_alt_target_from_climb_rate(-abs(g.land_speed), G_Dt, false);
 #else
-        attitude_control.reset_rate_controller_I_terms();
-        attitude_control.set_yaw_target_to_current_heading();
-        pos_control.relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
+        attitude_control->reset_rate_controller_I_terms();
+        attitude_control->set_yaw_target_to_current_heading();
+        pos_control->relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
 #endif
-        pos_control.update_z_controller();
+        pos_control->update_z_controller();
         break;
 
     case AltHold_Takeoff:
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
         // initiate take-off
         if (!takeoff_state.running) {
@@ -109,31 +109,31 @@ void Copter::althold_run()
         takeoff_get_climb_rates(target_climb_rate, takeoff_climb_rate);
 
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
 
         // call position controller
-        pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-        pos_control.add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+        pos_control->add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
+        pos_control->update_z_controller();
         break;
 
     case AltHold_Landed:
         // set motors to spin-when-armed if throttle below deadzone, otherwise full range (but motors will only spin at min throttle)
         if (target_climb_rate < 0.0f) {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         } else {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
         }
 
-        attitude_control.reset_rate_controller_I_terms();
-        attitude_control.set_yaw_target_to_current_heading();
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
-        pos_control.relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
-        pos_control.update_z_controller();
+        attitude_control->reset_rate_controller_I_terms();
+        attitude_control->set_yaw_target_to_current_heading();
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+        pos_control->relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
+        pos_control->update_z_controller();
         break;
 
     case AltHold_Flying:
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
 #if AC_AVOID_ENABLED == ENABLED
         // apply avoidance
@@ -141,17 +141,17 @@ void Copter::althold_run()
 #endif
 
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
 
         // adjust climb rate using rangefinder
         if (rangefinder_alt_ok()) {
             // if rangefinder is ok, use surface tracking
-            target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control.get_alt_target(), G_Dt);
+            target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
         }
 
         // call position controller
-        pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+        pos_control->update_z_controller();
         break;
     }
 }
diff --git a/ArduCopter/control_auto.cpp b/ArduCopter/control_auto.cpp
index b07bcd6..6619ffb 100644
--- a/ArduCopter/control_auto.cpp
+++ b/ArduCopter/control_auto.cpp
@@ -24,7 +24,7 @@ bool Copter::auto_init(bool ignore_checks)
         auto_mode = Auto_Loiter;
 
         // reject switching to auto mode if landed with motors armed but first command is not a takeoff (reduce chance of flips)
-        if (motors.armed() && ap.land_complete && !mission.starts_with_takeoff_cmd()) {
+        if (motors->armed() && ap.land_complete && !mission.starts_with_takeoff_cmd()) {
             gcs_send_text(MAV_SEVERITY_CRITICAL, "Auto: Missing Takeoff Cmd");
             return false;
         }
@@ -36,7 +36,7 @@ bool Copter::auto_init(bool ignore_checks)
         }
 
         // initialise waypoint and spline controller
-        wp_nav.wp_and_spline_init();
+        wp_nav->wp_and_spline_init();
 
         // clear guided limits
         guided_limit_clear();
@@ -129,7 +129,7 @@ void Copter::auto_takeoff_start(const Location& dest_loc)
     }
 
     // set waypoint controller target
-    if (!wp_nav.set_wp_destination(dest)) {
+    if (!wp_nav->set_wp_destination(dest)) {
         // failure to set destination can only be because of missing terrain data
         failsafe_terrain_on_event();
         return;
@@ -150,17 +150,17 @@ void Copter::auto_takeoff_start(const Location& dest_loc)
 void Copter::auto_takeoff_run()
 {
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
         // initialise wpnav targets
-        wp_nav.shift_wp_origin_to_current_pos();
+        wp_nav->shift_wp_origin_to_current_pos();
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else   // multicopters do not stabilize roll/pitch/yaw when disarmed
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // reset attitude control targets
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         // clear i term when we're taking off
         set_throttle_takeoff();
@@ -176,24 +176,24 @@ void Copter::auto_takeoff_run()
 
 #if FRAME_CONFIG == HELI_FRAME
     // helicopters stay in landed state until rotor speed runup has finished
-    if (motors.rotor_runup_complete()) {
+    if (motors->rotor_runup_complete()) {
         set_land_complete(false);
     } else {
         // initialise wpnav targets
-        wp_nav.shift_wp_origin_to_current_pos();
+        wp_nav->shift_wp_origin_to_current_pos();
     }
 #else
     set_land_complete(false);
 #endif
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run waypoint controller
-    failsafe_terrain_set_status(wp_nav.update_wpnav());
+    failsafe_terrain_set_status(wp_nav->update_wpnav());
 
     // call z-axis position controller (wpnav should have already updated it's alt target)
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // call attitude controller
     auto_takeoff_attitude_run(target_yaw_rate);
@@ -205,7 +205,7 @@ void Copter::auto_wp_start(const Vector3f& destination)
     auto_mode = Auto_WP;
 
     // initialise wpnav (no need to check return status because terrain data is not used)
-    wp_nav.set_wp_destination(destination, false);
+    wp_nav->set_wp_destination(destination, false);
 
     // initialise yaw
     // To-Do: reset the yaw only when the previous navigation command is not a WP.  this would allow removing the special check for ROI
@@ -220,7 +220,7 @@ void Copter::auto_wp_start(const Location_Class& dest_loc)
     auto_mode = Auto_WP;
 
     // send target to waypoint controller
-    if (!wp_nav.set_wp_destination(dest_loc)) {
+    if (!wp_nav->set_wp_destination(dest_loc)) {
         // failure to set destination can only be because of missing terrain data
         failsafe_terrain_on_event();
         return;
@@ -238,16 +238,16 @@ void Copter::auto_wp_start(const Location_Class& dest_loc)
 void Copter::auto_wp_run()
 {
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
         // To-Do: reset waypoint origin to current location because copter is probably on the ground so we don't want it lurching left or right on take-off
         //    (of course it would be better if people just used take-off)
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else   // multicopters do not stabilize roll/pitch/yaw when disarmed
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         // clear i term when we're taking off
         set_throttle_takeoff();
@@ -265,21 +265,21 @@ void Copter::auto_wp_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run waypoint controller
-    failsafe_terrain_set_status(wp_nav.update_wpnav());
+    failsafe_terrain_set_status(wp_nav->update_wpnav());
 
     // call z-axis position controller (wpnav should have already updated it's alt target)
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // call attitude controller
     if (auto_yaw_mode == AUTO_YAW_HOLD) {
         // roll & pitch from waypoint controller, yaw rate from pilot
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
     }else{
         // roll, pitch from waypoint controller, yaw heading from auto_heading()
-        attitude_control.input_euler_angle_roll_pitch_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), get_auto_heading(),true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), get_auto_heading(),true, get_smoothing_gain());
     }
 }
 
@@ -292,7 +292,7 @@ void Copter::auto_spline_start(const Location_Class& destination, bool stopped_a
     auto_mode = Auto_Spline;
 
     // initialise wpnav
-    if (!wp_nav.set_spline_destination(destination, stopped_at_start, seg_end_type, next_destination)) {
+    if (!wp_nav->set_spline_destination(destination, stopped_at_start, seg_end_type, next_destination)) {
         // failure to set destination can only be because of missing terrain data
         failsafe_terrain_on_event();
         return;
@@ -310,16 +310,16 @@ void Copter::auto_spline_start(const Location_Class& destination, bool stopped_a
 void Copter::auto_spline_run()
 {
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
         // To-Do: reset waypoint origin to current location because copter is probably on the ground so we don't want it lurching left or right on take-off
         //    (of course it would be better if people just used take-off)
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else   // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
 #endif
         // clear i term when we're taking off
         set_throttle_takeoff();
@@ -337,21 +337,21 @@ void Copter::auto_spline_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run waypoint controller
-    wp_nav.update_spline();
+    wp_nav->update_spline();
 
     // call z-axis position controller (wpnav should have already updated it's alt target)
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // call attitude controller
     if (auto_yaw_mode == AUTO_YAW_HOLD) {
         // roll & pitch from waypoint controller, yaw rate from pilot
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
     }else{
         // roll, pitch from waypoint controller, yaw heading from auto_heading()
-        attitude_control.input_euler_angle_roll_pitch_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), get_auto_heading(), true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), get_auto_heading(), true, get_smoothing_gain());
     }
 }
 
@@ -360,7 +360,7 @@ void Copter::auto_land_start()
 {
     // set target to stopping point
     Vector3f stopping_point;
-    wp_nav.get_loiter_stopping_point_xy(stopping_point);
+    wp_nav->get_loiter_stopping_point_xy(stopping_point);
 
     // call location specific land start function
     auto_land_start(stopping_point);
@@ -372,12 +372,12 @@ void Copter::auto_land_start(const Vector3f& destination)
     auto_mode = Auto_Land;
 
     // initialise loiter target destination
-    wp_nav.init_loiter_target(destination);
+    wp_nav->init_loiter_target(destination);
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target(inertial_nav.get_altitude());
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target(inertial_nav.get_altitude());
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
     // initialise yaw
@@ -389,23 +389,23 @@ void Copter::auto_land_start(const Vector3f& destination)
 void Copter::auto_land_run()
 {
     // if not auto armed or landed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || ap.land_complete || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || ap.land_complete || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         // set target to current position
-        wp_nav.init_loiter_target();
+        wp_nav->init_loiter_target();
         return;
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
     
     land_run_horizontal_control();
     land_run_vertical_control();
@@ -439,16 +439,16 @@ void Copter::auto_circle_movetoedge_start(const Location_Class &circle_center, f
         circle_center_neu = inertial_nav.get_position();
         Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_CIRCLE_INIT);
     }
-    circle_nav.set_center(circle_center_neu);
+    circle_nav->set_center(circle_center_neu);
 
     // set circle radius
     if (!is_zero(radius_m)) {
-        circle_nav.set_radius(radius_m * 100.0f);
+        circle_nav->set_radius(radius_m * 100.0f);
     }
 
     // check our distance from edge of circle
     Vector3f circle_edge_neu;
-    circle_nav.get_closest_point_on_circle(circle_edge_neu);
+    circle_nav->get_closest_point_on_circle(circle_edge_neu);
     float dist_to_edge = (inertial_nav.get_position() - circle_edge_neu).length();
 
     // if more than 3m then fly to edge
@@ -463,7 +463,7 @@ void Copter::auto_circle_movetoedge_start(const Location_Class &circle_center, f
         circle_edge.set_alt_cm(circle_center.alt, circle_center.get_alt_frame());
 
         // initialise wpnav to move to edge of circle
-        if (!wp_nav.set_wp_destination(circle_edge)) {
+        if (!wp_nav->set_wp_destination(circle_edge)) {
             // failure to set destination can only be because of missing terrain data
             failsafe_terrain_on_event();
         }
@@ -471,7 +471,7 @@ void Copter::auto_circle_movetoedge_start(const Location_Class &circle_center, f
         // if we are outside the circle, point at the edge, otherwise hold yaw
         const Vector3f &curr_pos = inertial_nav.get_position();
         float dist_to_center = norm(circle_center_neu.x - curr_pos.x, circle_center_neu.y - curr_pos.y);
-        if (dist_to_center > circle_nav.get_radius() && dist_to_center > 500) {
+        if (dist_to_center > circle_nav->get_radius() && dist_to_center > 500) {
             set_auto_yaw_mode(get_default_auto_yaw_mode(false));
         } else {
             // vehicle is within circle so hold yaw to avoid spinning as we move to edge of circle
@@ -489,7 +489,7 @@ void Copter::auto_circle_start()
     auto_mode = Auto_Circle;
 
     // initialise circle controller
-    circle_nav.init(circle_nav.get_center());
+    circle_nav->init(circle_nav->get_center());
 }
 
 // auto_circle_run - circle in AUTO flight mode
@@ -497,13 +497,13 @@ void Copter::auto_circle_start()
 void Copter::auto_circle_run()
 {
     // call circle controller
-    circle_nav.update();
+    circle_nav->update();
 
     // call z-axis position controller
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // roll & pitch from waypoint controller, yaw rate from pilot
-    attitude_control.input_euler_angle_roll_pitch_yaw(circle_nav.get_roll(), circle_nav.get_pitch(), circle_nav.get_yaw(),true, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_yaw(circle_nav->get_roll(), circle_nav->get_pitch(), circle_nav->get_yaw(),true, get_smoothing_gain());
 }
 
 #if NAV_GUIDED == ENABLED
@@ -542,11 +542,11 @@ bool Copter::auto_loiter_start()
 
     // calculate stopping point
     Vector3f stopping_point;
-    pos_control.get_stopping_point_xy(stopping_point);
-    pos_control.get_stopping_point_z(stopping_point);
+    pos_control->get_stopping_point_xy(stopping_point);
+    pos_control->get_stopping_point_z(stopping_point);
 
     // initialise waypoint controller target to stopping point
-    wp_nav.set_wp_origin_and_destination(origin, stopping_point);
+    wp_nav->set_wp_origin_and_destination(origin, stopping_point);
 
     // hold yaw at current heading
     set_auto_yaw_mode(AUTO_YAW_HOLD);
@@ -559,15 +559,15 @@ bool Copter::auto_loiter_start()
 void Copter::auto_loiter_run()
 {
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || ap.land_complete || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || ap.land_complete || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         return;
     }
@@ -579,13 +579,13 @@ void Copter::auto_loiter_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run waypoint and z-axis position controller
-    failsafe_terrain_set_status(wp_nav.update_wpnav());
+    failsafe_terrain_set_status(wp_nav->update_wpnav());
 
-    pos_control.update_z_controller();
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+    pos_control->update_z_controller();
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
 }
 
 // get_default_auto_yaw_mode - returns auto_yaw_mode based on WP_YAW_BEHAVIOR parameter
@@ -654,7 +654,7 @@ void Copter::set_auto_yaw_mode(uint8_t yaw_mode)
 void Copter::set_auto_yaw_look_at_heading(float angle_deg, float turn_rate_dps, int8_t direction, uint8_t relative_angle)
 {
     // get current yaw target
-    int32_t curr_yaw_target = attitude_control.get_att_target_euler_cd().z;
+    int32_t curr_yaw_target = attitude_control->get_att_target_euler_cd().z;
 
     // get final angle, 1 = Relative, 0 = Absolute
     if (relative_angle == 0) {
@@ -746,7 +746,7 @@ float Copter::get_auto_heading(void)
     default:
         // point towards next waypoint.
         // we don't use wp_bearing because we don't want the copter to turn too much during flight
-        return wp_nav.get_yaw();
+        return wp_nav->get_yaw();
     }
 }
 
@@ -755,7 +755,7 @@ void Copter::auto_payload_place_start()
 {
     // set target to stopping point
     Vector3f stopping_point;
-    wp_nav.get_loiter_stopping_point_xy(stopping_point);
+    wp_nav->get_loiter_stopping_point_xy(stopping_point);
 
     // call location specific place start function
     auto_payload_place_start(stopping_point);
@@ -769,12 +769,12 @@ void Copter::auto_payload_place_start(const Vector3f& destination)
     nav_payload_place.state = PayloadPlaceStateType_Calibrating_Hover_Start;
 
     // initialise loiter target destination
-    wp_nav.init_loiter_target(destination);
+    wp_nav->init_loiter_target(destination);
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target(inertial_nav.get_altitude());
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target(inertial_nav.get_altitude());
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
     // initialise yaw
@@ -784,7 +784,7 @@ void Copter::auto_payload_place_start(const Vector3f& destination)
 bool Copter::auto_payload_place_run_should_run()
 {
     // muts be armed
-    if (!motors.armed()) {
+    if (!motors->armed()) {
         return false;
     }
     // muts be auto-armed
@@ -796,7 +796,7 @@ bool Copter::auto_payload_place_run_should_run()
         return false;
     }
     // interlock must be enabled (i.e. unsafe)
-    if (!motors.get_interlock()) {
+    if (!motors->get_interlock()) {
         return false;
     }
 
@@ -810,20 +810,20 @@ void Copter::auto_payload_place_run()
     if (!auto_payload_place_run_should_run()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         // set target to current position
-        wp_nav.init_loiter_target();
+        wp_nav->init_loiter_target();
         return;
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     switch (nav_payload_place.state) {
     case PayloadPlaceStateType_FlyToLocation:
@@ -849,16 +849,16 @@ void Copter::auto_payload_place_run_loiter()
     land_run_horizontal_control();
 
     // run loiter controller
-    wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+    wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
     // call attitude controller
     const float target_yaw_rate = 0;
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
 
     // update altitude target and call position controller
     // const float target_climb_rate = 0;
-    // pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-    pos_control.update_z_controller();
+    // pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+    pos_control->update_z_controller();
 }
 
 void Copter::auto_payload_place_run_descend()
diff --git a/ArduCopter/control_autotune.cpp b/ArduCopter/control_autotune.cpp
index f91c046..d6f587e 100644
--- a/ArduCopter/control_autotune.cpp
+++ b/ArduCopter/control_autotune.cpp
@@ -211,7 +211,7 @@ void Copter::autotune_stop()
     autotune_load_orig_gains();
 
     // re-enable angle-to-rate request limits
-    attitude_control.use_ff_and_input_shaping(true);
+    attitude_control->use_ff_and_input_shaping(true);
 
     // log off event and send message to ground station
     autotune_update_gcs(AUTOTUNE_MESSAGE_STOPPED);
@@ -235,18 +235,18 @@ bool Copter::autotune_start(bool ignore_checks)
     }
 
     // ensure we are flying
-    if (!motors.armed() || !ap.auto_armed || ap.land_complete) {
+    if (!motors->armed() || !ap.auto_armed || ap.land_complete) {
         return false;
     }
 
     // initialize vertical speeds and leash lengths
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target_to_current_alt();
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target_to_current_alt();
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
     return true;
@@ -261,15 +261,15 @@ void Copter::autotune_run()
     int16_t target_climb_rate;
 
     // initialize vertical speeds and acceleration
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
     // this should not actually be possible because of the autotune_init() checks
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
-        pos_control.relax_alt_hold_controllers(0.0f);
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        pos_control->relax_alt_hold_controllers(0.0f);
         return;
     }
 
@@ -297,15 +297,15 @@ void Copter::autotune_run()
     if (ap.land_complete) {
         // set motors to spin-when-armed if throttle below deadzone, otherwise full range (but motors will only spin at min throttle)
         if (target_climb_rate < 0.0f) {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         } else {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
         }
-        attitude_control.reset_rate_controller_I_terms();
-        attitude_control.set_yaw_target_to_current_heading();
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
-        pos_control.relax_alt_hold_controllers(0.0f);
-        pos_control.update_z_controller();
+        attitude_control->reset_rate_controller_I_terms();
+        attitude_control->set_yaw_target_to_current_heading();
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+        pos_control->relax_alt_hold_controllers(0.0f);
+        pos_control->update_z_controller();
     }else{
         // check if pilot is overriding the controls
         if (!is_zero(target_roll) || !is_zero(target_pitch) || !is_zero(target_yaw_rate) || target_climb_rate != 0) {
@@ -313,7 +313,7 @@ void Copter::autotune_run()
                 autotune_state.pilot_override = true;
                 // set gains to their original values
                 autotune_load_orig_gains();
-                attitude_control.use_ff_and_input_shaping(true);
+                attitude_control->use_ff_and_input_shaping(true);
             }
             // reset pilot override time
             autotune_override_time = millis();
@@ -329,19 +329,19 @@ void Copter::autotune_run()
         }
 
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
         // if pilot override call attitude controller
         if (autotune_state.pilot_override || autotune_state.mode != AUTOTUNE_MODE_TUNING) {
-            attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+            attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
         }else{
             // somehow get attitude requests from autotuning
             autotune_attitude_control();
         }
 
         // call position controller
-        pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+        pos_control->update_z_controller();
     }
 }
 
@@ -358,10 +358,10 @@ void Copter::autotune_attitude_control()
     case AUTOTUNE_STEP_WAITING_FOR_LEVEL:
         // Note: we should be using intra-test gains (which are very close to the original gains but have lower I)
         // re-enable rate limits
-        attitude_control.use_ff_and_input_shaping(true);
+        attitude_control->use_ff_and_input_shaping(true);
 
         // hold level attitude
-        attitude_control.input_euler_angle_roll_pitch_yaw( 0.0f, 0.0f, autotune_desired_yaw, true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw( 0.0f, 0.0f, autotune_desired_yaw, true, get_smoothing_gain());
 
         // hold the copter level for 0.5 seconds before we begin a twitch
         // reset counter if we are no longer level
@@ -390,11 +390,11 @@ void Copter::autotune_attitude_control()
 
         switch (autotune_state.axis) {
         case AUTOTUNE_AXIS_ROLL:
-            autotune_target_rate = constrain_float(ToDeg(attitude_control.max_rate_step_bf_roll())*100.0f, AUTOTUNE_TARGET_MIN_RATE_RLLPIT_CDS, AUTOTUNE_TARGET_RATE_RLLPIT_CDS);
-            autotune_target_angle = constrain_float(ToDeg(attitude_control.max_angle_step_bf_roll())*100.0f, AUTOTUNE_TARGET_MIN_ANGLE_RLLPIT_CD, AUTOTUNE_TARGET_ANGLE_RLLPIT_CD);
+            autotune_target_rate = constrain_float(ToDeg(attitude_control->max_rate_step_bf_roll())*100.0f, AUTOTUNE_TARGET_MIN_RATE_RLLPIT_CDS, AUTOTUNE_TARGET_RATE_RLLPIT_CDS);
+            autotune_target_angle = constrain_float(ToDeg(attitude_control->max_angle_step_bf_roll())*100.0f, AUTOTUNE_TARGET_MIN_ANGLE_RLLPIT_CD, AUTOTUNE_TARGET_ANGLE_RLLPIT_CD);
             autotune_start_rate = ToDeg(ahrs.get_gyro().x) * 100.0f;
             autotune_start_angle = ahrs.roll_sensor;
-            rotation_rate_filt.set_cutoff_frequency(attitude_control.get_rate_roll_pid().filt_hz()*2.0f);
+            rotation_rate_filt.set_cutoff_frequency(attitude_control->get_rate_roll_pid().filt_hz()*2.0f);
             if ((autotune_state.tune_type == AUTOTUNE_TYPE_SP_DOWN) || (autotune_state.tune_type == AUTOTUNE_TYPE_SP_UP)) {
                 rotation_rate_filt.reset(autotune_start_rate);
             } else {
@@ -402,11 +402,11 @@ void Copter::autotune_attitude_control()
             }
         break;
         case AUTOTUNE_AXIS_PITCH:
-            autotune_target_rate = constrain_float(ToDeg(attitude_control.max_rate_step_bf_pitch())*100.0f, AUTOTUNE_TARGET_MIN_RATE_RLLPIT_CDS, AUTOTUNE_TARGET_RATE_RLLPIT_CDS);
-            autotune_target_angle = constrain_float(ToDeg(attitude_control.max_angle_step_bf_pitch())*100.0f, AUTOTUNE_TARGET_MIN_ANGLE_RLLPIT_CD, AUTOTUNE_TARGET_ANGLE_RLLPIT_CD);
+            autotune_target_rate = constrain_float(ToDeg(attitude_control->max_rate_step_bf_pitch())*100.0f, AUTOTUNE_TARGET_MIN_RATE_RLLPIT_CDS, AUTOTUNE_TARGET_RATE_RLLPIT_CDS);
+            autotune_target_angle = constrain_float(ToDeg(attitude_control->max_angle_step_bf_pitch())*100.0f, AUTOTUNE_TARGET_MIN_ANGLE_RLLPIT_CD, AUTOTUNE_TARGET_ANGLE_RLLPIT_CD);
             autotune_start_rate = ToDeg(ahrs.get_gyro().y) * 100.0f;
             autotune_start_angle = ahrs.pitch_sensor;
-            rotation_rate_filt.set_cutoff_frequency(attitude_control.get_rate_pitch_pid().filt_hz()*2.0f);
+            rotation_rate_filt.set_cutoff_frequency(attitude_control->get_rate_pitch_pid().filt_hz()*2.0f);
             if ((autotune_state.tune_type == AUTOTUNE_TYPE_SP_DOWN) || (autotune_state.tune_type == AUTOTUNE_TYPE_SP_UP)) {
                 rotation_rate_filt.reset(autotune_start_rate);
             } else {
@@ -414,8 +414,8 @@ void Copter::autotune_attitude_control()
             }
             break;
         case AUTOTUNE_AXIS_YAW:
-            autotune_target_rate = constrain_float(ToDeg(attitude_control.max_rate_step_bf_yaw()*0.75f)*100.0f, AUTOTUNE_TARGET_MIN_RATE_YAW_CDS, AUTOTUNE_TARGET_RATE_YAW_CDS);
-            autotune_target_angle = constrain_float(ToDeg(attitude_control.max_angle_step_bf_yaw()*0.75f)*100.0f, AUTOTUNE_TARGET_MIN_ANGLE_YAW_CD, AUTOTUNE_TARGET_ANGLE_YAW_CD);
+            autotune_target_rate = constrain_float(ToDeg(attitude_control->max_rate_step_bf_yaw()*0.75f)*100.0f, AUTOTUNE_TARGET_MIN_RATE_YAW_CDS, AUTOTUNE_TARGET_RATE_YAW_CDS);
+            autotune_target_angle = constrain_float(ToDeg(attitude_control->max_angle_step_bf_yaw()*0.75f)*100.0f, AUTOTUNE_TARGET_MIN_ANGLE_YAW_CD, AUTOTUNE_TARGET_ANGLE_YAW_CD);
             autotune_start_rate = ToDeg(ahrs.get_gyro().z) * 100.0f;
             autotune_start_angle = ahrs.yaw_sensor;
             rotation_rate_filt.set_cutoff_frequency(AUTOTUNE_Y_FILT_FREQ);
@@ -433,41 +433,41 @@ void Copter::autotune_attitude_control()
         // Note: we should be using intra-test gains (which are very close to the original gains but have lower I)
 
         // disable rate limits
-        attitude_control.use_ff_and_input_shaping(false);
+        attitude_control->use_ff_and_input_shaping(false);
 
         if ((autotune_state.tune_type == AUTOTUNE_TYPE_SP_DOWN) || (autotune_state.tune_type == AUTOTUNE_TYPE_SP_UP)) {
             // Testing increasing stabilize P gain so will set lean angle target
             switch (autotune_state.axis) {
             case AUTOTUNE_AXIS_ROLL:
                 // request roll to 20deg
-                attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw( direction_sign * autotune_target_angle + autotune_start_angle, 0.0f, 0.0f, get_smoothing_gain());
+                attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw( direction_sign * autotune_target_angle + autotune_start_angle, 0.0f, 0.0f, get_smoothing_gain());
                 break;
             case AUTOTUNE_AXIS_PITCH:
                 // request pitch to 20deg
-                attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw( 0.0f, direction_sign * autotune_target_angle + autotune_start_angle, 0.0f, get_smoothing_gain());
+                attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw( 0.0f, direction_sign * autotune_target_angle + autotune_start_angle, 0.0f, get_smoothing_gain());
                 break;
             case AUTOTUNE_AXIS_YAW:
                 // request pitch to 20deg
-                attitude_control.input_euler_angle_roll_pitch_yaw( 0.0f, 0.0f, wrap_180_cd(direction_sign * autotune_target_angle + autotune_start_angle), false, get_smoothing_gain());
+                attitude_control->input_euler_angle_roll_pitch_yaw( 0.0f, 0.0f, wrap_180_cd(direction_sign * autotune_target_angle + autotune_start_angle), false, get_smoothing_gain());
                 break;
             }
         } else {
             // Testing rate P and D gains so will set body-frame rate targets.
             // Rate controller will use existing body-frame rates and convert to motor outputs
             // for all axes except the one we override here.
-            attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw( 0.0f, 0.0f, 0.0f, get_smoothing_gain());
+            attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw( 0.0f, 0.0f, 0.0f, get_smoothing_gain());
             switch (autotune_state.axis) {
             case AUTOTUNE_AXIS_ROLL:
                 // override body-frame roll rate
-                attitude_control.rate_bf_roll_target(direction_sign * autotune_target_rate + autotune_start_rate);
+                attitude_control->rate_bf_roll_target(direction_sign * autotune_target_rate + autotune_start_rate);
                 break;
             case AUTOTUNE_AXIS_PITCH:
                 // override body-frame pitch rate
-                attitude_control.rate_bf_pitch_target(direction_sign * autotune_target_rate + autotune_start_rate);
+                attitude_control->rate_bf_pitch_target(direction_sign * autotune_target_rate + autotune_start_rate);
                 break;
             case AUTOTUNE_AXIS_YAW:
                 // override body-frame yaw rate
-                attitude_control.rate_bf_yaw_target(direction_sign * autotune_target_rate + autotune_start_rate);
+                attitude_control->rate_bf_yaw_target(direction_sign * autotune_target_rate + autotune_start_rate);
                 break;
             }
         }
@@ -526,13 +526,13 @@ void Copter::autotune_attitude_control()
 
         // log this iterations lean angle and rotation rate
         Log_Write_AutoTuneDetails(lean_angle, rotation_rate);
-        DataFlash.Log_Write_Rate(ahrs, motors, attitude_control, pos_control);
+        DataFlash.Log_Write_Rate(ahrs, *motors, *attitude_control, *pos_control);
         break;
 
     case AUTOTUNE_STEP_UPDATE_GAINS:
 
         // re-enable rate limits
-        attitude_control.use_ff_and_input_shaping(true);
+        attitude_control->use_ff_and_input_shaping(true);
 
         // log the latest gains
         if ((autotune_state.tune_type == AUTOTUNE_TYPE_SP_DOWN) || (autotune_state.tune_type == AUTOTUNE_TYPE_SP_UP)) {
@@ -731,7 +731,7 @@ void Copter::autotune_attitude_control()
         autotune_state.positive_direction = !autotune_state.positive_direction;
 
         if (autotune_state.axis == AUTOTUNE_AXIS_YAW) {
-            attitude_control.input_euler_angle_roll_pitch_yaw( 0.0f, 0.0f, ahrs.yaw_sensor, false, get_smoothing_gain());
+            attitude_control->input_euler_angle_roll_pitch_yaw( 0.0f, 0.0f, ahrs.yaw_sensor, false, get_smoothing_gain());
         }
 
         // set gains to their intra-test values (which are very close to the original gains)
@@ -765,39 +765,39 @@ void Copter::autotune_backup_gains_and_initialise()
 
     g.autotune_aggressiveness = constrain_float(g.autotune_aggressiveness, 0.05f, 0.2f);
 
-    orig_bf_feedforward = attitude_control.get_bf_feedforward();
+    orig_bf_feedforward = attitude_control->get_bf_feedforward();
 
     // backup original pids and initialise tuned pid values
-    orig_roll_rp = attitude_control.get_rate_roll_pid().kP();
-    orig_roll_ri = attitude_control.get_rate_roll_pid().kI();
-    orig_roll_rd = attitude_control.get_rate_roll_pid().kD();
-    orig_roll_sp = attitude_control.get_angle_roll_p().kP();
-    orig_roll_accel = attitude_control.get_accel_roll_max();
-    tune_roll_rp = attitude_control.get_rate_roll_pid().kP();
-    tune_roll_rd = attitude_control.get_rate_roll_pid().kD();
-    tune_roll_sp = attitude_control.get_angle_roll_p().kP();
-    tune_roll_accel = attitude_control.get_accel_roll_max();
-
-    orig_pitch_rp = attitude_control.get_rate_pitch_pid().kP();
-    orig_pitch_ri = attitude_control.get_rate_pitch_pid().kI();
-    orig_pitch_rd = attitude_control.get_rate_pitch_pid().kD();
-    orig_pitch_sp = attitude_control.get_angle_pitch_p().kP();
-    orig_pitch_accel = attitude_control.get_accel_pitch_max();
-    tune_pitch_rp = attitude_control.get_rate_pitch_pid().kP();
-    tune_pitch_rd = attitude_control.get_rate_pitch_pid().kD();
-    tune_pitch_sp = attitude_control.get_angle_pitch_p().kP();
-    tune_pitch_accel = attitude_control.get_accel_pitch_max();
-
-    orig_yaw_rp = attitude_control.get_rate_yaw_pid().kP();
-    orig_yaw_ri = attitude_control.get_rate_yaw_pid().kI();
-    orig_yaw_rd = attitude_control.get_rate_yaw_pid().kD();
-    orig_yaw_rLPF = attitude_control.get_rate_yaw_pid().filt_hz();
-    orig_yaw_accel = attitude_control.get_accel_yaw_max();
-    orig_yaw_sp = attitude_control.get_angle_yaw_p().kP();
-    tune_yaw_rp = attitude_control.get_rate_yaw_pid().kP();
-    tune_yaw_rLPF = attitude_control.get_rate_yaw_pid().filt_hz();
-    tune_yaw_sp = attitude_control.get_angle_yaw_p().kP();
-    tune_yaw_accel = attitude_control.get_accel_yaw_max();
+    orig_roll_rp = attitude_control->get_rate_roll_pid().kP();
+    orig_roll_ri = attitude_control->get_rate_roll_pid().kI();
+    orig_roll_rd = attitude_control->get_rate_roll_pid().kD();
+    orig_roll_sp = attitude_control->get_angle_roll_p().kP();
+    orig_roll_accel = attitude_control->get_accel_roll_max();
+    tune_roll_rp = attitude_control->get_rate_roll_pid().kP();
+    tune_roll_rd = attitude_control->get_rate_roll_pid().kD();
+    tune_roll_sp = attitude_control->get_angle_roll_p().kP();
+    tune_roll_accel = attitude_control->get_accel_roll_max();
+
+    orig_pitch_rp = attitude_control->get_rate_pitch_pid().kP();
+    orig_pitch_ri = attitude_control->get_rate_pitch_pid().kI();
+    orig_pitch_rd = attitude_control->get_rate_pitch_pid().kD();
+    orig_pitch_sp = attitude_control->get_angle_pitch_p().kP();
+    orig_pitch_accel = attitude_control->get_accel_pitch_max();
+    tune_pitch_rp = attitude_control->get_rate_pitch_pid().kP();
+    tune_pitch_rd = attitude_control->get_rate_pitch_pid().kD();
+    tune_pitch_sp = attitude_control->get_angle_pitch_p().kP();
+    tune_pitch_accel = attitude_control->get_accel_pitch_max();
+
+    orig_yaw_rp = attitude_control->get_rate_yaw_pid().kP();
+    orig_yaw_ri = attitude_control->get_rate_yaw_pid().kI();
+    orig_yaw_rd = attitude_control->get_rate_yaw_pid().kD();
+    orig_yaw_rLPF = attitude_control->get_rate_yaw_pid().filt_hz();
+    orig_yaw_accel = attitude_control->get_accel_yaw_max();
+    orig_yaw_sp = attitude_control->get_angle_yaw_p().kP();
+    tune_yaw_rp = attitude_control->get_rate_yaw_pid().kP();
+    tune_yaw_rLPF = attitude_control->get_rate_yaw_pid().filt_hz();
+    tune_yaw_sp = attitude_control->get_angle_yaw_p().kP();
+    tune_yaw_accel = attitude_control->get_accel_yaw_max();
 
     Log_Write_Event(DATA_AUTOTUNE_INITIALISED);
 }
@@ -806,33 +806,33 @@ void Copter::autotune_backup_gains_and_initialise()
 //  called by autotune_stop and autotune_failed functions
 void Copter::autotune_load_orig_gains()
 {
-    attitude_control.bf_feedforward(orig_bf_feedforward);
+    attitude_control->bf_feedforward(orig_bf_feedforward);
     if (autotune_roll_enabled()) {
         if (!is_zero(orig_roll_rp)) {
-            attitude_control.get_rate_roll_pid().kP(orig_roll_rp);
-            attitude_control.get_rate_roll_pid().kI(orig_roll_ri);
-            attitude_control.get_rate_roll_pid().kD(orig_roll_rd);
-            attitude_control.get_angle_roll_p().kP(orig_roll_sp);
-            attitude_control.set_accel_roll_max(orig_roll_accel);
+            attitude_control->get_rate_roll_pid().kP(orig_roll_rp);
+            attitude_control->get_rate_roll_pid().kI(orig_roll_ri);
+            attitude_control->get_rate_roll_pid().kD(orig_roll_rd);
+            attitude_control->get_angle_roll_p().kP(orig_roll_sp);
+            attitude_control->set_accel_roll_max(orig_roll_accel);
         }
     }
     if (autotune_pitch_enabled()) {
         if (!is_zero(orig_pitch_rp)) {
-            attitude_control.get_rate_pitch_pid().kP(orig_pitch_rp);
-            attitude_control.get_rate_pitch_pid().kI(orig_pitch_ri);
-            attitude_control.get_rate_pitch_pid().kD(orig_pitch_rd);
-            attitude_control.get_angle_pitch_p().kP(orig_pitch_sp);
-            attitude_control.set_accel_pitch_max(orig_pitch_accel);
+            attitude_control->get_rate_pitch_pid().kP(orig_pitch_rp);
+            attitude_control->get_rate_pitch_pid().kI(orig_pitch_ri);
+            attitude_control->get_rate_pitch_pid().kD(orig_pitch_rd);
+            attitude_control->get_angle_pitch_p().kP(orig_pitch_sp);
+            attitude_control->set_accel_pitch_max(orig_pitch_accel);
         }
     }
     if (autotune_yaw_enabled()) {
         if (!is_zero(orig_yaw_rp)) {
-            attitude_control.get_rate_yaw_pid().kP(orig_yaw_rp);
-            attitude_control.get_rate_yaw_pid().kI(orig_yaw_ri);
-            attitude_control.get_rate_yaw_pid().kD(orig_yaw_rd);
-            attitude_control.get_rate_yaw_pid().filt_hz(orig_yaw_rLPF);
-            attitude_control.get_angle_yaw_p().kP(orig_yaw_sp);
-            attitude_control.set_accel_yaw_max(orig_yaw_accel);
+            attitude_control->get_rate_yaw_pid().kP(orig_yaw_rp);
+            attitude_control->get_rate_yaw_pid().kI(orig_yaw_ri);
+            attitude_control->get_rate_yaw_pid().kD(orig_yaw_rd);
+            attitude_control->get_rate_yaw_pid().filt_hz(orig_yaw_rLPF);
+            attitude_control->get_angle_yaw_p().kP(orig_yaw_sp);
+            attitude_control->set_accel_yaw_max(orig_yaw_accel);
         }
     }
 }
@@ -840,37 +840,37 @@ void Copter::autotune_load_orig_gains()
 // autotune_load_tuned_gains - load tuned gains
 void Copter::autotune_load_tuned_gains()
 {
-    if (!attitude_control.get_bf_feedforward()) {
-        attitude_control.bf_feedforward(true);
-        attitude_control.set_accel_roll_max(0.0f);
-        attitude_control.set_accel_pitch_max(0.0f);
+    if (!attitude_control->get_bf_feedforward()) {
+        attitude_control->bf_feedforward(true);
+        attitude_control->set_accel_roll_max(0.0f);
+        attitude_control->set_accel_pitch_max(0.0f);
     }
     if (autotune_roll_enabled()) {
         if (!is_zero(tune_roll_rp)) {
-            attitude_control.get_rate_roll_pid().kP(tune_roll_rp);
-            attitude_control.get_rate_roll_pid().kI(tune_roll_rp*AUTOTUNE_PI_RATIO_FINAL);
-            attitude_control.get_rate_roll_pid().kD(tune_roll_rd);
-            attitude_control.get_angle_roll_p().kP(tune_roll_sp);
-            attitude_control.set_accel_roll_max(tune_roll_accel);
+            attitude_control->get_rate_roll_pid().kP(tune_roll_rp);
+            attitude_control->get_rate_roll_pid().kI(tune_roll_rp*AUTOTUNE_PI_RATIO_FINAL);
+            attitude_control->get_rate_roll_pid().kD(tune_roll_rd);
+            attitude_control->get_angle_roll_p().kP(tune_roll_sp);
+            attitude_control->set_accel_roll_max(tune_roll_accel);
         }
     }
     if (autotune_pitch_enabled()) {
         if (!is_zero(tune_pitch_rp)) {
-            attitude_control.get_rate_pitch_pid().kP(tune_pitch_rp);
-            attitude_control.get_rate_pitch_pid().kI(tune_pitch_rp*AUTOTUNE_PI_RATIO_FINAL);
-            attitude_control.get_rate_pitch_pid().kD(tune_pitch_rd);
-            attitude_control.get_angle_pitch_p().kP(tune_pitch_sp);
-            attitude_control.set_accel_pitch_max(tune_pitch_accel);
+            attitude_control->get_rate_pitch_pid().kP(tune_pitch_rp);
+            attitude_control->get_rate_pitch_pid().kI(tune_pitch_rp*AUTOTUNE_PI_RATIO_FINAL);
+            attitude_control->get_rate_pitch_pid().kD(tune_pitch_rd);
+            attitude_control->get_angle_pitch_p().kP(tune_pitch_sp);
+            attitude_control->set_accel_pitch_max(tune_pitch_accel);
         }
     }
     if (autotune_yaw_enabled()) {
         if (!is_zero(tune_yaw_rp)) {
-            attitude_control.get_rate_yaw_pid().kP(tune_yaw_rp);
-            attitude_control.get_rate_yaw_pid().kI(tune_yaw_rp*AUTOTUNE_YAW_PI_RATIO_FINAL);
-            attitude_control.get_rate_yaw_pid().kD(0.0f);
-            attitude_control.get_rate_yaw_pid().filt_hz(tune_yaw_rLPF);
-            attitude_control.get_angle_yaw_p().kP(tune_yaw_sp);
-            attitude_control.set_accel_yaw_max(tune_yaw_accel);
+            attitude_control->get_rate_yaw_pid().kP(tune_yaw_rp);
+            attitude_control->get_rate_yaw_pid().kI(tune_yaw_rp*AUTOTUNE_YAW_PI_RATIO_FINAL);
+            attitude_control->get_rate_yaw_pid().kD(0.0f);
+            attitude_control->get_rate_yaw_pid().filt_hz(tune_yaw_rLPF);
+            attitude_control->get_angle_yaw_p().kP(tune_yaw_sp);
+            attitude_control->set_accel_yaw_max(tune_yaw_accel);
         }
     }
 }
@@ -881,25 +881,25 @@ void Copter::autotune_load_intra_test_gains()
 {
     // we are restarting tuning so reset gains to tuning-start gains (i.e. low I term)
     // sanity check the gains
-    attitude_control.bf_feedforward(true);
+    attitude_control->bf_feedforward(true);
     if (autotune_roll_enabled()) {
-        attitude_control.get_rate_roll_pid().kP(orig_roll_rp);
-        attitude_control.get_rate_roll_pid().kI(orig_roll_rp*AUTOTUNE_PI_RATIO_FOR_TESTING);
-        attitude_control.get_rate_roll_pid().kD(orig_roll_rd);
-        attitude_control.get_angle_roll_p().kP(orig_roll_sp);
+        attitude_control->get_rate_roll_pid().kP(orig_roll_rp);
+        attitude_control->get_rate_roll_pid().kI(orig_roll_rp*AUTOTUNE_PI_RATIO_FOR_TESTING);
+        attitude_control->get_rate_roll_pid().kD(orig_roll_rd);
+        attitude_control->get_angle_roll_p().kP(orig_roll_sp);
     }
     if (autotune_pitch_enabled()) {
-        attitude_control.get_rate_pitch_pid().kP(orig_pitch_rp);
-        attitude_control.get_rate_pitch_pid().kI(orig_pitch_rp*AUTOTUNE_PI_RATIO_FOR_TESTING);
-        attitude_control.get_rate_pitch_pid().kD(orig_pitch_rd);
-        attitude_control.get_angle_pitch_p().kP(orig_pitch_sp);
+        attitude_control->get_rate_pitch_pid().kP(orig_pitch_rp);
+        attitude_control->get_rate_pitch_pid().kI(orig_pitch_rp*AUTOTUNE_PI_RATIO_FOR_TESTING);
+        attitude_control->get_rate_pitch_pid().kD(orig_pitch_rd);
+        attitude_control->get_angle_pitch_p().kP(orig_pitch_sp);
     }
     if (autotune_yaw_enabled()) {
-        attitude_control.get_rate_yaw_pid().kP(orig_yaw_rp);
-        attitude_control.get_rate_yaw_pid().kI(orig_yaw_rp*AUTOTUNE_PI_RATIO_FOR_TESTING);
-        attitude_control.get_rate_yaw_pid().kD(orig_yaw_rd);
-        attitude_control.get_rate_yaw_pid().filt_hz(orig_yaw_rLPF);
-        attitude_control.get_angle_yaw_p().kP(orig_yaw_sp);
+        attitude_control->get_rate_yaw_pid().kP(orig_yaw_rp);
+        attitude_control->get_rate_yaw_pid().kI(orig_yaw_rp*AUTOTUNE_PI_RATIO_FOR_TESTING);
+        attitude_control->get_rate_yaw_pid().kD(orig_yaw_rd);
+        attitude_control->get_rate_yaw_pid().filt_hz(orig_yaw_rLPF);
+        attitude_control->get_angle_yaw_p().kP(orig_yaw_sp);
     }
 }
 
@@ -909,23 +909,23 @@ void Copter::autotune_load_twitch_gains()
 {
     switch (autotune_state.axis) {
         case AUTOTUNE_AXIS_ROLL:
-            attitude_control.get_rate_roll_pid().kP(tune_roll_rp);
-            attitude_control.get_rate_roll_pid().kI(tune_roll_rp*0.01f);
-            attitude_control.get_rate_roll_pid().kD(tune_roll_rd);
-            attitude_control.get_angle_roll_p().kP(tune_roll_sp);
+            attitude_control->get_rate_roll_pid().kP(tune_roll_rp);
+            attitude_control->get_rate_roll_pid().kI(tune_roll_rp*0.01f);
+            attitude_control->get_rate_roll_pid().kD(tune_roll_rd);
+            attitude_control->get_angle_roll_p().kP(tune_roll_sp);
             break;
         case AUTOTUNE_AXIS_PITCH:
-            attitude_control.get_rate_pitch_pid().kP(tune_pitch_rp);
-            attitude_control.get_rate_pitch_pid().kI(tune_pitch_rp*0.01f);
-            attitude_control.get_rate_pitch_pid().kD(tune_pitch_rd);
-            attitude_control.get_angle_pitch_p().kP(tune_pitch_sp);
+            attitude_control->get_rate_pitch_pid().kP(tune_pitch_rp);
+            attitude_control->get_rate_pitch_pid().kI(tune_pitch_rp*0.01f);
+            attitude_control->get_rate_pitch_pid().kD(tune_pitch_rd);
+            attitude_control->get_angle_pitch_p().kP(tune_pitch_sp);
             break;
         case AUTOTUNE_AXIS_YAW:
-            attitude_control.get_rate_yaw_pid().kP(tune_yaw_rp);
-            attitude_control.get_rate_yaw_pid().kI(tune_yaw_rp*0.01f);
-            attitude_control.get_rate_yaw_pid().kD(0.0f);
-            attitude_control.get_rate_yaw_pid().filt_hz(tune_yaw_rLPF);
-            attitude_control.get_angle_yaw_p().kP(tune_yaw_sp);
+            attitude_control->get_rate_yaw_pid().kP(tune_yaw_rp);
+            attitude_control->get_rate_yaw_pid().kI(tune_yaw_rp*0.01f);
+            attitude_control->get_rate_yaw_pid().kD(0.0f);
+            attitude_control->get_rate_yaw_pid().filt_hz(tune_yaw_rLPF);
+            attitude_control->get_angle_yaw_p().kP(tune_yaw_sp);
             break;
     }
 }
@@ -937,76 +937,76 @@ void Copter::autotune_save_tuning_gains()
     // if we successfully completed tuning
     if (autotune_state.mode == AUTOTUNE_MODE_SUCCESS) {
 
-        if (!attitude_control.get_bf_feedforward()) {
-            attitude_control.bf_feedforward_save(true);
-            attitude_control.save_accel_roll_max(0.0f);
-            attitude_control.save_accel_pitch_max(0.0f);
+        if (!attitude_control->get_bf_feedforward()) {
+            attitude_control->bf_feedforward_save(true);
+            attitude_control->save_accel_roll_max(0.0f);
+            attitude_control->save_accel_pitch_max(0.0f);
         }
 
         // sanity check the rate P values
         if (autotune_roll_enabled() && !is_zero(tune_roll_rp)) {
             // rate roll gains
-            attitude_control.get_rate_roll_pid().kP(tune_roll_rp);
-            attitude_control.get_rate_roll_pid().kI(tune_roll_rp*AUTOTUNE_PI_RATIO_FINAL);
-            attitude_control.get_rate_roll_pid().kD(tune_roll_rd);
-            attitude_control.get_rate_roll_pid().save_gains();
+            attitude_control->get_rate_roll_pid().kP(tune_roll_rp);
+            attitude_control->get_rate_roll_pid().kI(tune_roll_rp*AUTOTUNE_PI_RATIO_FINAL);
+            attitude_control->get_rate_roll_pid().kD(tune_roll_rd);
+            attitude_control->get_rate_roll_pid().save_gains();
 
             // stabilize roll
-            attitude_control.get_angle_roll_p().kP(tune_roll_sp);
-            attitude_control.get_angle_roll_p().save_gains();
+            attitude_control->get_angle_roll_p().kP(tune_roll_sp);
+            attitude_control->get_angle_roll_p().save_gains();
 
             // acceleration roll
-            attitude_control.save_accel_roll_max(tune_roll_accel);
+            attitude_control->save_accel_roll_max(tune_roll_accel);
 
             // resave pids to originals in case the autotune is run again
-            orig_roll_rp = attitude_control.get_rate_roll_pid().kP();
-            orig_roll_ri = attitude_control.get_rate_roll_pid().kI();
-            orig_roll_rd = attitude_control.get_rate_roll_pid().kD();
-            orig_roll_sp = attitude_control.get_angle_roll_p().kP();
+            orig_roll_rp = attitude_control->get_rate_roll_pid().kP();
+            orig_roll_ri = attitude_control->get_rate_roll_pid().kI();
+            orig_roll_rd = attitude_control->get_rate_roll_pid().kD();
+            orig_roll_sp = attitude_control->get_angle_roll_p().kP();
         }
 
         if (autotune_pitch_enabled() && !is_zero(tune_pitch_rp)) {
             // rate pitch gains
-            attitude_control.get_rate_pitch_pid().kP(tune_pitch_rp);
-            attitude_control.get_rate_pitch_pid().kI(tune_pitch_rp*AUTOTUNE_PI_RATIO_FINAL);
-            attitude_control.get_rate_pitch_pid().kD(tune_pitch_rd);
-            attitude_control.get_rate_pitch_pid().save_gains();
+            attitude_control->get_rate_pitch_pid().kP(tune_pitch_rp);
+            attitude_control->get_rate_pitch_pid().kI(tune_pitch_rp*AUTOTUNE_PI_RATIO_FINAL);
+            attitude_control->get_rate_pitch_pid().kD(tune_pitch_rd);
+            attitude_control->get_rate_pitch_pid().save_gains();
 
             // stabilize pitch
-            attitude_control.get_angle_pitch_p().kP(tune_pitch_sp);
-            attitude_control.get_angle_pitch_p().save_gains();
+            attitude_control->get_angle_pitch_p().kP(tune_pitch_sp);
+            attitude_control->get_angle_pitch_p().save_gains();
 
             // acceleration pitch
-            attitude_control.save_accel_pitch_max(tune_pitch_accel);
+            attitude_control->save_accel_pitch_max(tune_pitch_accel);
 
             // resave pids to originals in case the autotune is run again
-            orig_pitch_rp = attitude_control.get_rate_pitch_pid().kP();
-            orig_pitch_ri = attitude_control.get_rate_pitch_pid().kI();
-            orig_pitch_rd = attitude_control.get_rate_pitch_pid().kD();
-            orig_pitch_sp = attitude_control.get_angle_pitch_p().kP();
+            orig_pitch_rp = attitude_control->get_rate_pitch_pid().kP();
+            orig_pitch_ri = attitude_control->get_rate_pitch_pid().kI();
+            orig_pitch_rd = attitude_control->get_rate_pitch_pid().kD();
+            orig_pitch_sp = attitude_control->get_angle_pitch_p().kP();
         }
 
         if (autotune_yaw_enabled() && !is_zero(tune_yaw_rp)) {
             // rate yaw gains
-            attitude_control.get_rate_yaw_pid().kP(tune_yaw_rp);
-            attitude_control.get_rate_yaw_pid().kI(tune_yaw_rp*AUTOTUNE_YAW_PI_RATIO_FINAL);
-            attitude_control.get_rate_yaw_pid().kD(0.0f);
-            attitude_control.get_rate_yaw_pid().filt_hz(tune_yaw_rLPF);
-            attitude_control.get_rate_yaw_pid().save_gains();
+            attitude_control->get_rate_yaw_pid().kP(tune_yaw_rp);
+            attitude_control->get_rate_yaw_pid().kI(tune_yaw_rp*AUTOTUNE_YAW_PI_RATIO_FINAL);
+            attitude_control->get_rate_yaw_pid().kD(0.0f);
+            attitude_control->get_rate_yaw_pid().filt_hz(tune_yaw_rLPF);
+            attitude_control->get_rate_yaw_pid().save_gains();
 
             // stabilize yaw
-            attitude_control.get_angle_yaw_p().kP(tune_yaw_sp);
-            attitude_control.get_angle_yaw_p().save_gains();
+            attitude_control->get_angle_yaw_p().kP(tune_yaw_sp);
+            attitude_control->get_angle_yaw_p().save_gains();
 
             // acceleration yaw
-            attitude_control.save_accel_yaw_max(tune_yaw_accel);
+            attitude_control->save_accel_yaw_max(tune_yaw_accel);
 
             // resave pids to originals in case the autotune is run again
-            orig_yaw_rp = attitude_control.get_rate_yaw_pid().kP();
-            orig_yaw_ri = attitude_control.get_rate_yaw_pid().kI();
-            orig_yaw_rd = attitude_control.get_rate_yaw_pid().kD();
-            orig_yaw_rLPF = attitude_control.get_rate_yaw_pid().filt_hz();
-            orig_yaw_sp = attitude_control.get_angle_yaw_p().kP();
+            orig_yaw_rp = attitude_control->get_rate_yaw_pid().kP();
+            orig_yaw_ri = attitude_control->get_rate_yaw_pid().kI();
+            orig_yaw_rd = attitude_control->get_rate_yaw_pid().kD();
+            orig_yaw_rLPF = attitude_control->get_rate_yaw_pid().filt_hz();
+            orig_yaw_sp = attitude_control->get_angle_yaw_p().kP();
         }
         // update GCS and log save gains event
         autotune_update_gcs(AUTOTUNE_MESSAGE_SAVED_GAINS);
diff --git a/ArduCopter/control_brake.cpp b/ArduCopter/control_brake.cpp
index 6106a86..e0cf912 100644
--- a/ArduCopter/control_brake.cpp
+++ b/ArduCopter/control_brake.cpp
@@ -10,19 +10,19 @@ bool Copter::brake_init(bool ignore_checks)
     if (position_ok() || ignore_checks) {
 
         // set desired acceleration to zero
-        wp_nav.clear_pilot_desired_acceleration();
+        wp_nav->clear_pilot_desired_acceleration();
 
         // set target to current position
-        wp_nav.init_brake_target(BRAKE_MODE_DECEL_RATE);
+        wp_nav->init_brake_target(BRAKE_MODE_DECEL_RATE);
 
         // initialize vertical speed and acceleration
-        pos_control.set_speed_z(BRAKE_MODE_SPEED_Z, BRAKE_MODE_SPEED_Z);
-        pos_control.set_accel_z(BRAKE_MODE_DECEL_RATE);
+        pos_control->set_speed_z(BRAKE_MODE_SPEED_Z, BRAKE_MODE_SPEED_Z);
+        pos_control->set_accel_z(BRAKE_MODE_DECEL_RATE);
 
         // initialise position and desired velocity
-        if (!pos_control.is_active_z()) {
-            pos_control.set_alt_target_to_current_alt();
-            pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+        if (!pos_control->is_active_z()) {
+            pos_control->set_alt_target_to_current_alt();
+            pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
         }
 
         brake_timeout_ms = 0;
@@ -38,24 +38,24 @@ bool Copter::brake_init(bool ignore_checks)
 void Copter::brake_run()
 {
     // if not auto armed set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
-        wp_nav.init_brake_target(BRAKE_MODE_DECEL_RATE);
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
+        wp_nav->init_brake_target(BRAKE_MODE_DECEL_RATE);
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
-        pos_control.relax_alt_hold_controllers(0.0f);
+        pos_control->relax_alt_hold_controllers(0.0f);
         return;
     }
 
     // relax stop target if we might be landed
     if (ap.land_complete_maybe) {
-        wp_nav.loiter_soften_for_landing();
+        wp_nav->loiter_soften_for_landing();
     }
 
     // if landed immediately disarm
@@ -64,19 +64,19 @@ void Copter::brake_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run brake controller
-    wp_nav.update_brake(ekfGndSpdLimit, ekfNavVelGainScaler);
+    wp_nav->update_brake(ekfGndSpdLimit, ekfNavVelGainScaler);
 
     // call attitude controller
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), 0.0f, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), 0.0f, get_smoothing_gain());
 
     // body-frame rate controller is run directly from 100hz loop
 
     // update altitude target and call position controller
-    pos_control.set_alt_target_from_climb_rate_ff(0.0f, G_Dt, false);
-    pos_control.update_z_controller();
+    pos_control->set_alt_target_from_climb_rate_ff(0.0f, G_Dt, false);
+    pos_control->update_z_controller();
 
     if (brake_timeout_ms != 0 && millis()-brake_timeout_start >= brake_timeout_ms) {
         if (!set_mode(LOITER, MODE_REASON_BRAKE_TIMEOUT)) {
diff --git a/ArduCopter/control_circle.cpp b/ArduCopter/control_circle.cpp
index 2785c15..e1e06fc 100644
--- a/ArduCopter/control_circle.cpp
+++ b/ArduCopter/control_circle.cpp
@@ -11,14 +11,14 @@ bool Copter::circle_init(bool ignore_checks)
         circle_pilot_yaw_override = false;
 
         // initialize speeds and accelerations
-        pos_control.set_speed_xy(wp_nav.get_speed_xy());
-        pos_control.set_accel_xy(wp_nav.get_wp_acceleration());
-        pos_control.set_jerk_xy_to_default();
-        pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-        pos_control.set_accel_z(g.pilot_accel_z);
+        pos_control->set_speed_xy(wp_nav->get_speed_xy());
+        pos_control->set_accel_xy(wp_nav->get_wp_acceleration());
+        pos_control->set_jerk_xy_to_default();
+        pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+        pos_control->set_accel_z(g.pilot_accel_z);
 
         // initialise circle controller including setting the circle center based on vehicle speed
-        circle_nav.init();
+        circle_nav->init();
 
         return true;
     }else{
@@ -34,24 +34,24 @@ void Copter::circle_run()
     float target_climb_rate = 0;
 
     // initialize speeds and accelerations
-    pos_control.set_speed_xy(wp_nav.get_speed_xy());
-    pos_control.set_accel_xy(wp_nav.get_wp_acceleration());
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_xy(wp_nav->get_speed_xy());
+    pos_control->set_accel_xy(wp_nav->get_wp_acceleration());
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
     
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || ap.land_complete || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || ap.land_complete || !motors->get_interlock()) {
         // To-Do: add some initialisation of position controllers
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
-        pos_control.set_alt_target_to_current_alt();
+        pos_control->set_alt_target_to_current_alt();
         return;
     }
 
@@ -76,24 +76,24 @@ void Copter::circle_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run circle controller
-    circle_nav.update();
+    circle_nav->update();
 
     // call attitude controller
     if (circle_pilot_yaw_override) {
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(circle_nav.get_roll(), circle_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(circle_nav->get_roll(), circle_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
     }else{
-        attitude_control.input_euler_angle_roll_pitch_yaw(circle_nav.get_roll(), circle_nav.get_pitch(), circle_nav.get_yaw(),true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(circle_nav->get_roll(), circle_nav->get_pitch(), circle_nav->get_yaw(),true, get_smoothing_gain());
     }
 
     // adjust climb rate using rangefinder
     if (rangefinder_alt_ok()) {
         // if rangefinder is ok, use surface tracking
-        target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control.get_alt_target(), G_Dt);
+        target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
     }
     // update altitude target and call position controller
-    pos_control.set_alt_target_from_climb_rate(target_climb_rate, G_Dt, false);
-    pos_control.update_z_controller();
+    pos_control->set_alt_target_from_climb_rate(target_climb_rate, G_Dt, false);
+    pos_control->update_z_controller();
 }
diff --git a/ArduCopter/control_drift.cpp b/ArduCopter/control_drift.cpp
index 14dea0e..37a9240 100644
--- a/ArduCopter/control_drift.cpp
+++ b/ArduCopter/control_drift.cpp
@@ -47,9 +47,9 @@ void Copter::drift_run()
     float pilot_throttle_scaled;
 
     // if landed and throttle at zero, set throttle to zero and exit immediately
-    if (!motors.armed() || !motors.get_interlock() || (ap.land_complete && ap.throttle_zero)) {
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+    if (!motors->armed() || !motors->get_interlock() || (ap.land_complete && ap.throttle_zero)) {
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
         return;
     }
 
@@ -98,13 +98,13 @@ void Copter::drift_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // call attitude controller
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
 
     // output pilot's throttle with angle boost
-    attitude_control.set_throttle_out(get_throttle_assist(vel.z, pilot_throttle_scaled), true, g.throttle_filt);
+    attitude_control->set_throttle_out(get_throttle_assist(vel.z, pilot_throttle_scaled), true, g.throttle_filt);
 }
 
 // get_throttle_assist - return throttle output (range 0 ~ 1) based on pilot input and z-axis velocity
diff --git a/ArduCopter/control_flip.cpp b/ArduCopter/control_flip.cpp
index 0c8cd6d..217dd2d 100644
--- a/ArduCopter/control_flip.cpp
+++ b/ArduCopter/control_flip.cpp
@@ -55,7 +55,7 @@ bool Copter::flip_init(bool ignore_checks)
     }
 
     // only allow flip when flying
-    if (!motors.armed() || ap.land_complete) {
+    if (!motors->armed() || ap.land_complete) {
         return false;
     }
 
@@ -98,7 +98,7 @@ void Copter::flip_run()
     float recovery_angle;
 
     // if pilot inputs roll > 40deg or timeout occurs abandon flip
-    if (!motors.armed() || (abs(channel_roll->get_control_in()) >= 4000) || (abs(channel_pitch->get_control_in()) >= 4000) || ((millis() - flip_start_time) > FLIP_TIMEOUT_MS)) {
+    if (!motors->armed() || (abs(channel_roll->get_control_in()) >= 4000) || (abs(channel_pitch->get_control_in()) >= 4000) || ((millis() - flip_start_time) > FLIP_TIMEOUT_MS)) {
         flip_state = Flip_Abandon;
     }
 
@@ -120,7 +120,7 @@ void Copter::flip_run()
 
     case Flip_Start:
         // under 45 degrees request 400deg/sec roll or pitch
-        attitude_control.input_rate_bf_roll_pitch_yaw(FLIP_ROTATION_RATE * flip_roll_dir, FLIP_ROTATION_RATE * flip_pitch_dir, 0.0);
+        attitude_control->input_rate_bf_roll_pitch_yaw(FLIP_ROTATION_RATE * flip_roll_dir, FLIP_ROTATION_RATE * flip_pitch_dir, 0.0);
 
         // increase throttle
         throttle_out += FLIP_THR_INC;
@@ -139,7 +139,7 @@ void Copter::flip_run()
 
     case Flip_Roll:
         // between 45deg ~ -90deg request 400deg/sec roll
-        attitude_control.input_rate_bf_roll_pitch_yaw(FLIP_ROTATION_RATE * flip_roll_dir, 0.0, 0.0);
+        attitude_control->input_rate_bf_roll_pitch_yaw(FLIP_ROTATION_RATE * flip_roll_dir, 0.0, 0.0);
         // decrease throttle
         throttle_out = MAX(throttle_out - FLIP_THR_DEC, 0.0f);
 
@@ -151,7 +151,7 @@ void Copter::flip_run()
 
     case Flip_Pitch_A:
         // between 45deg ~ -90deg request 400deg/sec pitch
-        attitude_control.input_rate_bf_roll_pitch_yaw(0.0f, FLIP_ROTATION_RATE * flip_pitch_dir, 0.0);
+        attitude_control->input_rate_bf_roll_pitch_yaw(0.0f, FLIP_ROTATION_RATE * flip_pitch_dir, 0.0);
         // decrease throttle
         throttle_out = MAX(throttle_out - FLIP_THR_DEC, 0.0f);
 
@@ -163,7 +163,7 @@ void Copter::flip_run()
 
     case Flip_Pitch_B:
         // between 45deg ~ -90deg request 400deg/sec pitch
-        attitude_control.input_rate_bf_roll_pitch_yaw(0.0, FLIP_ROTATION_RATE * flip_pitch_dir, 0.0);
+        attitude_control->input_rate_bf_roll_pitch_yaw(0.0, FLIP_ROTATION_RATE * flip_pitch_dir, 0.0);
         // decrease throttle
         throttle_out = MAX(throttle_out - FLIP_THR_DEC, 0.0f);
 
@@ -175,7 +175,7 @@ void Copter::flip_run()
 
     case Flip_Recover:
         // use originally captured earth-frame angle targets to recover
-        attitude_control.input_euler_angle_roll_pitch_yaw(flip_orig_attitude.x, flip_orig_attitude.y, flip_orig_attitude.z, false, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(flip_orig_attitude.x, flip_orig_attitude.y, flip_orig_attitude.z, false, get_smoothing_gain());
 
         // increase throttle to gain any lost altitude
         throttle_out += FLIP_THR_INC;
@@ -212,8 +212,8 @@ void Copter::flip_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // output pilot's throttle without angle boost
-    attitude_control.set_throttle_out(throttle_out, false, g.throttle_filt);
+    attitude_control->set_throttle_out(throttle_out, false, g.throttle_filt);
 }
diff --git a/ArduCopter/control_guided.cpp b/ArduCopter/control_guided.cpp
index eb6deb3..59ae772 100644
--- a/ArduCopter/control_guided.cpp
+++ b/ArduCopter/control_guided.cpp
@@ -59,7 +59,7 @@ bool Copter::guided_takeoff_start(float final_alt_above_home)
     Location_Class target_loc = current_loc;
     target_loc.set_alt_cm(final_alt_above_home, Location_Class::ALT_FRAME_ABOVE_HOME);
 
-    if (!wp_nav.set_wp_destination(target_loc)) {
+    if (!wp_nav->set_wp_destination(target_loc)) {
         // failure to set destination can only be because of missing terrain data
         Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         // failure is propagated to GCS with NAK
@@ -85,17 +85,17 @@ void Copter::guided_pos_control_start()
     guided_mode = Guided_WP;
 
     // initialise waypoint and spline controller
-    wp_nav.wp_and_spline_init();
+    wp_nav->wp_and_spline_init();
 
     // initialise wpnav to stopping point at current altitude
     // To-Do: set to current location if disarmed?
     // To-Do: set to stopping point altitude?
     Vector3f stopping_point;
     stopping_point.z = inertial_nav.get_altitude();
-    wp_nav.get_wp_stopping_point_xy(stopping_point);
+    wp_nav->get_wp_stopping_point_xy(stopping_point);
 
     // no need to check return status because terrain data is not used
-    wp_nav.set_wp_destination(stopping_point, false);
+    wp_nav->set_wp_destination(stopping_point, false);
 
     // initialise yaw
     set_auto_yaw_mode(get_default_auto_yaw_mode(false));
@@ -108,11 +108,11 @@ void Copter::guided_vel_control_start()
     guided_mode = Guided_Velocity;
 
     // initialize vertical speeds and leash lengths
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // initialise velocity controller
-    pos_control.init_vel_controller_xyz();
+    pos_control->init_vel_controller_xyz();
 }
 
 // initialise guided mode's posvel controller
@@ -121,23 +121,23 @@ void Copter::guided_posvel_control_start()
     // set guided_mode to velocity controller
     guided_mode = Guided_PosVel;
 
-    pos_control.init_xy_controller();
+    pos_control->init_xy_controller();
 
     // set speed and acceleration from wpnav's speed and acceleration
-    pos_control.set_speed_xy(wp_nav.get_speed_xy());
-    pos_control.set_accel_xy(wp_nav.get_wp_acceleration());
-    pos_control.set_jerk_xy_to_default();
+    pos_control->set_speed_xy(wp_nav->get_speed_xy());
+    pos_control->set_accel_xy(wp_nav->get_wp_acceleration());
+    pos_control->set_jerk_xy_to_default();
 
     const Vector3f& curr_pos = inertial_nav.get_position();
     const Vector3f& curr_vel = inertial_nav.get_velocity();
 
     // set target position and velocity to current position and velocity
-    pos_control.set_xy_target(curr_pos.x, curr_pos.y);
-    pos_control.set_desired_velocity_xy(curr_vel.x, curr_vel.y);
+    pos_control->set_xy_target(curr_pos.x, curr_pos.y);
+    pos_control->set_desired_velocity_xy(curr_vel.x, curr_vel.y);
 
     // set vertical speed and acceleration
-    pos_control.set_speed_z(wp_nav.get_speed_down(), wp_nav.get_speed_up());
-    pos_control.set_accel_z(wp_nav.get_accel_z());
+    pos_control->set_speed_z(wp_nav->get_speed_down(), wp_nav->get_speed_up());
+    pos_control->set_accel_z(wp_nav->get_accel_z());
 
     // pilot always controls yaw
     set_auto_yaw_mode(AUTO_YAW_HOLD);
@@ -150,13 +150,13 @@ void Copter::guided_angle_control_start()
     guided_mode = Guided_Angle;
 
     // set vertical speed and acceleration
-    pos_control.set_speed_z(wp_nav.get_speed_down(), wp_nav.get_speed_up());
-    pos_control.set_accel_z(wp_nav.get_accel_z());
+    pos_control->set_speed_z(wp_nav->get_speed_down(), wp_nav->get_speed_up());
+    pos_control->set_accel_z(wp_nav->get_accel_z());
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target_to_current_alt();
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target_to_current_alt();
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
     // initialise targets
@@ -193,7 +193,7 @@ bool Copter::guided_set_destination(const Vector3f& destination)
 #endif
 
     // no need to check return status because terrain data is not used
-    wp_nav.set_wp_destination(destination, false);
+    wp_nav->set_wp_destination(destination, false);
 
     // log target
     Log_Write_GuidedTarget(guided_mode, destination, Vector3f());
@@ -220,7 +220,7 @@ bool Copter::guided_set_destination(const Location_Class& dest_loc)
     }
 #endif
 
-    if (!wp_nav.set_wp_destination(dest_loc)) {
+    if (!wp_nav->set_wp_destination(dest_loc)) {
         // failure to set destination can only be because of missing terrain data
         Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         // failure is propagated to GCS with NAK
@@ -259,7 +259,7 @@ void Copter::guided_set_destination_posvel(const Vector3f& destination, const Ve
     guided_pos_target_cm = destination;
     guided_vel_target_cms = velocity;
 
-    pos_control.set_pos_target(guided_pos_target_cm);
+    pos_control->set_pos_target(guided_pos_target_cm);
 
     // log target
     Log_Write_GuidedTarget(guided_mode, destination, velocity);
@@ -285,7 +285,7 @@ void Copter::guided_set_angle(const Quaternion &q, float climb_rate_cms, bool us
     guided_angle_state.update_time_ms = millis();
 
     // interpret positive climb rate as triggering take-off
-    if (motors.armed() && !ap.auto_armed && (guided_angle_state.climb_rate_cms > 0.0f)) {
+    if (motors->armed() && !ap.auto_armed && (guided_angle_state.climb_rate_cms > 0.0f)) {
         set_auto_armed(true);
     }
 
@@ -334,15 +334,15 @@ void Copter::guided_run()
 void Copter::guided_takeoff_run()
 {
     // if not auto armed or motors not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         return;
     }
@@ -355,13 +355,13 @@ void Copter::guided_takeoff_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run waypoint controller
-    failsafe_terrain_set_status(wp_nav.update_wpnav());
+    failsafe_terrain_set_status(wp_nav->update_wpnav());
 
     // call z-axis position controller (wpnav should have already updated it's alt target)
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // call attitude controller
     auto_takeoff_attitude_run(target_yaw_rate);
@@ -372,15 +372,15 @@ void Copter::guided_takeoff_run()
 void Copter::guided_pos_control_run()
 {
     // if not auto armed or motors not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock() || ap.land_complete) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock() || ap.land_complete) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         return;
     }
@@ -396,21 +396,21 @@ void Copter::guided_pos_control_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run waypoint controller
-    failsafe_terrain_set_status(wp_nav.update_wpnav());
+    failsafe_terrain_set_status(wp_nav->update_wpnav());
 
     // call z-axis position controller (wpnav should have already updated it's alt target)
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // call attitude controller
     if (auto_yaw_mode == AUTO_YAW_HOLD) {
         // roll & pitch from waypoint controller, yaw rate from pilot
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
     }else{
         // roll, pitch from waypoint controller, yaw heading from auto_heading()
-        attitude_control.input_euler_angle_roll_pitch_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), get_auto_heading(), true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), get_auto_heading(), true, get_smoothing_gain());
     }
 }
 
@@ -419,17 +419,17 @@ void Copter::guided_pos_control_run()
 void Copter::guided_vel_control_run()
 {
     // if not auto armed or motors not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock() || ap.land_complete) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock() || ap.land_complete) {
         // initialise velocity controller
-        pos_control.init_vel_controller_xyz();
+        pos_control->init_vel_controller_xyz();
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         return;
     }
@@ -445,26 +445,26 @@ void Copter::guided_vel_control_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // set velocity to zero if no updates received for 3 seconds
     uint32_t tnow = millis();
-    if (tnow - vel_update_time_ms > GUIDED_POSVEL_TIMEOUT_MS && !pos_control.get_desired_velocity().is_zero()) {
+    if (tnow - vel_update_time_ms > GUIDED_POSVEL_TIMEOUT_MS && !pos_control->get_desired_velocity().is_zero()) {
         guided_set_desired_velocity_with_accel_and_fence_limits(Vector3f(0.0f,0.0f,0.0f));
     } else {
         guided_set_desired_velocity_with_accel_and_fence_limits(guided_vel_target_cms);
     }
 
     // call velocity controller which includes z axis controller
-    pos_control.update_vel_controller_xyz(ekfNavVelGainScaler);
+    pos_control->update_vel_controller_xyz(ekfNavVelGainScaler);
 
     // call attitude controller
     if (auto_yaw_mode == AUTO_YAW_HOLD) {
         // roll & pitch from waypoint controller, yaw rate from pilot
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(pos_control.get_roll(), pos_control.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(pos_control->get_roll(), pos_control->get_pitch(), target_yaw_rate, get_smoothing_gain());
     }else{
         // roll, pitch from waypoint controller, yaw heading from auto_heading()
-        attitude_control.input_euler_angle_roll_pitch_yaw(pos_control.get_roll(), pos_control.get_pitch(), get_auto_heading(), true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(pos_control->get_roll(), pos_control->get_pitch(), get_auto_heading(), true, get_smoothing_gain());
     }
 }
 
@@ -473,18 +473,18 @@ void Copter::guided_vel_control_run()
 void Copter::guided_posvel_control_run()
 {
     // if not auto armed or motors not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock() || ap.land_complete) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock() || ap.land_complete) {
         // set target position and velocity to current position and velocity
-        pos_control.set_pos_target(inertial_nav.get_position());
-        pos_control.set_desired_velocity(Vector3f(0,0,0));
+        pos_control->set_pos_target(inertial_nav.get_position());
+        pos_control->set_desired_velocity(Vector3f(0,0,0));
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         return;
     }
@@ -501,7 +501,7 @@ void Copter::guided_posvel_control_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // set velocity to zero if no updates received for 3 seconds
     uint32_t tnow = millis();
@@ -510,10 +510,10 @@ void Copter::guided_posvel_control_run()
     }
 
     // calculate dt
-    float dt = pos_control.time_since_last_xy_update();
+    float dt = pos_control->time_since_last_xy_update();
 
     // update at poscontrol update rate
-    if (dt >= pos_control.get_dt_xy()) {
+    if (dt >= pos_control->get_dt_xy()) {
         // sanity check dt
         if (dt >= 0.2f) {
             dt = 0.0f;
@@ -523,22 +523,22 @@ void Copter::guided_posvel_control_run()
         guided_pos_target_cm += guided_vel_target_cms * dt;
 
         // send position and velocity targets to position controller
-        pos_control.set_pos_target(guided_pos_target_cm);
-        pos_control.set_desired_velocity_xy(guided_vel_target_cms.x, guided_vel_target_cms.y);
+        pos_control->set_pos_target(guided_pos_target_cm);
+        pos_control->set_desired_velocity_xy(guided_vel_target_cms.x, guided_vel_target_cms.y);
 
         // run position controller
-        pos_control.update_xy_controller(AC_PosControl::XY_MODE_POS_AND_VEL_FF, ekfNavVelGainScaler, false);
+        pos_control->update_xy_controller(AC_PosControl::XY_MODE_POS_AND_VEL_FF, ekfNavVelGainScaler, false);
     }
 
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // call attitude controller
     if (auto_yaw_mode == AUTO_YAW_HOLD) {
         // roll & pitch from waypoint controller, yaw rate from pilot
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(pos_control.get_roll(), pos_control.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(pos_control->get_roll(), pos_control->get_pitch(), target_yaw_rate, get_smoothing_gain());
     }else{
         // roll, pitch from waypoint controller, yaw heading from auto_heading()
-        attitude_control.input_euler_angle_roll_pitch_yaw(pos_control.get_roll(), pos_control.get_pitch(), get_auto_heading(), true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(pos_control->get_roll(), pos_control->get_pitch(), get_auto_heading(), true, get_smoothing_gain());
     }
 }
 
@@ -547,18 +547,18 @@ void Copter::guided_posvel_control_run()
 void Copter::guided_angle_control_run()
 {
     // if not auto armed or motors not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock() || (ap.land_complete && guided_angle_state.climb_rate_cms <= 0.0f)) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock() || (ap.land_complete && guided_angle_state.climb_rate_cms <= 0.0f)) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.set_yaw_target_to_current_heading();
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f, get_smoothing_gain());
-        attitude_control.set_throttle_out(0.0f,false,g.throttle_filt);
+        attitude_control->set_yaw_target_to_current_heading();
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f, get_smoothing_gain());
+        attitude_control->set_throttle_out(0.0f,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0.0f,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0.0f,true,g.throttle_filt);
 #endif
-        pos_control.relax_alt_hold_controllers(0.0f);
+        pos_control->relax_alt_hold_controllers(0.0f);
         return;
     }
 
@@ -566,7 +566,7 @@ void Copter::guided_angle_control_run()
     float roll_in = guided_angle_state.roll_cd;
     float pitch_in = guided_angle_state.pitch_cd;
     float total_in = norm(roll_in, pitch_in);
-    float angle_max = MIN(attitude_control.get_althold_lean_angle_max(), aparm.angle_max);
+    float angle_max = MIN(attitude_control->get_althold_lean_angle_max(), aparm.angle_max);
     if (total_in > angle_max) {
         float ratio = angle_max / total_in;
         roll_in *= ratio;
@@ -578,7 +578,7 @@ void Copter::guided_angle_control_run()
     float yaw_rate_in = wrap_180_cd(guided_angle_state.yaw_rate_cds);
 
     // constrain climb rate
-    float climb_rate_cms = constrain_float(guided_angle_state.climb_rate_cms, -fabsf(wp_nav.get_speed_down()), wp_nav.get_speed_up());
+    float climb_rate_cms = constrain_float(guided_angle_state.climb_rate_cms, -fabsf(wp_nav->get_speed_down()), wp_nav->get_speed_up());
 
     // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds
     uint32_t tnow = millis();
@@ -590,25 +590,25 @@ void Copter::guided_angle_control_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // call attitude controller
     if (guided_angle_state.use_yaw_rate) {
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(roll_in, pitch_in, yaw_rate_in, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(roll_in, pitch_in, yaw_rate_in, get_smoothing_gain());
     } else {
-        attitude_control.input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(roll_in, pitch_in, yaw_in, true, get_smoothing_gain());
     }
 
     // call position controller
-    pos_control.set_alt_target_from_climb_rate_ff(climb_rate_cms, G_Dt, false);
-    pos_control.update_z_controller();
+    pos_control->set_alt_target_from_climb_rate_ff(climb_rate_cms, G_Dt, false);
+    pos_control->update_z_controller();
 }
 
 // helper function to update position controller's desired velocity while respecting acceleration limits
 void Copter::guided_set_desired_velocity_with_accel_and_fence_limits(const Vector3f& vel_des)
 {
     // get current desired velocity
-    Vector3f curr_vel_des = pos_control.get_desired_velocity();
+    Vector3f curr_vel_des = pos_control->get_desired_velocity();
 
     // exit immediately if already equal
     if (curr_vel_des == vel_des) {
@@ -620,7 +620,7 @@ void Copter::guided_set_desired_velocity_with_accel_and_fence_limits(const Vecto
 
     // limit xy change
     float vel_delta_xy = safe_sqrt(sq(vel_delta.x)+sq(vel_delta.y));
-    float vel_delta_xy_max = G_Dt * pos_control.get_accel_xy();
+    float vel_delta_xy_max = G_Dt * pos_control->get_accel_xy();
     float ratio_xy = 1.0f;
     if (!is_zero(vel_delta_xy) && (vel_delta_xy > vel_delta_xy_max)) {
         ratio_xy = vel_delta_xy_max / vel_delta_xy;
@@ -629,16 +629,16 @@ void Copter::guided_set_desired_velocity_with_accel_and_fence_limits(const Vecto
     curr_vel_des.y += (vel_delta.y * ratio_xy);
 
     // limit z change
-    float vel_delta_z_max = G_Dt * pos_control.get_accel_z();
+    float vel_delta_z_max = G_Dt * pos_control->get_accel_z();
     curr_vel_des.z += constrain_float(vel_delta.z, -vel_delta_z_max, vel_delta_z_max);
 
 #if AC_AVOID_ENABLED
     // limit the velocity to prevent fence violations
-    avoid.adjust_velocity(pos_control.get_pos_xy_kP(), pos_control.get_accel_xy(), curr_vel_des);
+    avoid.adjust_velocity(pos_control->get_pos_xy_kP(), pos_control->get_accel_xy(), curr_vel_des);
 #endif
 
     // update position controller with new target
-    pos_control.set_desired_velocity(curr_vel_des);
+    pos_control->set_desired_velocity(curr_vel_des);
 }
 
 // Guided Limit code
diff --git a/ArduCopter/control_land.cpp b/ArduCopter/control_land.cpp
index 4d5961b..cd48e08 100644
--- a/ArduCopter/control_land.cpp
+++ b/ArduCopter/control_land.cpp
@@ -13,18 +13,18 @@ bool Copter::land_init(bool ignore_checks)
     if (land_with_gps) {
         // set target to stopping point
         Vector3f stopping_point;
-        wp_nav.get_loiter_stopping_point_xy(stopping_point);
-        wp_nav.init_loiter_target(stopping_point);
+        wp_nav->get_loiter_stopping_point_xy(stopping_point);
+        wp_nav->init_loiter_target(stopping_point);
     }
 
     // initialize vertical speeds and leash lengths
-    pos_control.set_speed_z(wp_nav.get_speed_down(), wp_nav.get_speed_up());
-    pos_control.set_accel_z(wp_nav.get_accel_z());
+    pos_control->set_speed_z(wp_nav->get_speed_down(), wp_nav->get_speed_up());
+    pos_control->set_accel_z(wp_nav->get_accel_z());
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target_to_current_alt();
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target_to_current_alt();
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
     
     land_start_time = millis();
@@ -54,17 +54,17 @@ void Copter::land_run()
 void Copter::land_gps_run()
 {
     // if not auto armed or landed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || ap.land_complete || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || ap.land_complete || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
-        wp_nav.init_loiter_target();
+        wp_nav->init_loiter_target();
 
         // disarm when the landing detector says we've landed
         if (ap.land_complete) {
@@ -74,7 +74,7 @@ void Copter::land_gps_run()
     }
     
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
     
     // pause before beginning land descent
     if(land_pause && millis()-land_start_time >= LAND_WITH_DELAY_MS) {
@@ -114,15 +114,15 @@ void Copter::land_nogps_run()
     }
 
     // if not auto armed or landed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || ap.land_complete || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || ap.land_complete || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
 
         // disarm when the landing detector says we've landed
@@ -133,10 +133,10 @@ void Copter::land_nogps_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // call attitude controller
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
 
     // pause before beginning land descent
     if(land_pause && millis()-land_start_time >= LAND_WITH_DELAY_MS) {
@@ -155,7 +155,7 @@ int32_t Copter::land_get_alt_above_ground(void)
     if (rangefinder_alt_ok()) {
         alt_above_ground = rangefinder_state.alt_cm_filt.get();
     } else {
-        bool navigating = pos_control.is_active_xy();
+        bool navigating = pos_control->is_active_xy();
         if (!navigating || !current_loc.get_alt_cm(Location_Class::ALT_FRAME_ABOVE_TERRAIN, alt_above_ground)) {
             alt_above_ground = current_loc.alt;
         }
@@ -165,7 +165,7 @@ int32_t Copter::land_get_alt_above_ground(void)
 
 void Copter::land_run_vertical_control(bool pause_descent)
 {
-    bool navigating = pos_control.is_active_xy();
+    bool navigating = pos_control->is_active_xy();
 
 #if PRECISION_LANDING == ENABLED
     bool doing_precision_landing = !ap.land_repo_active && precland.target_acquired() && navigating;
@@ -184,21 +184,21 @@ void Copter::land_run_vertical_control(bool pause_descent)
         if (g.land_speed_high > 0) {
             max_land_descent_velocity = -g.land_speed_high;
         } else {
-            max_land_descent_velocity = pos_control.get_speed_down();
+            max_land_descent_velocity = pos_control->get_speed_down();
         }
 
         // Don't speed up for landing.
         max_land_descent_velocity = MIN(max_land_descent_velocity, -abs(g.land_speed));
 
         // Compute a vertical velocity demand such that the vehicle approaches LAND_START_ALT. Without the below constraint, this would cause the vehicle to hover at LAND_START_ALT.
-        cmb_rate = AC_AttitudeControl::sqrt_controller(LAND_START_ALT-alt_above_ground, g.p_alt_hold.kP(), pos_control.get_accel_z());
+        cmb_rate = AC_AttitudeControl::sqrt_controller(LAND_START_ALT-alt_above_ground, g.p_alt_hold.kP(), pos_control->get_accel_z());
 
         // Constrain the demanded vertical velocity so that it is between the configured maximum descent speed and the configured minimum descent speed.
         cmb_rate = constrain_float(cmb_rate, max_land_descent_velocity, -abs(g.land_speed));
 
         if (doing_precision_landing && rangefinder_alt_ok() && rangefinder_state.alt_cm > 35.0f && rangefinder_state.alt_cm < 200.0f) {
             float max_descent_speed = abs(g.land_speed)/2.0f;
-            float land_slowdown = MAX(0.0f, pos_control.get_horizontal_error()*(max_descent_speed/precland_acceptable_error));
+            float land_slowdown = MAX(0.0f, pos_control->get_horizontal_error()*(max_descent_speed/precland_acceptable_error));
             cmb_rate = MIN(-precland_min_descent_speed, -max_descent_speed+land_slowdown);
         }
     }
@@ -207,8 +207,8 @@ void Copter::land_run_vertical_control(bool pause_descent)
     desired_climb_rate = cmb_rate;
 
     // update altitude target and call position controller
-    pos_control.set_alt_target_from_climb_rate_ff(cmb_rate, G_Dt, true);
-    pos_control.update_z_controller();
+    pos_control->set_alt_target_from_climb_rate_ff(cmb_rate, G_Dt, true);
+    pos_control->update_z_controller();
 }
 
 void Copter::land_run_horizontal_control()
@@ -218,7 +218,7 @@ void Copter::land_run_horizontal_control()
     
     // relax loiter target if we might be landed
     if (ap.land_complete_maybe) {
-        wp_nav.loiter_soften_for_landing();
+        wp_nav->loiter_soften_for_landing();
     }
     
     // process pilot inputs
@@ -262,19 +262,19 @@ void Copter::land_run_horizontal_control()
             target_vel_rel.x = -inertial_nav.get_velocity().x;
             target_vel_rel.y = -inertial_nav.get_velocity().y;
         }
-        pos_control.set_xy_target(target_pos.x, target_pos.y);
-        pos_control.override_vehicle_velocity_xy(-target_vel_rel);
+        pos_control->set_xy_target(target_pos.x, target_pos.y);
+        pos_control->override_vehicle_velocity_xy(-target_vel_rel);
     }
 #endif
     
     // process roll, pitch inputs
-    wp_nav.set_pilot_desired_acceleration(roll_control, pitch_control);
+    wp_nav->set_pilot_desired_acceleration(roll_control, pitch_control);
 
     // run loiter controller
-    wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+    wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
-    int32_t nav_roll  = wp_nav.get_roll();
-    int32_t nav_pitch = wp_nav.get_pitch();
+    int32_t nav_roll  = wp_nav->get_roll();
+    int32_t nav_pitch = wp_nav->get_pitch();
 
     if (g2.wp_navalt_min > 0) {
         // user has requested an altitude below which navigation
@@ -293,13 +293,13 @@ void Copter::land_run_horizontal_control()
             nav_pitch *= ratio;
 
             // tell position controller we are applying an external limit
-            pos_control.set_limit_accel_xy();
+            pos_control->set_limit_accel_xy();
         }
     }
 
     
     // call attitude controller
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(nav_roll, nav_pitch, target_yaw_rate, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(nav_roll, nav_pitch, target_yaw_rate, get_smoothing_gain());
 }
 
 // land_do_not_use_GPS - forces land-mode to not use the GPS but instead rely on pilot input for roll and pitch
diff --git a/ArduCopter/control_loiter.cpp b/ArduCopter/control_loiter.cpp
index ba115b9..53c0542 100644
--- a/ArduCopter/control_loiter.cpp
+++ b/ArduCopter/control_loiter.cpp
@@ -9,7 +9,7 @@ bool Copter::loiter_init(bool ignore_checks)
 {
 #if FRAME_CONFIG == HELI_FRAME
     // do not allow helis to enter Loiter if the Rotor Runup is not complete
-    if (!ignore_checks && !motors.rotor_runup_complete()){
+    if (!ignore_checks && !motors->rotor_runup_complete()){
         return false;
     }
 #endif
@@ -17,16 +17,16 @@ bool Copter::loiter_init(bool ignore_checks)
     if (position_ok() || ignore_checks) {
 
         // set target to current position
-        wp_nav.init_loiter_target();
+        wp_nav->init_loiter_target();
 
         // initialize vertical speed and acceleration
-        pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-        pos_control.set_accel_z(g.pilot_accel_z);
+        pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+        pos_control->set_accel_z(g.pilot_accel_z);
 
         // initialise position and desired velocity
-        if (!pos_control.is_active_z()) {
-            pos_control.set_alt_target_to_current_alt();
-            pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+        if (!pos_control->is_active_z()) {
+            pos_control->set_alt_target_to_current_alt();
+            pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
         }
 
         return true;
@@ -45,7 +45,7 @@ bool Copter::do_precision_loiter() const
         return false;        // don't move on the ground
     }
     // if the pilot *really* wants to move the vehicle, let them....
-    if (wp_nav.get_pilot_desired_acceleration().length() > 50.0f) {
+    if (wp_nav->get_pilot_desired_acceleration().length() > 50.0f) {
         return false;
     }
     if (!precland.target_acquired()) {
@@ -56,7 +56,7 @@ bool Copter::do_precision_loiter() const
 
 void Copter::precision_loiter_xy()
 {
-    wp_nav.clear_pilot_desired_acceleration();
+    wp_nav->clear_pilot_desired_acceleration();
     Vector2f target_pos, target_vel_rel;
     if (!precland.get_target_position_cm(target_pos)) {
         target_pos.x = inertial_nav.get_position().x;
@@ -66,8 +66,8 @@ void Copter::precision_loiter_xy()
         target_vel_rel.x = -inertial_nav.get_velocity().x;
         target_vel_rel.y = -inertial_nav.get_velocity().y;
     }
-    pos_control.set_xy_target(target_pos.x, target_pos.y);
-    pos_control.override_vehicle_velocity_xy(-target_vel_rel);
+    pos_control->set_xy_target(target_pos.x, target_pos.y);
+    pos_control->override_vehicle_velocity_xy(-target_vel_rel);
 }
 #endif
 
@@ -81,8 +81,8 @@ void Copter::loiter_run()
     float takeoff_climb_rate = 0.0f;
 
     // initialize vertical speed and acceleration
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // process pilot inputs unless we are in radio failsafe
     if (!failsafe.radio) {
@@ -90,7 +90,7 @@ void Copter::loiter_run()
         update_simple_mode();
 
         // process pilot's roll and pitch input
-        wp_nav.set_pilot_desired_acceleration(channel_roll->get_control_in(), channel_pitch->get_control_in());
+        wp_nav->set_pilot_desired_acceleration(channel_roll->get_control_in(), channel_pitch->get_control_in());
 
         // get pilot's desired yaw rate
         target_yaw_rate = get_pilot_desired_yaw_rate(channel_yaw->get_control_in());
@@ -100,23 +100,23 @@ void Copter::loiter_run()
         target_climb_rate = constrain_float(target_climb_rate, -g.pilot_velocity_z_max, g.pilot_velocity_z_max);
     } else {
         // clear out pilot desired acceleration in case radio failsafe event occurs and we do not switch to RTL for some reason
-        wp_nav.clear_pilot_desired_acceleration();
+        wp_nav->clear_pilot_desired_acceleration();
     }
 
     // relax loiter target if we might be landed
     if (ap.land_complete_maybe) {
-        wp_nav.loiter_soften_for_landing();
+        wp_nav->loiter_soften_for_landing();
     }
 
 #if FRAME_CONFIG == HELI_FRAME
     // helicopters are held on the ground until rotor speed runup has finished
-    bool takeoff_triggered = (ap.land_complete && (target_climb_rate > 0.0f) && motors.rotor_runup_complete());
+    bool takeoff_triggered = (ap.land_complete && (target_climb_rate > 0.0f) && motors->rotor_runup_complete());
 #else
     bool takeoff_triggered = ap.land_complete && (target_climb_rate > 0.0f);
 #endif
 
     // Loiter State Machine Determination
-    if (!motors.armed() || !motors.get_interlock()) {
+    if (!motors->armed() || !motors->get_interlock()) {
         loiter_state = Loiter_MotorStopped;
     } else if (takeoff_state.running || takeoff_triggered) {
         loiter_state = Loiter_Takeoff;
@@ -131,24 +131,24 @@ void Copter::loiter_run()
 
     case Loiter_MotorStopped:
 
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
 #if FRAME_CONFIG == HELI_FRAME
         // force descent rate and call position controller
-        pos_control.set_alt_target_from_climb_rate(-abs(g.land_speed), G_Dt, false);
+        pos_control->set_alt_target_from_climb_rate(-abs(g.land_speed), G_Dt, false);
 #else
-        wp_nav.init_loiter_target();
-        attitude_control.reset_rate_controller_I_terms();
-        attitude_control.set_yaw_target_to_current_heading();
-        pos_control.relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
+        wp_nav->init_loiter_target();
+        attitude_control->reset_rate_controller_I_terms();
+        attitude_control->set_yaw_target_to_current_heading();
+        pos_control->relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
 #endif
-        wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
-        pos_control.update_z_controller();
+        wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
+        pos_control->update_z_controller();
         break;
 
     case Loiter_Takeoff:
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
         // initiate take-off
         if (!takeoff_state.running) {
@@ -163,36 +163,36 @@ void Copter::loiter_run()
         takeoff_get_climb_rates(target_climb_rate, takeoff_climb_rate);
 
         // run loiter controller
-        wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+        wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
 
         // update altitude target and call position controller
-        pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-        pos_control.add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+        pos_control->add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
+        pos_control->update_z_controller();
         break;
 
     case Loiter_Landed:
         // set motors to spin-when-armed if throttle below deadzone, otherwise full range (but motors will only spin at min throttle)
         if (target_climb_rate < 0.0f) {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         } else {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
         }
-        wp_nav.init_loiter_target();
-        attitude_control.reset_rate_controller_I_terms();
-        attitude_control.set_yaw_target_to_current_heading();
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        pos_control.relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
-        pos_control.update_z_controller();
+        wp_nav->init_loiter_target();
+        attitude_control->reset_rate_controller_I_terms();
+        attitude_control->set_yaw_target_to_current_heading();
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        pos_control->relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
+        pos_control->update_z_controller();
         break;
 
     case Loiter_Flying:
 
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
 #if PRECISION_LANDING == ENABLED
         if (do_precision_loiter()) {
@@ -201,20 +201,20 @@ void Copter::loiter_run()
 #endif
 
         // run loiter controller
-        wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+        wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
 
         // adjust climb rate using rangefinder
         if (rangefinder_alt_ok()) {
             // if rangefinder is ok, use surface tracking
-            target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control.get_alt_target(), G_Dt);
+            target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
         }
 
         // update altitude target and call position controller
-        pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+        pos_control->update_z_controller();
         break;
     }
 }
diff --git a/ArduCopter/control_poshold.cpp b/ArduCopter/control_poshold.cpp
index 76a0675..bbf986a 100644
--- a/ArduCopter/control_poshold.cpp
+++ b/ArduCopter/control_poshold.cpp
@@ -77,7 +77,7 @@ bool Copter::poshold_init(bool ignore_checks)
 {
 #if FRAME_CONFIG == HELI_FRAME
     // do not allow helis to enter Pos Hold if the Rotor Runup is not complete
-    if (!ignore_checks && !motors.rotor_runup_complete()){
+    if (!ignore_checks && !motors->rotor_runup_complete()){
         return false;
     }
 #endif
@@ -88,13 +88,13 @@ bool Copter::poshold_init(bool ignore_checks)
     }
     
     // initialize vertical speeds and acceleration
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target_to_current_alt();
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target_to_current_alt();
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
     // initialise lean angles to current attitude
@@ -110,7 +110,7 @@ bool Copter::poshold_init(bool ignore_checks)
         poshold.pitch_mode = POSHOLD_LOITER;
         // set target to current position
         // only init here as we can switch to PosHold in flight with a velocity <> 0 that will be used as _last_vel in PosControl and never updated again as we inhibit Reset_I
-        wp_nav.init_loiter_target();
+        wp_nav->init_loiter_target();
     }else{
         // if not landed start in pilot override to avoid hard twitch
         poshold.roll_mode = POSHOLD_PILOT_OVERRIDE;
@@ -144,15 +144,15 @@ void Copter::poshold_run()
     const Vector3f& vel = inertial_nav.get_velocity();
 
     // initialize vertical speeds and acceleration
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
-        wp_nav.init_loiter_target();
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
-        pos_control.relax_alt_hold_controllers(0.0f);
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        wp_nav->init_loiter_target();
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        pos_control->relax_alt_hold_controllers(0.0f);
         return;
     }
 
@@ -174,7 +174,7 @@ void Copter::poshold_run()
         // check for take-off
 #if FRAME_CONFIG == HELI_FRAME
         // helicopters are held on the ground until rotor speed runup has finished
-        if (ap.land_complete && (takeoff_state.running || (target_climb_rate > 0.0f && motors.rotor_runup_complete()))) {
+        if (ap.land_complete && (takeoff_state.running || (target_climb_rate > 0.0f && motors->rotor_runup_complete()))) {
 #else
         if (ap.land_complete && (takeoff_state.running || target_climb_rate > 0.0f)) {
 #endif
@@ -191,23 +191,23 @@ void Copter::poshold_run()
 
     // relax loiter target if we might be landed
     if (ap.land_complete_maybe) {
-        wp_nav.loiter_soften_for_landing();
+        wp_nav->loiter_soften_for_landing();
     }
 
     // if landed initialise loiter targets, set throttle to zero and exit
     if (ap.land_complete) {
         // set motors to spin-when-armed if throttle below deadzone, otherwise full range (but motors will only spin at min throttle)
         if (target_climb_rate < 0.0f) {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         } else {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
         }
-        wp_nav.init_loiter_target();
-        attitude_control.reset_rate_controller_I_terms();
-        attitude_control.set_yaw_target_to_current_heading();
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        pos_control.relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
-        pos_control.update_z_controller();
+        wp_nav->init_loiter_target();
+        attitude_control->reset_rate_controller_I_terms();
+        attitude_control->set_yaw_target_to_current_heading();
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        pos_control->relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
+        pos_control->update_z_controller();
         return;
     }else{
         // convert pilot input to lean angles
@@ -411,7 +411,7 @@ void Copter::poshold_run()
         }
 
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
         //
         // Shared roll & pitch states (POSHOLD_BRAKE_TO_LOITER and POSHOLD_LOITER)
@@ -423,7 +423,7 @@ void Copter::poshold_run()
             poshold.pitch_mode = POSHOLD_BRAKE_TO_LOITER;
             poshold.brake_to_loiter_timer = POSHOLD_BRAKE_TO_LOITER_TIMER;
             // init loiter controller
-            wp_nav.init_loiter_target(inertial_nav.get_position(), poshold.loiter_reset_I); // (false) to avoid I_term reset. In original code, velocity(0,0,0) was used instead of current velocity: wp_nav.init_loiter_target(inertial_nav.get_position(), Vector3f(0,0,0));
+            wp_nav->init_loiter_target(inertial_nav.get_position(), poshold.loiter_reset_I); // (false) to avoid I_term reset. In original code, velocity(0,0,0) was used instead of current velocity: wp_nav->init_loiter_target(inertial_nav.get_position(), Vector3f(0,0,0));
             // at this stage, we are going to run update_loiter that will reset I_term once. From now, we ensure next time that we will enter loiter and update it, I_term won't be reset anymore
             poshold.loiter_reset_I = false;
             // set delay to start of wind compensation estimate updates
@@ -456,11 +456,11 @@ void Copter::poshold_run()
                     poshold_update_brake_angle_from_velocity(poshold.brake_pitch, -vel_fw);
 
                     // run loiter controller
-                    wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+                    wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
                     // calculate final roll and pitch output by mixing loiter and brake controls
-                    poshold.roll = poshold_mix_controls(brake_to_loiter_mix, poshold.brake_roll + poshold.wind_comp_roll, wp_nav.get_roll());
-                    poshold.pitch = poshold_mix_controls(brake_to_loiter_mix, poshold.brake_pitch + poshold.wind_comp_pitch, wp_nav.get_pitch());
+                    poshold.roll = poshold_mix_controls(brake_to_loiter_mix, poshold.brake_roll + poshold.wind_comp_roll, wp_nav->get_roll());
+                    poshold.pitch = poshold_mix_controls(brake_to_loiter_mix, poshold.brake_pitch + poshold.wind_comp_pitch, wp_nav->get_pitch());
 
                     // check for pilot input
                     if (!is_zero(target_roll) || !is_zero(target_pitch)) {
@@ -487,11 +487,11 @@ void Copter::poshold_run()
 
                 case POSHOLD_LOITER:
                     // run loiter controller
-                    wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+                    wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
                     // set roll angle based on loiter controller outputs
-                    poshold.roll = wp_nav.get_roll();
-                    poshold.pitch = wp_nav.get_pitch();
+                    poshold.roll = wp_nav->get_roll();
+                    poshold.pitch = wp_nav->get_pitch();
 
                     // update wind compensation estimate
                     poshold_update_wind_comp_estimate();
@@ -531,17 +531,17 @@ void Copter::poshold_run()
         poshold.pitch = constrain_int16(poshold.pitch, -aparm.angle_max, aparm.angle_max);
 
         // update attitude controller targets
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(poshold.roll, poshold.pitch, target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(poshold.roll, poshold.pitch, target_yaw_rate, get_smoothing_gain());
 
         // adjust climb rate using rangefinder
         if (rangefinder_alt_ok()) {
             // if rangefinder is ok, use surface tracking
-            target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control.get_alt_target(), G_Dt);
+            target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
         }
         // update altitude target and call position controller
-        pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-        pos_control.add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+        pos_control->add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
+        pos_control->update_z_controller();
     }
 }
 
@@ -618,7 +618,7 @@ void Copter::poshold_update_wind_comp_estimate()
 
     // get position controller accel target
     //  To-Do: clean this up by using accessor in loiter controller (or move entire PosHold controller to a library shared with loiter)
-    const Vector3f& accel_target = pos_control.get_accel_target();
+    const Vector3f& accel_target = pos_control->get_accel_target();
 
     // update wind compensation in earth-frame lean angles
     if (is_zero(poshold.wind_comp_ef.x)) {
diff --git a/ArduCopter/control_rtl.cpp b/ArduCopter/control_rtl.cpp
index 6fa7e9e..650b922 100644
--- a/ArduCopter/control_rtl.cpp
+++ b/ArduCopter/control_rtl.cpp
@@ -92,21 +92,21 @@ void Copter::rtl_climb_start()
     rtl_state_complete = false;
 
     // initialise waypoint and spline controller
-    wp_nav.wp_and_spline_init();
+    wp_nav->wp_and_spline_init();
 
     // RTL_SPEED == 0 means use WPNAV_SPEED
     if (g.rtl_speed_cms != 0) {
-        wp_nav.set_speed_xy(g.rtl_speed_cms);
+        wp_nav->set_speed_xy(g.rtl_speed_cms);
     }
 
     // set the destination
-    if (!wp_nav.set_wp_destination(rtl_path.climb_target)) {
+    if (!wp_nav->set_wp_destination(rtl_path.climb_target)) {
         // this should not happen because rtl_build_path will have checked terrain data was available
         Log_Write_Error(ERROR_SUBSYSTEM_NAVIGATION, ERROR_CODE_FAILED_TO_SET_DESTINATION);
         set_mode(LAND, MODE_REASON_TERRAIN_FAILSAFE);
         return;
     }
-    wp_nav.set_fast_waypoint(true);
+    wp_nav->set_fast_waypoint(true);
 
     // hold current yaw during initial climb
     set_auto_yaw_mode(AUTO_YAW_HOLD);
@@ -118,7 +118,7 @@ void Copter::rtl_return_start()
     rtl_state = RTL_ReturnHome;
     rtl_state_complete = false;
 
-    if (!wp_nav.set_wp_destination(rtl_path.return_target)) {
+    if (!wp_nav->set_wp_destination(rtl_path.return_target)) {
         // failure must be caused by missing terrain data, restart RTL
         rtl_restart_without_terrain();
     }
@@ -132,16 +132,16 @@ void Copter::rtl_return_start()
 void Copter::rtl_climb_return_run()
 {
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
         // reset attitude control targets
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         // To-Do: re-initialise wpnav targets
         return;
@@ -158,25 +158,25 @@ void Copter::rtl_climb_return_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run waypoint controller
-    failsafe_terrain_set_status(wp_nav.update_wpnav());
+    failsafe_terrain_set_status(wp_nav->update_wpnav());
 
     // call z-axis position controller (wpnav should have already updated it's alt target)
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // call attitude controller
     if (auto_yaw_mode == AUTO_YAW_HOLD) {
         // roll & pitch from waypoint controller, yaw rate from pilot
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
     }else{
         // roll, pitch from waypoint controller, yaw heading from auto_heading()
-        attitude_control.input_euler_angle_roll_pitch_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), get_auto_heading(),true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), get_auto_heading(),true, get_smoothing_gain());
     }
 
     // check if we've completed this stage of RTL
-    rtl_state_complete = wp_nav.reached_wp_destination();
+    rtl_state_complete = wp_nav->reached_wp_destination();
 }
 
 // rtl_loiterathome_start - initialise return to home
@@ -199,16 +199,16 @@ void Copter::rtl_loiterathome_start()
 void Copter::rtl_loiterathome_run()
 {
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
         // reset attitude control targets
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         // To-Do: re-initialise wpnav targets
         return;
@@ -225,21 +225,21 @@ void Copter::rtl_loiterathome_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // run waypoint controller
-    failsafe_terrain_set_status(wp_nav.update_wpnav());
+    failsafe_terrain_set_status(wp_nav->update_wpnav());
 
     // call z-axis position controller (wpnav should have already updated it's alt target)
-    pos_control.update_z_controller();
+    pos_control->update_z_controller();
 
     // call attitude controller
     if (auto_yaw_mode == AUTO_YAW_HOLD) {
         // roll & pitch from waypoint controller, yaw rate from pilot
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
     }else{
         // roll, pitch from waypoint controller, yaw heading from auto_heading()
-        attitude_control.input_euler_angle_roll_pitch_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), get_auto_heading(),true, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), get_auto_heading(),true, get_smoothing_gain());
     }
 
     // check if we've completed this stage of RTL
@@ -263,10 +263,10 @@ void Copter::rtl_descent_start()
     rtl_state_complete = false;
 
     // Set wp navigation target to above home
-    wp_nav.init_loiter_target(wp_nav.get_wp_destination());
+    wp_nav->init_loiter_target(wp_nav->get_wp_destination());
 
     // initialise altitude target to stopping point
-    pos_control.set_target_to_stopping_point_z();
+    pos_control->set_target_to_stopping_point_z();
 
     // initialise yaw
     set_auto_yaw_mode(AUTO_YAW_HOLD);
@@ -280,18 +280,18 @@ void Copter::rtl_descent_run()
     float target_yaw_rate = 0;
 
     // if not auto armed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         // set target to current position
-        wp_nav.init_loiter_target();
+        wp_nav->init_loiter_target();
         return;
     }
 
@@ -319,20 +319,20 @@ void Copter::rtl_descent_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // process roll, pitch inputs
-    wp_nav.set_pilot_desired_acceleration(roll_control, pitch_control);
+    wp_nav->set_pilot_desired_acceleration(roll_control, pitch_control);
 
     // run loiter controller
-    wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+    wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
     // call z-axis position controller
-    pos_control.set_alt_target_with_slew(rtl_path.descent_target.alt, G_Dt);
-    pos_control.update_z_controller();
+    pos_control->set_alt_target_with_slew(rtl_path.descent_target.alt, G_Dt);
+    pos_control->update_z_controller();
 
     // roll & pitch from waypoint controller, yaw rate from pilot
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), target_yaw_rate, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
 
     // check if we've reached within 20cm of final altitude
     rtl_state_complete = fabsf(rtl_path.descent_target.alt - current_loc.alt) < 20.0f;
@@ -345,12 +345,12 @@ void Copter::rtl_land_start()
     rtl_state_complete = false;
 
     // Set wp navigation target to above home
-    wp_nav.init_loiter_target(wp_nav.get_wp_destination());
+    wp_nav->init_loiter_target(wp_nav->get_wp_destination());
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target_to_current_alt();
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target_to_current_alt();
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
     // initialise yaw
@@ -362,18 +362,18 @@ void Copter::rtl_land_start()
 void Copter::rtl_land_run()
 {
     // if not auto armed or landing completed or motor interlock not enabled set throttle to zero and exit immediately
-    if (!motors.armed() || !ap.auto_armed || ap.land_complete || !motors.get_interlock()) {
+    if (!motors->armed() || !ap.auto_armed || ap.land_complete || !motors->get_interlock()) {
 #if FRAME_CONFIG == HELI_FRAME  // Helicopters always stabilize roll/pitch/yaw
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
-        attitude_control.set_throttle_out(0,false,g.throttle_filt);
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0, 0, 0, get_smoothing_gain());
+        attitude_control->set_throttle_out(0,false,g.throttle_filt);
 #else
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         // multicopters do not stabilize roll/pitch/yaw when disarmed
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 #endif
         // set target to current position
-        wp_nav.init_loiter_target();
+        wp_nav->init_loiter_target();
 
         // disarm when the landing detector says we've landed
         if (ap.land_complete) {
@@ -386,7 +386,7 @@ void Copter::rtl_land_run()
     }
 
     // set motors to full range
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     land_run_horizontal_control();
     land_run_vertical_control();
@@ -399,8 +399,8 @@ void Copter::rtl_build_path(bool terrain_following_allowed)
 {
     // origin point is our stopping point
     Vector3f stopping_point;
-    pos_control.get_stopping_point_xy(stopping_point);
-    pos_control.get_stopping_point_z(stopping_point);
+    pos_control->get_stopping_point_xy(stopping_point);
+    pos_control->get_stopping_point_z(stopping_point);
     rtl_path.origin_point = Location_Class(stopping_point);
     rtl_path.origin_point.change_alt_frame(Location_Class::ALT_FRAME_ABOVE_HOME);
 
diff --git a/ArduCopter/control_sport.cpp b/ArduCopter/control_sport.cpp
index 7bd5c8e..3c56b8c 100644
--- a/ArduCopter/control_sport.cpp
+++ b/ArduCopter/control_sport.cpp
@@ -8,13 +8,13 @@
 bool Copter::sport_init(bool ignore_checks)
 {
     // initialize vertical speed and acceleration
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // initialise position and desired velocity
-    if (!pos_control.is_active_z()) {
-        pos_control.set_alt_target_to_current_alt();
-        pos_control.set_desired_velocity_z(inertial_nav.get_velocity_z());
+    if (!pos_control->is_active_z()) {
+        pos_control->set_alt_target_to_current_alt();
+        pos_control->set_desired_velocity_z(inertial_nav.get_velocity_z());
     }
 
     return true;
@@ -28,8 +28,8 @@ void Copter::sport_run()
     float takeoff_climb_rate = 0.0f;
 
     // initialize vertical speed and acceleration
-    pos_control.set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
-    pos_control.set_accel_z(g.pilot_accel_z);
+    pos_control->set_speed_z(-g.pilot_velocity_z_max, g.pilot_velocity_z_max);
+    pos_control->set_accel_z(g.pilot_accel_z);
 
     // apply SIMPLE mode transform
     update_simple_mode();
@@ -68,13 +68,13 @@ void Copter::sport_run()
 
 #if FRAME_CONFIG == HELI_FRAME
     // helicopters are held on the ground until rotor speed runup has finished
-    bool takeoff_triggered = (ap.land_complete && (target_climb_rate > 0.0f) && motors.rotor_runup_complete());
+    bool takeoff_triggered = (ap.land_complete && (target_climb_rate > 0.0f) && motors->rotor_runup_complete());
 #else
     bool takeoff_triggered = ap.land_complete && (target_climb_rate > 0.0f);
 #endif
 
     // State Machine Determination
-    if (!motors.armed() || !motors.get_interlock()) {
+    if (!motors->armed() || !motors->get_interlock()) {
         sport_state = Sport_MotorStopped;
     } else if (takeoff_state.running || takeoff_triggered) {
         sport_state = Sport_Takeoff;
@@ -89,23 +89,23 @@ void Copter::sport_run()
 
     case Sport_MotorStopped:
 
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
-        attitude_control.input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
+        attitude_control->input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
 #if FRAME_CONFIG == HELI_FRAME
         // force descent rate and call position controller
-        pos_control.set_alt_target_from_climb_rate(-abs(g.land_speed), G_Dt, false);
+        pos_control->set_alt_target_from_climb_rate(-abs(g.land_speed), G_Dt, false);
 #else
-        attitude_control.relax_attitude_controllers();
-        attitude_control.reset_rate_controller_I_terms();
-        attitude_control.set_yaw_target_to_current_heading();
-        pos_control.relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
+        attitude_control->relax_attitude_controllers();
+        attitude_control->reset_rate_controller_I_terms();
+        attitude_control->set_yaw_target_to_current_heading();
+        pos_control->relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
 #endif
-        pos_control.update_z_controller();
+        pos_control->update_z_controller();
         break;
 
     case Sport_Takeoff:
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
         // initiate take-off
         if (!takeoff_state.running) {
@@ -120,43 +120,43 @@ void Copter::sport_run()
         takeoff_get_climb_rates(target_climb_rate, takeoff_climb_rate);
 
         // call attitude controller
-        attitude_control.input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
+        attitude_control->input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
 
         // call position controller
-        pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-        pos_control.add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+        pos_control->add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
+        pos_control->update_z_controller();
         break;
 
     case Sport_Landed:
         // set motors to spin-when-armed if throttle below deadzone, otherwise full range (but motors will only spin at min throttle)
         if (target_climb_rate < 0.0f) {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         } else {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
         }
 
-        attitude_control.reset_rate_controller_I_terms();
-        attitude_control.set_yaw_target_to_current_heading();
-        attitude_control.input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
-        pos_control.relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
-        pos_control.update_z_controller();
+        attitude_control->reset_rate_controller_I_terms();
+        attitude_control->set_yaw_target_to_current_heading();
+        attitude_control->input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
+        pos_control->relax_alt_hold_controllers(0.0f);   // forces throttle output to go to zero
+        pos_control->update_z_controller();
         break;
 
     case Sport_Flying:
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
         // call attitude controller
-        attitude_control.input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
+        attitude_control->input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
 
         // adjust climb rate using rangefinder
         if (rangefinder_alt_ok()) {
             // if rangefinder is ok, use surface tracking
-            target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control.get_alt_target(), G_Dt);
+            target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
         }
 
         // call position controller
-        pos_control.set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+        pos_control->update_z_controller();
         break;
     }
 }
diff --git a/ArduCopter/control_stabilize.cpp b/ArduCopter/control_stabilize.cpp
index 7e9ea86..a2e5f3f 100644
--- a/ArduCopter/control_stabilize.cpp
+++ b/ArduCopter/control_stabilize.cpp
@@ -8,12 +8,12 @@
 bool Copter::stabilize_init(bool ignore_checks)
 {
     // if landed and the mode we're switching from does not have manual throttle and the throttle stick is too high
-    if (motors.armed() && ap.land_complete && !mode_has_manual_throttle(control_mode) &&
+    if (motors->armed() && ap.land_complete && !mode_has_manual_throttle(control_mode) &&
             (get_pilot_desired_throttle(channel_throttle->get_control_in()) > get_non_takeoff_throttle())) {
         return false;
     }
     // set target altitude to zero for reporting
-    pos_control.set_alt_target(0);
+    pos_control->set_alt_target(0);
 
     return true;
 }
@@ -27,16 +27,16 @@ void Copter::stabilize_run()
     float pilot_throttle_scaled;
 
     // if not armed set throttle to zero and exit immediately
-    if (!motors.armed() || ap.throttle_zero || !motors.get_interlock()) {
-        motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+    if (!motors->armed() || ap.throttle_zero || !motors->get_interlock()) {
+        motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
         return;
     }
 
     // clear landing flag
     set_land_complete(false);
 
-    motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+    motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
     // apply SIMPLE mode transform to pilot inputs
     update_simple_mode();
@@ -52,10 +52,10 @@ void Copter::stabilize_run()
     pilot_throttle_scaled = get_pilot_desired_throttle(channel_throttle->get_control_in());
 
     // call attitude controller
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
 
     // body-frame rate controller is run directly from 100hz loop
 
     // output pilot's throttle
-    attitude_control.set_throttle_out(pilot_throttle_scaled, true, g.throttle_filt);
+    attitude_control->set_throttle_out(pilot_throttle_scaled, true, g.throttle_filt);
 }
diff --git a/ArduCopter/control_throw.cpp b/ArduCopter/control_throw.cpp
index ed48ffa..f9cf4da 100644
--- a/ArduCopter/control_throw.cpp
+++ b/ArduCopter/control_throw.cpp
@@ -10,7 +10,7 @@ bool Copter::throw_init(bool ignore_checks)
 #endif
 
     // do not enter the mode when already armed or when flying
-    if (motors.armed()) {
+    if (motors->armed()) {
         return false;
     }
 
@@ -34,11 +34,11 @@ void Copter::throw_run()
     */
 
     // Don't enter THROW mode if interlock will prevent motors running
-    if (!motors.armed() && motors.get_interlock()) {
+    if (!motors->armed() && motors->get_interlock()) {
         // state machine entry is always from a disarmed state
         throw_state.stage = Throw_Disarmed;
 
-    } else if (throw_state.stage == Throw_Disarmed && motors.armed()) {
+    } else if (throw_state.stage == Throw_Disarmed && motors->armed()) {
         gcs_send_text(MAV_SEVERITY_INFO,"waiting for throw");
         throw_state.stage = Throw_Detecting;
 
@@ -55,20 +55,20 @@ void Copter::throw_run()
 
         // initialize vertical speed and acceleration limits
         // use brake mode values for rapid response
-        pos_control.set_speed_z(BRAKE_MODE_SPEED_Z, BRAKE_MODE_SPEED_Z);
-        pos_control.set_accel_z(BRAKE_MODE_DECEL_RATE);
+        pos_control->set_speed_z(BRAKE_MODE_SPEED_Z, BRAKE_MODE_SPEED_Z);
+        pos_control->set_accel_z(BRAKE_MODE_DECEL_RATE);
 
         // initialise the demanded height to 3m above the throw height
         // we want to rapidly clear surrounding obstacles
         if (g2.throw_type == ThrowType_Drop) {
-            pos_control.set_alt_target(inertial_nav.get_altitude() - 100);
+            pos_control->set_alt_target(inertial_nav.get_altitude() - 100);
         } else {
-            pos_control.set_alt_target(inertial_nav.get_altitude() + 300);
+            pos_control->set_alt_target(inertial_nav.get_altitude() + 300);
         }
 
         // set the initial velocity of the height controller demand to the measured velocity if it is going up
         // if it is going down, set it to zero to enforce a very hard stop
-        pos_control.set_desired_velocity_z(fmaxf(inertial_nav.get_velocity_z(),0.0f));
+        pos_control->set_desired_velocity_z(fmaxf(inertial_nav.get_velocity_z(),0.0f));
 
         // Set the auto_arm status to true to avoid a possible automatic disarm caused by selection of an auto mode with throttle at minimum
         set_auto_armed(true);
@@ -78,7 +78,7 @@ void Copter::throw_run()
         throw_state.stage = Throw_PosHold;
 
         // initialise the loiter target to the curent position and velocity
-        wp_nav.init_loiter_target();
+        wp_nav->init_loiter_target();
 
         // Set the auto_arm status to true to avoid a possible automatic disarm caused by selection of an auto mode with throttle at minimum
         set_auto_armed(true);
@@ -107,26 +107,26 @@ void Copter::throw_run()
 
         // prevent motors from rotating before the throw is detected unless enabled by the user
         if (g.throw_motor_start == 1) {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         } else {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
         }
 
         // demand zero throttle (motors will be stopped anyway) and continually reset the attitude controller
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
         break;
 
     case Throw_Detecting:
 
         // prevent motors from rotating before the throw is detected unless enabled by the user
         if (g.throw_motor_start == 1) {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SPIN_WHEN_ARMED);
         } else {
-            motors.set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
+            motors->set_desired_spool_state(AP_Motors::DESIRED_SHUT_DOWN);
         }
 
         // Hold throttle at zero during the throw and continually reset the attitude controller
-        attitude_control.set_throttle_out_unstabilized(0,true,g.throttle_filt);
+        attitude_control->set_throttle_out_unstabilized(0,true,g.throttle_filt);
 
         // Play the waiting for throw tone sequence to alert the user
         AP_Notify::flags.waiting_for_throw = true;
@@ -136,44 +136,44 @@ void Copter::throw_run()
     case Throw_Uprighting:
 
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
         // demand a level roll/pitch attitude with zero yaw rate
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f, get_smoothing_gain());
 
         // output 50% throttle and turn off angle boost to maximise righting moment
-        attitude_control.set_throttle_out(0.5f, false, g.throttle_filt);
+        attitude_control->set_throttle_out(0.5f, false, g.throttle_filt);
 
         break;
 
     case Throw_HgtStabilise:
 
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(0.0f, 0.0f, 0.0f, get_smoothing_gain());
 
         // call height controller
-        pos_control.set_alt_target_from_climb_rate_ff(0.0f, G_Dt, false);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(0.0f, G_Dt, false);
+        pos_control->update_z_controller();
 
         break;
 
     case Throw_PosHold:
 
         // set motors to full range
-        motors.set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
+        motors->set_desired_spool_state(AP_Motors::DESIRED_THROTTLE_UNLIMITED);
 
         // run loiter controller
-        wp_nav.update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
+        wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
         // call attitude controller
-        attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav.get_roll(), wp_nav.get_pitch(), 0.0f, get_smoothing_gain());
+        attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), 0.0f, get_smoothing_gain());
 
         // call height controller
-        pos_control.set_alt_target_from_climb_rate_ff(0.0f, G_Dt, false);
-        pos_control.update_z_controller();
+        pos_control->set_alt_target_from_climb_rate_ff(0.0f, G_Dt, false);
+        pos_control->update_z_controller();
 
         break;
     }
@@ -258,11 +258,11 @@ bool Copter::throw_attitude_good()
 bool Copter::throw_height_good()
 {
     // Check that we are no more than 0.5m below the demanded height
-    return (pos_control.get_alt_error() < 50.0f);
+    return (pos_control->get_alt_error() < 50.0f);
 }
 
 bool Copter::throw_position_good()
 {
     // check that our horizontal position error is within 50cm
-    return (pos_control.get_horizontal_error() < 50.0f);
+    return (pos_control->get_horizontal_error() < 50.0f);
 }
diff --git a/ArduCopter/crash_check.cpp b/ArduCopter/crash_check.cpp
index 0ff358d..6f706f2 100644
--- a/ArduCopter/crash_check.cpp
+++ b/ArduCopter/crash_check.cpp
@@ -13,7 +13,7 @@ void Copter::crash_check()
     static uint16_t crash_counter;  // number of iterations vehicle may have been crashed
 
     // return immediately if disarmed, or crash checking disabled
-    if (!motors.armed() || ap.land_complete || g.fs_crash_check == 0) {
+    if (!motors->armed() || ap.land_complete || g.fs_crash_check == 0) {
         crash_counter = 0;
         return;
     }
@@ -31,7 +31,7 @@ void Copter::crash_check()
     }
 
     // check for angle error over 30 degrees
-    const float angle_error = attitude_control.get_att_error_angle_deg();
+    const float angle_error = attitude_control->get_att_error_angle_deg();
     if (angle_error <= CRASH_CHECK_ANGLE_DEVIATION_DEG) {
         crash_counter = 0;
         return;
@@ -74,7 +74,7 @@ void Copter::parachute_check()
     parachute.update();
 
     // return immediately if motors are not armed or pilot's throttle is above zero
-    if (!motors.armed()) {
+    if (!motors->armed()) {
         control_loss_count = 0;
         return;
     }
@@ -97,7 +97,7 @@ void Copter::parachute_check()
     }
 
     // check for angle error over 30 degrees
-    const float angle_error = attitude_control.get_att_error_angle_deg();
+    const float angle_error = attitude_control->get_att_error_angle_deg();
     if (angle_error <= CRASH_CHECK_ANGLE_DEVIATION_DEG) {
         if (control_loss_count > 0) {
             control_loss_count--;
diff --git a/ArduCopter/ekf_check.cpp b/ArduCopter/ekf_check.cpp
index 5a20710..ece5534 100644
--- a/ArduCopter/ekf_check.cpp
+++ b/ArduCopter/ekf_check.cpp
@@ -35,7 +35,7 @@ void Copter::ekf_check()
     }
 
     // return immediately if motors are not armed, ekf check is disabled, not using ekf or usb is connected
-    if (!motors.armed() || ap.usb_connected || (g.fs_ekf_thresh <= 0.0f)) {
+    if (!motors->armed() || ap.usb_connected || (g.fs_ekf_thresh <= 0.0f)) {
         ekf_check_state.fail_count = 0;
         ekf_check_state.bad_variance = false;
         AP_Notify::flags.ekf_bad = ekf_check_state.bad_variance;
@@ -122,7 +122,7 @@ void Copter::failsafe_ekf_event()
     }
 
     // do nothing if motors disarmed
-    if (!motors.armed()) {
+    if (!motors->armed()) {
         return;
     }
 
@@ -174,7 +174,7 @@ void Copter::check_ekf_reset()
     float yaw_angle_change_rad = 0.0f;
     uint32_t new_ekfYawReset_ms = ahrs.getLastYawResetAngle(yaw_angle_change_rad);
     if (new_ekfYawReset_ms != ekfYawReset_ms) {
-        attitude_control.shift_ef_yaw_target(ToDeg(yaw_angle_change_rad) * 100.0f);
+        attitude_control->shift_ef_yaw_target(ToDeg(yaw_angle_change_rad) * 100.0f);
         ekfYawReset_ms = new_ekfYawReset_ms;
         Log_Write_Event(DATA_EKF_YAW_RESET);
     }
diff --git a/ArduCopter/esc_calibration.cpp b/ArduCopter/esc_calibration.cpp
index dc083c7..521abdf 100644
--- a/ArduCopter/esc_calibration.cpp
+++ b/ArduCopter/esc_calibration.cpp
@@ -79,20 +79,20 @@ void Copter::esc_calibration_passthrough()
     // clear esc flag for next time
     g.esc_calibrate.set_and_save(ESCCAL_NONE);
 
-    if (motors.get_pwm_type() >= AP_Motors::PWM_TYPE_ONESHOT) {
+    if (motors->get_pwm_type() >= AP_Motors::PWM_TYPE_ONESHOT) {
         // run at full speed for oneshot ESCs (actually done on push)
-        motors.set_update_rate(g.rc_speed);
+        motors->set_update_rate(g.rc_speed);
     } else {
         // reduce update rate to motors to 50Hz
-        motors.set_update_rate(50);
+        motors->set_update_rate(50);
     }
 
     // send message to GCS
     gcs_send_text(MAV_SEVERITY_INFO,"ESC calibration: Passing pilot throttle to ESCs");
 
     // arm motors
-    motors.armed(true);
-    motors.enable();
+    motors->armed(true);
+    motors->enable();
     
     while(1) {
         // flash LEDS
@@ -106,7 +106,7 @@ void Copter::esc_calibration_passthrough()
         delay(3);
 
         // pass through to motors
-        motors.set_throttle_passthrough_for_esc_calibration(channel_throttle->get_control_in() / 1000.0f);
+        motors->set_throttle_passthrough_for_esc_calibration(channel_throttle->get_control_in() / 1000.0f);
     }
 #endif  // FRAME_CONFIG != HELI_FRAME
 }
@@ -117,20 +117,20 @@ void Copter::esc_calibration_auto()
 #if FRAME_CONFIG != HELI_FRAME
     bool printed_msg = false;
 
-    if (motors.get_pwm_type() >= AP_Motors::PWM_TYPE_ONESHOT) {
+    if (motors->get_pwm_type() >= AP_Motors::PWM_TYPE_ONESHOT) {
         // run at full speed for oneshot ESCs (actually done on push)
-        motors.set_update_rate(g.rc_speed);
+        motors->set_update_rate(g.rc_speed);
     } else {
         // reduce update rate to motors to 50Hz
-        motors.set_update_rate(50);
+        motors->set_update_rate(50);
     }
 
     // send message to GCS
     gcs_send_text(MAV_SEVERITY_INFO,"ESC calibration: Auto calibration");
 
     // arm and enable motors
-    motors.armed(true);
-    motors.enable();
+    motors->armed(true);
+    motors->enable();
 
     // flash LEDS
     AP_Notify::flags.esc_calibration = true;
@@ -144,19 +144,19 @@ void Copter::esc_calibration_auto()
             gcs_send_text(MAV_SEVERITY_INFO,"ESC calibration: Push safety switch");
             printed_msg = true;
         }
-        motors.set_throttle_passthrough_for_esc_calibration(1.0f);
+        motors->set_throttle_passthrough_for_esc_calibration(1.0f);
         delay(3);
     }
 
     // delay for 5 seconds while outputting pulses
     uint32_t tstart = millis();
     while (millis() - tstart < 5000) {
-        motors.set_throttle_passthrough_for_esc_calibration(1.0f);
+        motors->set_throttle_passthrough_for_esc_calibration(1.0f);
         delay(3);
     }
 
     // reduce throttle to minimum
-    motors.set_throttle_passthrough_for_esc_calibration(0.0f);
+    motors->set_throttle_passthrough_for_esc_calibration(0.0f);
 
     // clear esc parameter
     g.esc_calibrate.set_and_save(ESCCAL_NONE);
@@ -164,7 +164,7 @@ void Copter::esc_calibration_auto()
     // block until we restart
     while(1) {
         delay(3);
-        motors.set_throttle_passthrough_for_esc_calibration(0.0f);
+        motors->set_throttle_passthrough_for_esc_calibration(0.0f);
     }
 #endif // FRAME_CONFIG != HELI_FRAME
 }
diff --git a/ArduCopter/events.cpp b/ArduCopter/events.cpp
index 2a713e6..36b78cd 100644
--- a/ArduCopter/events.cpp
+++ b/ArduCopter/events.cpp
@@ -7,7 +7,7 @@
 void Copter::failsafe_radio_on_event()
 {
     // if motors are not armed there is nothing to do
-    if( !motors.armed() ) {
+    if( !motors->armed() ) {
         return;
     }
 
@@ -50,7 +50,7 @@ void Copter::failsafe_battery_event(void)
     }
 
     // failsafe check
-    if (g.failsafe_battery_enabled != FS_BATT_DISABLED && motors.armed()) {
+    if (g.failsafe_battery_enabled != FS_BATT_DISABLED && motors->armed()) {
         if (should_disarm_on_failsafe()) {
             init_disarm_motors();
         } else {
@@ -97,7 +97,7 @@ void Copter::failsafe_gcs_check()
     }
 
     // do nothing if gcs failsafe already triggered or motors disarmed
-    if (failsafe.gcs || !motors.armed()) {
+    if (failsafe.gcs || !motors->armed()) {
         return;
     }
 
diff --git a/ArduCopter/failsafe.cpp b/ArduCopter/failsafe.cpp
index 09b5623..15c09e3 100644
--- a/ArduCopter/failsafe.cpp
+++ b/ArduCopter/failsafe.cpp
@@ -50,11 +50,11 @@ void Copter::failsafe_check()
     if (!in_failsafe && failsafe_enabled && tnow - failsafe_last_timestamp > 2000000) {
         // motors are running but we have gone 2 second since the
         // main loop ran. That means we're in trouble and should
-        // disarm the motors.
+        // disarm the motors->
         in_failsafe = true;
         // reduce motors to minimum (we do not immediately disarm because we want to log the failure)
-        if (motors.armed()) {
-            motors.output_min();
+        if (motors->armed()) {
+            motors->output_min();
         }
         // log an error
         Log_Write_Error(ERROR_SUBSYSTEM_CPU,ERROR_CODE_FAILSAFE_OCCURRED);
@@ -63,9 +63,9 @@ void Copter::failsafe_check()
     if (failsafe_enabled && in_failsafe && tnow - failsafe_last_timestamp > 1000000) {
         // disarm motors every second
         failsafe_last_timestamp = tnow;
-        if(motors.armed()) {
-            motors.armed(false);
-            motors.output();
+        if(motors->armed()) {
+            motors->armed(false);
+            motors->output();
         }
     }
 }
diff --git a/ArduCopter/fence.cpp b/ArduCopter/fence.cpp
index 067912b..3d7b59c 100644
--- a/ArduCopter/fence.cpp
+++ b/ArduCopter/fence.cpp
@@ -18,7 +18,7 @@ void Copter::fence_check()
     new_breaches = fence.check_fence(current_loc.alt/100.0f);
 
     // return immediately if motors are not armed
-    if(!motors.armed()) {
+    if(!motors->armed()) {
         return;
     }
 
diff --git a/ArduCopter/flight_mode.cpp b/ArduCopter/flight_mode.cpp
index 6bdc9fb..69acbf9 100644
--- a/ArduCopter/flight_mode.cpp
+++ b/ArduCopter/flight_mode.cpp
@@ -13,7 +13,7 @@ bool Copter::set_mode(control_mode_t mode, mode_reason_t reason)
 {
     // boolean to record if flight mode could be set
     bool success = false;
-    bool ignore_checks = !motors.armed();   // allow switching to any mode if disarmed.  We rely on the arming check to perform
+    bool ignore_checks = !motors->armed();   // allow switching to any mode if disarmed.  We rely on the arming check to perform
 
     // return immediately if we are already in the desired mode
     if (mode == control_mode) {
@@ -271,7 +271,7 @@ void Copter::exit_mode(control_mode_t old_control_mode, control_mode_t new_contr
     }
 
     // smooth throttle transition when switching from manual to automatic flight modes
-    if (mode_has_manual_throttle(old_control_mode) && !mode_has_manual_throttle(new_control_mode) && motors.armed() && !ap.land_complete) {
+    if (mode_has_manual_throttle(old_control_mode) && !mode_has_manual_throttle(new_control_mode) && motors->armed() && !ap.land_complete) {
         // this assumes all manual flight modes use get_pilot_desired_throttle to translate pilot input to output throttle
         set_accel_throttle_I_from_pilot_throttle();
     }
@@ -282,8 +282,8 @@ void Copter::exit_mode(control_mode_t old_control_mode, control_mode_t new_contr
 #if FRAME_CONFIG == HELI_FRAME
     // firmly reset the flybar passthrough to false when exiting acro mode.
     if (old_control_mode == ACRO) {
-        attitude_control.use_flybar_passthrough(false, false);
-        motors.set_acro_tail(false);
+        attitude_control->use_flybar_passthrough(false, false);
+        motors->set_acro_tail(false);
     }
 
     // if we are changing from a mode that did not use manual throttle,
diff --git a/ArduCopter/heli.cpp b/ArduCopter/heli.cpp
index 06f42af..3e0e70c 100644
--- a/ArduCopter/heli.cpp
+++ b/ArduCopter/heli.cpp
@@ -23,7 +23,7 @@ void Copter::heli_init()
 // should be called at 50hz
 void Copter::check_dynamic_flight(void)
 {
-    if (!motors.armed() || !motors.rotor_runup_complete() ||
+    if (!motors->armed() || !motors->rotor_runup_complete() ||
         control_mode == LAND || (control_mode==RTL && rtl_state == RTL_Land) || (control_mode == AUTO && auto_mode == Auto_Land)) {
         heli_dynamic_flight_counter = 0;
         heli_flags.dynamic_flight = false;
@@ -39,7 +39,7 @@ void Copter::check_dynamic_flight(void)
         moving = (velocity >= HELI_DYNAMIC_FLIGHT_SPEED_MIN);
     }else{
         // with no GPS lock base it on throttle and forward lean angle
-        moving = (motors.get_throttle() > 0.8f || ahrs.pitch_sensor < -1500);
+        moving = (motors->get_throttle() > 0.8f || ahrs.pitch_sensor < -1500);
     }
 
     if (!moving && rangefinder_state.enabled && rangefinder.status() == RangeFinder::RangeFinder_Good) {
@@ -74,9 +74,9 @@ void Copter::check_dynamic_flight(void)
 void Copter::update_heli_control_dynamics(void)
 {
     // Use Leaky_I if we are not moving fast
-    attitude_control.use_leaky_i(!heli_flags.dynamic_flight);
+    attitude_control->use_leaky_i(!heli_flags.dynamic_flight);
 
-    if (ap.land_complete || (is_zero(motors.get_desired_rotor_speed()))){
+    if (ap.land_complete || (is_zero(motors->get_desired_rotor_speed()))){
         // if we are landed or there is no rotor power demanded, decrement slew scalar
         hover_roll_trim_scalar_slew--;        
     } else {
@@ -86,7 +86,7 @@ void Copter::update_heli_control_dynamics(void)
     hover_roll_trim_scalar_slew = constrain_int16(hover_roll_trim_scalar_slew, 0, scheduler.get_loop_rate_hz());
 
     // set hover roll trim scalar, will ramp from 0 to 1 over 1 second after we think helicopter has taken off
-    attitude_control.set_hover_roll_trim_scalar((float)(hover_roll_trim_scalar_slew/scheduler.get_loop_rate_hz()));
+    attitude_control->set_hover_roll_trim_scalar((float)(hover_roll_trim_scalar_slew/scheduler.get_loop_rate_hz()));
 }
 
 // heli_update_landing_swash - sets swash plate flag so higher minimum is used when landed or landing
@@ -99,33 +99,33 @@ void Copter::heli_update_landing_swash()
         case DRIFT:
         case SPORT:
             // manual modes always uses full swash range
-            motors.set_collective_for_landing(false);
+            motors->set_collective_for_landing(false);
             break;
 
         case LAND:
             // landing always uses limit swash range
-            motors.set_collective_for_landing(true);
+            motors->set_collective_for_landing(true);
             break;
 
         case RTL:
             if (rtl_state == RTL_Land) {
-                motors.set_collective_for_landing(true);
+                motors->set_collective_for_landing(true);
             }else{
-                motors.set_collective_for_landing(!heli_flags.dynamic_flight || ap.land_complete || !ap.auto_armed);
+                motors->set_collective_for_landing(!heli_flags.dynamic_flight || ap.land_complete || !ap.auto_armed);
             }
             break;
 
         case AUTO:
             if (auto_mode == Auto_Land) {
-                motors.set_collective_for_landing(true);
+                motors->set_collective_for_landing(true);
             }else{
-                motors.set_collective_for_landing(!heli_flags.dynamic_flight || ap.land_complete || !ap.auto_armed);
+                motors->set_collective_for_landing(!heli_flags.dynamic_flight || ap.land_complete || !ap.auto_armed);
             }
             break;
 
         default:
             // auto and hold use limited swash when landed
-            motors.set_collective_for_landing(!heli_flags.dynamic_flight || ap.land_complete || !ap.auto_armed);
+            motors->set_collective_for_landing(!heli_flags.dynamic_flight || ap.land_complete || !ap.auto_armed);
             break;
     }
 }
@@ -137,7 +137,7 @@ void Copter::heli_update_rotor_speed_targets()
     static bool rotor_runup_complete_last = false;
 
     // get rotor control method
-    uint8_t rsc_control_mode = motors.get_rsc_mode();
+    uint8_t rsc_control_mode = motors->get_rsc_mode();
 
     float rsc_control_deglitched = rotor_speed_deglitch_filter.apply((float)RC_Channels::rc_channel(CH_8)->get_control_in()) * 0.001f;
 
@@ -146,10 +146,10 @@ void Copter::heli_update_rotor_speed_targets()
             // pass through pilot desired rotor speed if control input is higher than 10, creating a deadband at the bottom
             if (rsc_control_deglitched > 0.01f) {
                 ap.motor_interlock_switch = true;
-                motors.set_desired_rotor_speed(rsc_control_deglitched);
+                motors->set_desired_rotor_speed(rsc_control_deglitched);
             } else {
                 ap.motor_interlock_switch = false;
-                motors.set_desired_rotor_speed(0.0f);
+                motors->set_desired_rotor_speed(0.0f);
             }
             break;
         case ROTOR_CONTROL_MODE_SPEED_SETPOINT:
@@ -159,21 +159,21 @@ void Copter::heli_update_rotor_speed_targets()
             // other than being used to create a crude estimate of rotor speed
             if (rsc_control_deglitched > 0.0f) {
                 ap.motor_interlock_switch = true;
-                motors.set_desired_rotor_speed(motors.get_rsc_setpoint());
+                motors->set_desired_rotor_speed(motors->get_rsc_setpoint());
             }else{
                 ap.motor_interlock_switch = false;
-                motors.set_desired_rotor_speed(0.0f);
+                motors->set_desired_rotor_speed(0.0f);
             }
             break;
     }
 
     // when rotor_runup_complete changes to true, log event
-    if (!rotor_runup_complete_last && motors.rotor_runup_complete()){
+    if (!rotor_runup_complete_last && motors->rotor_runup_complete()){
         Log_Write_Event(DATA_ROTOR_RUNUP_COMPLETE);
-    } else if (rotor_runup_complete_last && !motors.rotor_runup_complete()){
+    } else if (rotor_runup_complete_last && !motors->rotor_runup_complete()){
         Log_Write_Event(DATA_ROTOR_SPEED_BELOW_CRITICAL);
     }
-    rotor_runup_complete_last = motors.rotor_runup_complete();
+    rotor_runup_complete_last = motors->rotor_runup_complete();
 }
 
 #endif  // FRAME_CONFIG == HELI_FRAME
diff --git a/ArduCopter/heli_control_acro.cpp b/ArduCopter/heli_control_acro.cpp
index efc97ec..c1037a7 100644
--- a/ArduCopter/heli_control_acro.cpp
+++ b/ArduCopter/heli_control_acro.cpp
@@ -9,9 +9,9 @@
 bool Copter::heli_acro_init(bool ignore_checks)
 {
     // if heli is equipped with a flybar, then tell the attitude controller to pass through controls directly to servos
-    attitude_control.use_flybar_passthrough(motors.has_flybar(), motors.supports_yaw_passthrough());
+    attitude_control->use_flybar_passthrough(motors->has_flybar(), motors->supports_yaw_passthrough());
 
-    motors.set_acro_tail(true);
+    motors->set_acro_tail(true);
     
     // set stab collective false to use full collective pitch range
     input_manager.set_use_stab_col(false);
@@ -33,28 +33,28 @@ void Copter::heli_acro_run()
     // that the servos move in a realistic fashion while disarmed for operational checks.
     // Also, unlike multicopters we do not set throttle (i.e. collective pitch) to zero so the swash servos move
     
-    if(!motors.armed()) {
+    if(!motors->armed()) {
         heli_flags.init_targets_on_arming=true;
-        attitude_control.set_yaw_target_to_current_heading();
+        attitude_control->set_yaw_target_to_current_heading();
     }
     
-    if(motors.armed() && heli_flags.init_targets_on_arming) {
-        attitude_control.set_yaw_target_to_current_heading();
-        if (motors.rotor_speed_above_critical()) {
+    if(motors->armed() && heli_flags.init_targets_on_arming) {
+        attitude_control->set_yaw_target_to_current_heading();
+        if (motors->rotor_speed_above_critical()) {
             heli_flags.init_targets_on_arming=false;
         }
     }   
 
     // clear landing flag above zero throttle
-    if (motors.armed() && motors.get_interlock() && motors.rotor_runup_complete() && !ap.throttle_zero) {
+    if (motors->armed() && motors->get_interlock() && motors->rotor_runup_complete() && !ap.throttle_zero) {
         set_land_complete(false);
     }
 
-    if (!motors.has_flybar()){
+    if (!motors->has_flybar()){
         // convert the input to the desired body frame rate
         get_pilot_desired_angle_rates(channel_roll->get_control_in(), channel_pitch->get_control_in(), channel_yaw->get_control_in(), target_roll, target_pitch, target_yaw);
 
-        if (motors.supports_yaw_passthrough()) {
+        if (motors->supports_yaw_passthrough()) {
             // if the tail on a flybar heli has an external gyro then
             // also use no deadzone for the yaw control and
             // pass-through the input direct to output.
@@ -62,7 +62,7 @@ void Copter::heli_acro_run()
         }
 
         // run attitude controller
-        attitude_control.input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw);
+        attitude_control->input_rate_bf_roll_pitch_yaw(target_roll, target_pitch, target_yaw);
     }else{
         /*
           for fly-bar passthrough use control_in values with no
@@ -72,7 +72,7 @@ void Copter::heli_acro_run()
         float pitch_in = channel_pitch->get_control_in_zero_dz();
         float yaw_in;
         
-        if (motors.supports_yaw_passthrough()) {
+        if (motors->supports_yaw_passthrough()) {
             // if the tail on a flybar heli has an external gyro then
             // also use no deadzone for the yaw control and
             // pass-through the input direct to output.
@@ -85,14 +85,14 @@ void Copter::heli_acro_run()
         }
 
         // run attitude controller
-        attitude_control.passthrough_bf_roll_pitch_rate_yaw(roll_in, pitch_in, yaw_in);
+        attitude_control->passthrough_bf_roll_pitch_rate_yaw(roll_in, pitch_in, yaw_in);
     }
 
     // get pilot's desired throttle
     pilot_throttle_scaled = input_manager.get_pilot_desired_collective(channel_throttle->get_control_in());
 
     // output pilot's throttle without angle boost
-    attitude_control.set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt);
+    attitude_control->set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt);
 }
 
 #endif  //HELI_FRAME
diff --git a/ArduCopter/heli_control_stabilize.cpp b/ArduCopter/heli_control_stabilize.cpp
index f1f1aad..f225c1c 100644
--- a/ArduCopter/heli_control_stabilize.cpp
+++ b/ArduCopter/heli_control_stabilize.cpp
@@ -10,7 +10,7 @@ bool Copter::heli_stabilize_init(bool ignore_checks)
 {
     // set target altitude to zero for reporting
     // To-Do: make pos controller aware when it's active/inactive so it can always report the altitude error?
-    pos_control.set_alt_target(0);
+    pos_control->set_alt_target(0);
 
     // set stab collective true to use stabilize scaled collective pitch range
     input_manager.set_use_stab_col(true);
@@ -32,20 +32,20 @@ void Copter::heli_stabilize_run()
     // that the servos move in a realistic fashion while disarmed for operational checks.
     // Also, unlike multicopters we do not set throttle (i.e. collective pitch) to zero so the swash servos move
     
-    if(!motors.armed()) {
+    if(!motors->armed()) {
         heli_flags.init_targets_on_arming=true;
-        attitude_control.set_yaw_target_to_current_heading();
+        attitude_control->set_yaw_target_to_current_heading();
     }
     
-    if(motors.armed() && heli_flags.init_targets_on_arming) {
-        attitude_control.set_yaw_target_to_current_heading();
-        if (motors.rotor_speed_above_critical()) {
+    if(motors->armed() && heli_flags.init_targets_on_arming) {
+        attitude_control->set_yaw_target_to_current_heading();
+        if (motors->rotor_speed_above_critical()) {
             heli_flags.init_targets_on_arming=false;
         }
     }
 
     // clear landing flag above zero throttle
-    if (motors.armed() && motors.get_interlock() && motors.rotor_runup_complete() && !ap.throttle_zero) {
+    if (motors->armed() && motors->get_interlock() && motors->rotor_runup_complete() && !ap.throttle_zero) {
         set_land_complete(false);
     }
 
@@ -63,10 +63,10 @@ void Copter::heli_stabilize_run()
     pilot_throttle_scaled = input_manager.get_pilot_desired_collective(channel_throttle->get_control_in());
 
     // call attitude controller
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
 
     // output pilot's throttle - note that TradHeli does not used angle-boost
-    attitude_control.set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt);
+    attitude_control->set_throttle_out(pilot_throttle_scaled, false, g.throttle_filt);
 }
 
 #endif  //HELI_FRAME
diff --git a/ArduCopter/land_detector.cpp b/ArduCopter/land_detector.cpp
index 7c116b3..d13edc4 100644
--- a/ArduCopter/land_detector.cpp
+++ b/ArduCopter/land_detector.cpp
@@ -40,16 +40,16 @@ void Copter::update_land_detector()
     // range finder :                       tend to be problematic at very short distances
     // input throttle :                     in slow land the input throttle may be only slightly less than hover
 
-    if (!motors.armed()) {
+    if (!motors->armed()) {
         // if disarmed, always landed.
         set_land_complete(true);
     } else if (ap.land_complete) {
 #if FRAME_CONFIG == HELI_FRAME
         // if rotor speed and collective pitch are high then clear landing flag
-        if (motors.get_throttle() > get_non_takeoff_throttle() && !motors.limit.throttle_lower && motors.rotor_runup_complete()) {
+        if (motors->get_throttle() > get_non_takeoff_throttle() && !motors->limit.throttle_lower && motors->rotor_runup_complete()) {
 #else
         // if throttle output is high then clear landing flag
-        if (motors.get_throttle() > get_non_takeoff_throttle()) {
+        if (motors->get_throttle() > get_non_takeoff_throttle()) {
 #endif
             set_land_complete(false);
         }
@@ -57,10 +57,10 @@ void Copter::update_land_detector()
 
 #if FRAME_CONFIG == HELI_FRAME
         // check that collective pitch is on lower limit (should be constrained by LAND_COL_MIN)
-        bool motor_at_lower_limit = motors.limit.throttle_lower;
+        bool motor_at_lower_limit = motors->limit.throttle_lower;
 #else
         // check that the average throttle output is near minimum (less than 12.5% hover throttle)
-        bool motor_at_lower_limit = motors.limit.throttle_lower && attitude_control.is_throttle_mix_min();
+        bool motor_at_lower_limit = motors->limit.throttle_lower && attitude_control->is_throttle_mix_min();
 #endif
 
         // check that the airframe is not accelerating (not falling or breaking after fast forward flight)
@@ -110,7 +110,7 @@ void Copter::set_land_complete(bool b)
     bool disarm_on_land_configured = (g.throttle_behavior & THR_BEHAVE_DISARM_ON_LAND_DETECT) != 0;
     bool mode_disarms_on_land = mode_allows_arming(control_mode,false) && !mode_has_manual_throttle(control_mode);
 
-    if (ap.land_complete && motors.armed() && disarm_on_land_configured && mode_disarms_on_land) {
+    if (ap.land_complete && motors->armed() && disarm_on_land_configured && mode_disarms_on_land) {
         init_disarm_motors();
     }
 }
@@ -135,27 +135,27 @@ void Copter::update_throttle_thr_mix()
 {
 #if FRAME_CONFIG != HELI_FRAME
     // if disarmed or landed prioritise throttle
-    if(!motors.armed() || ap.land_complete) {
-        attitude_control.set_throttle_mix_min();
+    if(!motors->armed() || ap.land_complete) {
+        attitude_control->set_throttle_mix_min();
         return;
     }
 
     if (mode_has_manual_throttle(control_mode)) {
         // manual throttle
         if(channel_throttle->get_control_in() <= 0) {
-            attitude_control.set_throttle_mix_min();
+            attitude_control->set_throttle_mix_min();
         } else {
-            attitude_control.set_throttle_mix_mid();
+            attitude_control->set_throttle_mix_mid();
         }
     } else {
         // autopilot controlled throttle
 
         // check for aggressive flight requests - requested roll or pitch angle below 15 degrees
-        const Vector3f angle_target = attitude_control.get_att_target_euler_cd();
+        const Vector3f angle_target = attitude_control->get_att_target_euler_cd();
         bool large_angle_request = (norm(angle_target.x, angle_target.y) > LAND_CHECK_LARGE_ANGLE_CD);
 
         // check for large external disturbance - angle error over 30 degrees
-        const float angle_error = attitude_control.get_att_error_angle_deg();
+        const float angle_error = attitude_control->get_att_error_angle_deg();
         bool large_angle_error = (angle_error > LAND_CHECK_ANGLE_ERROR_DEG);
 
         // check for large acceleration - falling or high turbulence
@@ -164,12 +164,12 @@ void Copter::update_throttle_thr_mix()
         bool accel_moving = (accel_ef.length() > LAND_CHECK_ACCEL_MOVING);
 
         // check for requested decent
-        bool descent_not_demanded = pos_control.get_desired_velocity().z >= 0.0f;
+        bool descent_not_demanded = pos_control->get_desired_velocity().z >= 0.0f;
 
         if ( large_angle_request || large_angle_error || accel_moving || descent_not_demanded) {
-            attitude_control.set_throttle_mix_max();
+            attitude_control->set_throttle_mix_max();
         } else {
-            attitude_control.set_throttle_mix_min();
+            attitude_control->set_throttle_mix_min();
         }
     }
 #endif
diff --git a/ArduCopter/motor_test.cpp b/ArduCopter/motor_test.cpp
index 097d18d..8e140a3 100644
--- a/ArduCopter/motor_test.cpp
+++ b/ArduCopter/motor_test.cpp
@@ -38,8 +38,8 @@ void Copter::motor_test_output()
                 // sanity check motor_test_throttle value
 #if FRAME_CONFIG != HELI_FRAME
                 if (motor_test_throttle_value <= 100) {
-                    int16_t pwm_min = motors.get_pwm_output_min();
-                    int16_t pwm_max = motors.get_pwm_output_max();
+                    int16_t pwm_min = motors->get_pwm_output_min();
+                    int16_t pwm_max = motors->get_pwm_output_max();
                     pwm = pwm_min + (pwm_max - pwm_min) * (float)motor_test_throttle_value/100.0f;
                 }
 #endif
@@ -61,7 +61,7 @@ void Copter::motor_test_output()
         // sanity check throttle values
         if (pwm >= MOTOR_TEST_PWM_MIN && pwm <= MOTOR_TEST_PWM_MAX ) {
             // turn on motor to specified pwm vlaue
-            motors.output_test(motor_test_seq, pwm);
+            motors->output_test(motor_test_seq, pwm);
         } else {
             motor_test_stop();
         }
@@ -112,10 +112,10 @@ uint8_t Copter::mavlink_motor_test_start(mavlink_channel_t chan, uint8_t motor_s
             ap.motor_test = true;
 
             // enable and arm motors
-            if (!motors.armed()) {
+            if (!motors->armed()) {
                 init_rc_out();
                 enable_motor_output();
-                motors.armed(true);
+                motors->armed(true);
             }
 
             // disable throttle, battery and gps failsafe
@@ -153,7 +153,7 @@ void Copter::motor_test_stop()
     ap.motor_test = false;
 
     // disarm motors
-    motors.armed(false);
+    motors->armed(false);
 
     // reset timeout
     motor_test_start_ms = 0;
diff --git a/ArduCopter/motors.cpp b/ArduCopter/motors.cpp
index b1db229..7dbd330 100644
--- a/ArduCopter/motors.cpp
+++ b/ArduCopter/motors.cpp
@@ -30,7 +30,7 @@ void Copter::arm_motors_check()
         }
 
         // arm the motors and configure for flight
-        if (arming_counter == ARM_DELAY && !motors.armed()) {
+        if (arming_counter == ARM_DELAY && !motors->armed()) {
             // reset arming counter if arming fail
             if (!init_arm_motors(false)) {
                 arming_counter = 0;
@@ -38,7 +38,7 @@ void Copter::arm_motors_check()
         }
 
         // arm the motors and configure for flight
-        if (arming_counter == AUTO_TRIM_DELAY && motors.armed() && control_mode == STABILIZE) {
+        if (arming_counter == AUTO_TRIM_DELAY && motors->armed() && control_mode == STABILIZE) {
             auto_trim_counter = 250;
             // ensure auto-disarm doesn't trigger immediately
             auto_disarm_begin = millis();
@@ -57,7 +57,7 @@ void Copter::arm_motors_check()
         }
 
         // disarm the motors
-        if (arming_counter == DISARM_DELAY && motors.armed()) {
+        if (arming_counter == DISARM_DELAY && motors->armed()) {
             init_disarm_motors();
         }
 
@@ -75,21 +75,21 @@ void Copter::auto_disarm_check()
 
     // exit immediately if we are already disarmed, or if auto
     // disarming is disabled
-    if (!motors.armed() || disarm_delay_ms == 0 || control_mode == THROW) {
+    if (!motors->armed() || disarm_delay_ms == 0 || control_mode == THROW) {
         auto_disarm_begin = tnow_ms;
         return;
     }
 
 #if FRAME_CONFIG == HELI_FRAME
     // if the rotor is still spinning, don't initiate auto disarm
-    if (motors.rotor_speed_above_critical()) {
+    if (motors->rotor_speed_above_critical()) {
         auto_disarm_begin = tnow_ms;
         return;
     }
 #endif
 
     // always allow auto disarm if using interlock switch or motors are Emergency Stopped
-    if ((ap.using_interlock && !motors.get_interlock()) || ap.motor_emergency_stop) {
+    if ((ap.using_interlock && !motors->get_interlock()) || ap.motor_emergency_stop) {
 #if FRAME_CONFIG != HELI_FRAME
         // use a shorter delay if using throttle interlock switch or Emergency Stop, because it is less
         // obvious the copter is armed as the motors will not be spinning
@@ -131,7 +131,7 @@ bool Copter::init_arm_motors(bool arming_from_gcs)
     in_arm_motors = true;
 
     // return true if already armed
-    if (motors.armed()) {
+    if (motors->armed()) {
         in_arm_motors = false;
         return true;
     }
@@ -192,7 +192,7 @@ bool Copter::init_arm_motors(bool arming_from_gcs)
     enable_motor_output();
 
     // finally actually arm the motors
-    motors.armed(true);
+    motors->armed(true);
 
     // log arming to dataflash
     Log_Write_Event(DATA_ARMED);
@@ -223,7 +223,7 @@ bool Copter::init_arm_motors(bool arming_from_gcs)
 void Copter::init_disarm_motors()
 {
     // return immediately if we are already disarmed
-    if (!motors.armed()) {
+    if (!motors->armed()) {
         return;
     }
 
@@ -254,7 +254,7 @@ void Copter::init_disarm_motors()
     Log_Write_Event(DATA_DISARMED);
 
     // send disarm command to motors
-    motors.armed(false);
+    motors->armed(false);
 
     // reset the mission
     mission.reset();
@@ -286,7 +286,7 @@ void Copter::motors_output()
 #endif
 
     // Update arming delay state
-    if (ap.in_arming_delay && (!motors.armed() || millis()-arm_time_ms > ARMING_DELAY_SEC*1.0e3f || control_mode == THROW)) {
+    if (ap.in_arming_delay && (!motors->armed() || millis()-arm_time_ms > ARMING_DELAY_SEC*1.0e3f || control_mode == THROW)) {
         ap.in_arming_delay = false;
     }
 
@@ -294,17 +294,17 @@ void Copter::motors_output()
     if (ap.motor_test) {
         motor_test_output();
     } else {
-        bool interlock = motors.armed() && !ap.in_arming_delay && (!ap.using_interlock || ap.motor_interlock_switch) && !ap.motor_emergency_stop;
-        if (!motors.get_interlock() && interlock) {
-            motors.set_interlock(true);
+        bool interlock = motors->armed() && !ap.in_arming_delay && (!ap.using_interlock || ap.motor_interlock_switch) && !ap.motor_emergency_stop;
+        if (!motors->get_interlock() && interlock) {
+            motors->set_interlock(true);
             Log_Write_Event(DATA_MOTORS_INTERLOCK_ENABLED);
-        } else if (motors.get_interlock() && !interlock) {
-            motors.set_interlock(false);
+        } else if (motors->get_interlock() && !interlock) {
+            motors->set_interlock(false);
             Log_Write_Event(DATA_MOTORS_INTERLOCK_DISABLED);
         }
 
         // send output signals to motors
-        motors.output();
+        motors->output();
     }
 }
 
@@ -319,7 +319,7 @@ void Copter::lost_vehicle_check()
     }
 
     // ensure throttle is down, motors not armed, pitch and roll rc at max. Note: rc1=roll rc2=pitch
-    if (ap.throttle_zero && !motors.armed() && (channel_roll->get_control_in() > 4000) && (channel_pitch->get_control_in() > 4000)) {
+    if (ap.throttle_zero && !motors->armed() && (channel_roll->get_control_in() > 4000) && (channel_pitch->get_control_in() > 4000)) {
         if (soundalarm_counter >= LOST_VEHICLE_DELAY) {
             if (AP_Notify::flags.vehicle_lost == false) {
                 AP_Notify::flags.vehicle_lost = true;
diff --git a/ArduCopter/navigation.cpp b/ArduCopter/navigation.cpp
index 50f0d81..ef4e026 100644
--- a/ArduCopter/navigation.cpp
+++ b/ArduCopter/navigation.cpp
@@ -27,17 +27,17 @@ void Copter::calc_wp_distance()
     switch (control_mode) {
     case LOITER:
     case CIRCLE:
-        wp_distance = wp_nav.get_loiter_distance_to_target();
+        wp_distance = wp_nav->get_loiter_distance_to_target();
         break;
 
     case AUTO:
     case RTL:
-        wp_distance = wp_nav.get_wp_distance_to_destination();
+        wp_distance = wp_nav->get_wp_distance_to_destination();
         break;
 
     case GUIDED:
         if (guided_mode == Guided_WP) {
-            wp_distance = wp_nav.get_wp_distance_to_destination();
+            wp_distance = wp_nav->get_wp_distance_to_destination();
             break;
         }
         // no break
@@ -54,17 +54,17 @@ void Copter::calc_wp_bearing()
     switch (control_mode) {
     case LOITER:
     case CIRCLE:
-        wp_bearing = wp_nav.get_loiter_bearing_to_target();
+        wp_bearing = wp_nav->get_loiter_bearing_to_target();
         break;
 
     case AUTO:
     case RTL:
-        wp_bearing = wp_nav.get_wp_bearing_to_destination();
+        wp_bearing = wp_nav->get_wp_bearing_to_destination();
         break;
 
     case GUIDED:
         if (guided_mode == Guided_WP) {
-            wp_bearing = wp_nav.get_wp_bearing_to_destination();
+            wp_bearing = wp_nav->get_wp_bearing_to_destination();
             break;
         }
         // no break
diff --git a/ArduCopter/radio.cpp b/ArduCopter/radio.cpp
index 972b830..7ddc268 100644
--- a/ArduCopter/radio.cpp
+++ b/ArduCopter/radio.cpp
@@ -48,14 +48,11 @@ void Copter::init_rc_in()
  // init_rc_out -- initialise motors and check if pilot wants to perform ESC calibration
 void Copter::init_rc_out()
 {
-    // default frame class to match firmware if possible
-    set_default_frame_class();
-
-    motors.set_update_rate(g.rc_speed);
-    motors.set_loop_rate(scheduler.get_loop_rate_hz());
-    motors.init((AP_Motors::motor_frame_class)g2.frame_class.get(), (AP_Motors::motor_frame_type)g.frame_type.get());
+    motors->set_update_rate(g.rc_speed);
+    motors->set_loop_rate(scheduler.get_loop_rate_hz());
+    motors->init((AP_Motors::motor_frame_class)g2.frame_class.get(), (AP_Motors::motor_frame_type)g.frame_type.get());
 #if FRAME_CONFIG != HELI_FRAME
-    motors.set_throttle_range(channel_throttle->get_radio_min(), channel_throttle->get_radio_max());
+    motors->set_throttle_range(channel_throttle->get_radio_min(), channel_throttle->get_radio_max());
 #endif
 
     for(uint8_t i = 0; i < 5; i++) {
@@ -83,7 +80,7 @@ void Copter::init_rc_out()
     /*
       setup a default safety ignore mask, so that servo gimbals can be active while safety is on
      */
-    uint16_t safety_ignore_mask = (~copter.motors.get_motor_mask()) & 0x3FFF;
+    uint16_t safety_ignore_mask = (~copter.motors->get_motor_mask()) & 0x3FFF;
     BoardConfig.set_default_safety_ignore_mask(safety_ignore_mask);
 #endif
 }
@@ -93,8 +90,8 @@ void Copter::init_rc_out()
 void Copter::enable_motor_output()
 {
     // enable motors
-    motors.enable();
-    motors.output_min();
+    motors->enable();
+    motors->output_min();
 }
 
 void Copter::read_radio()
@@ -126,7 +123,7 @@ void Copter::read_radio()
         uint32_t elapsed = tnow_ms - last_radio_update_ms;
         // turn on throttle failsafe if no update from the RC Radio for 500ms or 2000ms if we are using RC_OVERRIDE
         if (((!failsafe.rc_override_active && (elapsed >= FS_RADIO_TIMEOUT_MS)) || (failsafe.rc_override_active && (elapsed >= FS_RADIO_RC_OVERRIDE_TIMEOUT_MS))) &&
-            (g.failsafe_throttle && (ap.rc_receiver_present||motors.armed()) && !failsafe.radio)) {
+            (g.failsafe_throttle && (ap.rc_receiver_present||motors->armed()) && !failsafe.radio)) {
             Log_Write_Error(ERROR_SUBSYSTEM_RADIO, ERROR_CODE_RADIO_LATE_FRAME);
             set_failsafe_radio(true);
         }
@@ -146,7 +143,7 @@ void Copter::set_throttle_and_failsafe(uint16_t throttle_pwm)
     if (throttle_pwm < (uint16_t)g.failsafe_throttle_value) {
 
         // if we are already in failsafe or motors not armed pass through throttle and exit
-        if (failsafe.radio || !(ap.rc_receiver_present || motors.armed())) {
+        if (failsafe.radio || !(ap.rc_receiver_present || motors->armed())) {
             channel_throttle->set_pwm(throttle_pwm);
             return;
         }
@@ -188,7 +185,7 @@ void Copter::set_throttle_zero_flag(int16_t throttle_control)
     // if not using throttle interlock and non-zero throttle and not E-stopped,
     // or using motor interlock and it's enabled, then motors are running, 
     // and we are flying. Immediately set as non-zero
-    if ((!ap.using_interlock && (throttle_control > 0) && !ap.motor_emergency_stop) || (ap.using_interlock && motors.get_interlock())) {
+    if ((!ap.using_interlock && (throttle_control > 0) && !ap.motor_emergency_stop) || (ap.using_interlock && motors->get_interlock())) {
         last_nonzero_throttle_ms = tnow_ms;
         ap.throttle_zero = false;
     } else if (tnow_ms - last_nonzero_throttle_ms > THROTTLE_ZERO_DEBOUNCE_TIME_MS) {
@@ -199,5 +196,5 @@ void Copter::set_throttle_zero_flag(int16_t throttle_control)
 // pass pilot's inputs to motors library (used to allow wiggling servos while disarmed on heli, single, coax copters)
 void Copter::radio_passthrough_to_motors()
 {
-    motors.set_radio_passthrough(channel_roll->get_control_in()/1000.0f, channel_pitch->get_control_in()/1000.0f, channel_throttle->get_control_in()/1000.0f, channel_yaw->get_control_in()/1000.0f);
+    motors->set_radio_passthrough(channel_roll->get_control_in()/1000.0f, channel_pitch->get_control_in()/1000.0f, channel_throttle->get_control_in()/1000.0f, channel_yaw->get_control_in()/1000.0f);
 }
diff --git a/ArduCopter/sensors.cpp b/ArduCopter/sensors.cpp
index 3eeb05d..fae4ebe 100644
--- a/ArduCopter/sensors.cpp
+++ b/ArduCopter/sensors.cpp
@@ -21,7 +21,7 @@ void Copter::read_barometer(void)
     baro_alt = barometer.get_altitude() * 100.0f;
     baro_climbrate = barometer.get_climb_rate() * 100.0f;
 
-    motors.set_air_density_ratio(barometer.get_air_density_ratio());
+    motors->set_air_density_ratio(barometer.get_air_density_ratio());
 }
 
 void Copter::init_rangefinder(void)
@@ -69,7 +69,7 @@ void Copter::read_rangefinder(void)
     }
 
     // send rangefinder altitude and health to waypoint navigation library
-    wp_nav.set_rangefinder_alt(rangefinder_state.enabled, rangefinder_state.alt_healthy, rangefinder_state.alt_cm_filt.get());
+    wp_nav->set_rangefinder_alt(rangefinder_state.enabled, rangefinder_state.alt_healthy, rangefinder_state.alt_cm_filt.get());
 
 #else
     rangefinder_state.enabled = false;
@@ -165,10 +165,10 @@ void Copter::read_battery(void)
 
     // update motors with voltage and current
     if (battery.get_type() != AP_BattMonitor::BattMonitor_TYPE_NONE) {
-        motors.set_voltage(battery.voltage());
+        motors->set_voltage(battery.voltage());
     }
     if (battery.has_current()) {
-        motors.set_current(battery.current_amps());
+        motors->set_current(battery.current_amps());
     }
 
     // check for low voltage or current if the low voltage check hasn't already been triggered
@@ -203,7 +203,7 @@ void Copter::compass_cal_update()
             compass.cancel_calibration_all();
         }
     } else {
-        bool stick_gesture_detected = compass_cal_stick_gesture_begin != 0 && !motors.armed() && channel_yaw->get_control_in() > 4000 && channel_throttle->get_control_in() > 900;
+        bool stick_gesture_detected = compass_cal_stick_gesture_begin != 0 && !motors->armed() && channel_yaw->get_control_in() > 4000 && channel_throttle->get_control_in() > 900;
         uint32_t tnow = millis();
 
         if (!stick_gesture_detected) {
diff --git a/ArduCopter/setup.cpp b/ArduCopter/setup.cpp
index a49eec7..0f9b126 100644
--- a/ArduCopter/setup.cpp
+++ b/ArduCopter/setup.cpp
@@ -221,7 +221,7 @@ int8_t Copter::esc_calib(uint8_t argc,const Menu::arg *argv)
 	max_channels = AP_MOTORS_MAX_NUM_MOTORS;
 
 	/* tell IO/FMU that the system is armed (it will output values if safety is off) */
-	motors.armed(true);
+	motors->armed(true);
 
 
 	cliSerial->println("Outputs armed");
@@ -238,7 +238,7 @@ int8_t Copter::esc_calib(uint8_t argc,const Menu::arg *argv)
 		for (unsigned i = 0; i < max_channels; i++) {
 
 			if (set_mask & 1<<i) {
-				motors.output_test(i, pwm_high);
+				motors->output_test(i, pwm_high);
 			}
 		}
         c = cliSerial->read();
@@ -265,7 +265,7 @@ int8_t Copter::esc_calib(uint8_t argc,const Menu::arg *argv)
 		/* set disarmed PWM */
 		for (unsigned i = 0; i < max_channels; i++) {
 			if (set_mask & 1<<i) {
-				motors.output_test(i, pwm_low);
+				motors->output_test(i, pwm_low);
 			}
 		}
 		c = cliSerial->read();
@@ -284,7 +284,7 @@ int8_t Copter::esc_calib(uint8_t argc,const Menu::arg *argv)
 	}
 
 	/* disarm */
-	motors.armed(false);
+	motors->armed(false);
     
 	cliSerial->println("Outputs disarmed");
 
diff --git a/ArduCopter/switches.cpp b/ArduCopter/switches.cpp
index aab68c9..10d3b5d 100644
--- a/ArduCopter/switches.cpp
+++ b/ArduCopter/switches.cpp
@@ -247,7 +247,7 @@ void Copter::do_aux_switch_function(int8_t ch_function, uint8_t ch_flag)
             if (ch_flag == AUX_SWITCH_HIGH) {
 
                 // do not allow saving new waypoints while we're in auto or disarmed
-                if (control_mode == AUTO || !motors.armed()) {
+                if (control_mode == AUTO || !motors->armed()) {
                     return;
                 }
 
@@ -364,7 +364,7 @@ void Copter::do_aux_switch_function(int8_t ch_function, uint8_t ch_flag)
 #if SPRAYER == ENABLED
             sprayer.run(ch_flag == AUX_SWITCH_HIGH);
             // if we are disarmed the pilot must want to test the pump
-            sprayer.test_pump((ch_flag == AUX_SWITCH_HIGH) && !motors.armed());
+            sprayer.test_pump((ch_flag == AUX_SWITCH_HIGH) && !motors->armed());
 #endif
             break;
 
@@ -452,12 +452,12 @@ void Copter::do_aux_switch_function(int8_t ch_function, uint8_t ch_flag)
 
         case AUXSW_ATTCON_FEEDFWD:
             // enable or disable feed forward
-            attitude_control.bf_feedforward(ch_flag == AUX_SWITCH_HIGH);
+            attitude_control->bf_feedforward(ch_flag == AUX_SWITCH_HIGH);
             break;
 
         case AUXSW_ATTCON_ACCEL_LIM:
             // enable or disable accel limiting by restoring defaults
-            attitude_control.accel_limiting(ch_flag == AUX_SWITCH_HIGH);
+            attitude_control->accel_limiting(ch_flag == AUX_SWITCH_HIGH);
             break;
 
         case AUXSW_RETRACT_MOUNT:
diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index 4ed6e04..ca500c0 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -56,9 +56,9 @@ void Copter::run_cli(AP_HAL::UARTDriver *port)
     failsafe_disable();
 
     // cut the engines
-    if(motors.armed()) {
-        motors.armed(false);
-        motors.output();
+    if(motors->armed()) {
+        motors->armed(false);
+        motors->output();
     }
 
     while (1) {
@@ -177,10 +177,17 @@ void Copter::init_ardupilot()
 #endif
     
     init_rc_in();               // sets up rc channels from radio
+
+    // default frame class to match firmware if possible
+    set_default_frame_class();
+
+    // allocate the motors class
+    allocate_motors();
+
     init_rc_out();              // sets up motors and output to escs
 
     // initialise which outputs Servo and Relay events can use
-    ServoRelayEvents.set_channel_mask(~motors.get_motor_mask());
+    ServoRelayEvents.set_channel_mask(~motors->get_motor_mask());
 
     relay.init();
 
@@ -208,14 +215,14 @@ void Copter::init_ardupilot()
     Location_Class::set_ahrs(&ahrs);
 #if AP_TERRAIN_AVAILABLE && AC_TERRAIN
     Location_Class::set_terrain(&terrain);
-    wp_nav.set_terrain(&terrain);
+    wp_nav->set_terrain(&terrain);
 #endif
 #if AC_AVOID_ENABLED == ENABLED
-    wp_nav.set_avoidance(&avoid);
+    wp_nav->set_avoidance(&avoid);
 #endif
 
-    attitude_control.parameter_sanity_check();
-    pos_control.set_dt(MAIN_LOOP_SECONDS);
+    attitude_control->parameter_sanity_check();
+    pos_control->set_dt(MAIN_LOOP_SECONDS);
 
     // init the optical flow sensor
     init_optflow();
@@ -362,7 +369,7 @@ bool Copter::ekf_position_ok()
     nav_filter_status filt_status = inertial_nav.get_filter_status();
 
     // if disarmed we accept a predicted horizontal position
-    if (!motors.armed()) {
+    if (!motors->armed()) {
         return ((filt_status.flags.horiz_pos_abs || filt_status.flags.pred_horiz_pos_abs));
     } else {
         // once armed we require a good absolute position and EKF must not be in const_pos_mode
@@ -385,7 +392,7 @@ bool Copter::optflow_position_ok()
     nav_filter_status filt_status = inertial_nav.get_filter_status();
 
     // if disarmed we accept a predicted horizontal relative position
-    if (!motors.armed()) {
+    if (!motors->armed()) {
         return (filt_status.flags.pred_horiz_pos_rel);
     } else {
         return (filt_status.flags.horiz_pos_rel && !filt_status.flags.const_pos_mode);
@@ -399,7 +406,7 @@ void Copter::update_auto_armed()
     // disarm checks
     if(ap.auto_armed){
         // if motors are disarmed, auto_armed should also be false
-        if(!motors.armed()) {
+        if(!motors->armed()) {
             set_auto_armed(false);
             return;
         }
@@ -410,7 +417,7 @@ void Copter::update_auto_armed()
 #if FRAME_CONFIG == HELI_FRAME 
         // if helicopters are on the ground, and the motor is switched off, auto-armed should be false
         // so that rotor runup is checked again before attempting to take-off
-        if(ap.land_complete && !motors.rotor_runup_complete()) {
+        if(ap.land_complete && !motors->rotor_runup_complete()) {
             set_auto_armed(false);
         }
 #endif // HELI_FRAME
@@ -419,13 +426,13 @@ void Copter::update_auto_armed()
         
 #if FRAME_CONFIG == HELI_FRAME
         // for tradheli if motors are armed and throttle is above zero and the motor is started, auto_armed should be true
-        if(motors.armed() && !ap.throttle_zero && motors.rotor_runup_complete()) {
+        if(motors->armed() && !ap.throttle_zero && motors->rotor_runup_complete()) {
             set_auto_armed(true);
         }
 #else
         // if motors are armed and throttle is above zero auto_armed should be true
         // if motors are armed and we are in throw mode, then auto_ermed should be true
-        if(motors.armed() && (!ap.throttle_zero || control_mode == THROW)) {
+        if(motors->armed() && (!ap.throttle_zero || control_mode == THROW)) {
             set_auto_armed(true);
         }
 #endif // HELI_FRAME
@@ -452,7 +459,7 @@ bool Copter::should_log(uint32_t mask)
     if (!(mask & g.log_bitmask) || in_mavlink_delay) {
         return false;
     }
-    bool ret = motors.armed() || DataFlash.log_while_disarmed();
+    bool ret = motors->armed() || DataFlash.log_while_disarmed();
     if (ret && !DataFlash.logging_started() && !in_log_download) {
         start_logging();
     }
@@ -465,30 +472,8 @@ bool Copter::should_log(uint32_t mask)
 // default frame_class to match firmware if possible
 void Copter::set_default_frame_class()
 {
-    switch (FRAME_CONFIG) {
-        case QUAD_FRAME:
-        case HEXA_FRAME:
-        case OCTA_FRAME:
-        case OCTA_QUAD_FRAME:
-        case Y6_FRAME:
-            // reset frame_class to undefined if firmware does not match
-            // Note: this assumes that Y6 is the highest numbered frame to be supported by the AP_Motors_Matrix class
-            if (g2.frame_class > AP_Motors::MOTOR_FRAME_Y6) {
-                g2.frame_class = AP_Motors::MOTOR_FRAME_UNDEFINED;
-            }
-            break;
-        case TRI_FRAME:
-            g2.frame_class = AP_Motors::MOTOR_FRAME_TRI;
-            break;
-        case HELI_FRAME:
-            g2.frame_class = AP_Motors::MOTOR_FRAME_HELI;
-            break;
-        case SINGLE_FRAME:
-            g2.frame_class = AP_Motors::MOTOR_FRAME_SINGLE;
-            break;
-        case COAX_FRAME:
-            g2.frame_class = AP_Motors::MOTOR_FRAME_COAX;
-            break;
+    if (FRAME_CONFIG == HELI_FRAME) {
+        g2.frame_class.set(AP_Motors::MOTOR_FRAME_HELI);
     }
 }
 
@@ -545,3 +530,64 @@ const char* Copter::get_frame_string()
     }
 }
 
+/*
+  allocate the motors class
+ */
+void Copter::allocate_motors(void)
+{
+    switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
+#if FRAME_CONFIG != HELI_FRAME
+        case AP_Motors::MOTOR_FRAME_QUAD:
+        case AP_Motors::MOTOR_FRAME_HEXA:
+        case AP_Motors::MOTOR_FRAME_Y6:
+        case AP_Motors::MOTOR_FRAME_OCTA:
+        case AP_Motors::MOTOR_FRAME_OCTAQUAD:
+            motors = new AP_MotorsMatrix(MAIN_LOOP_RATE);
+            break;
+        case AP_Motors::MOTOR_FRAME_TRI:
+            motors = new AP_MotorsTri(MAIN_LOOP_RATE);
+            break;
+        case AP_Motors::MOTOR_FRAME_SINGLE:
+            motors = new AP_MotorsSingle(MAIN_LOOP_RATE);
+            break;
+        case AP_Motors::MOTOR_FRAME_COAX:
+            motors = new AP_MotorsCoax(MAIN_LOOP_RATE);
+            break;
+#else // FRAME_CONFIG == HELI_FRAME
+        case AP_Motors::MOTOR_FRAME_HELI:
+            motors = new AP_MotorsHeli_Single(MAIN_LOOP_RATE);
+            break;            
+#endif
+        default:
+            break;
+    }
+    if (motors == nullptr) {
+        AP_HAL::panic("Unable to allocate FRAME_CLASS=%u", (unsigned)g2.frame_class.get());
+    }
+
+#if FRAME_CONFIG != HELI_FRAME
+    attitude_control = new AC_AttitudeControl_Multi(ahrs, aparm, *motors, MAIN_LOOP_SECONDS);
+#else
+    attitude_control = new AC_AttitudeControl_Heli(ahrs, aparm, *motors, MAIN_LOOP_SECONDS);
+#endif
+    if (attitude_control == nullptr) {
+        AP_HAL::panic("Unable to allocate AttitudeControl");
+    }
+        
+    pos_control = new AC_PosControl(ahrs, inertial_nav, *motors, *attitude_control,
+                                    g.p_alt_hold, g.p_vel_z, g.pid_accel_z,
+                                    g.p_pos_xy, g.pi_vel_xy);
+    if (pos_control == nullptr) {
+        AP_HAL::panic("Unable to allocate PosControl");
+    }
+
+    wp_nav = new AC_WPNav(inertial_nav, ahrs, *pos_control, *attitude_control);
+    if (wp_nav == nullptr) {
+        AP_HAL::panic("Unable to allocate WPNav");
+    }
+
+    circle_nav = new AC_Circle(inertial_nav, ahrs, *pos_control);
+    if (wp_nav == nullptr) {
+        AP_HAL::panic("Unable to allocate CircleNav");
+    }
+}
diff --git a/ArduCopter/takeoff.cpp b/ArduCopter/takeoff.cpp
index ac266fc..0834a42 100644
--- a/ArduCopter/takeoff.cpp
+++ b/ArduCopter/takeoff.cpp
@@ -25,11 +25,11 @@ bool Copter::current_mode_has_user_takeoff(bool must_navigate)
 // initiate user takeoff - called when MAVLink TAKEOFF command is received
 bool Copter::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
 {
-    if (motors.armed() && ap.land_complete && current_mode_has_user_takeoff(must_navigate) && takeoff_alt_cm > current_loc.alt) {
+    if (motors->armed() && ap.land_complete && current_mode_has_user_takeoff(must_navigate) && takeoff_alt_cm > current_loc.alt) {
 
 #if FRAME_CONFIG == HELI_FRAME
         // Helicopters should return false if MAVlink takeoff command is received while the rotor is not spinning
-        if (!motors.rotor_runup_complete()) {
+        if (!motors->rotor_runup_complete()) {
             return false;
         }
 #endif
@@ -59,7 +59,7 @@ bool Copter::do_user_takeoff(float takeoff_alt_cm, bool must_navigate)
 void Copter::takeoff_timer_start(float alt_cm)
 {
     // calculate climb rate
-    float speed = MIN(wp_nav.get_speed_up(), MAX(g.pilot_velocity_z_max*2.0f/3.0f, g.pilot_velocity_z_max-50.0f));
+    float speed = MIN(wp_nav->get_speed_up(), MAX(g.pilot_velocity_z_max*2.0f/3.0f, g.pilot_velocity_z_max-50.0f));
 
     // sanity check speed and target
     if (takeoff_state.running || speed <= 0.0f || alt_cm <= 0.0f) {
@@ -147,7 +147,7 @@ void Copter::auto_takeoff_set_start_alt(void)
     // start with our current altitude
     auto_takeoff_no_nav_alt_cm = inertial_nav.get_altitude();
     
-    if (!motors.armed() || !ap.auto_armed || !motors.get_interlock() || ap.land_complete) {
+    if (!motors->armed() || !ap.auto_armed || !motors->get_interlock() || ap.land_complete) {
         // we are not flying, add the wp_navalt_min
         auto_takeoff_no_nav_alt_cm += g2.wp_navalt_min * 100;
     }
@@ -171,12 +171,12 @@ void Copter::auto_takeoff_attitude_run(float target_yaw_rate)
         hover_roll_trim_scalar_slew = 0;        
 #endif
         // tell the position controller that we have limited roll/pitch demand to prevent integrator buildup
-        pos_control.set_limit_accel_xy();
+        pos_control->set_limit_accel_xy();
     } else {
-        nav_roll = wp_nav.get_roll();
-        nav_pitch = wp_nav.get_pitch();
+        nav_roll = wp_nav->get_roll();
+        nav_pitch = wp_nav->get_pitch();
     }
     
     // roll & pitch from waypoint controller, yaw rate from pilot
-    attitude_control.input_euler_angle_roll_pitch_euler_rate_yaw(nav_roll, nav_pitch, target_yaw_rate, get_smoothing_gain());
+    attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(nav_roll, nav_pitch, target_yaw_rate, get_smoothing_gain());
 }
diff --git a/ArduCopter/tuning.cpp b/ArduCopter/tuning.cpp
index 686b4e9..716f73b 100644
--- a/ArduCopter/tuning.cpp
+++ b/ArduCopter/tuning.cpp
@@ -29,36 +29,36 @@ void Copter::tuning() {
 
     // Roll, Pitch tuning
     case TUNING_STABILIZE_ROLL_PITCH_KP:
-        attitude_control.get_angle_roll_p().kP(tuning_value);
-        attitude_control.get_angle_pitch_p().kP(tuning_value);
+        attitude_control->get_angle_roll_p().kP(tuning_value);
+        attitude_control->get_angle_pitch_p().kP(tuning_value);
         break;
 
     case TUNING_RATE_ROLL_PITCH_KP:
-        attitude_control.get_rate_roll_pid().kP(tuning_value);
-        attitude_control.get_rate_pitch_pid().kP(tuning_value);
+        attitude_control->get_rate_roll_pid().kP(tuning_value);
+        attitude_control->get_rate_pitch_pid().kP(tuning_value);
         break;
 
     case TUNING_RATE_ROLL_PITCH_KI:
-        attitude_control.get_rate_roll_pid().kI(tuning_value);
-        attitude_control.get_rate_pitch_pid().kI(tuning_value);
+        attitude_control->get_rate_roll_pid().kI(tuning_value);
+        attitude_control->get_rate_pitch_pid().kI(tuning_value);
         break;
 
     case TUNING_RATE_ROLL_PITCH_KD:
-        attitude_control.get_rate_roll_pid().kD(tuning_value);
-        attitude_control.get_rate_pitch_pid().kD(tuning_value);
+        attitude_control->get_rate_roll_pid().kD(tuning_value);
+        attitude_control->get_rate_pitch_pid().kD(tuning_value);
         break;
 
     // Yaw tuning
     case TUNING_STABILIZE_YAW_KP:
-        attitude_control.get_angle_yaw_p().kP(tuning_value);
+        attitude_control->get_angle_yaw_p().kP(tuning_value);
         break;
 
     case TUNING_YAW_RATE_KP:
-        attitude_control.get_rate_yaw_pid().kP(tuning_value);
+        attitude_control->get_rate_yaw_pid().kP(tuning_value);
         break;
 
     case TUNING_YAW_RATE_KD:
-        attitude_control.get_rate_yaw_pid().kD(tuning_value);
+        attitude_control->get_rate_yaw_pid().kD(tuning_value);
         break;
 
     // Altitude and throttle tuning
@@ -97,7 +97,7 @@ void Copter::tuning() {
 
     case TUNING_WP_SPEED:
         // set waypoint navigation horizontal speed to 0 ~ 1000 cm/s
-        wp_nav.set_speed_xy(control_in);
+        wp_nav->set_speed_xy(control_in);
         break;
 
     // Acro roll pitch gain
@@ -112,19 +112,19 @@ void Copter::tuning() {
 
 #if FRAME_CONFIG == HELI_FRAME
     case TUNING_HELI_EXTERNAL_GYRO:
-        motors.ext_gyro_gain((float)control_in / 1000.0f);
+        motors->ext_gyro_gain((float)control_in / 1000.0f);
         break;
 
     case TUNING_RATE_PITCH_FF:
-        attitude_control.get_heli_rate_pitch_pid().ff(tuning_value);
+        attitude_control->get_heli_rate_pitch_pid().ff(tuning_value);
         break;
 
     case TUNING_RATE_ROLL_FF:
-        attitude_control.get_heli_rate_roll_pid().ff(tuning_value);
+        attitude_control->get_heli_rate_roll_pid().ff(tuning_value);
         break;
 
     case TUNING_RATE_YAW_FF:
-        attitude_control.get_heli_rate_yaw_pid().ff(tuning_value);
+        attitude_control->get_heli_rate_yaw_pid().ff(tuning_value);
         break;
 #endif
 
@@ -135,7 +135,7 @@ void Copter::tuning() {
 
     case TUNING_CIRCLE_RATE:
         // set circle rate up to approximately 45 deg/sec in either direction
-        circle_nav.set_rate((float)control_in/25.0f-20.0f);
+        circle_nav->set_rate((float)control_in/25.0f-20.0f);
         break;
 
     case TUNING_RANGEFINDER_GAIN:
@@ -180,37 +180,37 @@ void Copter::tuning() {
         break;
 
     case TUNING_RATE_PITCH_KP:
-        attitude_control.get_rate_pitch_pid().kP(tuning_value);
+        attitude_control->get_rate_pitch_pid().kP(tuning_value);
         break;
 
     case TUNING_RATE_PITCH_KI:
-        attitude_control.get_rate_pitch_pid().kI(tuning_value);
+        attitude_control->get_rate_pitch_pid().kI(tuning_value);
         break;
 
     case TUNING_RATE_PITCH_KD:
-        attitude_control.get_rate_pitch_pid().kD(tuning_value);
+        attitude_control->get_rate_pitch_pid().kD(tuning_value);
         break;
 
     case TUNING_RATE_ROLL_KP:
-        attitude_control.get_rate_roll_pid().kP(tuning_value);
+        attitude_control->get_rate_roll_pid().kP(tuning_value);
         break;
 
     case TUNING_RATE_ROLL_KI:
-        attitude_control.get_rate_roll_pid().kI(tuning_value);
+        attitude_control->get_rate_roll_pid().kI(tuning_value);
         break;
 
     case TUNING_RATE_ROLL_KD:
-        attitude_control.get_rate_roll_pid().kD(tuning_value);
+        attitude_control->get_rate_roll_pid().kD(tuning_value);
         break;
 
 #if FRAME_CONFIG != HELI_FRAME
     case TUNING_RATE_MOT_YAW_HEADROOM:
-        motors.set_yaw_headroom(tuning_value*1000);
+        motors->set_yaw_headroom(tuning_value*1000);
         break;
 #endif
 
      case TUNING_RATE_YAW_FILT:
-         attitude_control.get_rate_yaw_pid().filt_hz(tuning_value);
+         attitude_control->get_rate_yaw_pid().filt_hz(tuning_value);
          break;
     }
 }

From 8e3bf71aa96d6b1d8a5f1a02ab2b0a4f31261cc4 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 18:31:56 +1100
Subject: [PATCH 076/200] AP_Motors: allow single, tri and coax to be part of
 multicopter class

---
 libraries/AP_Motors/AP_MotorsCoax.cpp        | 32 +---------------------------
 libraries/AP_Motors/AP_MotorsCoax.h          |  7 ------
 libraries/AP_Motors/AP_MotorsMulticopter.cpp |  9 ++++++++
 libraries/AP_Motors/AP_MotorsMulticopter.h   |  3 +++
 libraries/AP_Motors/AP_MotorsSingle.cpp      | 31 ++-------------------------
 libraries/AP_Motors/AP_MotorsSingle.h        |  7 ------
 libraries/AP_Motors/AP_MotorsTri.cpp         |  9 --------
 libraries/AP_Motors/AP_MotorsTri.h           |  1 -
 8 files changed, 15 insertions(+), 84 deletions(-)

diff --git a/libraries/AP_Motors/AP_MotorsCoax.cpp b/libraries/AP_Motors/AP_MotorsCoax.cpp
index e2c0971..f599c4e 100644
--- a/libraries/AP_Motors/AP_MotorsCoax.cpp
+++ b/libraries/AP_Motors/AP_MotorsCoax.cpp
@@ -27,32 +27,9 @@
 extern const AP_HAL::HAL& hal;
 
 
-const AP_Param::GroupInfo AP_MotorsCoax::var_info[] = {
-    // variables from parent vehicle
-    AP_NESTEDGROUPINFO(AP_MotorsMulticopter, 0),
-
-    // parameters 1 ~ 29 were reserved for tradheli
-    // parameters 30 ~ 39 reserved for tricopter
-    // parameters 40 ~ 49 for single copter and coax copter (these have identical parameter files)
-
-    // 40 was ROLL_SV_REV
-    // 41 was PITCH_SV_REV
-    // 42 was YAW_SV_REV
-
-	// @Param: SV_SPEED
-    // @DisplayName: Servo speed 
-    // @Description: Servo update speed
-    // @Units: Hz
-    AP_GROUPINFO("SV_SPEED", 43, AP_MotorsCoax, _servo_speed, AP_MOTORS_SINGLE_SPEED_DIGITAL_SERVOS),
-
-    AP_GROUPEND
-};
 // init
 void AP_MotorsCoax::init(motor_frame_class frame_class, motor_frame_type frame_type)
 {
-    // set update rate for the 3 motors (but not the servo on channel 7)
-    set_update_rate(_speed_hz);
-
     _servo1 = SRV_Channels::get_channel_for(SRV_Channel::k_motor1, CH_1);
     _servo2 = SRV_Channels::get_channel_for(SRV_Channel::k_motor2, CH_2);
     _servo3 = SRV_Channels::get_channel_for(SRV_Channel::k_motor3, CH_3);
@@ -89,17 +66,10 @@ void AP_MotorsCoax::set_update_rate( uint16_t speed_hz )
     // record requested speed
     _speed_hz = speed_hz;
 
-    // set update rate for the 4 servos and 2 motors
     uint32_t mask =
-        1U << AP_MOTORS_MOT_1 |
-        1U << AP_MOTORS_MOT_2 |
-        1U << AP_MOTORS_MOT_3 |
-        1U << AP_MOTORS_MOT_4 ;
-    rc_set_freq(mask, _servo_speed);
-    uint32_t mask2 =
         1U << AP_MOTORS_MOT_5 |
         1U << AP_MOTORS_MOT_6 ;
-    rc_set_freq(mask2, _speed_hz);
+    rc_set_freq(mask, _speed_hz);
 }
 
 // enable - starts allowing signals to be sent to motors
diff --git a/libraries/AP_Motors/AP_MotorsCoax.h b/libraries/AP_Motors/AP_MotorsCoax.h
index 92a9de8..98f7ddc 100644
--- a/libraries/AP_Motors/AP_MotorsCoax.h
+++ b/libraries/AP_Motors/AP_MotorsCoax.h
@@ -26,7 +26,6 @@ class AP_MotorsCoax : public AP_MotorsMulticopter {
     AP_MotorsCoax(uint16_t loop_rate, uint16_t speed_hz = AP_MOTORS_SPEED_DEFAULT) :
         AP_MotorsMulticopter(loop_rate, speed_hz)
     {
-        AP_Param::setup_object_defaults(this, var_info);
     };
 
     // init
@@ -53,16 +52,10 @@ class AP_MotorsCoax : public AP_MotorsMulticopter {
     //  this can be used to ensure other pwm outputs (i.e. for servos) do not conflict
     virtual uint16_t    get_motor_mask();
 
-    // var_info for holding Parameter information
-    static const struct AP_Param::GroupInfo var_info[];
-
 protected:
     // output - sends commands to the motors
     void                output_armed_stabilizing();
 
-    // servo speed
-    AP_Int16            _servo_speed;
-
     float               _actuator_out[NUM_ACTUATORS]; // combined roll, pitch, yaw and throttle outputs to motors in 0~1 range
     float               _thrust_yt_ccw;
     float               _thrust_yt_cw;
diff --git a/libraries/AP_Motors/AP_MotorsMulticopter.cpp b/libraries/AP_Motors/AP_MotorsMulticopter.cpp
index 8a3dd43..004918f 100644
--- a/libraries/AP_Motors/AP_MotorsMulticopter.cpp
+++ b/libraries/AP_Motors/AP_MotorsMulticopter.cpp
@@ -145,6 +145,15 @@ const AP_Param::GroupInfo AP_MotorsMulticopter::var_info[] = {
     // @User: Advanced
     AP_GROUPINFO("SAFE_DISARM", 23, AP_MotorsMulticopter, _disarm_disable_pwm, 0),
 
+    // @Param: YAW_SV_ANGLE
+    // @DisplayName: Yaw Servo Max Lean Angle
+    // @Description: Yaw servo's maximum lean angle
+    // @Range: 5 80
+    // @Units: Degrees
+    // @Increment: 1
+    // @User: Standard
+    AP_GROUPINFO("YAW_SV_ANGLE", 35, AP_MotorsMulticopter,  _yaw_servo_angle_max_deg, 30),
+    
     AP_GROUPEND
 };
 
diff --git a/libraries/AP_Motors/AP_MotorsMulticopter.h b/libraries/AP_Motors/AP_MotorsMulticopter.h
index c3996ff..01e438c 100644
--- a/libraries/AP_Motors/AP_MotorsMulticopter.h
+++ b/libraries/AP_Motors/AP_MotorsMulticopter.h
@@ -163,6 +163,9 @@ class AP_MotorsMulticopter : public AP_Motors {
     AP_Int8             _throttle_hover_learn;  // enable/disabled hover thrust learning
     AP_Int8             _disarm_disable_pwm;    // disable PWM output while disarmed
 
+    // Maximum lean angle of yaw servo in degrees. This is specific to tricopter
+    AP_Float            _yaw_servo_angle_max_deg;
+    
     // motor output variables
     bool                motor_enabled[AP_MOTORS_MAX_NUM_MOTORS];    // true if motor is enabled
     int16_t             _throttle_radio_min;        // minimum PWM from RC input's throttle channel (i.e. minimum PWM input from receiver, RC3_MIN)
diff --git a/libraries/AP_Motors/AP_MotorsSingle.cpp b/libraries/AP_Motors/AP_MotorsSingle.cpp
index dd4c57c..8bc103c 100644
--- a/libraries/AP_Motors/AP_MotorsSingle.cpp
+++ b/libraries/AP_Motors/AP_MotorsSingle.cpp
@@ -27,26 +27,6 @@
 extern const AP_HAL::HAL& hal;
 
 
-const AP_Param::GroupInfo AP_MotorsSingle::var_info[] = {
-    // variables from parent vehicle
-    AP_NESTEDGROUPINFO(AP_MotorsMulticopter, 0),
-
-    // parameters 1 ~ 29 were reserved for tradheli
-    // parameters 30 ~ 39 reserved for tricopter
-    // parameters 40 ~ 49 for single copter and coax copter (these have identical parameter files)
-
-    // 40 was ROLL_SV_REV
-    // 41 was PITCH_SV_REV
-	// 42 was YAW_SV_REV
-
-	// @Param: SV_SPEED
-    // @DisplayName: Servo speed 
-    // @Description: Servo update speed in hz
-    // @Values: 50, 125, 250
-    AP_GROUPINFO("SV_SPEED", 43, AP_MotorsSingle, _servo_speed, AP_MOTORS_SINGLE_SPEED_DIGITAL_SERVOS),
-
-    AP_GROUPEND
-};
 // init
 void AP_MotorsSingle::init(motor_frame_class frame_class, motor_frame_type frame_type)
 {
@@ -92,17 +72,10 @@ void AP_MotorsSingle::set_update_rate( uint16_t speed_hz )
     // record requested speed
     _speed_hz = speed_hz;
 
-    // set update rate for the 3 motors (but not the servo on channel 7)
-    uint32_t mask = 
-        1U << AP_MOTORS_MOT_1 |
-        1U << AP_MOTORS_MOT_2 |
-        1U << AP_MOTORS_MOT_3 |
-        1U << AP_MOTORS_MOT_4 ;
-    rc_set_freq(mask, _servo_speed);
-    uint32_t mask2 =
+    uint32_t mask =
         1U << AP_MOTORS_MOT_5 |
         1U << AP_MOTORS_MOT_6 ;
-    rc_set_freq(mask2, _speed_hz);
+    rc_set_freq(mask, _speed_hz);
 }
 
 // enable - starts allowing signals to be sent to motors
diff --git a/libraries/AP_Motors/AP_MotorsSingle.h b/libraries/AP_Motors/AP_MotorsSingle.h
index 8aa059e..d0626ea 100644
--- a/libraries/AP_Motors/AP_MotorsSingle.h
+++ b/libraries/AP_Motors/AP_MotorsSingle.h
@@ -26,7 +26,6 @@ class AP_MotorsSingle : public AP_MotorsMulticopter {
     AP_MotorsSingle(uint16_t loop_rate, uint16_t speed_hz = AP_MOTORS_SPEED_DEFAULT) :
         AP_MotorsMulticopter(loop_rate, speed_hz)
     {
-        AP_Param::setup_object_defaults(this, var_info);
     };
 
     // init
@@ -53,16 +52,10 @@ class AP_MotorsSingle : public AP_MotorsMulticopter {
     //  this can be used to ensure other pwm outputs (i.e. for servos) do not conflict
     virtual uint16_t    get_motor_mask();
 
-    // var_info for holding Parameter information
-    static const struct AP_Param::GroupInfo var_info[];
-
 protected:
     // output - sends commands to the motors
     void                output_armed_stabilizing();
 
-    // servo speed
-    AP_Int16            _servo_speed;
-
     int16_t             _throttle_radio_output;   // total throttle pwm value, summed onto throttle channel minimum, typically ~1100-1900
     float               _actuator_out[NUM_ACTUATORS]; // combined roll, pitch, yaw and throttle outputs to motors in 0~1 range
     float               _thrust_out;
diff --git a/libraries/AP_Motors/AP_MotorsTri.cpp b/libraries/AP_Motors/AP_MotorsTri.cpp
index d577b58..8633bc1 100644
--- a/libraries/AP_Motors/AP_MotorsTri.cpp
+++ b/libraries/AP_Motors/AP_MotorsTri.cpp
@@ -33,15 +33,6 @@ const AP_Param::GroupInfo AP_MotorsTri::var_info[] = {
     // parameters 30 ~ 39 reserved for tricopter
     // parameters 40 ~ 49 for single copter and coax copter (these have identical parameter files)
 
-    // @Param: YAW_SV_ANGLE
-    // @DisplayName: Yaw Servo Max Lean Angle
-    // @Description: Yaw servo's maximum lean angle
-    // @Range: 5 80
-    // @Units: Degrees
-    // @Increment: 1
-    // @User: Standard
-    AP_GROUPINFO("YAW_SV_ANGLE", 35,   AP_MotorsTri,  _yaw_servo_angle_max_deg, 30),
-
     AP_GROUPEND
 };
 
diff --git a/libraries/AP_Motors/AP_MotorsTri.h b/libraries/AP_Motors/AP_MotorsTri.h
index 75d7ff1..87d8c12 100644
--- a/libraries/AP_Motors/AP_MotorsTri.h
+++ b/libraries/AP_Motors/AP_MotorsTri.h
@@ -64,7 +64,6 @@ class AP_MotorsTri : public AP_MotorsMulticopter {
     // parameters
 
     SRV_Channel     *_yaw_servo; // yaw output channel
-    AP_Float        _yaw_servo_angle_max_deg;           // Maximum lean angle of yaw servo in degrees
     float           _pivot_angle;                       // Angle of yaw pivot
     float           _thrust_right;
     float           _thrust_rear;

From 2086b591a27b47e94f6c2d7831354667a0bfe0b9 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 18:49:53 +1100
Subject: [PATCH 077/200] AC_PID: expose ff() method in AC_PID

this allows for an abstract AC_PID class to be used in
AC_AttitudeControl for both multicopter and heli
---
 libraries/AC_PID/AC_HELI_PID.h | 5 -----
 libraries/AC_PID/AC_PID.h      | 3 +++
 2 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/libraries/AC_PID/AC_HELI_PID.h b/libraries/AC_PID/AC_HELI_PID.h
index 0e66db6..50da771 100644
--- a/libraries/AC_PID/AC_HELI_PID.h
+++ b/libraries/AC_PID/AC_HELI_PID.h
@@ -25,14 +25,9 @@ class AC_HELI_PID : public AC_PID {
     /// get_leaky_i - replacement for get_i but output is leaded at leak_rate
     float       get_leaky_i(float leak_rate);
 
-    // accessors
-    float       ff() const { return _vff.get(); }
-    void        ff(const float v) { _vff.set(v); }
-
     static const struct AP_Param::GroupInfo        var_info[];
 
 private:
-    AP_Float        _vff;
     AP_Float        _leak_min;
 
     float           _last_requested_rate;       // Requested rate from last iteration, used to calculate rate change of requested rate
diff --git a/libraries/AC_PID/AC_PID.h b/libraries/AC_PID/AC_PID.h
index bb1ae2d..5c38c5d 100644
--- a/libraries/AC_PID/AC_PID.h
+++ b/libraries/AC_PID/AC_PID.h
@@ -62,6 +62,7 @@ class AC_PID {
     float       imax() const { return _imax.get(); }
     float       filt_hz() const { return _filt_hz.get(); }
     float       get_filt_alpha() const;
+    float       ff() const { return _vff.get(); }
 
     // set accessors
     void        kP(const float v) { _kp.set(v); }
@@ -69,6 +70,7 @@ class AC_PID {
     void        kD(const float v) { _kd.set(v); }
     void        imax(const float v) { _imax.set(fabsf(v)); }
     void        filt_hz(const float v);
+    void        ff(const float v) { _vff.set(v); }
 
     float       get_integrator() const { return _integrator; }
     void        set_integrator(float i) { _integrator = i; }
@@ -89,6 +91,7 @@ class AC_PID {
     AP_Float        _kd;
     AP_Float        _imax;
     AP_Float        _filt_hz;                   // PID Input filter frequency in Hz
+    AP_Float        _vff; // only used by heli
 
     // flags
     struct ac_pid_flags {

From 4a4fc8ab061ba2705cc7c290c9581a9196cf2639 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 18:50:09 +1100
Subject: [PATCH 078/200] Copter: adjust for change to AC_PID

---
 ArduCopter/tuning.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/ArduCopter/tuning.cpp b/ArduCopter/tuning.cpp
index 716f73b..64a008a2 100644
--- a/ArduCopter/tuning.cpp
+++ b/ArduCopter/tuning.cpp
@@ -116,15 +116,15 @@ void Copter::tuning() {
         break;
 
     case TUNING_RATE_PITCH_FF:
-        attitude_control->get_heli_rate_pitch_pid().ff(tuning_value);
+        attitude_control->get_rate_pitch_pid().ff(tuning_value);
         break;
 
     case TUNING_RATE_ROLL_FF:
-        attitude_control->get_heli_rate_roll_pid().ff(tuning_value);
+        attitude_control->get_rate_roll_pid().ff(tuning_value);
         break;
 
     case TUNING_RATE_YAW_FF:
-        attitude_control->get_heli_rate_yaw_pid().ff(tuning_value);
+        attitude_control->get_rate_yaw_pid().ff(tuning_value);
         break;
 #endif
 

From 556cda13e14ca41153adf510340de795567e3f69 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 18:52:19 +1100
Subject: [PATCH 079/200] Copter: reduced copter frame build

---
 ArduCopter/wscript | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/ArduCopter/wscript b/ArduCopter/wscript
index c8f0485..00bee1f 100644
--- a/ArduCopter/wscript
+++ b/ArduCopter/wscript
@@ -36,8 +36,7 @@ def build(bld):
     )
 
     frames = (
-        'quad', 'tri', 'hexa', 'y6', 'octa', 'octa-quad', 'heli', 'single',
-        'coax',
+        'quad', 'heli',
     )
     for frame in frames:
         frame_config = frame.upper().replace('-', '_') + '_FRAME'

From 2a1408becf1a873b01d2cdf75eea978be261f2e5 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 18:52:51 +1100
Subject: [PATCH 080/200] Tools: no need to build tri separately

---
 Tools/scripts/build_binaries.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Tools/scripts/build_binaries.sh b/Tools/scripts/build_binaries.sh
index 269e1f6..7115015 100755
--- a/Tools/scripts/build_binaries.sh
+++ b/Tools/scripts/build_binaries.sh
@@ -296,7 +296,7 @@ build_arducopter() {
     # work out what frames to build by looking for FRAME_CLASS parameter
     checkout ArduCopter $tag "" ""
     if grep -q FRAME_CLASS ArduCopter/Parameters.cpp; then
-        frames="quad tri heli"
+        frames="quad heli"
     else
         frames="quad tri hexa y6 octa octa-quad heli"
     fi

From 2f100b080418222902bea88637d5ec63e77c0e52 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 19:19:42 +1100
Subject: [PATCH 081/200] Plane: removed separate tricopter quadplane build

can all be done with one build now
---
 ArduPlane/quadplane.cpp | 30 ++++++++++++++++--------------
 ArduPlane/quadplane.h   | 20 +-------------------
 ArduPlane/wscript       |  7 -------
 3 files changed, 17 insertions(+), 40 deletions(-)

diff --git a/ArduPlane/quadplane.cpp b/ArduPlane/quadplane.cpp
index edafc16..a0ab216 100644
--- a/ArduPlane/quadplane.cpp
+++ b/ArduPlane/quadplane.cpp
@@ -11,7 +11,7 @@ const AP_Param::GroupInfo QuadPlane::var_info[] = {
 
     // @Group: M_
     // @Path: ../libraries/AP_Motors/AP_MotorsMulticopter.cpp
-    AP_SUBGROUPPTR(motors, "M_", 2, QuadPlane, AP_MOTORS_CLASS),
+    AP_SUBGROUPPTR(motors, "M_", 2, QuadPlane, AP_MotorsMulticopter),
 
     // 3 ~ 8 were used by quadplane attitude control PIDs
 
@@ -369,7 +369,8 @@ bool QuadPlane::setup(void)
     }
     float loop_delta_t = 1.0 / plane.scheduler.get_loop_rate_hz();
 
-#if FRAME_CONFIG != TRI_FRAME
+    enum AP_Motors::motor_frame_class motor_class;
+    
     /*
       cope with upgrade from old AP_Motors values for frame_class
      */
@@ -397,7 +398,6 @@ bool QuadPlane::setup(void)
         }
         frame_class.set_and_save(new_value);
     }
-#endif
     
     if (hal.util->available_memory() <
         4096 + sizeof(*motors) + sizeof(*attitude_control) + sizeof(*pos_control) + sizeof(*wp_nav)) {
@@ -405,20 +405,13 @@ bool QuadPlane::setup(void)
         goto failed;
     }
 
-#if FRAME_CONFIG == TRI_FRAME
-    SRV_Channels::set_default_function(CH_5, SRV_Channel::k_motor1);
-    SRV_Channels::set_default_function(CH_6, SRV_Channel::k_motor2);
-    SRV_Channels::set_default_function(CH_8, SRV_Channel::k_motor4);
-    SRV_Channels::set_default_function(CH_11, SRV_Channel::k_motor7);
-    frame_class.set(AP_Motors::MOTOR_FRAME_TRI);
-    motors = new AP_MOTORS_CLASS(plane.scheduler.get_loop_rate_hz());
-#else
     /*
       dynamically allocate the key objects for quadplane. This ensures
       that the objects don't affect the vehicle unless enabled and
       also saves memory when not in use
      */
-    switch ((enum AP_Motors::motor_frame_class)frame_class.get()) {
+    motor_class = (enum AP_Motors::motor_frame_class)frame_class.get();
+    switch (motor_class) {
     case AP_Motors::MOTOR_FRAME_QUAD:
         setup_default_channels(4);
         break;
@@ -432,12 +425,21 @@ bool QuadPlane::setup(void)
     case AP_Motors::MOTOR_FRAME_Y6:
         setup_default_channels(7);
         break;
+    case AP_Motors::MOTOR_FRAME_TRI:
+        SRV_Channels::set_default_function(CH_5, SRV_Channel::k_motor1);
+        SRV_Channels::set_default_function(CH_6, SRV_Channel::k_motor2);
+        SRV_Channels::set_default_function(CH_8, SRV_Channel::k_motor4);
+        SRV_Channels::set_default_function(CH_11, SRV_Channel::k_motor7);
+        break;
     default:
         hal.console->printf("Unknown frame class %u\n", (unsigned)frame_class.get());
         goto failed;
     }
-    motors = new AP_MotorsMatrix(plane.scheduler.get_loop_rate_hz());
-#endif // AP_MOTORS_CLASS
+    if (motor_class == AP_Motors::MOTOR_FRAME_TRI) {
+        motors = new AP_MotorsTri(plane.scheduler.get_loop_rate_hz());
+    } else {
+        motors = new AP_MotorsMatrix(plane.scheduler.get_loop_rate_hz());
+    }
     const static char *strUnableToAllocate = "Unable to allocate";
     if (!motors) {
         hal.console->printf("%s motors\n", strUnableToAllocate);
diff --git a/ArduPlane/quadplane.h b/ArduPlane/quadplane.h
index 193e9ca..a6337cb 100644
--- a/ArduPlane/quadplane.h
+++ b/ArduPlane/quadplane.h
@@ -9,24 +9,6 @@
 #include <AP_Proximity/AP_Proximity.h>
 
 /*
-  frame types for quadplane build. Most case be set with
-  parameters. Those that can't are listed here and chosen with a build
-  time FRAME_CONFIG parameter
- */
-#define MULTICOPTER_FRAME 1
-#define TRI_FRAME 2
-
-#ifndef FRAME_CONFIG
-# define FRAME_CONFIG MULTICOPTER_FRAME
-#endif
-
-#if FRAME_CONFIG == TRI_FRAME
-#define AP_MOTORS_CLASS AP_MotorsTri
-#else
-#define AP_MOTORS_CLASS AP_MotorsMulticopter
-#endif
-
-/*
   QuadPlane specific functionality
  */
 class QuadPlane
@@ -124,7 +106,7 @@ class QuadPlane
     AP_Int8 frame_class;
     AP_Int8 frame_type;
     
-    AP_MOTORS_CLASS *motors;
+    AP_MotorsMulticopter *motors;
     AC_AttitudeControl_Multi *attitude_control;
     AC_PosControl *pos_control;
     AC_WPNav *wp_nav;
diff --git a/ArduPlane/wscript b/ArduPlane/wscript
index 2c4ae9d..139eb32 100644
--- a/ArduPlane/wscript
+++ b/ArduPlane/wscript
@@ -41,10 +41,3 @@ def build(bld):
         program_groups=['bin', 'plane'],
         use=vehicle + '_libs',
     )
-
-    bld.ap_program(
-        program_name='arduplane-tri',
-        program_groups=['bin', 'plane'],
-        use=vehicle + '_libs',
-        defines=['FRAME_CONFIG=TRI_FRAME'],
-    )

From ccae8979c1e9f340054523aa63fc618a481a1e3c Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 20:52:02 +1100
Subject: [PATCH 082/200] AC_PID: expose filt_hz as a AP_Float

this allows defaults to be overridden
---
 libraries/AC_PID/AC_PID.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AC_PID/AC_PID.h b/libraries/AC_PID/AC_PID.h
index 5c38c5d..367783a 100644
--- a/libraries/AC_PID/AC_PID.h
+++ b/libraries/AC_PID/AC_PID.h
@@ -59,8 +59,8 @@ class AC_PID {
     AP_Float   &kP() { return _kp; }
     AP_Float   &kI() { return _ki; }
     AP_Float   &kD() { return _kd; }
+    AP_Float   &filt_hz() { return _filt_hz; }
     float       imax() const { return _imax.get(); }
-    float       filt_hz() const { return _filt_hz.get(); }
     float       get_filt_alpha() const;
     float       ff() const { return _vff.get(); }
 

From 0c32178d070d27ee0fe4d118a1a56ea1ceb400d3 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 20:52:36 +1100
Subject: [PATCH 083/200] AP_Param: added reload_defaults_file()

this allows defaults to be set for parameters in pointer objects
---
 libraries/AP_Param/AP_Param.cpp | 55 ++++++++++++++++++++++++-----------------
 libraries/AP_Param/AP_Param.h   | 10 +++++---
 2 files changed, 39 insertions(+), 26 deletions(-)

diff --git a/libraries/AP_Param/AP_Param.cpp b/libraries/AP_Param/AP_Param.cpp
index 505bcc8..11805e4 100644
--- a/libraries/AP_Param/AP_Param.cpp
+++ b/libraries/AP_Param/AP_Param.cpp
@@ -1209,25 +1209,12 @@ void AP_Param::setup_sketch_defaults(void)
 
 // Load all variables from EEPROM
 //
-bool AP_Param::load_all(void)
+bool AP_Param::load_all(bool check_defaults_file)
 {
     struct Param_header phdr;
     uint16_t ofs = sizeof(AP_Param::EEPROM_header);
 
-#if HAL_OS_POSIX_IO == 1
-    /*
-      if the HAL specifies a defaults parameter file then override
-      defaults using that file
-     */
-    const char *default_file = hal.util->get_custom_defaults_file();
-    if (default_file) {
-        if (load_defaults_file(default_file)) {
-            printf("Loaded defaults from %s\n", default_file);
-        } else {
-            printf("Failed to load defaults from %s\n", default_file);
-        }
-    }
-#endif
+    reload_defaults_file(check_defaults_file);
 
     while (ofs < _storage.size()) {
         _storage.read_block(&phdr, ofs, sizeof(phdr));
@@ -1254,6 +1241,26 @@ bool AP_Param::load_all(void)
     return false;
 }
 
+/*
+  reload from hal.util defaults file
+ */
+void AP_Param::reload_defaults_file(bool panic_on_error)
+{
+#if HAL_OS_POSIX_IO == 1
+    /*
+      if the HAL specifies a defaults parameter file then override
+      defaults using that file
+     */
+    const char *default_file = hal.util->get_custom_defaults_file();
+    if (default_file) {
+        if (load_defaults_file(default_file, panic_on_error)) {
+            printf("Loaded defaults from %s\n", default_file);
+        } else {
+            printf("Failed to load defaults from %s\n", default_file);
+        }
+    }
+#endif
+}
 
 
 /* 
@@ -1714,7 +1721,7 @@ bool AP_Param::parse_param_line(char *line, char **vname, float &value)
 /*
   load a default set of parameters from a file
  */
-bool AP_Param::load_defaults_file(const char *filename)
+bool AP_Param::load_defaults_file(const char *filename, bool panic_on_error)
 {
     if (filename == nullptr) {
         return false;
@@ -1736,10 +1743,14 @@ bool AP_Param::load_defaults_file(const char *filename)
             continue;
         }
         if (!find_def_value_ptr(pname)) {
-            fclose(f);
-            ::printf("invalid param %s in defaults file\n", pname);
-            AP_HAL::panic("AP_Param: Invalid param in defaults file");
-            return false;
+            if (panic_on_error) {
+                fclose(f);
+                ::printf("invalid param %s in defaults file\n", pname);
+                AP_HAL::panic("AP_Param: Invalid param in defaults file");
+                return false;
+            } else {
+                continue;
+            }
         }
         num_defaults++;
     }
@@ -1774,9 +1785,7 @@ bool AP_Param::load_defaults_file(const char *filename)
         }
         const float *def_value_ptr = find_def_value_ptr(pname);
         if (!def_value_ptr) {
-            fclose(f);
-            AP_HAL::panic("AP_Param: Invalid param in defaults file");
-            return false;
+            continue;
         }
         param_overrides[idx].def_value_ptr = def_value_ptr;
         param_overrides[idx].value = value;
diff --git a/libraries/AP_Param/AP_Param.h b/libraries/AP_Param/AP_Param.h
index 92fc3bf..28f96de 100644
--- a/libraries/AP_Param/AP_Param.h
+++ b/libraries/AP_Param/AP_Param.h
@@ -262,8 +262,12 @@ class AP_Param
     ///
     /// @return                False if any variable failed to load
     ///
-    static bool load_all(void);
+    static bool load_all(bool check_defaults_file=true);
 
+    /// reoad the hal.util defaults file. Called after pointer parameters have been allocated
+    ///
+    static void reload_defaults_file(bool panic_on_error=true);
+    
     static void load_object_from_eeprom(const void *object_pointer, const struct GroupInfo *group_info);
     
     // set a AP_Param variable to a specified value
@@ -473,9 +477,9 @@ class AP_Param
       load a parameter defaults file. This happens as part of load_all()
      */
     static bool parse_param_line(char *line, char **vname, float &value);
-    static bool load_defaults_file(const char *filename);
+    static bool load_defaults_file(const char *filename, bool panic_on_error);
 #endif
-
+    
     // send a parameter to all GCS instances
     void send_parameter(const char *name, enum ap_var_type param_header_type, uint8_t idx) const;
     

From 3338b4295ef115ede30c816f92bd3a18504d2333 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 20:52:49 +1100
Subject: [PATCH 084/200] Plane: use reload_defaults_file()

---
 ArduPlane/Parameters.cpp | 2 +-
 ArduPlane/system.cpp     | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/ArduPlane/Parameters.cpp b/ArduPlane/Parameters.cpp
index 782d9e3..ea06d4d 100644
--- a/ArduPlane/Parameters.cpp
+++ b/ArduPlane/Parameters.cpp
@@ -1320,7 +1320,7 @@ void Plane::load_parameters(void)
 
     uint32_t before = micros();
     // Load all auto-loaded EEPROM variables
-    AP_Param::load_all();
+    AP_Param::load_all(false);
     AP_Param::convert_old_parameters(&conversion_table[0], ARRAY_SIZE(conversion_table));
 
     // setup defaults in SRV_Channels
diff --git a/ArduPlane/system.cpp b/ArduPlane/system.cpp
index 8ed0e55..868e5cf 100644
--- a/ArduPlane/system.cpp
+++ b/ArduPlane/system.cpp
@@ -241,6 +241,8 @@ void Plane::init_ardupilot()
 
     quadplane.setup();
 
+    AP_Param::reload_defaults_file();
+    
     startup_ground();
 
     // don't initialise aux rc output until after quadplane is setup as

From e85df47b065d5a426a57404bf45c3ec438a2e825 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 20:54:18 +1100
Subject: [PATCH 085/200] Copter: fixed parameter handling for pointer objects

fixed loading of default files and use of POINTER flag on object
groups
---
 ArduCopter/APM_Config.h   | 13 -------------
 ArduCopter/Parameters.cpp | 31 +++++++++----------------------
 ArduCopter/config.h       | 19 +------------------
 ArduCopter/defines.h      | 11 ++---------
 ArduCopter/system.cpp     | 20 ++++++++++++++++++++
 5 files changed, 32 insertions(+), 62 deletions(-)

diff --git a/ArduCopter/APM_Config.h b/ArduCopter/APM_Config.h
index 6f431ba..e88b9a5 100644
--- a/ArduCopter/APM_Config.h
+++ b/ArduCopter/APM_Config.h
@@ -3,19 +3,6 @@
 // If you used to define your CONFIG_APM_HARDWARE setting here, it is no longer
 // valid! You should switch to using a HAL_BOARD flag in your local config.mk.
 
-//#define FRAME_CONFIG QUAD_FRAME
-/*  options:
- *  QUAD_FRAME
- *  TRI_FRAME
- *  HEXA_FRAME
- *  Y6_FRAME
- *  OCTA_FRAME
- *  OCTA_QUAD_FRAME
- *  HELI_FRAME
- *  SINGLE_FRAME
- *  COAX_FRAME
- */
-
 // uncomment the lines below to disable features (flash sizes listed are for APM2 boards and will underestimate savings on Pixhawk and other boards)
 //#define LOGGING_ENABLED       DISABLED            // disable dataflash logging to save 11K of flash space
 //#define MOUNT                 DISABLED            // disable the camera gimbal to save 8K of flash space
diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index 28779e9..e1c9df2 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -24,6 +24,7 @@
 #define ASCALAR(v, name, def) { copter.aparm.v.vtype, name, Parameters::k_param_ ## v, (const void *)&copter.aparm.v, {def_value : def} }
 #define GGROUP(v, name, class) { AP_PARAM_GROUP, name, Parameters::k_param_ ## v, &copter.g.v, {group_info : class::var_info} }
 #define GOBJECT(v, name, class) { AP_PARAM_GROUP, name, Parameters::k_param_ ## v, (const void *)&copter.v, {group_info : class::var_info} }
+#define GOBJECTPTR(v, name, class) { AP_PARAM_GROUP, name, Parameters::k_param_ ## v, (const void *)&copter.v, {group_info : class::var_info}, AP_PARAM_FLAG_POINTER }
 #define GOBJECTN(v, pname, name, class) { AP_PARAM_GROUP, name, Parameters::k_param_ ## pname, (const void *)&copter.v, {group_info : class::var_info} }
 
 const AP_Param::Info Copter::var_info[] = {
@@ -683,23 +684,19 @@ const AP_Param::Info Copter::var_info[] = {
 
     // @Group: WPNAV_
     // @Path: ../libraries/AC_WPNav/AC_WPNav.cpp
-    GOBJECT(wp_nav, "WPNAV_",       AC_WPNav),
+    GOBJECTPTR(wp_nav, "WPNAV_",       AC_WPNav),
 
     // @Group: CIRCLE_
     // @Path: ../libraries/AC_WPNav/AC_Circle.cpp
-    GOBJECT(circle_nav, "CIRCLE_",  AC_Circle),
+    GOBJECTPTR(circle_nav, "CIRCLE_",  AC_Circle),
 
-#if FRAME_CONFIG == HELI_FRAME
-    GOBJECT(attitude_control, "ATC_", AC_AttitudeControl_Heli),
-#else
     // @Group: ATC_
     // @Path: ../libraries/AC_AttitudeControl/AC_AttitudeControl.cpp,../libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp
-    GOBJECT(attitude_control, "ATC_", AC_AttitudeControl_Multi),
-#endif
+    GOBJECTPTR(attitude_control, "ATC_", AC_AttitudeControl_Multi),
 
     // @Group: POSCON_
     // @Path: ../libraries/AC_AttitudeControl/AC_PosControl.cpp
-    GOBJECT(pos_control, "PSC", AC_PosControl),
+    GOBJECTPTR(pos_control, "PSC", AC_PosControl),
 
     // @Group: SR0_
     // @Path: GCS_Mavlink.cpp
@@ -783,21 +780,11 @@ const AP_Param::Info Copter::var_info[] = {
 #if FRAME_CONFIG == HELI_FRAME
     // @Group: H_
     // @Path: ../libraries/AP_Motors/AP_MotorsHeli_Single.cpp
-    GOBJECT(motors, "H_",           AP_MotorsHeli_Single),
-
-#elif FRAME_CONFIG == SINGLE_FRAME
-    GOBJECT(motors, "MOT_",           AP_MotorsSingle),
-
-#elif FRAME_CONFIG == COAX_FRAME
-    GOBJECT(motors, "MOT_",           AP_MotorsCoax),
-
-#elif FRAME_CONFIG == TRI_FRAME
-    GOBJECT(motors, "MOT_",           AP_MotorsTri),
-
+    GOBJECTPTR(motors, "H_",           AP_MotorsHeli_Single),
 #else
     // @Group: MOT_
     // @Path: ../libraries/AP_Motors/AP_MotorsMulticopter.cpp
-    GOBJECT(motors, "MOT_",         AP_MotorsMulticopter),
+    GOBJECTPTR(motors, "MOT_",         AP_MotorsMulticopter),
 #endif
 
     // @Group: RCMAP_
@@ -1080,7 +1067,7 @@ void Copter::load_parameters(void)
 
     uint32_t before = micros();
     // Load all auto-loaded EEPROM variables
-    AP_Param::load_all();
+    AP_Param::load_all(false);
     AP_Param::convert_old_parameters(&conversion_table[0], ARRAY_SIZE(conversion_table));
     cliSerial->printf("load_all took %uus\n", (unsigned)(micros() - before));
 
@@ -1135,7 +1122,7 @@ void Copter::convert_pid_parameters(void)
     // and motor libraries switch to accept inputs in -1 to +1 range instead of -4500 ~ +4500
     float pid_scaler = 1.27f;
 
-#if FRAME_CONFIG == QUAD_FRAME || FRAME_CONFIG == HEXA_FRAME || FRAME_CONFIG == Y6_FRAME  || FRAME_CONFIG == OCTA_FRAME || FRAME_CONFIG == OCTA_QUAD_FRAME
+#if FRAME_CONFIG != HELI_FRAME
     // Multicopter x-frame gains are 40% lower because -1 or +1 input to motors now results in maximum rotation
     if (g.frame_type == AP_Motors::MOTOR_FRAME_TYPE_X || g.frame_type == AP_Motors::MOTOR_FRAME_TYPE_V || g.frame_type == AP_Motors::MOTOR_FRAME_TYPE_H) {
         pid_scaler = 0.9f;
diff --git a/ArduCopter/config.h b/ArduCopter/config.h
index 2116087..630f0c3 100644
--- a/ArduCopter/config.h
+++ b/ArduCopter/config.h
@@ -61,7 +61,7 @@
 // FRAME_CONFIG
 //
 #ifndef FRAME_CONFIG
- # define FRAME_CONFIG   QUAD_FRAME
+ # define FRAME_CONFIG   MULTICOPTER_FRAME
 #endif
 
 /////////////////////////////////////////////////////////////////////////////////
@@ -73,23 +73,6 @@
   # define AUTOTUNE_ENABLED                     DISABLED
 #endif
 
-/////////////////////////////////////////////////////////////////////////////////
-// Y6 defaults
-#if FRAME_CONFIG == Y6_FRAME
-  # define RATE_ROLL_P                  0.1f
-  # define RATE_ROLL_D                  0.006f
-  # define RATE_PITCH_P                 0.1f
-  # define RATE_PITCH_D                 0.006f
-  # define RATE_YAW_P                   0.150f
-  # define RATE_YAW_I                   0.015f
-#endif
-
-/////////////////////////////////////////////////////////////////////////////////
-// Tri defaults
-#if FRAME_CONFIG == TRI_FRAME
-  # define RATE_YAW_FILT_HZ             100.0f
-#endif
-
 //////////////////////////////////////////////////////////////////////////////
 // PWM control
 // default RC speed in Hz
diff --git a/ArduCopter/defines.h b/ArduCopter/defines.h
index 381e63d..37323f5 100644
--- a/ArduCopter/defines.h
+++ b/ArduCopter/defines.h
@@ -75,15 +75,8 @@ enum aux_sw_func {
 
 // Frame types
 #define UNDEFINED_FRAME 0
-#define QUAD_FRAME 1
-#define TRI_FRAME 2
-#define HEXA_FRAME 3
-#define Y6_FRAME 4
-#define OCTA_FRAME 5
-#define HELI_FRAME 6
-#define OCTA_QUAD_FRAME 7
-#define SINGLE_FRAME 8
-#define COAX_FRAME 9
+#define MULTICOPTER_FRAME 1
+#define HELI_FRAME 2
 
 // HIL enumerations
 #define HIL_MODE_DISABLED               0
diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index ca500c0..19b8d30 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -590,4 +590,24 @@ void Copter::allocate_motors(void)
     if (wp_nav == nullptr) {
         AP_HAL::panic("Unable to allocate CircleNav");
     }
+
+    // reload lines from the defaults file that may now be accessible
+    AP_Param::reload_defaults_file();
+    
+    // now setup some frame-class specific defaults
+    switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
+    case AP_Motors::MOTOR_FRAME_Y6:
+        attitude_control->get_rate_roll_pid().kP().set_default(0.1);
+        attitude_control->get_rate_roll_pid().kD().set_default(0.006);
+        attitude_control->get_rate_pitch_pid().kP().set_default(0.1);
+        attitude_control->get_rate_pitch_pid().kD().set_default(0.006);
+        attitude_control->get_rate_yaw_pid().kP().set_default(0.15);
+        attitude_control->get_rate_yaw_pid().kI().set_default(0.015);
+        break;
+    case AP_Motors::MOTOR_FRAME_TRI:
+        attitude_control->get_rate_yaw_pid().filt_hz().set_default(100);
+        break;
+    default:
+        break;
+    }
 }

From 8dcde8ee923a3cb01703a7daa8b0d747722c5ad6 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 20:54:39 +1100
Subject: [PATCH 086/200] Copter: make binary names arducopter and
 arducopter-heli

---
 ArduCopter/wscript | 22 ++++++++++++----------
 1 file changed, 12 insertions(+), 10 deletions(-)

diff --git a/ArduCopter/wscript b/ArduCopter/wscript
index 00bee1f..7fc3b27 100644
--- a/ArduCopter/wscript
+++ b/ArduCopter/wscript
@@ -35,14 +35,16 @@ def build(bld):
         ],
     )
 
-    frames = (
-        'quad', 'heli',
-    )
-    for frame in frames:
-        frame_config = frame.upper().replace('-', '_') + '_FRAME'
-        bld.ap_program(
-            program_name='arducopter-%s' % frame,
-            program_groups=['bin', 'copter'],
-            use=vehicle + '_libs',
-            defines=['FRAME_CONFIG=%s' % frame_config],
+    bld.ap_program(
+        program_name='arducopter',
+        program_groups=['bin', 'copter'],
+        use=vehicle + '_libs',
+        defines=['FRAME_CONFIG=MULTICOPTER_FRAME'],
+        )
+
+    bld.ap_program(
+        program_name='arducopter-heli',
+        program_groups=['bin', 'copter'],
+        use=vehicle + '_libs',
+        defines=['FRAME_CONFIG=HELI_FRAME'],
         )

From 34a7d47b3ff3a30f01e867d517207c50ddfff75b Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 20:54:59 +1100
Subject: [PATCH 087/200] autotest: fixed frame class for quadplane tri frames

---
 Tools/autotest/default_params/quadplane-tilttri.parm | 1 +
 Tools/autotest/default_params/quadplane-tri.parm     | 1 +
 2 files changed, 2 insertions(+)

diff --git a/Tools/autotest/default_params/quadplane-tilttri.parm b/Tools/autotest/default_params/quadplane-tilttri.parm
index de51137..cd7b7ed 100644
--- a/Tools/autotest/default_params/quadplane-tilttri.parm
+++ b/Tools/autotest/default_params/quadplane-tilttri.parm
@@ -49,6 +49,7 @@ PTCH2SRV_RLL     1
 Q_ANGLE_MAX      4500
 Q_ASSIST_SPEED   6
 Q_ENABLE         1
+Q_FRAME_CLASS    7
 RALLY_INCL_HOME  0
 RALLY_LIMIT_KM   5
 RALLY_TOTAL      0
diff --git a/Tools/autotest/default_params/quadplane-tri.parm b/Tools/autotest/default_params/quadplane-tri.parm
index f76f2d4..cd157de 100644
--- a/Tools/autotest/default_params/quadplane-tri.parm
+++ b/Tools/autotest/default_params/quadplane-tri.parm
@@ -49,6 +49,7 @@ PTCH2SRV_RLL     1
 Q_ANGLE_MAX      4500
 Q_ASSIST_SPEED   18
 Q_ENABLE         1
+Q_FRAME_CLASS    7
 RALLY_INCL_HOME  0
 RALLY_LIMIT_KM   5
 RALLY_TOTAL      0

From 8504a8baadb8fbb1f11189edee14c68ff0046060 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 20:55:20 +1100
Subject: [PATCH 088/200] autotest: fixed sim_vehicle for new frame builds

---
 Tools/autotest/sim_vehicle.py | 50 +++++++++++++++++++++----------------------
 1 file changed, 25 insertions(+), 25 deletions(-)

diff --git a/Tools/autotest/sim_vehicle.py b/Tools/autotest/sim_vehicle.py
index f8ae001..f9fcad4 100755
--- a/Tools/autotest/sim_vehicle.py
+++ b/Tools/autotest/sim_vehicle.py
@@ -227,49 +227,49 @@ def find_root_dir():
     },
     # COPTER
     "+": {
-        "waf_target": "bin/arducopter-quad",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter.parm",
     },
     "quad": {
         "model": "+",
-        "waf_target": "bin/arducopter-quad",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter.parm",
     },
     "X": {
-        "waf_target": "bin/arducopter-quad",
+        "waf_target": "bin/arducopter",
         # this param set FRAME doesn't actually work because mavproxy
         # won't set a parameter unless it knows of it, and the param fetch happens asynchronously
         "default_params_filename": "default_params/copter.parm",
         "extra_mavlink_cmds": "param fetch frame; param set FRAME 1;",
     },
     "hexa": {
-        "make_target": "sitl-hexa",
-        "waf_target": "bin/arducopter-hexa",
+        "make_target": "sitl",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter.parm",
     },
     "octa-quad": {
-        "make_target": "sitl-octa-quad",
-        "waf_target": "bin/arducopter-octa-quad",
+        "make_target": "sitl",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter.parm",
     },
     "octa": {
-        "make_target": "sitl-octa",
-        "waf_target": "bin/arducopter-octa",
+        "make_target": "sitl",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter.parm",
     },
     "tri": {
-        "make_target": "sitl-tri",
-        "waf_target": "bin/arducopter-tri",
+        "make_target": "sitl",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter-tri.parm",
     },
     "y6": {
-        "make_target": "sitl-y6",
-        "waf_target": "bin/arducopter-y6",
+        "make_target": "sitl",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter-y6.parm",
     },
     # COPTER TYPES
     "IrisRos": {
-        "waf_target": "bin/arducopter-quad",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter.parm",
     },
     "firefly": {
@@ -279,7 +279,7 @@ def find_root_dir():
     # HELICOPTER
     "heli": {
         "make_target": "sitl-heli",
-        "waf_target": "bin/arducopter-heli",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter-heli.parm",
     },
     "heli-dual": {
@@ -291,24 +291,24 @@ def find_root_dir():
         "waf_target": "bin/arducopter-coax",  # is this correct? -pb201604301447
     },
     "singlecopter": {
-        "make_target": "sitl-single",
-        "waf_target": "bin/arducopter-single",
+        "make_target": "sitl",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter-single.parm",
     },
     "coaxcopter": {
-        "make_target": "sitl-coax",
-        "waf_target": "bin/arducopter-coax",
+        "make_target": "sitl",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/copter-coax.parm",
     },
     # PLANE
     "quadplane-tilttri": {
-        "make_target": "sitl-tri",
-        "waf_target": "bin/arduplane-tri",
+        "make_target": "sitl",
+        "waf_target": "bin/arduplane",
         "default_params_filename": "default_params/quadplane-tilttri.parm",
     },
     "quadplane-tri": {
-        "make_target": "sitl-tri",
-        "waf_target": "bin/arduplane-tri",
+        "make_target": "sitl",
+        "waf_target": "bin/arduplane",
         "default_params_filename": "default_params/quadplane-tri.parm",
     },
     "quadplane": {
@@ -338,7 +338,7 @@ def find_root_dir():
     },
     # SIM
     "gazebo-iris": {
-        "waf_target": "bin/arducopter-quad",
+        "waf_target": "bin/arducopter",
         "default_params_filename": "default_params/gazebo-iris.parm",
     },
     "gazebo-zephyr": {
@@ -359,7 +359,7 @@ def find_root_dir():
 
 _default_waf_target = {
     "ArduPlane": "bin/arduplane",
-    "ArduCopter": "bin/arducopter-quad",
+    "ArduCopter": "bin/arducopter",
     "APMrover2": "bin/ardurover",
     "AntennaTracker": "bin/antennatracker",
 }

From c0c25e058883d9ef71f038ce497c7a35a4c3d116 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 21:10:32 +1100
Subject: [PATCH 089/200] Copter: fixed parameter doc paths

---
 ArduCopter/Parameters.cpp | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index e1c9df2..139dd4d 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -691,9 +691,13 @@ const AP_Param::Info Copter::var_info[] = {
     GOBJECTPTR(circle_nav, "CIRCLE_",  AC_Circle),
 
     // @Group: ATC_
-    // @Path: ../libraries/AC_AttitudeControl/AC_AttitudeControl.cpp,../libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp
+    // @Path: ../libraries/AC_AttitudeControl/AC_AttitudeControl.cpp,../libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp,,../libraries/AC_AttitudeControl/AC_AttitudeControl_Heli.cpp
+#if FRAME_CONFIG == HELI_FRAME
+    GOBJECTPTR(attitude_control, "ATC_", AC_AttitudeControl_Heli),
+#else
     GOBJECTPTR(attitude_control, "ATC_", AC_AttitudeControl_Multi),
-
+#endif
+    
     // @Group: POSCON_
     // @Path: ../libraries/AC_AttitudeControl/AC_PosControl.cpp
     GOBJECTPTR(pos_control, "PSC", AC_PosControl),
@@ -779,7 +783,7 @@ const AP_Param::Info Copter::var_info[] = {
 
 #if FRAME_CONFIG == HELI_FRAME
     // @Group: H_
-    // @Path: ../libraries/AP_Motors/AP_MotorsHeli_Single.cpp
+    // @Path: ../libraries/AP_Motors/AP_MotorsHeli_Single.cpp,../libraries/AP_Motors/AP_MotorsHeli.cpp
     GOBJECTPTR(motors, "H_",           AP_MotorsHeli_Single),
 #else
     // @Group: MOT_

From 370e893fb3320e00d451e20a71cc3b1d33851220 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 21:13:04 +1100
Subject: [PATCH 090/200] waf: fixed build docs for arducopter

---
 BUILD.md | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/BUILD.md b/BUILD.md
index 0d1bae4..820f99b 100644
--- a/BUILD.md
+++ b/BUILD.md
@@ -63,7 +63,7 @@ list some basic and more used commands as example.
     uses the `--targets` option that is explained in the next item.
 
     ```sh
-    ./waf --targets bin/arducopter-quad --upload
+    ./waf --targets bin/arducopter --upload
     ```
 
     Currently Linux boards don't support the upload option, but there's an
@@ -92,7 +92,7 @@ list some basic and more used commands as example.
 
     ```
     # Quad frame of ArduCopter
-    ./waf --targets bin/arducopter-quad
+    ./waf --targets bin/arducopter
 
     # unit test of our math functions
     ./waf --targets tests/test_math
@@ -226,7 +226,7 @@ to `build/<board>/` to the option `--targets`. Example:
 
 ```bash
 # Build arducopter for quad frame
-./waf --targets bin/arducopter-quad
+./waf --targets bin/arducopter
 
 # Build vectors unit test
 ./waf --targets tests/test_vectors

From fda31e67d953df94c3a0e41d2dd8c3978123285e Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 21:13:17 +1100
Subject: [PATCH 091/200] autotest: fixed arducopter binary name

---
 Tools/autotest/autotest.py | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/Tools/autotest/autotest.py b/Tools/autotest/autotest.py
index 6fce9aa..c5477c4 100755
--- a/Tools/autotest/autotest.py
+++ b/Tools/autotest/autotest.py
@@ -222,7 +222,7 @@ def skip_step(step):
 
 def binary_path(step, debug=False):
     if step.find("ArduCopter") != -1:
-        binary_name = "arducopter-quad"
+        binary_name = "arducopter"
     elif step.find("ArduPlane") != -1:
         binary_name = "arduplane"
     elif step.find("APMrover2") != -1:
@@ -268,7 +268,7 @@ def run_step(step):
         return util.build_SITL('bin/ardurover', j=opts.j, debug=opts.debug)
 
     if step == 'build.ArduCopter':
-        return util.build_SITL('bin/arducopter-quad', j=opts.j, debug=opts.debug)
+        return util.build_SITL('bin/arducopter', j=opts.j, debug=opts.debug)
 
     if step == 'build.AntennaTracker':
         return util.build_SITL('bin/antennatracker', j=opts.j, debug=opts.debug)

From 7a3c4fd2ee8ad15b24ea5698d92d5a14fc95779d Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Mon, 9 Jan 2017 21:17:02 +1100
Subject: [PATCH 092/200] mk: removed most frame build targets

---
 mk/targets.mk | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/mk/targets.mk b/mk/targets.mk
index 8ae376f..0f26cbc 100644
--- a/mk/targets.mk
+++ b/mk/targets.mk
@@ -108,11 +108,8 @@ qurt: all
 %-asan: OPTFLAGS = -g -O0 -fsanitize=address -fno-omit-frame-pointer
 %-asan: LDFLAGS += -fsanitize=address
 
-# cope with -nologging
-%-nologging: EXTRAFLAGS += "-DLOGGING_ENABLED=DISABLED "
-
 # cope with copter and hil targets
-FRAMES = quad tri hexa y6 octa octa-quad heli single coax obc nologging
+FRAMES = heli
 BOARDS = apm1 apm2 apm2beta apm1-1280 px4 px4-v1 px4-v2 px4-v4 sitl flymaple linux erle pxf navio navio2 raspilot bbbmini minlure erlebrain2 bhat qflight pxfmini
 BOARDS += vrbrain
 BOARDS += vrbrain-v51 vrbrain-v52 vrbrain-v54

From 3fe1a69a32f1ff75240ddd136576c030bbdc7509 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 06:44:54 +1100
Subject: [PATCH 093/200] Copter: always allocate a motors backend

this allows autotest to run, and gives a less confusing error to users
when no FRAME_CLASS error is selected
---
 ArduCopter/system.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index 19b8d30..04b9301 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -542,6 +542,7 @@ void Copter::allocate_motors(void)
         case AP_Motors::MOTOR_FRAME_Y6:
         case AP_Motors::MOTOR_FRAME_OCTA:
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
+        default:
             motors = new AP_MotorsMatrix(MAIN_LOOP_RATE);
             break;
         case AP_Motors::MOTOR_FRAME_TRI:
@@ -555,11 +556,10 @@ void Copter::allocate_motors(void)
             break;
 #else // FRAME_CONFIG == HELI_FRAME
         case AP_Motors::MOTOR_FRAME_HELI:
+        default:
             motors = new AP_MotorsHeli_Single(MAIN_LOOP_RATE);
             break;            
 #endif
-        default:
-            break;
     }
     if (motors == nullptr) {
         AP_HAL::panic("Unable to allocate FRAME_CLASS=%u", (unsigned)g2.frame_class.get());

From d430cd62a6915cb5bc0e379f9ffe63106ac9bfba Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 14:38:45 +1100
Subject: [PATCH 094/200] AP_Param: fixed loading defaults file after storage

make sure defaults don't override storage values
---
 libraries/AP_Param/AP_Param.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/libraries/AP_Param/AP_Param.cpp b/libraries/AP_Param/AP_Param.cpp
index 11805e4..7f8fda8 100644
--- a/libraries/AP_Param/AP_Param.cpp
+++ b/libraries/AP_Param/AP_Param.cpp
@@ -1797,7 +1797,9 @@ bool AP_Param::load_defaults_file(const char *filename, bool panic_on_error)
             AP_HAL::panic("AP_Param: Failed to set param default");
             return false;
         }
-        vp->set_float(value, var_type);
+        if (!vp->configured_in_storage()) {
+            vp->set_float(value, var_type);
+        }
     }
     fclose(f);
 

From bf889e01e16988c1e13c71e24a308aa95ab95eda Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 14:39:04 +1100
Subject: [PATCH 095/200] Copter: load objects from storage after allocation

---
 ArduCopter/system.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index 04b9301..155d339 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -564,6 +564,7 @@ void Copter::allocate_motors(void)
     if (motors == nullptr) {
         AP_HAL::panic("Unable to allocate FRAME_CLASS=%u", (unsigned)g2.frame_class.get());
     }
+    AP_Param::load_object_from_eeprom(motors, motors->var_info);
 
 #if FRAME_CONFIG != HELI_FRAME
     attitude_control = new AC_AttitudeControl_Multi(ahrs, aparm, *motors, MAIN_LOOP_SECONDS);
@@ -573,6 +574,7 @@ void Copter::allocate_motors(void)
     if (attitude_control == nullptr) {
         AP_HAL::panic("Unable to allocate AttitudeControl");
     }
+    AP_Param::load_object_from_eeprom(attitude_control, attitude_control->var_info);
         
     pos_control = new AC_PosControl(ahrs, inertial_nav, *motors, *attitude_control,
                                     g.p_alt_hold, g.p_vel_z, g.pid_accel_z,
@@ -580,16 +582,19 @@ void Copter::allocate_motors(void)
     if (pos_control == nullptr) {
         AP_HAL::panic("Unable to allocate PosControl");
     }
+    AP_Param::load_object_from_eeprom(pos_control, pos_control->var_info);
 
     wp_nav = new AC_WPNav(inertial_nav, ahrs, *pos_control, *attitude_control);
     if (wp_nav == nullptr) {
         AP_HAL::panic("Unable to allocate WPNav");
     }
+    AP_Param::load_object_from_eeprom(wp_nav, wp_nav->var_info);
 
     circle_nav = new AC_Circle(inertial_nav, ahrs, *pos_control);
     if (wp_nav == nullptr) {
         AP_HAL::panic("Unable to allocate CircleNav");
     }
+    AP_Param::load_object_from_eeprom(circle_nav, circle_nav->var_info);
 
     // reload lines from the defaults file that may now be accessible
     AP_Param::reload_defaults_file();

From e248078401c4aabf852493fda8476f99a46a0185 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 16:09:42 +1100
Subject: [PATCH 096/200] SRV_Channel: added AP_Motors servo channel parameter
 upgrading

---
 libraries/SRV_Channel/SRV_Channel.h       |  1 +
 libraries/SRV_Channel/SRV_Channel_aux.cpp | 85 ++++++++++++++++++++++++++++---
 2 files changed, 78 insertions(+), 8 deletions(-)

diff --git a/libraries/SRV_Channel/SRV_Channel.h b/libraries/SRV_Channel/SRV_Channel.h
index 4151bea..67b2050 100644
--- a/libraries/SRV_Channel/SRV_Channel.h
+++ b/libraries/SRV_Channel/SRV_Channel.h
@@ -348,6 +348,7 @@ class SRV_Channels {
 
     // upgrade RC* parameters into SERVO* parameters
     static bool upgrade_parameters(const uint8_t old_keys[14], uint16_t aux_channel_mask, RCMapper *rcmap);
+    static void upgrade_motors_servo(uint8_t ap_motors_key, uint8_t ap_motors_idx, uint8_t new_channel);
     
 private:
     struct {
diff --git a/libraries/SRV_Channel/SRV_Channel_aux.cpp b/libraries/SRV_Channel/SRV_Channel_aux.cpp
index 91ceef8..90ebba6 100644
--- a/libraries/SRV_Channel/SRV_Channel_aux.cpp
+++ b/libraries/SRV_Channel/SRV_Channel_aux.cpp
@@ -632,18 +632,23 @@ bool SRV_Channels::upgrade_parameters(const uint8_t rc_keys[14], uint16_t aux_ch
         }
         SRV_Channel &srv_chan = channels[i];
         RC_Channel &rc_chan = RC_Channels::channels[i];
+        enum {
+            FLAG_NONE=0,
+            FLAG_IS_REVERSE=1,
+            FLAG_AUX_ONLY=2
+        };
         const struct mapping {
             uint8_t old_index;
             AP_Param *new_srv_param;
             AP_Param *new_rc_param;
             enum ap_var_type type;
-            bool is_reverse;
+            uint8_t flags;
         } mapping[] = {
-            { 0, &srv_chan.servo_min,  &rc_chan.radio_min,  AP_PARAM_INT16, false },
-            { 1, &srv_chan.servo_trim, &rc_chan.radio_trim, AP_PARAM_INT16, false },
-            { 2, &srv_chan.servo_max,  &rc_chan.radio_max,  AP_PARAM_INT16, false },
-            { 3, &srv_chan.reversed,   &rc_chan.reversed,   AP_PARAM_INT8,  true },
-            { 1, &srv_chan.function,   nullptr,             AP_PARAM_INT8,  false },
+            { 0, &srv_chan.servo_min,  &rc_chan.radio_min,  AP_PARAM_INT16, FLAG_NONE },
+            { 1, &srv_chan.servo_trim, &rc_chan.radio_trim, AP_PARAM_INT16, FLAG_NONE },
+            { 2, &srv_chan.servo_max,  &rc_chan.radio_max,  AP_PARAM_INT16, FLAG_NONE },
+            { 3, &srv_chan.reversed,   &rc_chan.reversed,   AP_PARAM_INT8,  FLAG_IS_REVERSE },
+            { 1, &srv_chan.function,   nullptr,             AP_PARAM_INT8,  FLAG_AUX_ONLY },
         };
         bool is_aux = aux_channel_mask & (1U<<i);
         
@@ -653,18 +658,23 @@ bool SRV_Channels::upgrade_parameters(const uint8_t rc_keys[14], uint16_t aux_ch
             AP_Int8 v8;
             AP_Int16 v16;
             AP_Param *v = m.type == AP_PARAM_INT16?(AP_Param*)&v16:(AP_Param*)&v8;
+            bool aux_only = (m.flags & FLAG_AUX_ONLY)!=0;
+            if (!is_aux && aux_only) {
+                continue;
+            }
             info.old_key = k;
             info.type = m.type;
             info.new_name = nullptr;
+
             // if this was an aux channel we need to shift by 6 bits, but not for RCn_FUNCTION
-            info.old_group_element = (is_aux && m.new_rc_param)?(m.old_index<<6):m.old_index;
+            info.old_group_element = (is_aux && !aux_only)?(m.old_index<<6):m.old_index;
             
             if (!AP_Param::find_old_parameter(&info, v)) {
                 // the parameter wasn't set in the old eeprom
                 continue;
             }
 
-            if (m.is_reverse) {
+            if (m.flags & FLAG_IS_REVERSE) {
                 // special mapping from RCn_REV to RCn_REVERSED
                 v8.set(v8.get() == -1?1:0);
             }
@@ -710,3 +720,62 @@ bool SRV_Channels::upgrade_parameters(const uint8_t rc_keys[14], uint16_t aux_ch
     return true;
 }
 
+
+
+/*
+  Upgrade servo MIN/MAX/TRIM/REVERSE parameters for a single AP_Motors
+  RC_Channel servo from previous firmwares, setting the equivalent
+  parameter in the new SRV_Channels object
+*/
+void SRV_Channels::upgrade_motors_servo(uint8_t ap_motors_key, uint8_t ap_motors_idx, uint8_t new_channel)
+{
+    SRV_Channel &srv_chan = channels[new_channel];
+    enum {
+        FLAG_NONE=0,
+        FLAG_IS_REVERSE=1
+    };
+    const struct mapping {
+        uint8_t old_index;
+        AP_Param *new_srv_param;
+        enum ap_var_type type;
+        uint8_t flags;
+    } mapping[] = {
+            { 0, &srv_chan.servo_min,  AP_PARAM_INT16, FLAG_NONE },
+            { 1, &srv_chan.servo_trim, AP_PARAM_INT16, FLAG_NONE },
+            { 2, &srv_chan.servo_max,  AP_PARAM_INT16, FLAG_NONE },
+            { 3, &srv_chan.reversed,   AP_PARAM_INT8,  FLAG_IS_REVERSE },
+    };
+        
+    for (uint8_t j=0; j<ARRAY_SIZE(mapping); j++) {
+        const struct mapping &m = mapping[j];
+        AP_Param::ConversionInfo info;
+        AP_Int8 v8;
+        AP_Int16 v16;
+        AP_Param *v = m.type == AP_PARAM_INT16?(AP_Param*)&v16:(AP_Param*)&v8;
+
+        info.old_key = ap_motors_key;
+        info.type = m.type;
+        info.new_name = nullptr;
+        info.old_group_element = ap_motors_idx | (m.old_index<<6);
+        
+        if (!AP_Param::find_old_parameter(&info, v)) {
+            // the parameter wasn't set in the old eeprom
+            continue;
+        }
+
+        if (m.flags & FLAG_IS_REVERSE) {
+            // special mapping from RCn_REV to RCn_REVERSED
+            v8.set(v8.get() == -1?1:0);
+        }
+
+        // we save even if there is already a value in the new eeprom,
+        // as that may come from the equivalent RC channel, not the
+        // old motor servo channel
+        if (m.type == AP_PARAM_INT16) {
+            ((AP_Int16 *)m.new_srv_param)->set_and_save_ifchanged(v16.get());
+        } else {
+            ((AP_Int8 *)m.new_srv_param)->set_and_save_ifchanged(v8.get());
+        }
+    }
+}
+

From 6a12ed0d65031c8d0741b77179a6286d7bbf430f Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 16:09:58 +1100
Subject: [PATCH 097/200] Copter: upgrade heli servo parameters

---
 ArduCopter/Parameters.cpp | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index 139dd4d..c58ad5b 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -1163,5 +1163,13 @@ void Copter::convert_pid_parameters(void)
                                       Parameters::k_param_rc_13_old, Parameters::k_param_rc_14_old };
     const uint16_t old_aux_chan_mask = 0x3FF0;
     // note that we don't pass in rcmap as we don't want output channel functions changed based on rcmap
-    SRV_Channels::upgrade_parameters(old_rc_keys, old_aux_chan_mask, nullptr);
+    if (SRV_Channels::upgrade_parameters(old_rc_keys, old_aux_chan_mask, nullptr)) {
+        // do frame specific upgrade
+#if FRAME_CONFIG == HELI_FRAME
+        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 12, CH_1);
+        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 13, CH_2);
+        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 14, CH_3);
+        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 15, CH_4);
+#endif
+    }
 }

From a56090113cd3ceee2996c0464ca4c514776a2c79 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 16:23:45 +1100
Subject: [PATCH 098/200] autotest: fixed sim_vehicle.py with -f heli

---
 Tools/autotest/sim_vehicle.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Tools/autotest/sim_vehicle.py b/Tools/autotest/sim_vehicle.py
index f9fcad4..365b637 100755
--- a/Tools/autotest/sim_vehicle.py
+++ b/Tools/autotest/sim_vehicle.py
@@ -279,7 +279,7 @@ def find_root_dir():
     # HELICOPTER
     "heli": {
         "make_target": "sitl-heli",
-        "waf_target": "bin/arducopter",
+        "waf_target": "bin/arducopter-heli",
         "default_params_filename": "default_params/copter-heli.parm",
     },
     "heli-dual": {

From a3220944d8c52b1f6564c041bc517ae31ec39c40 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 16:30:03 +1100
Subject: [PATCH 099/200] Copter: make conversion tables constant

---
 ArduCopter/Parameters.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index c58ad5b..4f0e558 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -1083,7 +1083,7 @@ void Copter::load_parameters(void)
 void Copter::convert_pid_parameters(void)
 {
     // conversion info
-    AP_Param::ConversionInfo pid_conversion_info[] = {
+    const AP_Param::ConversionInfo pid_conversion_info[] = {
         { Parameters::k_param_pid_rate_roll, 0, AP_PARAM_FLOAT, "ATC_RAT_RLL_P" },
         { Parameters::k_param_pid_rate_roll, 1, AP_PARAM_FLOAT, "ATC_RAT_RLL_I" },
         { Parameters::k_param_pid_rate_roll, 2, AP_PARAM_FLOAT, "ATC_RAT_RLL_D" },
@@ -1099,7 +1099,7 @@ void Copter::convert_pid_parameters(void)
         { Parameters::k_param_pid_rate_yaw  , 4, AP_PARAM_FLOAT, "ATC_RAT_YAW_VFF" },
 #endif
     };
-    AP_Param::ConversionInfo imax_conversion_info[] = {
+    const AP_Param::ConversionInfo imax_conversion_info[] = {
         { Parameters::k_param_pid_rate_roll,  5, AP_PARAM_FLOAT, "ATC_RAT_RLL_IMAX" },
         { Parameters::k_param_pid_rate_pitch, 5, AP_PARAM_FLOAT, "ATC_RAT_PIT_IMAX" },
         { Parameters::k_param_pid_rate_yaw,   5, AP_PARAM_FLOAT, "ATC_RAT_YAW_IMAX" },
@@ -1109,7 +1109,7 @@ void Copter::convert_pid_parameters(void)
         { Parameters::k_param_pid_rate_yaw,   7, AP_PARAM_FLOAT, "ATC_RAT_YAW_ILMI" },
 #endif
     };
-    AP_Param::ConversionInfo angle_and_filt_conversion_info[] = {
+    const AP_Param::ConversionInfo angle_and_filt_conversion_info[] = {
         { Parameters::k_param_p_stabilize_roll, 0, AP_PARAM_FLOAT, "ATC_ANG_RLL_P" },
         { Parameters::k_param_p_stabilize_pitch, 0, AP_PARAM_FLOAT, "ATC_ANG_PIT_P" },
         { Parameters::k_param_p_stabilize_yaw, 0, AP_PARAM_FLOAT, "ATC_ANG_YAW_P" },
@@ -1117,7 +1117,7 @@ void Copter::convert_pid_parameters(void)
         { Parameters::k_param_pid_rate_pitch, 6, AP_PARAM_FLOAT, "ATC_RAT_PIT_FILT" },
         { Parameters::k_param_pid_rate_yaw, 6, AP_PARAM_FLOAT, "ATC_RAT_YAW_FILT" }
     };
-    AP_Param::ConversionInfo throttle_conversion_info[] = {
+    const AP_Param::ConversionInfo throttle_conversion_info[] = {
         { Parameters::k_param_throttle_min, 0, AP_PARAM_FLOAT, "MOT_SPIN_MIN" },
         { Parameters::k_param_throttle_mid, 0, AP_PARAM_FLOAT, "MOT_THST_HOVER" }
     };

From 05e9462a9c31cc71f11b6bef439da8c8d00d14df Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 17:07:53 +1100
Subject: [PATCH 100/200] AP_Param: added CONVERT_FLAG_REVERSE and
 CONVERT_FLAG_FORCE

---
 libraries/AP_Param/AP_Param.cpp | 14 +++++++++-----
 libraries/AP_Param/AP_Param.h   |  8 ++++++--
 2 files changed, 15 insertions(+), 7 deletions(-)

diff --git a/libraries/AP_Param/AP_Param.cpp b/libraries/AP_Param/AP_Param.cpp
index 7f8fda8..3e45763 100644
--- a/libraries/AP_Param/AP_Param.cpp
+++ b/libraries/AP_Param/AP_Param.cpp
@@ -1592,7 +1592,7 @@ bool AP_Param::find_old_parameter(const struct ConversionInfo *info, AP_Param *v
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wformat"
 // convert one old vehicle parameter to new object parameter
-void AP_Param::convert_old_parameter(const struct ConversionInfo *info, float scaler)
+void AP_Param::convert_old_parameter(const struct ConversionInfo *info, float scaler, uint8_t flags)
 {
     uint8_t old_value[type_size(info->type)];
     AP_Param *ap = (AP_Param *)&old_value[0];
@@ -1614,14 +1614,14 @@ void AP_Param::convert_old_parameter(const struct ConversionInfo *info, float sc
     }
 
     // see if we can load it from EEPROM
-    if (ap2->load()) {
+    if (!(flags & CONVERT_FLAG_FORCE) && ap2->configured_in_storage()) {
         // the new parameter already has a value set by the user, or
         // has already been converted
         return;
     }
 
     // see if they are the same type and no scaling applied
-    if (ptype == info->type && is_equal(scaler, 1.0f)) {
+    if (ptype == info->type && is_equal(scaler, 1.0f) && flags == 0) {
         // copy the value over only if the new parameter does not already
         // have the old value (via a default).
         if (memcmp(ap2, ap, sizeof(old_value)) != 0) {
@@ -1632,6 +1632,10 @@ void AP_Param::convert_old_parameter(const struct ConversionInfo *info, float sc
     } else if (ptype <= AP_PARAM_FLOAT && info->type <= AP_PARAM_FLOAT) {
         // perform scalar->scalar conversion
         float v = ap->cast_to_float(info->type);
+        if (flags & CONVERT_FLAG_REVERSE) {
+            // convert a _REV parameter to a _REVERSED parameter
+            v = is_equal(v, -1.0f)?1:0;
+        }
         if (!is_equal(v,ap2->cast_to_float(ptype))) {
             // the value needs to change
             set_value(ptype, ap2, v * scaler);
@@ -1646,10 +1650,10 @@ void AP_Param::convert_old_parameter(const struct ConversionInfo *info, float sc
 
 
 // convert old vehicle parameters to new object parametersv
-void AP_Param::convert_old_parameters(const struct ConversionInfo *conversion_table, uint8_t table_size)
+void AP_Param::convert_old_parameters(const struct ConversionInfo *conversion_table, uint8_t table_size, uint8_t flags)
 {
     for (uint8_t i=0; i<table_size; i++) {
-        convert_old_parameter(&conversion_table[i], 1.0f);
+        convert_old_parameter(&conversion_table[i], 1.0f, flags);
     }
 }
 
diff --git a/libraries/AP_Param/AP_Param.h b/libraries/AP_Param/AP_Param.h
index 28f96de..22033d8 100644
--- a/libraries/AP_Param/AP_Param.h
+++ b/libraries/AP_Param/AP_Param.h
@@ -296,10 +296,14 @@ class AP_Param
     static bool find_old_parameter(const struct ConversionInfo *info, AP_Param *value);
     
     // convert old vehicle parameters to new object parameters
-    static void         convert_old_parameters(const struct ConversionInfo *conversion_table, uint8_t table_size);
+    static void         convert_old_parameters(const struct ConversionInfo *conversion_table, uint8_t table_size, uint8_t flags=0);
 
     // convert a single parameter with scaling
-    static void         convert_old_parameter(const struct ConversionInfo *info, float scaler);
+    enum {
+        CONVERT_FLAG_REVERSE=1, // handle _REV -> _REVERSED conversion
+        CONVERT_FLAG_FORCE=2    // store new value even if configured in eeprom already
+    };
+    static void         convert_old_parameter(const struct ConversionInfo *info, float scaler, uint8_t flags=0);
 
     /// Erase all variables in EEPROM.
     ///

From 7aee3500e196dcfa2ea43a24dc1b92a09080463f Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 17:08:12 +1100
Subject: [PATCH 101/200] Copter: added conversion of tricopter tail servo
 parameters

---
 ArduCopter/Parameters.cpp | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index 4f0e558..1f3b9f1 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -1164,12 +1164,25 @@ void Copter::convert_pid_parameters(void)
     const uint16_t old_aux_chan_mask = 0x3FF0;
     // note that we don't pass in rcmap as we don't want output channel functions changed based on rcmap
     if (SRV_Channels::upgrade_parameters(old_rc_keys, old_aux_chan_mask, nullptr)) {
-        // do frame specific upgrade
+        // do frame specific upgrade. This is only done the first time we run the new firmware
 #if FRAME_CONFIG == HELI_FRAME
         SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 12, CH_1);
         SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 13, CH_2);
         SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 14, CH_3);
         SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 15, CH_4);
+#else
+        if (g2.frame_class == AP_Motors::MOTOR_FRAME_TRI) {
+            const AP_Param::ConversionInfo tri_conversion_info[] = {
+                { Parameters::k_param_motors, 32, AP_PARAM_INT16, "SERVO7_TRIM" },
+                { Parameters::k_param_motors, 33, AP_PARAM_INT16, "SERVO7_MIN" },
+                { Parameters::k_param_motors, 34, AP_PARAM_INT16, "SERVO7_MAX" },
+                { Parameters::k_param_motors, 35, AP_PARAM_FLOAT, "MOT_YAW_SV_ANGLE" },
+            };
+            // we need to use CONVERT_FLAG_FORCE as the SERVO7_* parameters will already be set from RC7_*
+            AP_Param::convert_old_parameters(tri_conversion_info, ARRAY_SIZE(tri_conversion_info), AP_Param::CONVERT_FLAG_FORCE);
+            const AP_Param::ConversionInfo tri_conversion_info_rev { Parameters::k_param_motors, 31, AP_PARAM_INT8,  "SERVO7_REVERSED" };
+            AP_Param::convert_old_parameter(&tri_conversion_info_rev, 1, AP_Param::CONVERT_FLAG_REVERSE | AP_Param::CONVERT_FLAG_FORCE);
+        }
 #endif
     }
 }

From d005cbffd8ca1f24ab7a270fa6f99a0e41c31f35 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 17:48:36 +1100
Subject: [PATCH 102/200] AP_Param: added convert_parent_class()

---
 libraries/AP_Param/AP_Param.cpp | 29 +++++++++++++++++++++++++++++
 libraries/AP_Param/AP_Param.h   |  6 +++++-
 2 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/libraries/AP_Param/AP_Param.cpp b/libraries/AP_Param/AP_Param.cpp
index 3e45763..2eb0da8 100644
--- a/libraries/AP_Param/AP_Param.cpp
+++ b/libraries/AP_Param/AP_Param.cpp
@@ -1657,6 +1657,35 @@ void AP_Param::convert_old_parameters(const struct ConversionInfo *conversion_ta
     }
 }
 
+/*
+  move old class variables for a class that was sub-classed to one that isn't
+  For example, used when the AP_MotorsTri class changed from having its own parameter table
+  plus a subgroup for AP_MotorsMulticopter to just inheriting the AP_MotorsMulticopter var_info
+
+  This does not handle nesting beyond the single level shift
+*/
+void AP_Param::convert_parent_class(uint8_t param_key, void *object_pointer,
+                                    const struct AP_Param::GroupInfo *group_info)
+{
+    for (uint8_t i=0; group_info[i].type != AP_PARAM_NONE; i++) {
+        struct ConversionInfo info;
+        info.old_key = param_key;
+        info.type = (ap_var_type)group_info[i].type;
+        info.new_name = nullptr;
+        info.old_group_element = uint16_t(group_info[i].idx)<<6;
+        uint8_t old_value[type_size(info.type)];
+        AP_Param *ap = (AP_Param *)&old_value[0];
+        
+        if (!AP_Param::find_old_parameter(&info, ap)) {
+            // the parameter wasn't set in the old eeprom
+            continue;
+        }
+
+        uint8_t *new_value = group_info[i].offset + (uint8_t *)object_pointer;
+        memcpy(new_value, old_value, sizeof(old_value));
+    }
+}
+
 
 /*
   set a parameter to a float value
diff --git a/libraries/AP_Param/AP_Param.h b/libraries/AP_Param/AP_Param.h
index 22033d8..e5c43a3 100644
--- a/libraries/AP_Param/AP_Param.h
+++ b/libraries/AP_Param/AP_Param.h
@@ -121,7 +121,7 @@ class AP_Param
     };
     struct ConversionInfo {
         uint16_t old_key; // k_param_*
-        uint8_t old_group_element; // index in old object
+        uint32_t old_group_element; // index in old object
         enum ap_var_type type; // AP_PARAM_*
         const char *new_name;
     };
@@ -305,6 +305,10 @@ class AP_Param
     };
     static void         convert_old_parameter(const struct ConversionInfo *info, float scaler, uint8_t flags=0);
 
+    // move old class variables for a class that was sub-classed to one that isn't
+    static void         convert_parent_class(uint8_t param_key, void *object_pointer,
+                                             const struct AP_Param::GroupInfo *group_info);
+    
     /// Erase all variables in EEPROM.
     ///
     static void         erase_all(void);

From 1297a7dedbac0883ee28e9cb36813262e0514f34 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Tue, 10 Jan 2017 17:48:51 +1100
Subject: [PATCH 103/200] Copter: convert the rest of motors class for
 tricopter

---
 ArduCopter/Copter.h       |  3 +++
 ArduCopter/Parameters.cpp | 22 ++--------------------
 ArduCopter/system.cpp     | 25 +++++++++++++++++++++++++
 3 files changed, 30 insertions(+), 20 deletions(-)

diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index 926b55d..5a384ea 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -608,6 +608,9 @@ class Copter : public AP_HAL::HAL::Callbacks {
         float takeoff_alt_cm;
     } gndeffect_state;
 
+    // set when we are upgrading parameters from 3.4
+    bool upgrading_frame_params;
+    
     static const AP_Scheduler::Task scheduler_tasks[];
     static const AP_Param::Info var_info[];
     static const struct LogStructure log_structure[];
diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index 1f3b9f1..1f2d97a 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -1164,25 +1164,7 @@ void Copter::convert_pid_parameters(void)
     const uint16_t old_aux_chan_mask = 0x3FF0;
     // note that we don't pass in rcmap as we don't want output channel functions changed based on rcmap
     if (SRV_Channels::upgrade_parameters(old_rc_keys, old_aux_chan_mask, nullptr)) {
-        // do frame specific upgrade. This is only done the first time we run the new firmware
-#if FRAME_CONFIG == HELI_FRAME
-        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 12, CH_1);
-        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 13, CH_2);
-        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 14, CH_3);
-        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 15, CH_4);
-#else
-        if (g2.frame_class == AP_Motors::MOTOR_FRAME_TRI) {
-            const AP_Param::ConversionInfo tri_conversion_info[] = {
-                { Parameters::k_param_motors, 32, AP_PARAM_INT16, "SERVO7_TRIM" },
-                { Parameters::k_param_motors, 33, AP_PARAM_INT16, "SERVO7_MIN" },
-                { Parameters::k_param_motors, 34, AP_PARAM_INT16, "SERVO7_MAX" },
-                { Parameters::k_param_motors, 35, AP_PARAM_FLOAT, "MOT_YAW_SV_ANGLE" },
-            };
-            // we need to use CONVERT_FLAG_FORCE as the SERVO7_* parameters will already be set from RC7_*
-            AP_Param::convert_old_parameters(tri_conversion_info, ARRAY_SIZE(tri_conversion_info), AP_Param::CONVERT_FLAG_FORCE);
-            const AP_Param::ConversionInfo tri_conversion_info_rev { Parameters::k_param_motors, 31, AP_PARAM_INT8,  "SERVO7_REVERSED" };
-            AP_Param::convert_old_parameter(&tri_conversion_info_rev, 1, AP_Param::CONVERT_FLAG_REVERSE | AP_Param::CONVERT_FLAG_FORCE);
-        }
-#endif
+        // the rest needs to be done after motors allocation
+        upgrading_frame_params = true;
     }
 }
diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index 155d339..9ecff11 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -615,4 +615,29 @@ void Copter::allocate_motors(void)
     default:
         break;
     }
+
+    if (upgrading_frame_params) {
+        // do frame specific upgrade. This is only done the first time we run the new firmware
+#if FRAME_CONFIG == HELI_FRAME
+        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 12, CH_1);
+        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 13, CH_2);
+        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 14, CH_3);
+        SRV_Channels::upgrade_motors_servo(Parameters::k_param_motors, 15, CH_4);
+#else
+        if (g2.frame_class == AP_Motors::MOTOR_FRAME_TRI) {
+            const AP_Param::ConversionInfo tri_conversion_info[] = {
+                { Parameters::k_param_motors, 32, AP_PARAM_INT16, "SERVO7_TRIM" },
+                { Parameters::k_param_motors, 33, AP_PARAM_INT16, "SERVO7_MIN" },
+                { Parameters::k_param_motors, 34, AP_PARAM_INT16, "SERVO7_MAX" },
+                { Parameters::k_param_motors, 35, AP_PARAM_FLOAT, "MOT_YAW_SV_ANGLE" },
+            };
+            // we need to use CONVERT_FLAG_FORCE as the SERVO7_* parameters will already be set from RC7_*
+            AP_Param::convert_old_parameters(tri_conversion_info, ARRAY_SIZE(tri_conversion_info), AP_Param::CONVERT_FLAG_FORCE);
+            const AP_Param::ConversionInfo tri_conversion_info_rev { Parameters::k_param_motors, 31, AP_PARAM_INT8,  "SERVO7_REVERSED" };
+            AP_Param::convert_old_parameter(&tri_conversion_info_rev, 1, AP_Param::CONVERT_FLAG_REVERSE | AP_Param::CONVERT_FLAG_FORCE);
+            // AP_MotorsTri was converted from having nested var_info to one level
+            AP_Param::convert_parent_class(Parameters::k_param_motors, motors, motors->var_info);
+        }
+#endif
+    }
 }

From 978d32ff126874dba0d0466ea0c0e8ae494dc273 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 12 Jan 2017 21:30:17 +1100
Subject: [PATCH 104/200] autotest: fixed JSBSim plane defaults

---
 Tools/autotest/default_params/plane-jsbsim.parm | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/Tools/autotest/default_params/plane-jsbsim.parm b/Tools/autotest/default_params/plane-jsbsim.parm
index 391ff24..9a0d5cd 100644
--- a/Tools/autotest/default_params/plane-jsbsim.parm
+++ b/Tools/autotest/default_params/plane-jsbsim.parm
@@ -18,6 +18,8 @@ KFF_RDDRMIX     0.5
 THR_MAX		100
 RC2_REVERSED	1
 RC4_REVERSED	1
+SERVO2_REVERSED 1
+SERVO4_REVERSED 1
 RC1_MAX         2000
 RC1_MIN         1000
 RC1_TRIM        1500

From 746b0dd3764d6f06dad509a25ff85cd5c6f7cdf1 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Thu, 12 Jan 2017 21:37:33 +1100
Subject: [PATCH 105/200] Tools: fixed build_binaries for new build names

---
 Tools/scripts/build_binaries.sh | 28 +++++++++++++++++++---------
 1 file changed, 19 insertions(+), 9 deletions(-)

diff --git a/Tools/scripts/build_binaries.sh b/Tools/scripts/build_binaries.sh
index 7115015..7fce52b 100755
--- a/Tools/scripts/build_binaries.sh
+++ b/Tools/scripts/build_binaries.sh
@@ -129,7 +129,7 @@ skip_frame() {
     sboard=$1
     sframe=$2
     if [ "$sboard" = "bebop" ]; then
-        if [ "$sframe" != "quad" ]; then
+        if [ "$sframe" != "quad" -a "$sframe" != "none" ]; then
             return 0
         fi
     fi
@@ -296,7 +296,7 @@ build_arducopter() {
     # work out what frames to build by looking for FRAME_CLASS parameter
     checkout ArduCopter $tag "" ""
     if grep -q FRAME_CLASS ArduCopter/Parameters.cpp; then
-        frames="quad heli"
+        frames="none heli"
     else
         frames="quad tri hexa y6 octa octa-quad heli"
     fi
@@ -308,6 +308,11 @@ build_arducopter() {
     for b in erlebrain2 navio navio2 pxf pxfmini bebop; do
         echo "Building board: $b"
         for f in $frames; do
+            if [ "$f" = "none" ]; then
+                framesuffix=""
+            else
+                framesuffix="-$f"
+            fi
             echo "Building frame $f for board $b"
             checkout ArduCopter $tag $b $f || {
                 echo "Failed checkout of ArduCopter $b $tag $f"
@@ -316,23 +321,28 @@ build_arducopter() {
             }
             skip_board_waf $b && continue
             echo "Building ArduCopter $tag $b binaries $f"
-            ddir=$binaries/Copter/$hdate/$b-$f
+            ddir=$binaries/Copter/$hdate/$b$framesuffix
             skip_build $tag $ddir && continue
             skip_frame $b $f && continue
             options=$(board_options $b)
             waf configure --board $b $options --out $BUILDROOT clean \
-                    build --targets bin/arducopter-$f || {
-                echo "Failed build of ArduCopter $b-$f $tag"
+                    build --targets bin/arducopter$framesuffix || {
+                echo "Failed build of ArduCopter $b$framesuffix $tag"
                 error_count=$((error_count+1))
                 continue
             }
-            copyit $BUILDROOT/$b/bin/arducopter-$f $ddir $tag "ArduCopter"
+            copyit $BUILDROOT/$b/bin/arducopter$framesuffix $ddir $tag "ArduCopter"
             touch $binaries/Copter/$tag
         done
     done
     pushd ArduCopter
     for f in $frames; do
         echo "Building frame $f for board PX4"
+        if [ "$f" = "none" ]; then
+            framesuffix=""
+        else
+            framesuffix="-$f"
+        fi
         checkout ArduCopter $tag PX4 $f || {
             echo "Failed checkout of ArduCopter PX4 $tag $f"
             error_count=$((error_count+1))
@@ -340,12 +350,12 @@ build_arducopter() {
             continue
         }
         rm -rf ../Build.ArduCopter
-        echo "Building ArduCopter $tag PX4-$f binaries"
-        ddir="$binaries/Copter/$hdate/PX4-$f"
+        echo "Building ArduCopter $tag PX4$framesuffix binaries"
+        ddir="$binaries/Copter/$hdate/PX4$framesuffix"
         skip_build $tag $ddir && continue
         for v in v1 v2 v3 v4; do
             make px4-clean
-            make px4-$v-$f -j2 || {
+            make px4-$v$framesuffix -j2 || {
                 echo "Failed build of ArduCopter PX4 $tag for $v"
                 error_count=$((error_count+1))
                 continue

From e52cff3f0b5f7c06d99f7880b3aaef00d511899b Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 13 Jan 2017 08:33:57 +1100
Subject: [PATCH 106/200] autotest: fixed throttle range for default parameters

---
 Tools/autotest/default_params/firefly.parm           | 2 ++
 Tools/autotest/default_params/plane-elevons.parm     | 2 ++
 Tools/autotest/default_params/plane-jsbsim.parm      | 2 ++
 Tools/autotest/default_params/plane-vtail.parm       | 2 ++
 Tools/autotest/default_params/plane.parm             | 2 ++
 Tools/autotest/default_params/quadplane-tilttri.parm | 2 ++
 Tools/autotest/default_params/quadplane-tri.parm     | 2 ++
 Tools/autotest/default_params/quadplane.parm         | 2 ++
 Tools/autotest/default_params/rover-skid.parm        | 4 ++++
 Tools/autotest/default_params/rover.parm             | 2 ++
 10 files changed, 22 insertions(+)

diff --git a/Tools/autotest/default_params/firefly.parm b/Tools/autotest/default_params/firefly.parm
index 8eafe6a..55c3048 100644
--- a/Tools/autotest/default_params/firefly.parm
+++ b/Tools/autotest/default_params/firefly.parm
@@ -56,6 +56,8 @@ RC1_MIN          1087
 RC1_TRIM         1500
 RC3_MAX          2000
 RC3_MIN          1000
+SERVO3_MIN       1000
+SERVO3_MAX       2000
 RLL2SRV_D        0.141009
 RLL2SRV_I        0.425000
 RLL2SRV_IMAX     4000
diff --git a/Tools/autotest/default_params/plane-elevons.parm b/Tools/autotest/default_params/plane-elevons.parm
index a5e6f5f..ac9150e 100644
--- a/Tools/autotest/default_params/plane-elevons.parm
+++ b/Tools/autotest/default_params/plane-elevons.parm
@@ -27,6 +27,8 @@ RC2_TRIM        1500
 RC3_MAX         2000
 RC3_MIN         1000
 RC3_TRIM        1000
+SERVO3_MIN      1000
+SERVO3_MAX      2000
 RC4_MAX         2000
 RC4_MIN         1000
 RC4_TRIM        1500
diff --git a/Tools/autotest/default_params/plane-jsbsim.parm b/Tools/autotest/default_params/plane-jsbsim.parm
index 9a0d5cd..636bd74 100644
--- a/Tools/autotest/default_params/plane-jsbsim.parm
+++ b/Tools/autotest/default_params/plane-jsbsim.parm
@@ -29,6 +29,8 @@ RC2_TRIM        1500
 RC3_MAX         2000
 RC3_MIN         1000
 RC3_TRIM        1000
+SERVO3_MIN      1000
+SERVO3_MAX      2000
 RC4_MAX         2000
 RC4_MIN         1000
 RC4_TRIM        1500
diff --git a/Tools/autotest/default_params/plane-vtail.parm b/Tools/autotest/default_params/plane-vtail.parm
index 041c00f..ce5da15 100644
--- a/Tools/autotest/default_params/plane-vtail.parm
+++ b/Tools/autotest/default_params/plane-vtail.parm
@@ -25,6 +25,8 @@ RC2_TRIM        1500
 RC3_MAX         2000
 RC3_MIN         1000
 RC3_TRIM        1000
+SERVO3_MIN      1000
+SERVO3_MAX      2000
 RC4_MAX         2000
 RC4_MIN         1000
 RC4_TRIM        1500
diff --git a/Tools/autotest/default_params/plane.parm b/Tools/autotest/default_params/plane.parm
index 57e27a5..2bb423e 100644
--- a/Tools/autotest/default_params/plane.parm
+++ b/Tools/autotest/default_params/plane.parm
@@ -24,6 +24,8 @@ RC2_MIN         1000
 RC2_TRIM        1500
 RC3_MAX         2000
 RC3_MIN         1000
+SERVO3_MIN      1000
+SERVO3_MAX      2000
 RC3_TRIM        1000
 RC4_MAX         2000
 RC4_MIN         1000
diff --git a/Tools/autotest/default_params/quadplane-tilttri.parm b/Tools/autotest/default_params/quadplane-tilttri.parm
index cd7b7ed..14b16fc 100644
--- a/Tools/autotest/default_params/quadplane-tilttri.parm
+++ b/Tools/autotest/default_params/quadplane-tilttri.parm
@@ -59,6 +59,8 @@ RC1_MIN          1087
 RC1_TRIM         1500
 RC3_MAX          2000
 RC3_MIN          1000
+SERVO3_MIN       1000
+SERVO3_MAX       2000
 RLL2SRV_D        0.141009
 RLL2SRV_I        0.425000
 RLL2SRV_IMAX     4000
diff --git a/Tools/autotest/default_params/quadplane-tri.parm b/Tools/autotest/default_params/quadplane-tri.parm
index cd157de..b4a87a9 100644
--- a/Tools/autotest/default_params/quadplane-tri.parm
+++ b/Tools/autotest/default_params/quadplane-tri.parm
@@ -59,6 +59,8 @@ RC1_MIN          1087
 RC1_TRIM         1500
 RC3_MAX          2000
 RC3_MIN          1000
+SERVO3_MIN       1000
+SERVO3_MAX       2000
 RLL2SRV_D        0.141009
 RLL2SRV_I        0.425000
 RLL2SRV_IMAX     4000
diff --git a/Tools/autotest/default_params/quadplane.parm b/Tools/autotest/default_params/quadplane.parm
index f4e08da..1b683de 100644
--- a/Tools/autotest/default_params/quadplane.parm
+++ b/Tools/autotest/default_params/quadplane.parm
@@ -57,6 +57,8 @@ RC1_MIN          1087
 RC1_TRIM         1500
 RC3_MAX          2000
 RC3_MIN          1000
+SERVO3_MIN       1000
+SERVO3_MAX       2000
 RLL2SRV_D        0.141009
 RLL2SRV_I        0.425000
 RLL2SRV_IMAX     4000
diff --git a/Tools/autotest/default_params/rover-skid.parm b/Tools/autotest/default_params/rover-skid.parm
index 6679710..b2f38cd 100644
--- a/Tools/autotest/default_params/rover-skid.parm
+++ b/Tools/autotest/default_params/rover-skid.parm
@@ -12,6 +12,10 @@ RC3_TRIM        1500
 RC1_MAX         2000
 RC1_MIN         1000
 RC1_TRIM        1500
+SERVO1_MIN      1000
+SERVO1_MAX      2000
+SERVO3_MIN      1000
+SERVO3_MAX      2000
 MODE1        0
 MODE2        0
 MODE3        11
diff --git a/Tools/autotest/default_params/rover.parm b/Tools/autotest/default_params/rover.parm
index 127e7da..326e731 100644
--- a/Tools/autotest/default_params/rover.parm
+++ b/Tools/autotest/default_params/rover.parm
@@ -8,6 +8,8 @@ THR_MAX		100
 RC3_MAX         2000
 RC3_MIN         1000
 RC3_TRIM        1500
+SERVO3_MIN      1000
+SERVO3_MAX      2000
 RC1_MAX         2000
 RC1_MIN         1000
 RC1_TRIM        1500

From 960da452754a24ef77e7f48390768b80147545c0 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 13 Jan 2017 08:43:28 +1100
Subject: [PATCH 107/200] mk: fixed px4-v3 build with make

---
 mk/targets.mk | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mk/targets.mk b/mk/targets.mk
index 0f26cbc..1f19e8b 100644
--- a/mk/targets.mk
+++ b/mk/targets.mk
@@ -110,7 +110,7 @@ qurt: all
 
 # cope with copter and hil targets
 FRAMES = heli
-BOARDS = apm1 apm2 apm2beta apm1-1280 px4 px4-v1 px4-v2 px4-v4 sitl flymaple linux erle pxf navio navio2 raspilot bbbmini minlure erlebrain2 bhat qflight pxfmini
+BOARDS = apm1 apm2 apm2beta apm1-1280 px4 px4-v1 px4-v2 px4-v3 px4-v4 sitl flymaple linux erle pxf navio navio2 raspilot bbbmini minlure erlebrain2 bhat qflight pxfmini
 BOARDS += vrbrain
 BOARDS += vrbrain-v51 vrbrain-v52 vrbrain-v54
 BOARDS += vrcore-v10

From 87c2dfd9212ad00cdf733af1463e4516fe4d447a Mon Sep 17 00:00:00 2001
From: murata <ma2maru@gmail.com>
Date: Thu, 12 Jan 2017 21:35:11 +0900
Subject: [PATCH 108/200] AP_Baro: Change to secure code, from magic number to
 sizeof value.

---
 libraries/AP_Baro/AP_Baro_BMP085.cpp | 6 +++---
 libraries/AP_Baro/AP_Baro_MS5611.cpp | 4 ++--
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/libraries/AP_Baro/AP_Baro_BMP085.cpp b/libraries/AP_Baro/AP_Baro_BMP085.cpp
index cf8a1c7..4873e0e 100644
--- a/libraries/AP_Baro/AP_Baro_BMP085.cpp
+++ b/libraries/AP_Baro/AP_Baro_BMP085.cpp
@@ -53,7 +53,7 @@ AP_Baro_BMP085::AP_Baro_BMP085(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::I2CDevice>
     }
 
     // We read the calibration data registers
-    if (!_dev->read_registers(0xAA, buff, 22)) {
+    if (!_dev->read_registers(0xAA, buff, sizeof(buff))) {
         AP_HAL::panic("BMP085: bad calibration registers");
     }
 
@@ -140,7 +140,7 @@ bool AP_Baro_BMP085::_read_pressure()
 {
     uint8_t buf[3];
 
-    if (!_dev->read_registers(0xF6, buf, 3)) {
+    if (!_dev->read_registers(0xF6, buf, sizeof(buf))) {
         _retry_time = AP_HAL::millis() + 1000;
         _dev->set_speed(AP_HAL::Device::SPEED_LOW);
         return false;
@@ -165,7 +165,7 @@ void AP_Baro_BMP085::_read_temp()
     uint8_t buf[2];
     int32_t _temp_sensor;
 
-    if (!_dev->read_registers(0xF6, buf, 2)) {
+    if (!_dev->read_registers(0xF6, buf, sizeof(buf))) {
         _dev->set_speed(AP_HAL::Device::SPEED_LOW);
         return;
     }
diff --git a/libraries/AP_Baro/AP_Baro_MS5611.cpp b/libraries/AP_Baro/AP_Baro_MS5611.cpp
index 68e4bca..90cbb26 100644
--- a/libraries/AP_Baro/AP_Baro_MS5611.cpp
+++ b/libraries/AP_Baro/AP_Baro_MS5611.cpp
@@ -173,7 +173,7 @@ uint16_t AP_Baro_MS56XX::_read_prom_word(uint8_t word)
 {
     const uint8_t reg = CMD_MS56XX_PROM + (word << 1);
     uint8_t val[2];
-    if (!_dev->transfer(&reg, 1, val, 2)) {
+    if (!_dev->transfer(&reg, 1, val, sizeof(val))) {
         return 0;
     }
     return (val[0] << 8) | val[1];
@@ -182,7 +182,7 @@ uint16_t AP_Baro_MS56XX::_read_prom_word(uint8_t word)
 uint32_t AP_Baro_MS56XX::_read_adc()
 {
     uint8_t val[3];
-    if (!_dev->transfer(&CMD_MS56XX_READ_ADC, 1, val, 3)) {
+    if (!_dev->transfer(&CMD_MS56XX_READ_ADC, 1, val, sizeof(val))) {
         return 0;
     }
     return (val[0] << 16) | (val[1] << 8) | val[2];

From 07e5b431328904f9f0b58e8ce8e7428d153526b6 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Fri, 13 Jan 2017 07:45:18 +0900
Subject: [PATCH 109/200] Tools: add FRAME_CLASS to bebop parameter files

---
 Tools/Frame_params/Parrot_Bebop.param  | 3 ++-
 Tools/Frame_params/Parrot_Bebop2.param | 4 +++-
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/Tools/Frame_params/Parrot_Bebop.param b/Tools/Frame_params/Parrot_Bebop.param
index 3a1463c..471f5c1 100644
--- a/Tools/Frame_params/Parrot_Bebop.param
+++ b/Tools/Frame_params/Parrot_Bebop.param
@@ -1,4 +1,4 @@
-#NOTE: Bebop default parameters
+#NOTE: Bebop default parameters (Copter-3.4 and higher)
 ARMING_CHECK,126
 ATC_ACCEL_P_MAX,220000
 ATC_ACCEL_R_MAX,220000
@@ -20,6 +20,7 @@ ATC_ANG_RLL_P,10
 ATC_ANG_YAW_P,12
 BATT_MONITOR,6
 BATT_CAPACITY,1200
+FRAME_CLASS,1
 FS_THR_ENABLE,1
 GND_EFFECT_COMP,1
 INS_GYRO_FILTER,40
diff --git a/Tools/Frame_params/Parrot_Bebop2.param b/Tools/Frame_params/Parrot_Bebop2.param
index 796e124..09c4559 100644
--- a/Tools/Frame_params/Parrot_Bebop2.param
+++ b/Tools/Frame_params/Parrot_Bebop2.param
@@ -1,4 +1,4 @@
-#NOTE: Bebop2 parameter defaults (Copter-3.4)
+#NOTE: Bebop2 parameter defaults (Copter-3.4 and higher)
 ARMING_CHECK,126
 ATC_ACCEL_P_MAX,220000
 ATC_ACCEL_R_MAX,220000
@@ -22,6 +22,8 @@ BATT_MONITOR,6
 BATT_CAPACITY,2700
 COMPASS_EXTERNAL,1
 COMPASS_ORIENT,2
+FRAME_CLASS,1
+FRAME_TYPE,3
 FRAME,3
 FS_THR_ENABLE,1
 GND_EFFECT_COMP,1

From b8784e2c4a5b30d3069ef0881f5e7726e433941b Mon Sep 17 00:00:00 2001
From: Tom Pittenger <magicrub@gmail.com>
Date: Tue, 10 Jan 2017 22:52:12 -0800
Subject: [PATCH 110/200] Plane: do not crosstrack after a land abort

---
 ArduPlane/GCS_Mavlink.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/ArduPlane/GCS_Mavlink.cpp b/ArduPlane/GCS_Mavlink.cpp
index a0e6dc3..388b5be 100644
--- a/ArduPlane/GCS_Mavlink.cpp
+++ b/ArduPlane/GCS_Mavlink.cpp
@@ -1359,6 +1359,7 @@ void GCS_MAVLINK_Plane::handleMessage(mavlink_message_t* msg)
                     plane.auto_state.takeoff_altitude_rel_cm = packet.param1 * 100;
                 }
                 if (plane.landing.request_go_around()) {
+                    plane.auto_state.next_wp_no_crosstrack = true;
                     result = MAV_RESULT_ACCEPTED;
                 }
             }

From 4daa4e9df95f85911c36951352dc05ccc6e3e06c Mon Sep 17 00:00:00 2001
From: Mathieu OTHACEHE <mathieu.othacehe@parrot.com>
Date: Thu, 12 Jan 2017 17:13:40 +0100
Subject: [PATCH 111/200] Tools: remove deleted parameters

RCx_REV and SERVO_RNG_ENABLE no longer exists, they need to be erased
from param files.
---
 Tools/Frame_params/3DR_Iris+.param                    | 1 -
 Tools/Frame_params/3DR_Iris+_AC34.param               | 1 -
 Tools/Frame_params/3DR_QUAD_X4_RTF.param              | 1 -
 Tools/Frame_params/3DR_X8+_RTF.param                  | 1 -
 Tools/Frame_params/3DR_X8-M_RTF.param                 | 1 -
 Tools/Frame_params/3DR_X8_RTF.param                   | 1 -
 Tools/Frame_params/3DR_Y6B_RTF.param                  | 1 -
 Tools/Frame_params/Iris with Front Mount Go Pro.param | 1 -
 Tools/Frame_params/Iris with Tarot Gimbal.param       | 1 -
 Tools/Frame_params/Iris.param                         | 1 -
 Tools/Frame_params/Parrot_Disco/Parrot_Disco.param    | 2 --
 11 files changed, 12 deletions(-)

diff --git a/Tools/Frame_params/3DR_Iris+.param b/Tools/Frame_params/3DR_Iris+.param
index 9c91c5b..5accf0e 100644
--- a/Tools/Frame_params/3DR_Iris+.param
+++ b/Tools/Frame_params/3DR_Iris+.param
@@ -72,7 +72,6 @@ RC_FEEL_RP,25
 RC9_FUNCTION,7
 RC9_MAX,1520
 RC9_MIN,1000
-RC9_REV,1
 RTL_ALT,2000
 SERIAL2_PROTOCOL,3
 STB_PIT_P,11.25
diff --git a/Tools/Frame_params/3DR_Iris+_AC34.param b/Tools/Frame_params/3DR_Iris+_AC34.param
index b6e451e..72653aa 100644
--- a/Tools/Frame_params/3DR_Iris+_AC34.param
+++ b/Tools/Frame_params/3DR_Iris+_AC34.param
@@ -62,7 +62,6 @@ RC_FEEL_RP,25
 RC9_FUNCTION,7
 RC9_MAX,1520
 RC9_MIN,1000
-RC9_REV,1
 RTL_ALT,2000
 SERIAL2_PROTOCOL,3
 THR_DZ,50
diff --git a/Tools/Frame_params/3DR_QUAD_X4_RTF.param b/Tools/Frame_params/3DR_QUAD_X4_RTF.param
index 2d3fd10..b13da07 100644
--- a/Tools/Frame_params/3DR_QUAD_X4_RTF.param
+++ b/Tools/Frame_params/3DR_QUAD_X4_RTF.param
@@ -26,7 +26,6 @@ MNT_MODE,3
 MNT_RC_IN_TILT,6
 MOT_SPIN_ARMED,90
 RC9_FUNCTION,7
-RC9_REV,1
 RATE_PIT_D,0.0055
 RATE_PIT_I,0.07999999
 RATE_PIT_P,0.07999999
diff --git a/Tools/Frame_params/3DR_X8+_RTF.param b/Tools/Frame_params/3DR_X8+_RTF.param
index ae86fec..e5649c8 100644
--- a/Tools/Frame_params/3DR_X8+_RTF.param
+++ b/Tools/Frame_params/3DR_X8+_RTF.param
@@ -72,7 +72,6 @@ RC_FEEL_RP,15
 RC9_FUNCTION,7
 RC9_MAX,1520
 RC9_MIN,1000
-RC9_REV,1
 RTL_ALT,2000
 SERIAL2_PROTOCOL,3
 STB_PIT_P,6.6484
diff --git a/Tools/Frame_params/3DR_X8-M_RTF.param b/Tools/Frame_params/3DR_X8-M_RTF.param
index 02039c6..9e41b3c 100644
--- a/Tools/Frame_params/3DR_X8-M_RTF.param
+++ b/Tools/Frame_params/3DR_X8-M_RTF.param
@@ -76,7 +76,6 @@ RC_FEEL_RP,15
 RC9_FUNCTION,7
 RC9_MAX,1520
 RC9_MIN,1000
-RC9_REV,1
 RELAY_PIN,55
 RTL_ALT,2000
 SERIAL2_PROTOCOL,3
diff --git a/Tools/Frame_params/3DR_X8_RTF.param b/Tools/Frame_params/3DR_X8_RTF.param
index 05beb93..63ab1ef 100644
--- a/Tools/Frame_params/3DR_X8_RTF.param
+++ b/Tools/Frame_params/3DR_X8_RTF.param
@@ -72,7 +72,6 @@ RC_FEEL_RP,15
 RC9_FUNCTION,7
 RC9_MAX,1520
 RC9_MIN,1000
-RC9_REV,1
 RTL_ALT,2000
 SERIAL2_PROTOCOL,2
 STB_PIT_P,6.6484
diff --git a/Tools/Frame_params/3DR_Y6B_RTF.param b/Tools/Frame_params/3DR_Y6B_RTF.param
index 2d04974..86014d5 100644
--- a/Tools/Frame_params/3DR_Y6B_RTF.param
+++ b/Tools/Frame_params/3DR_Y6B_RTF.param
@@ -26,7 +26,6 @@ MNT_MODE,3
 MNT_RC_IN_TILT,6
 MOT_SPIN_ARMED,90
 RC9_FUNCTION,7
-RC9_REV,1
 RATE_PIT_D,0.008
 RATE_PIT_I,0.1
 RATE_PIT_P,0.1
diff --git a/Tools/Frame_params/Iris with Front Mount Go Pro.param b/Tools/Frame_params/Iris with Front Mount Go Pro.param
index 13b3bff..77daba4 100644
--- a/Tools/Frame_params/Iris with Front Mount Go Pro.param	
+++ b/Tools/Frame_params/Iris with Front Mount Go Pro.param	
@@ -27,7 +27,6 @@ MOT_SPIN_ARMED,90
 RC9_FUNCTION,7
 RC9_MAX,1520
 RC9_MIN,1000
-RC9_REV,1
 RATE_PIT_D,0.005
 RATE_PIT_I,0.115
 RATE_PIT_P,0.115
diff --git a/Tools/Frame_params/Iris with Tarot Gimbal.param b/Tools/Frame_params/Iris with Tarot Gimbal.param
index 5ce96af..f2cea6e 100644
--- a/Tools/Frame_params/Iris with Tarot Gimbal.param	
+++ b/Tools/Frame_params/Iris with Tarot Gimbal.param	
@@ -27,7 +27,6 @@ MOT_SPIN_ARMED,90
 RC9_FUNCTION,7
 RC9_MAX,1520
 RC9_MIN,1000
-RC9_REV,1
 RATE_PIT_D,0.01075
 RATE_PIT_I,0.14
 RATE_PIT_P,0.14
diff --git a/Tools/Frame_params/Iris.param b/Tools/Frame_params/Iris.param
index 44e709d..7557679 100644
--- a/Tools/Frame_params/Iris.param
+++ b/Tools/Frame_params/Iris.param
@@ -27,7 +27,6 @@ MOT_SPIN_ARMED,90
 RC9_FUNCTION,7
 RC9_MAX,1520
 RC9_MIN,1000
-RC9_REV,1
 RATE_PIT_D,0.00775
 RATE_PIT_I,0.09499999
 RATE_PIT_P,0.09499999
diff --git a/Tools/Frame_params/Parrot_Disco/Parrot_Disco.param b/Tools/Frame_params/Parrot_Disco/Parrot_Disco.param
index 5eab11c..26ff771 100644
--- a/Tools/Frame_params/Parrot_Disco/Parrot_Disco.param
+++ b/Tools/Frame_params/Parrot_Disco/Parrot_Disco.param
@@ -60,6 +60,4 @@ WP_LOITER_RAD    30
 WP_RADIUS        90
 STICK_MIXING     0
 THROTTLE_NUDGE   0
-RC2_REV          1
-SERVO_RNG_ENABLE 1
 SCHED_LOOP_RATE  200

From 5aa4bc436895c391b421ecba83b30092152f5a5b Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Fri, 13 Jan 2017 14:17:47 +0100
Subject: [PATCH 112/200] AP_Params: fix seg fault in debug function otherwise
 at start, when loading paramter is could fail at AP_Param.cpp:611,
 Debug("scan past end of eeprom")"

---
 libraries/AP_Param/AP_Param.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_Param/AP_Param.cpp b/libraries/AP_Param/AP_Param.cpp
index 2eb0da8..d18cecc 100644
--- a/libraries/AP_Param/AP_Param.cpp
+++ b/libraries/AP_Param/AP_Param.cpp
@@ -38,7 +38,7 @@ extern const AP_HAL::HAL &hal;
 #define ENABLE_DEBUG 1
 
 #if ENABLE_DEBUG
- # define Debug(fmt, args ...)  do {hal.console->printf("%s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args); } while(0)
+ # define Debug(fmt, args ...)  do {::printf("%s:%d: " fmt "\n", __FUNCTION__, __LINE__, ## args); } while(0)
 #else
  # define Debug(fmt, args ...)
 #endif

From 5472bc4de1c20a66e988b3c77fbd69231c42f69b Mon Sep 17 00:00:00 2001
From: Lucas De Marchi <lucas.demarchi@intel.com>
Date: Fri, 13 Jan 2017 11:26:14 -0800
Subject: [PATCH 113/200] Global: change Device::PeriodicCb signature

Remove bool return as it's never being used and not supported on PX4.
---
 libraries/AP_ADC/AP_ADC_ADS1115.cpp                         | 12 +++++-------
 libraries/AP_ADC/AP_ADC_ADS1115.h                           |  2 +-
 libraries/AP_Airspeed/AP_Airspeed_MS4525.cpp                |  7 +++----
 libraries/AP_Airspeed/AP_Airspeed_MS4525.h                  |  2 +-
 libraries/AP_Airspeed/AP_Airspeed_MS5525.cpp                |  8 +++-----
 libraries/AP_Airspeed/AP_Airspeed_MS5525.h                  |  2 +-
 libraries/AP_Baro/AP_Baro_BMP085.cpp                        |  7 +++----
 libraries/AP_Baro/AP_Baro_BMP085.h                          |  4 ++--
 libraries/AP_Baro/AP_Baro_MS5611.cpp                        | 12 +++++-------
 libraries/AP_Baro/AP_Baro_MS5611.h                          |  2 +-
 libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.cpp       |  5 ++---
 libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.h         |  2 +-
 libraries/AP_Compass/AP_Compass_AK09916.cpp                 |  7 +++----
 libraries/AP_Compass/AP_Compass_AK09916.h                   |  2 +-
 libraries/AP_Compass/AP_Compass_AK8963.cpp                  | 13 +++++--------
 libraries/AP_Compass/AP_Compass_AK8963.h                    |  2 +-
 libraries/AP_Compass/AP_Compass_BMM150.cpp                  |  9 ++++-----
 libraries/AP_Compass/AP_Compass_BMM150.h                    |  2 +-
 libraries/AP_Compass/AP_Compass_HMC5843.cpp                 |  8 +++-----
 libraries/AP_Compass/AP_Compass_HMC5843.h                   |  4 ++--
 libraries/AP_Compass/AP_Compass_IST8310.cpp                 | 11 ++++-------
 libraries/AP_Compass/AP_Compass_IST8310.h                   |  2 +-
 libraries/AP_Compass/AP_Compass_LIS3MDL.cpp                 |  5 ++---
 libraries/AP_Compass/AP_Compass_LIS3MDL.h                   |  2 +-
 libraries/AP_Compass/AP_Compass_LSM303D.cpp                 |  7 +++----
 libraries/AP_Compass/AP_Compass_LSM303D.h                   |  2 +-
 libraries/AP_Compass/AP_Compass_LSM9DS1.cpp                 | 13 +++++--------
 libraries/AP_Compass/AP_Compass_LSM9DS1.h                   |  2 +-
 libraries/AP_HAL/Device.h                                   |  2 +-
 libraries/AP_HAL_Linux/AnalogIn_Raspilot.cpp                |  5 ++---
 libraries/AP_HAL_Linux/AnalogIn_Raspilot.h                  |  2 +-
 libraries/AP_HAL_Linux/PollerThread.cpp                     |  4 +---
 libraries/AP_HAL_Linux/RCInput_Raspilot.cpp                 |  6 ++----
 libraries/AP_HAL_Linux/RCInput_Raspilot.h                   |  2 +-
 libraries/AP_HAL_Linux/RCOutput_Raspilot.cpp                |  7 +++----
 libraries/AP_HAL_Linux/RCOutput_Raspilot.h                  |  2 +-
 libraries/AP_HAL_Linux/RPIOUARTDriver.cpp                   |  8 +++-----
 libraries/AP_HAL_Linux/RPIOUARTDriver.h                     |  2 +-
 libraries/AP_IRLock/AP_IRLock_I2C.cpp                       | 10 ++++------
 libraries/AP_IRLock/AP_IRLock_I2C.h                         |  2 +-
 libraries/AP_InertialSensor/AP_InertialSensor_BMI160.cpp    |  5 ++---
 libraries/AP_InertialSensor/AP_InertialSensor_BMI160.h      |  2 +-
 .../AP_InertialSensor/AP_InertialSensor_Invensense.cpp      |  5 ++---
 libraries/AP_InertialSensor/AP_InertialSensor_Invensense.h  |  2 +-
 libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.cpp  |  7 +++----
 libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.h    |  2 +-
 libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.cpp   |  6 ++----
 libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.h     |  2 +-
 libraries/AP_Notify/Display_SSD1306_I2C.cpp                 |  8 +++-----
 libraries/AP_Notify/Display_SSD1306_I2C.h                   |  2 +-
 libraries/AP_Notify/NavioLED_I2C.cpp                        |  8 +++-----
 libraries/AP_Notify/NavioLED_I2C.h                          |  2 +-
 libraries/AP_Notify/ToshibaLED_I2C.cpp                      |  9 ++++-----
 libraries/AP_Notify/ToshibaLED_I2C.h                        |  2 +-
 libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.cpp         |  8 +++-----
 libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.h           |  2 +-
 libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.cpp          |  9 ++++-----
 libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.h            |  2 +-
 libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.cpp    |  7 +++----
 libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.h      |  4 ++--
 libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.cpp   |  7 +++----
 libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.h     |  4 ++--
 libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.cpp  |  5 ++---
 libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.h    |  2 +-
 64 files changed, 135 insertions(+), 185 deletions(-)

diff --git a/libraries/AP_ADC/AP_ADC_ADS1115.cpp b/libraries/AP_ADC/AP_ADC_ADS1115.cpp
index 4bc5d8a..b098c88 100644
--- a/libraries/AP_ADC/AP_ADC_ADS1115.cpp
+++ b/libraries/AP_ADC/AP_ADC_ADS1115.cpp
@@ -130,7 +130,7 @@ bool AP_ADC_ADS1115::init()
 
     _gain = ADS1115_PGA_4P096;
 
-    _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AP_ADC_ADS1115::_update, bool));
+    _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AP_ADC_ADS1115::_update, void));
 
     return true;
 }
@@ -200,23 +200,23 @@ float AP_ADC_ADS1115::_convert_register_data_to_mv(int16_t word) const
     return (float) word * pga;
 }
 
-bool AP_ADC_ADS1115::_update()
+void AP_ADC_ADS1115::_update()
 {
     uint8_t config[2];
     be16_t val;
 
     if (!_dev->read_registers(ADS1115_RA_CONFIG, config, sizeof(config))) {
         error("_dev->read_registers failed in ADS1115");
-        return true;
+        return;
     }
 
     /* check rdy bit */
     if ((config[1] & 0x80) != 0x80 ) {
-        return true;
+        return;
     }
 
     if (!_dev->read_registers(ADS1115_RA_CONVERSION, (uint8_t *)&val,  sizeof(val))) {
-        return true;
+        return;
     }
 
     float sample = _convert_register_data_to_mv(be16toh(val));
@@ -227,6 +227,4 @@ bool AP_ADC_ADS1115::_update()
     /* select next channel */
     _channel_to_read = (_channel_to_read + 1) % _channels_number;
     _start_conversion(_channel_to_read);
-
-    return true;
 }
diff --git a/libraries/AP_ADC/AP_ADC_ADS1115.h b/libraries/AP_ADC/AP_ADC_ADS1115.h
index 2f49a9d..98e6544 100644
--- a/libraries/AP_ADC/AP_ADC_ADS1115.h
+++ b/libraries/AP_ADC/AP_ADC_ADS1115.h
@@ -36,7 +36,7 @@ class AP_ADC_ADS1115
     int                 _channel_to_read;
     adc_report_s        *_samples;
 
-    bool _update();
+    void _update();
     bool _start_conversion(uint8_t channel);
 
     float _convert_register_data_to_mv(int16_t word) const;
diff --git a/libraries/AP_Airspeed/AP_Airspeed_MS4525.cpp b/libraries/AP_Airspeed/AP_Airspeed_MS4525.cpp
index 4905945..9f227fc 100644
--- a/libraries/AP_Airspeed/AP_Airspeed_MS4525.cpp
+++ b/libraries/AP_Airspeed/AP_Airspeed_MS4525.cpp
@@ -84,7 +84,7 @@ bool AP_Airspeed_MS4525::init()
     _dev->set_retries(2);
     
     _dev->register_periodic_callback(20000,
-                                     FUNCTOR_BIND_MEMBER(&AP_Airspeed_MS4525::_timer, bool));
+                                     FUNCTOR_BIND_MEMBER(&AP_Airspeed_MS4525::_timer, void));
     return true;
 }
 
@@ -173,18 +173,17 @@ void AP_Airspeed_MS4525::_voltage_correction(float &diff_press_pa, float &temper
 }
 
 // 50Hz timer
-bool AP_Airspeed_MS4525::_timer()
+void AP_Airspeed_MS4525::_timer()
 {
     if (_measurement_started_ms == 0) {
         _measure();
-        return true;
+        return;
     }
     if ((AP_HAL::millis() - _measurement_started_ms) > 10) {
         _collect();
         // start a new measurement
         _measure();
     }
-    return true;
 }
 
 // return the current differential_pressure in Pascal
diff --git a/libraries/AP_Airspeed/AP_Airspeed_MS4525.h b/libraries/AP_Airspeed/AP_Airspeed_MS4525.h
index b89edcc..cb3208c 100644
--- a/libraries/AP_Airspeed/AP_Airspeed_MS4525.h
+++ b/libraries/AP_Airspeed/AP_Airspeed_MS4525.h
@@ -45,7 +45,7 @@ class AP_Airspeed_MS4525 : public AP_Airspeed_Backend
 private:
     void _measure();
     void _collect();
-    bool _timer();
+    void _timer();
     void _voltage_correction(float &diff_press_pa, float &temperature);
 
     float _temp_sum;
diff --git a/libraries/AP_Airspeed/AP_Airspeed_MS5525.cpp b/libraries/AP_Airspeed/AP_Airspeed_MS5525.cpp
index 1c8f8e71..75f0315 100644
--- a/libraries/AP_Airspeed/AP_Airspeed_MS5525.cpp
+++ b/libraries/AP_Airspeed/AP_Airspeed_MS5525.cpp
@@ -96,7 +96,7 @@ bool AP_Airspeed_MS5525::init()
 
     // read at 80Hz
     dev->register_periodic_callback(1000000UL/80U,
-                                    FUNCTOR_BIND_MEMBER(&AP_Airspeed_MS5525::timer, bool));
+                                    FUNCTOR_BIND_MEMBER(&AP_Airspeed_MS5525::timer, void));
     return true;
 }
 
@@ -219,7 +219,7 @@ void AP_Airspeed_MS5525::calculate(void)
 }
 
 // 50Hz timer
-bool AP_Airspeed_MS5525::timer()
+void AP_Airspeed_MS5525::timer()
 {
     uint32_t adc_val = read_adc();
 
@@ -241,12 +241,10 @@ bool AP_Airspeed_MS5525::timer()
 
     uint8_t next_cmd = next_state == 0 ? REG_CONVERT_TEMPERATURE : REG_CONVERT_PRESSURE;
     if (!dev->transfer(&next_cmd, 1, nullptr, 0)) {
-        return true;
+        return;
     }
 
     state = next_state;
-    
-    return true;
 }
 
 // return the current differential_pressure in Pascal
diff --git a/libraries/AP_Airspeed/AP_Airspeed_MS5525.h b/libraries/AP_Airspeed/AP_Airspeed_MS5525.h
index c4cdd5c..e5e227a 100644
--- a/libraries/AP_Airspeed/AP_Airspeed_MS5525.h
+++ b/libraries/AP_Airspeed/AP_Airspeed_MS5525.h
@@ -45,7 +45,7 @@ class AP_Airspeed_MS5525 : public AP_Airspeed_Backend
 private:
     void measure();
     void collect();
-    bool timer();
+    void timer();
     bool read_prom(void);
     uint16_t crc4_prom(void);
     int32_t read_adc();
diff --git a/libraries/AP_Baro/AP_Baro_BMP085.cpp b/libraries/AP_Baro/AP_Baro_BMP085.cpp
index 4873e0e..95ec3c9 100644
--- a/libraries/AP_Baro/AP_Baro_BMP085.cpp
+++ b/libraries/AP_Baro/AP_Baro_BMP085.cpp
@@ -81,16 +81,16 @@ AP_Baro_BMP085::AP_Baro_BMP085(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::I2CDevice>
 
     sem->give();
 
-    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP085::_timer, bool));
+    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP085::_timer, void));
 }
 
 /*
   This is a state machine. Acumulate a new sensor reading.
  */
-bool AP_Baro_BMP085::_timer(void)
+void AP_Baro_BMP085::_timer(void)
 {
     if (!_data_ready()) {
-        return true;
+        return;
     }
 
     if (_state == 0) {
@@ -106,7 +106,6 @@ bool AP_Baro_BMP085::_timer(void)
     } else {
         _cmd_read_pressure();
     }
-    return true;
 }
 
 /*
diff --git a/libraries/AP_Baro/AP_Baro_BMP085.h b/libraries/AP_Baro/AP_Baro_BMP085.h
index cdc3de3..7bf345c 100644
--- a/libraries/AP_Baro/AP_Baro_BMP085.h
+++ b/libraries/AP_Baro/AP_Baro_BMP085.h
@@ -23,8 +23,8 @@ class AP_Baro_BMP085 : public AP_Baro_Backend
     void _calculate();
     bool _data_ready();
 
-    bool _timer(void);
-    
+    void _timer(void);
+
     AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
     AP_HAL::DigitalSource *_eoc;
 
diff --git a/libraries/AP_Baro/AP_Baro_MS5611.cpp b/libraries/AP_Baro/AP_Baro_MS5611.cpp
index 90cbb26..5088bc5 100644
--- a/libraries/AP_Baro/AP_Baro_MS5611.cpp
+++ b/libraries/AP_Baro/AP_Baro_MS5611.cpp
@@ -137,7 +137,7 @@ bool AP_Baro_MS56XX::_init()
 
     /* Request 100Hz update */
     _dev->register_periodic_callback(10 * USEC_PER_MSEC,
-                                     FUNCTOR_BIND_MEMBER(&AP_Baro_MS56XX::_timer, bool));
+                                     FUNCTOR_BIND_MEMBER(&AP_Baro_MS56XX::_timer, void));
     return true;
 }
 
@@ -259,7 +259,7 @@ bool AP_Baro_MS56XX::_read_prom_5637(uint16_t prom[8])
  * as fast as pressure. Hence we reuse the same temperature for 4 samples of
  * pressure.
 */
-bool AP_Baro_MS56XX::_timer(void)
+void AP_Baro_MS56XX::_timer(void)
 {
     uint8_t next_cmd;
     uint8_t next_state;
@@ -278,7 +278,7 @@ bool AP_Baro_MS56XX::_timer(void)
     next_cmd = next_state == 0 ? ADDR_CMD_CONVERT_TEMPERATURE
                                : ADDR_CMD_CONVERT_PRESSURE;
     if (!_dev->transfer(&next_cmd, 1, nullptr, 0)) {
-        return true;
+        return;
     }
 
     /* if we had a failed read we are all done */
@@ -286,13 +286,13 @@ bool AP_Baro_MS56XX::_timer(void)
         // a failed read can mean the next returned value will be
         // corrupt, we must discard it
         _discard_next = true;
-        return true;
+        return;
     }
 
     if (_discard_next) {
         _discard_next = false;
         _state = next_state;
-        return true;
+        return;
     }
 
     if (_sem->take(HAL_SEMAPHORE_BLOCK_FOREVER)) {
@@ -306,8 +306,6 @@ bool AP_Baro_MS56XX::_timer(void)
         _sem->give();
         _state = next_state;
     }
-
-    return true;
 }
 
 void AP_Baro_MS56XX::_update_and_wrap_accumulator(uint32_t *accum, uint32_t val,
diff --git a/libraries/AP_Baro/AP_Baro_MS5611.h b/libraries/AP_Baro/AP_Baro_MS5611.h
index e230f45..d74b136 100644
--- a/libraries/AP_Baro/AP_Baro_MS5611.h
+++ b/libraries/AP_Baro/AP_Baro_MS5611.h
@@ -46,7 +46,7 @@ class AP_Baro_MS56XX : public AP_Baro_Backend
     uint16_t _read_prom_word(uint8_t word);
     uint32_t _read_adc();
 
-    bool _timer();
+    void _timer();
 
     AP_HAL::OwnPtr<AP_HAL::Device> _dev;
 
diff --git a/libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.cpp b/libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.cpp
index 0b0ae6d..25e57f0 100644
--- a/libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.cpp
+++ b/libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.cpp
@@ -30,7 +30,7 @@ AP_BattMonitor_SMBus_I2C::AP_BattMonitor_SMBus_I2C(AP_BattMonitor &mon, uint8_t
     : AP_BattMonitor_SMBus(mon, instance, mon_state)
     , _dev(std::move(dev))
 {
-    _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AP_BattMonitor_SMBus_I2C::timer, bool));
+    _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AP_BattMonitor_SMBus_I2C::timer, void));
 }
 
 /// Read the battery voltage and current.  Should be called at 10hz
@@ -39,7 +39,7 @@ void AP_BattMonitor_SMBus_I2C::read()
     // nothing to do - all done in timer()
 }
 
-bool AP_BattMonitor_SMBus_I2C::timer()
+void AP_BattMonitor_SMBus_I2C::timer()
 {
     uint16_t data;
     uint8_t buff[4];
@@ -62,7 +62,6 @@ bool AP_BattMonitor_SMBus_I2C::timer()
     if ((tnow - _state.last_time_micros) > AP_BATTMONITOR_SMBUS_TIMEOUT_MICROS) {
         _state.healthy = false;
     }
-    return true;
 }
 
 // read word from register
diff --git a/libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.h b/libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.h
index a84e8aa..dc92e32 100644
--- a/libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.h
+++ b/libraries/AP_BattMonitor/AP_BattMonitor_SMBus_I2C.h
@@ -23,7 +23,7 @@ class AP_BattMonitor_SMBus_I2C : public AP_BattMonitor_SMBus
 
 private:
 
-    bool timer(void);
+    void timer(void);
 
     // read word from register
     // returns true if read was successful, false if failed
diff --git a/libraries/AP_Compass/AP_Compass_AK09916.cpp b/libraries/AP_Compass/AP_Compass_AK09916.cpp
index d11ea80..439a04d 100644
--- a/libraries/AP_Compass/AP_Compass_AK09916.cpp
+++ b/libraries/AP_Compass/AP_Compass_AK09916.cpp
@@ -103,7 +103,7 @@ bool AP_Compass_AK09916::init()
 
     // call timer() at 100Hz
     dev->register_periodic_callback(10000,
-                                    FUNCTOR_BIND_MEMBER(&AP_Compass_AK09916::timer, bool));
+                                    FUNCTOR_BIND_MEMBER(&AP_Compass_AK09916::timer, void));
 
     return true;
 
@@ -112,7 +112,7 @@ bool AP_Compass_AK09916::init()
     return false;
 }
 
-bool AP_Compass_AK09916::timer()
+void AP_Compass_AK09916::timer()
 {
     struct PACKED {
         int16_t magx;
@@ -131,7 +131,7 @@ bool AP_Compass_AK09916::timer()
     if (!dev->read_registers(REG_ST1, &st1, 1) || !(st1 & 1)) {
         goto check_registers;
     }
-    
+
     if (!dev->read_registers(REG_HXL, (uint8_t *)&data, sizeof(data))) {
         goto check_registers;
     }
@@ -155,7 +155,6 @@ bool AP_Compass_AK09916::timer()
 
 check_registers:
     dev->check_next_register();
-    return true;
 }
 
 void AP_Compass_AK09916::read()
diff --git a/libraries/AP_Compass/AP_Compass_AK09916.h b/libraries/AP_Compass/AP_Compass_AK09916.h
index a9a7e4d..45541ed 100644
--- a/libraries/AP_Compass/AP_Compass_AK09916.h
+++ b/libraries/AP_Compass/AP_Compass_AK09916.h
@@ -49,7 +49,7 @@ class AP_Compass_AK09916 : public AP_Compass_Backend
      * Device periodic callback to read data from the sensor.
      */
     bool init();
-    bool timer();
+    void timer();
 
     uint8_t compass_instance;
     Vector3f accum;
diff --git a/libraries/AP_Compass/AP_Compass_AK8963.cpp b/libraries/AP_Compass/AP_Compass_AK8963.cpp
index 8708912..e865bfa 100644
--- a/libraries/AP_Compass/AP_Compass_AK8963.cpp
+++ b/libraries/AP_Compass/AP_Compass_AK8963.cpp
@@ -168,7 +168,7 @@ bool AP_Compass_AK8963::init()
     bus_sem->give();
 
     /* timer needs to be called every 10ms so set the freq_div to 10 */
-    if (!_bus->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_AK8963::_update, bool))) {
+    if (!_bus->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_AK8963::_update, void))) {
         // fallback to timer
         _timesliced = hal.scheduler->register_timer_process(FUNCTOR_BIND_MEMBER(&AP_Compass_AK8963::_update_timer, void), 10);
     }
@@ -215,26 +215,26 @@ void AP_Compass_AK8963::_make_factory_sensitivity_adjustment(Vector3f& field) co
     field.z *= _magnetometer_ASA[2];
 }
 
-bool AP_Compass_AK8963::_update()
+void AP_Compass_AK8963::_update()
 {
     struct sample_regs regs;
     Vector3f raw_field;
     uint32_t time_us = AP_HAL::micros();
 
     if (!_bus->block_read(AK8963_HXL, (uint8_t *) &regs, sizeof(regs))) {
-        goto fail;
+        return;
     }
 
     /* Check for overflow. See AK8963's datasheet, section
      * 6.4.3.6 - Magnetic Sensor Overflow. */
     if ((regs.st2 & 0x08)) {
-        goto fail;
+        return;
     }
 
     raw_field = Vector3f(regs.val[0], regs.val[1], regs.val[2]);
 
     if (is_zero(raw_field.x) && is_zero(raw_field.y) && is_zero(raw_field.z)) {
-        goto fail;
+        return;
     }
 
     _make_factory_sensitivity_adjustment(raw_field);
@@ -263,9 +263,6 @@ bool AP_Compass_AK8963::_update()
         }
         _sem->give();
     }
-
-fail:
-    return true;
 }
 
 /*
diff --git a/libraries/AP_Compass/AP_Compass_AK8963.h b/libraries/AP_Compass/AP_Compass_AK8963.h
index 5a75a56..518351e 100644
--- a/libraries/AP_Compass/AP_Compass_AK8963.h
+++ b/libraries/AP_Compass/AP_Compass_AK8963.h
@@ -50,7 +50,7 @@ class AP_Compass_AK8963 : public AP_Compass_Backend
     bool _check_id();
     bool _calibrate();
 
-    bool _update();
+    void _update();
     void _update_timer();
 
     AP_AK8963_BusDriver *_bus;
diff --git a/libraries/AP_Compass/AP_Compass_BMM150.cpp b/libraries/AP_Compass/AP_Compass_BMM150.cpp
index 48194ea..cd919be 100644
--- a/libraries/AP_Compass/AP_Compass_BMM150.cpp
+++ b/libraries/AP_Compass/AP_Compass_BMM150.cpp
@@ -190,7 +190,7 @@ bool AP_Compass_BMM150::init()
     set_dev_id(_compass_instance, _dev->get_bus_id());
 
     _dev->register_periodic_callback(MEASURE_TIME_USEC,
-            FUNCTOR_BIND_MEMBER(&AP_Compass_BMM150::_update, bool));
+            FUNCTOR_BIND_MEMBER(&AP_Compass_BMM150::_update, void));
 
     return true;
 
@@ -237,7 +237,7 @@ int16_t AP_Compass_BMM150::_compensate_z(int16_t z, uint32_t rhall)
     return constrain_int32(dividend / divisor, -0x8000, 0x8000);
 }
 
-bool AP_Compass_BMM150::_update()
+void AP_Compass_BMM150::_update()
 {
     const uint32_t time_usec = AP_HAL::micros();
 
@@ -246,7 +246,7 @@ bool AP_Compass_BMM150::_update()
 
     /* Checking data ready status */
     if (!ret || !(data[3] & 0x1)) {
-        return true;
+        return;
     }
 
     const uint16_t rhall = le16toh(data[3] >> 2);
@@ -273,7 +273,7 @@ bool AP_Compass_BMM150::_update()
     correct_field(raw_field, _compass_instance);
 
     if (!_sem->take(HAL_SEMAPHORE_BLOCK_FOREVER)) {
-        return true;
+        return;
     }
     _mag_accum += raw_field;
     _accum_count++;
@@ -282,7 +282,6 @@ bool AP_Compass_BMM150::_update()
         _accum_count = 5;
     }
     _sem->give();
-    return true;
 }
 
 void AP_Compass_BMM150::read()
diff --git a/libraries/AP_Compass/AP_Compass_BMM150.h b/libraries/AP_Compass/AP_Compass_BMM150.h
index de24c6d..83b95fa 100644
--- a/libraries/AP_Compass/AP_Compass_BMM150.h
+++ b/libraries/AP_Compass/AP_Compass_BMM150.h
@@ -41,7 +41,7 @@ class AP_Compass_BMM150 : public AP_Compass_Backend
      * Device periodic callback to read data from the sensor.
      */
     bool init();
-    bool _update();
+    void _update();
     bool _load_trim_values();
     int16_t _compensate_xy(int16_t xy, uint32_t rhall, int32_t txy1, int32_t txy2);
     int16_t _compensate_z(int16_t z, uint32_t rhall);
diff --git a/libraries/AP_Compass/AP_Compass_HMC5843.cpp b/libraries/AP_Compass/AP_Compass_HMC5843.cpp
index 5cff49b..a151e98 100644
--- a/libraries/AP_Compass/AP_Compass_HMC5843.cpp
+++ b/libraries/AP_Compass/AP_Compass_HMC5843.cpp
@@ -209,7 +209,7 @@ bool AP_Compass_HMC5843::init()
 
     // read from sensor at 75Hz
     _bus->register_periodic_callback(13333,
-                                     FUNCTOR_BIND_MEMBER(&AP_Compass_HMC5843::_timer, bool));
+                                     FUNCTOR_BIND_MEMBER(&AP_Compass_HMC5843::_timer, void));
 
     hal.console->printf("HMC5843 found on bus 0x%x\n", _bus->get_bus_id());
     
@@ -225,7 +225,7 @@ bool AP_Compass_HMC5843::init()
  *
  * bus semaphore has been taken already by HAL
  */
-bool AP_Compass_HMC5843::_timer()
+void AP_Compass_HMC5843::_timer()
 {
     bool result = _read_sample();
 
@@ -233,7 +233,7 @@ bool AP_Compass_HMC5843::_timer()
     _take_sample();
     
     if (!result) {
-        return true;
+        return;
     }
 
     uint32_t tnow = AP_HAL::micros();    
@@ -274,8 +274,6 @@ bool AP_Compass_HMC5843::_timer()
         }
         _sem->give();
     }
-    
-    return true;
 }
 
 /*
diff --git a/libraries/AP_Compass/AP_Compass_HMC5843.h b/libraries/AP_Compass/AP_Compass_HMC5843.h
index 3197bb0..11c4cca 100644
--- a/libraries/AP_Compass/AP_Compass_HMC5843.h
+++ b/libraries/AP_Compass/AP_Compass_HMC5843.h
@@ -39,8 +39,8 @@ class AP_Compass_HMC5843 : public AP_Compass_Backend
     bool _calibrate();
     bool _setup_sampling_mode();
 
-    bool _timer();
-    
+    void _timer();
+
     /* Read a single sample */
     bool _read_sample();
 
diff --git a/libraries/AP_Compass/AP_Compass_IST8310.cpp b/libraries/AP_Compass/AP_Compass_IST8310.cpp
index 264d95e..2bd63b5 100644
--- a/libraries/AP_Compass/AP_Compass_IST8310.cpp
+++ b/libraries/AP_Compass/AP_Compass_IST8310.cpp
@@ -111,7 +111,7 @@ bool AP_Compass_IST8310::init()
     set_dev_id(_instance, _dev->get_bus_id());
 
     _dev->register_periodic_callback(10 * USEC_PER_MSEC,
-                                     FUNCTOR_BIND_MEMBER(&AP_Compass_IST8310::timer, bool));
+                                     FUNCTOR_BIND_MEMBER(&AP_Compass_IST8310::timer, void));
 
     return true;
 
@@ -126,9 +126,8 @@ void AP_Compass_IST8310::start_conversion()
             SINGLE_MEASUREMENT_MODE);
 }
 
-bool AP_Compass_IST8310::timer()
+void AP_Compass_IST8310::timer()
 {
-
     bool ret = false;
 
     struct PACKED {
@@ -142,14 +141,14 @@ bool AP_Compass_IST8310::timer()
     ret = _dev->read_registers(STAT1_REG, (uint8_t *) &buffer, sizeof(buffer));
     if (!ret) {
         /* We're going to be back on the next iteration either way */
-        return true;
+        return;
     }
 
     auto status = buffer.status;
 
     if (!(status & 0x01)) {
         /* We're not ready yet */
-       return true;
+       return;
     }
 
     auto x = static_cast<int16_t>(le16toh(buffer.rx));
@@ -175,8 +174,6 @@ bool AP_Compass_IST8310::timer()
     }
 
     start_conversion();
-
-    return true;
 }
 
 void AP_Compass_IST8310::read()
diff --git a/libraries/AP_Compass/AP_Compass_IST8310.h b/libraries/AP_Compass/AP_Compass_IST8310.h
index 7927096..2ee0cf0 100644
--- a/libraries/AP_Compass/AP_Compass_IST8310.h
+++ b/libraries/AP_Compass/AP_Compass_IST8310.h
@@ -41,7 +41,7 @@ class AP_Compass_IST8310 : public AP_Compass_Backend
                        AP_HAL::OwnPtr<AP_HAL::Device> dev,
                        enum Rotation rotation);
 
-    bool timer();
+    void timer();
     bool init();
     void start_conversion();
 
diff --git a/libraries/AP_Compass/AP_Compass_LIS3MDL.cpp b/libraries/AP_Compass/AP_Compass_LIS3MDL.cpp
index 12c7381..15d6ef6 100644
--- a/libraries/AP_Compass/AP_Compass_LIS3MDL.cpp
+++ b/libraries/AP_Compass/AP_Compass_LIS3MDL.cpp
@@ -125,7 +125,7 @@ bool AP_Compass_LIS3MDL::init()
 
     // call timer() at 155Hz
     dev->register_periodic_callback(1000000U/155U,
-                                    FUNCTOR_BIND_MEMBER(&AP_Compass_LIS3MDL::timer, bool));
+                                    FUNCTOR_BIND_MEMBER(&AP_Compass_LIS3MDL::timer, void));
 
     return true;
 
@@ -134,7 +134,7 @@ bool AP_Compass_LIS3MDL::init()
     return false;
 }
 
-bool AP_Compass_LIS3MDL::timer()
+void AP_Compass_LIS3MDL::timer()
 {
     struct PACKED {
         int16_t magx;
@@ -177,7 +177,6 @@ bool AP_Compass_LIS3MDL::timer()
 
 check_registers:
     dev->check_next_register();
-    return true;
 }
 
 void AP_Compass_LIS3MDL::read()
diff --git a/libraries/AP_Compass/AP_Compass_LIS3MDL.h b/libraries/AP_Compass/AP_Compass_LIS3MDL.h
index 18e5027..dc3255e 100644
--- a/libraries/AP_Compass/AP_Compass_LIS3MDL.h
+++ b/libraries/AP_Compass/AP_Compass_LIS3MDL.h
@@ -50,7 +50,7 @@ class AP_Compass_LIS3MDL : public AP_Compass_Backend
      * Device periodic callback to read data from the sensor.
      */
     bool init();
-    bool timer();
+    void timer();
 
     uint8_t compass_instance;
     Vector3f accum;
diff --git a/libraries/AP_Compass/AP_Compass_LSM303D.cpp b/libraries/AP_Compass/AP_Compass_LSM303D.cpp
index a5c306a..a3e6e10 100644
--- a/libraries/AP_Compass/AP_Compass_LSM303D.cpp
+++ b/libraries/AP_Compass/AP_Compass_LSM303D.cpp
@@ -284,7 +284,7 @@ bool AP_Compass_LSM303D::init(enum Rotation rotation)
 #endif
 
     // read at 100Hz
-    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_LSM303D::_update, bool));
+    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_LSM303D::_update, void));
 
     return true;
 }
@@ -343,10 +343,10 @@ bool AP_Compass_LSM303D::_hardware_init()
     return false;
 }
 
-bool AP_Compass_LSM303D::_update()
+void AP_Compass_LSM303D::_update()
 {
     if (!_read_sample()) {
-        return true;
+        return;
     }
 
     Vector3f raw_field = Vector3f(_mag_x, _mag_y, _mag_z) * _mag_range_scale;
@@ -373,7 +373,6 @@ bool AP_Compass_LSM303D::_update()
         }
         _sem->give();
     }
-    return true;
 }
 
 // Read Sensor data
diff --git a/libraries/AP_Compass/AP_Compass_LSM303D.h b/libraries/AP_Compass/AP_Compass_LSM303D.h
index beb6934..dcc263b 100644
--- a/libraries/AP_Compass/AP_Compass_LSM303D.h
+++ b/libraries/AP_Compass/AP_Compass_LSM303D.h
@@ -34,7 +34,7 @@ class AP_Compass_LSM303D : public AP_Compass_Backend
 
     bool _data_ready();
     bool _hardware_init();
-    bool _update();
+    void _update();
     void _disable_i2c();
     bool _mag_set_range(uint8_t max_ga);
     bool _mag_set_samplerate(uint16_t frequency);
diff --git a/libraries/AP_Compass/AP_Compass_LSM9DS1.cpp b/libraries/AP_Compass/AP_Compass_LSM9DS1.cpp
index fbc5e2e..be03506 100644
--- a/libraries/AP_Compass/AP_Compass_LSM9DS1.cpp
+++ b/libraries/AP_Compass/AP_Compass_LSM9DS1.cpp
@@ -113,7 +113,7 @@ bool AP_Compass_LSM9DS1::init()
     _dev->set_device_type(DEVTYPE_LSM9DS1);
     set_dev_id(_compass_instance, _dev->get_bus_id());
 
-    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_LSM9DS1::_update, bool));
+    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&AP_Compass_LSM9DS1::_update, void));
 
     bus_sem->give();
 
@@ -137,24 +137,24 @@ void AP_Compass_LSM9DS1::_dump_registers()
     hal.console->println();
 }
 
-bool AP_Compass_LSM9DS1::_update(void)
+void AP_Compass_LSM9DS1::_update(void)
 {
     struct sample_regs regs;
     Vector3f raw_field;
     uint32_t time_us = AP_HAL::micros();
 
     if (!_block_read(LSM9DS1M_STATUS_REG_M, (uint8_t *) &regs, sizeof(regs))) {
-        goto fail;
+        return;
     }
 
     if (regs.status & 0x80) {
-        goto fail;
+        return;
     }
 
     raw_field = Vector3f(regs.val[0], regs.val[1], regs.val[2]);
 
     if (is_zero(raw_field.x) && is_zero(raw_field.y) && is_zero(raw_field.z)) {
-        goto fail;
+        return;
     }
 
     raw_field *= _scaling;
@@ -181,9 +181,6 @@ bool AP_Compass_LSM9DS1::_update(void)
         }
         _sem->give();
     }
-
-fail:
-    return true;
 }
 
 void AP_Compass_LSM9DS1::read()
diff --git a/libraries/AP_Compass/AP_Compass_LSM9DS1.h b/libraries/AP_Compass/AP_Compass_LSM9DS1.h
index 4a68b06..db86025 100644
--- a/libraries/AP_Compass/AP_Compass_LSM9DS1.h
+++ b/libraries/AP_Compass/AP_Compass_LSM9DS1.h
@@ -28,7 +28,7 @@ class AP_Compass_LSM9DS1 : public AP_Compass_Backend
     bool _check_id(void);
     bool _configure(void);
     bool _set_scale(void);
-    bool _update(void);
+    void _update(void);
 
     uint8_t _register_read(uint8_t reg);
     void _register_write(uint8_t reg, uint8_t val);
diff --git a/libraries/AP_HAL/Device.h b/libraries/AP_HAL/Device.h
index 8121be0..8a51284 100644
--- a/libraries/AP_HAL/Device.h
+++ b/libraries/AP_HAL/Device.h
@@ -38,7 +38,7 @@ class AP_HAL::Device {
         SPEED_LOW,
     };
 
-    FUNCTOR_TYPEDEF(PeriodicCb, bool);
+    FUNCTOR_TYPEDEF(PeriodicCb, void);
     typedef void* PeriodicHandle;
 
     Device(enum BusType type)
diff --git a/libraries/AP_HAL_Linux/AnalogIn_Raspilot.cpp b/libraries/AP_HAL_Linux/AnalogIn_Raspilot.cpp
index bf50bb3..a24701a 100644
--- a/libraries/AP_HAL_Linux/AnalogIn_Raspilot.cpp
+++ b/libraries/AP_HAL_Linux/AnalogIn_Raspilot.cpp
@@ -81,10 +81,10 @@ void AnalogIn_Raspilot::init()
         return;
     }
 
-    _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AnalogIn_Raspilot::_update, bool));
+    _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AnalogIn_Raspilot::_update, void));
 }
 
-bool AnalogIn_Raspilot::_update()
+void AnalogIn_Raspilot::_update()
 {
     struct IOPacket tx = { }, rx = { };
     uint16_t count = RASPILOT_ADC_MAX_CHANNELS;
@@ -120,5 +120,4 @@ bool AnalogIn_Raspilot::_update()
             }
         }
     }
-    return true;
 }
diff --git a/libraries/AP_HAL_Linux/AnalogIn_Raspilot.h b/libraries/AP_HAL_Linux/AnalogIn_Raspilot.h
index db48ff4..5ee582f 100644
--- a/libraries/AP_HAL_Linux/AnalogIn_Raspilot.h
+++ b/libraries/AP_HAL_Linux/AnalogIn_Raspilot.h
@@ -35,7 +35,7 @@ class AnalogIn_Raspilot: public AP_HAL::AnalogIn {
     float board_voltage(void);
 
 protected:
-    bool _update();
+    void _update();
 
     AP_HAL::AnalogSource *_vcc_pin_analog_source;
     AnalogSource_Raspilot *_channels[RASPILOT_ADC_MAX_CHANNELS];
diff --git a/libraries/AP_HAL_Linux/PollerThread.cpp b/libraries/AP_HAL_Linux/PollerThread.cpp
index 8b8302b..ce505f1 100644
--- a/libraries/AP_HAL_Linux/PollerThread.cpp
+++ b/libraries/AP_HAL_Linux/PollerThread.cpp
@@ -41,9 +41,7 @@ void TimerPollable::on_can_read()
         _wrapper->start_cb();
     }
 
-    if (!_cb()) {
-        _removeme = true;
-    }
+    _cb();
 
     if (_wrapper) {
         _wrapper->end_cb();
diff --git a/libraries/AP_HAL_Linux/RCInput_Raspilot.cpp b/libraries/AP_HAL_Linux/RCInput_Raspilot.cpp
index edffcab..1d5ab68 100644
--- a/libraries/AP_HAL_Linux/RCInput_Raspilot.cpp
+++ b/libraries/AP_HAL_Linux/RCInput_Raspilot.cpp
@@ -24,10 +24,10 @@ void RCInput_Raspilot::init()
     _dev = hal.spi->get_device("raspio");
 
     // start the timer process to read samples
-    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&RCInput_Raspilot::_poll_data, bool));
+    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&RCInput_Raspilot::_poll_data, void));
 }
 
-bool RCInput_Raspilot::_poll_data(void)
+void RCInput_Raspilot::_poll_data(void)
 {
     struct IOPacket _dma_packet_tx, _dma_packet_rx;
     uint16_t count = LINUX_RC_INPUT_NUM_CHANNELS;
@@ -52,8 +52,6 @@ bool RCInput_Raspilot::_poll_data(void)
     if ( rc_ok && (rx_crc == crc_packet(&_dma_packet_rx)) ) {
       _update_periods(&_dma_packet_rx.regs[6], (uint8_t)num_values);
     }
-
-    return true;
 }
 
 #endif // CONFIG_HAL_BOARD_SUBTYPE
diff --git a/libraries/AP_HAL_Linux/RCInput_Raspilot.h b/libraries/AP_HAL_Linux/RCInput_Raspilot.h
index 16fb077..fc9a867 100644
--- a/libraries/AP_HAL_Linux/RCInput_Raspilot.h
+++ b/libraries/AP_HAL_Linux/RCInput_Raspilot.h
@@ -15,7 +15,7 @@ class RCInput_Raspilot : public RCInput
 private:
     AP_HAL::OwnPtr<AP_HAL::SPIDevice> _dev;
 
-    bool _poll_data(void);
+    void _poll_data(void);
 };
 
 }
diff --git a/libraries/AP_HAL_Linux/RCOutput_Raspilot.cpp b/libraries/AP_HAL_Linux/RCOutput_Raspilot.cpp
index dea9c68..223217b 100644
--- a/libraries/AP_HAL_Linux/RCOutput_Raspilot.cpp
+++ b/libraries/AP_HAL_Linux/RCOutput_Raspilot.cpp
@@ -27,7 +27,7 @@ void RCOutput_Raspilot::init()
 {
     _dev = hal.spi->get_device("raspio");
 
-    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&RCOutput_Raspilot::_update, bool));
+    _dev->register_periodic_callback(10000, FUNCTOR_BIND_MEMBER(&RCOutput_Raspilot::_update, void));
 }
 
 void RCOutput_Raspilot::set_freq(uint32_t chmask, uint16_t freq_hz)
@@ -74,12 +74,12 @@ void RCOutput_Raspilot::read(uint16_t* period_us, uint8_t len)
         period_us[i] = read(0 + i);
 }
 
-bool RCOutput_Raspilot::_update(void)
+void RCOutput_Raspilot::_update(void)
 {
     int i;
 
     if (_corked) {
-        return true;
+        return;
     }
 
     if (_new_frequency) {
@@ -129,7 +129,6 @@ bool RCOutput_Raspilot::_update(void)
     _dma_packet_tx.crc = crc_packet(&_dma_packet_tx);
     _dev->transfer((uint8_t *)&_dma_packet_tx, sizeof(_dma_packet_tx),
                    (uint8_t *)&_dma_packet_rx, sizeof(_dma_packet_rx));
-    return true;
 }
 
 void RCOutput_Raspilot::cork(void)
diff --git a/libraries/AP_HAL_Linux/RCOutput_Raspilot.h b/libraries/AP_HAL_Linux/RCOutput_Raspilot.h
index 179ae62..e8529ea 100644
--- a/libraries/AP_HAL_Linux/RCOutput_Raspilot.h
+++ b/libraries/AP_HAL_Linux/RCOutput_Raspilot.h
@@ -20,7 +20,7 @@ class RCOutput_Raspilot : public AP_HAL::RCOutput {
 
 private:
     void reset();
-    bool _update(void);
+    void _update(void);
 
     AP_HAL::OwnPtr<AP_HAL::SPIDevice> _dev;
 
diff --git a/libraries/AP_HAL_Linux/RPIOUARTDriver.cpp b/libraries/AP_HAL_Linux/RPIOUARTDriver.cpp
index f44fcec..d80b566 100644
--- a/libraries/AP_HAL_Linux/RPIOUARTDriver.cpp
+++ b/libraries/AP_HAL_Linux/RPIOUARTDriver.cpp
@@ -66,7 +66,7 @@ void RPIOUARTDriver::begin(uint32_t b, uint16_t rxS, uint16_t txS)
     if (!_registered_callback) {
         _dev = hal.spi->get_device("raspio");
         _registered_callback = true;
-        _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&RPIOUARTDriver::_bus_timer, bool));
+        _dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&RPIOUARTDriver::_bus_timer, void));
     }
 
     /* set baudrate */
@@ -105,7 +105,7 @@ void RPIOUARTDriver::_timer_tick(void)
     }
 }
 
-bool RPIOUARTDriver::_bus_timer(void)
+void RPIOUARTDriver::_bus_timer(void)
 {
     /* set the baudrate of raspilotio */
     if (_need_set_baud) {
@@ -129,7 +129,7 @@ bool RPIOUARTDriver::_bus_timer(void)
     /* finish set */
 
     if (!_initialised) {
-        return true;
+        return;
     }
 
     _in_timer = true;
@@ -172,6 +172,4 @@ bool RPIOUARTDriver::_bus_timer(void)
     }
 
     _in_timer = false;
-
-    return true;
 }
diff --git a/libraries/AP_HAL_Linux/RPIOUARTDriver.h b/libraries/AP_HAL_Linux/RPIOUARTDriver.h
index 9a4df0f..e1b119b 100644
--- a/libraries/AP_HAL_Linux/RPIOUARTDriver.h
+++ b/libraries/AP_HAL_Linux/RPIOUARTDriver.h
@@ -26,7 +26,7 @@ class RPIOUARTDriver : public UARTDriver {
 private:
     bool _in_timer;
 
-    bool _bus_timer(void);
+    void _bus_timer(void);
 
     AP_HAL::OwnPtr<AP_HAL::SPIDevice> _dev;
 
diff --git a/libraries/AP_IRLock/AP_IRLock_I2C.cpp b/libraries/AP_IRLock/AP_IRLock_I2C.cpp
index eea4776..46f1ab1 100644
--- a/libraries/AP_IRLock/AP_IRLock_I2C.cpp
+++ b/libraries/AP_IRLock/AP_IRLock_I2C.cpp
@@ -44,7 +44,7 @@ void AP_IRLock_I2C::init()
     // read at 50Hz
     printf("Starting IRLock on I2C\n");
 
-    dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&AP_IRLock_I2C::read_frames, bool));
+    dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&AP_IRLock_I2C::read_frames, void));
 }
 
 /*
@@ -108,15 +108,15 @@ bool AP_IRLock_I2C::read_block(struct frame &irframe)
     return true;
 }
 
-bool AP_IRLock_I2C::read_frames(void)
+void AP_IRLock_I2C::read_frames(void)
 {
     if (!sync_frame_start()) {
-        return true;
+        return;
     }
     struct frame irframe;
     
     if (!read_block(irframe)) {
-        return true;
+        return;
     }
 
     int16_t corner1_pix_x = irframe.pixel_x - irframe.pixel_size_x/2;
@@ -148,8 +148,6 @@ bool AP_IRLock_I2C::read_frames(void)
                _target_info.size_x, _target_info.size_y);
     }
 #endif
-
-    return true;
 }
 
 // retrieve latest sensor data - returns true if new data is available
diff --git a/libraries/AP_IRLock/AP_IRLock_I2C.h b/libraries/AP_IRLock/AP_IRLock_I2C.h
index dcb1700..80238a4 100644
--- a/libraries/AP_IRLock/AP_IRLock_I2C.h
+++ b/libraries/AP_IRLock/AP_IRLock_I2C.h
@@ -31,7 +31,7 @@ class AP_IRLock_I2C : public IRLock
 
     bool sync_frame_start(void);
     bool read_block(struct frame &irframe);
-    bool read_frames(void);
+    void read_frames(void);
 
     void pixel_to_1M_plane(float pix_x, float pix_y, float &ret_x, float &ret_y);
 
diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_BMI160.cpp b/libraries/AP_InertialSensor/AP_InertialSensor_BMI160.cpp
index f5305c0..94ee571 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_BMI160.cpp
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_BMI160.cpp
@@ -185,7 +185,7 @@ void AP_InertialSensor_BMI160::start()
 
     /* Call _poll_data() at 1kHz */
     _dev->register_periodic_callback(1000,
-        FUNCTOR_BIND_MEMBER(&AP_InertialSensor_BMI160::_poll_data, bool));
+        FUNCTOR_BIND_MEMBER(&AP_InertialSensor_BMI160::_poll_data, void));
 }
 
 bool AP_InertialSensor_BMI160::update()
@@ -417,10 +417,9 @@ void AP_InertialSensor_BMI160::_read_fifo()
     }
 }
 
-bool AP_InertialSensor_BMI160::_poll_data()
+void AP_InertialSensor_BMI160::_poll_data()
 {
     _read_fifo();
-    return true;
 }
 
 bool AP_InertialSensor_BMI160::_hardware_init()
diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_BMI160.h b/libraries/AP_InertialSensor/AP_InertialSensor_BMI160.h
index 240731b..332910f 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_BMI160.h
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_BMI160.h
@@ -98,7 +98,7 @@ class AP_InertialSensor_BMI160 : public AP_InertialSensor_Backend {
     /**
      * Device periodic callback to read data from the sensors.
      */
-    bool _poll_data();
+    void _poll_data();
 
     /**
      * Read samples from fifo.
diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp b/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp
index 1e4ff3a..2f8376d 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.cpp
@@ -463,7 +463,7 @@ void AP_InertialSensor_Invensense::start()
     }
 
     // start the timer process to read samples
-    _dev->register_periodic_callback(1000, FUNCTOR_BIND_MEMBER(&AP_InertialSensor_Invensense::_poll_data, bool));
+    _dev->register_periodic_callback(1000, FUNCTOR_BIND_MEMBER(&AP_InertialSensor_Invensense::_poll_data, void));
 }
 
 
@@ -519,10 +519,9 @@ bool AP_InertialSensor_Invensense::_data_ready()
 /*
  * Timer process to poll for new data from the Invensense. Called from bus thread with semaphore held
  */
-bool AP_InertialSensor_Invensense::_poll_data()
+void AP_InertialSensor_Invensense::_poll_data()
 {
     _read_fifo();
-    return true;
 }
 
 bool AP_InertialSensor_Invensense::_accumulate(uint8_t *samples, uint8_t n_samples)
diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.h b/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.h
index 4615946..54b3634 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.h
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_Invensense.h
@@ -83,7 +83,7 @@ class AP_InertialSensor_Invensense : public AP_InertialSensor_Backend
     bool _data_ready();
 
     /* Poll for new data (non-blocking) */
-    bool _poll_data();
+    void _poll_data();
 
     /* Read and write functions taking the differences between buses into
      * account */
diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.cpp b/libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.cpp
index 6dfe709..31f3161 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.cpp
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.cpp
@@ -211,7 +211,7 @@ void AP_InertialSensor_L3G4200D::start(void)
     _accel_instance = _imu.register_accel(800, _dev->get_bus_id_devtype(DEVTYPE_L3G4200D));
 
     // start the timer process to read samples
-    _dev->register_periodic_callback(1250, FUNCTOR_BIND_MEMBER(&AP_InertialSensor_L3G4200D::_accumulate, bool));
+    _dev->register_periodic_callback(1250, FUNCTOR_BIND_MEMBER(&AP_InertialSensor_L3G4200D::_accumulate, void));
 }
 
 /*
@@ -226,7 +226,7 @@ bool AP_InertialSensor_L3G4200D::update(void)
 }
 
 // Accumulate values from accels and gyros
-bool AP_InertialSensor_L3G4200D::_accumulate(void)
+void AP_InertialSensor_L3G4200D::_accumulate(void)
 {
     uint8_t num_samples_available;
     uint8_t fifo_status = 0;
@@ -279,8 +279,7 @@ bool AP_InertialSensor_L3G4200D::_accumulate(void)
                 _notify_new_accel_raw_sample(_accel_instance, accel);
             }
         }
-    }
-    return true;
+    } 
 }
 
 #endif
diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.h b/libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.h
index f3728e0..02da026 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.h
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_L3G4200D.h
@@ -28,7 +28,7 @@ class AP_InertialSensor_L3G4200D : public AP_InertialSensor_Backend
 
 private:
     bool _init_sensor();
-    bool _accumulate();
+    void _accumulate();
 
     AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
 
diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.cpp b/libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.cpp
index 5a17fb4..700acd8 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.cpp
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.cpp
@@ -528,7 +528,7 @@ void AP_InertialSensor_LSM9DS0::start(void)
     _set_accel_max_abs_offset(_accel_instance, 5.0f);
 
     /* start the timer process to read samples */
-    _dev_gyro->register_periodic_callback(1000, FUNCTOR_BIND_MEMBER(&AP_InertialSensor_LSM9DS0::_poll_data, bool));
+    _dev_gyro->register_periodic_callback(1000, FUNCTOR_BIND_MEMBER(&AP_InertialSensor_LSM9DS0::_poll_data, void));
 }
 
 
@@ -685,7 +685,7 @@ void AP_InertialSensor_LSM9DS0::_set_accel_scale(accel_scale scale)
 /**
  * Timer process to poll for new data from the LSM9DS0.
  */
-bool AP_InertialSensor_LSM9DS0::_poll_data()
+void AP_InertialSensor_LSM9DS0::_poll_data()
 {
     if (_gyro_data_ready()) {
         _read_data_transaction_g();
@@ -701,8 +701,6 @@ bool AP_InertialSensor_LSM9DS0::_poll_data()
     if (!_dev_accel->check_next_register()) {
         _inc_accel_error_count(_accel_instance);
     }
-    
-    return true;
 }
 
 bool AP_InertialSensor_LSM9DS0::_accel_data_ready()
diff --git a/libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.h b/libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.h
index 49373e1..d0f0e75 100644
--- a/libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.h
+++ b/libraries/AP_InertialSensor/AP_InertialSensor_LSM9DS0.h
@@ -52,7 +52,7 @@ class AP_InertialSensor_LSM9DS0 : public AP_InertialSensor_Backend
     bool _accel_data_ready();
     bool _gyro_data_ready();
 
-    bool _poll_data();
+    void _poll_data();
 
     bool _init_sensor();
     bool _hardware_init();
diff --git a/libraries/AP_Notify/Display_SSD1306_I2C.cpp b/libraries/AP_Notify/Display_SSD1306_I2C.cpp
index 3b28349..7c417a2 100644
--- a/libraries/AP_Notify/Display_SSD1306_I2C.cpp
+++ b/libraries/AP_Notify/Display_SSD1306_I2C.cpp
@@ -51,7 +51,7 @@ bool Display_SSD1306_I2C::hw_init()
 
     _need_hw_update = true;
 
-    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&Display_SSD1306_I2C::_timer, bool));
+    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&Display_SSD1306_I2C::_timer, void));
 
     return true;
 }
@@ -62,10 +62,10 @@ bool Display_SSD1306_I2C::hw_update()
     return true;
 }
 
-bool Display_SSD1306_I2C::_timer()
+void Display_SSD1306_I2C::_timer()
 {
     if (!_need_hw_update) {
-        return true;
+        return;
     }
     _need_hw_update = false;
     
@@ -88,8 +88,6 @@ bool Display_SSD1306_I2C::_timer()
         memcpy(&display_buffer.db[0], &_displaybuffer[i * SSD1306_ROWS], SSD1306_ROWS);
         _dev->transfer((uint8_t *)&display_buffer, sizeof(display_buffer), nullptr, 0);
     }
-
-    return true;
 }
 
 bool Display_SSD1306_I2C::set_pixel(uint16_t x, uint16_t y)
diff --git a/libraries/AP_Notify/Display_SSD1306_I2C.h b/libraries/AP_Notify/Display_SSD1306_I2C.h
index 94b8770..2568af9 100644
--- a/libraries/AP_Notify/Display_SSD1306_I2C.h
+++ b/libraries/AP_Notify/Display_SSD1306_I2C.h
@@ -18,5 +18,5 @@ class Display_SSD1306_I2C: public Display {
     AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
     uint8_t _displaybuffer[SSD1306_ROWS * SSD1306_COLUMNS_PER_PAGE];
     bool _need_hw_update;
-    bool _timer(void);
+    void _timer(void);
 };
diff --git a/libraries/AP_Notify/NavioLED_I2C.cpp b/libraries/AP_Notify/NavioLED_I2C.cpp
index 3863f85..0c4770e 100644
--- a/libraries/AP_Notify/NavioLED_I2C.cpp
+++ b/libraries/AP_Notify/NavioLED_I2C.cpp
@@ -32,7 +32,7 @@ bool NavioLED_I2C::hw_init()
         return false;
     }
 
-    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&NavioLED_I2C::_timer, bool));
+    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&NavioLED_I2C::_timer, void));
 
     return true;
 }
@@ -47,10 +47,10 @@ bool NavioLED_I2C::hw_set_rgb(uint8_t red, uint8_t green, uint8_t blue)
     return true;
 }
 
-bool NavioLED_I2C::_timer(void)
+void NavioLED_I2C::_timer(void)
 {
     if (!_need_update) {
-        return true;
+        return;
     }
     _need_update = false;
     
@@ -73,6 +73,4 @@ bool NavioLED_I2C::_timer(void)
 			     0x00, 0x00, red_channel_lsb, red_channel_msb};
 
     _dev->transfer(transaction, sizeof(transaction), nullptr, 0);
-    
-    return true;
 }
diff --git a/libraries/AP_Notify/NavioLED_I2C.h b/libraries/AP_Notify/NavioLED_I2C.h
index ab57895..ca3f966 100644
--- a/libraries/AP_Notify/NavioLED_I2C.h
+++ b/libraries/AP_Notify/NavioLED_I2C.h
@@ -27,7 +27,7 @@ class NavioLED_I2C : public NavioLED
 
 private:
     AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
-    bool _timer(void);
+    void _timer(void);
     struct {
         uint8_t r, g, b;
     } rgb;
diff --git a/libraries/AP_Notify/ToshibaLED_I2C.cpp b/libraries/AP_Notify/ToshibaLED_I2C.cpp
index 6558178..0a20a6f 100644
--- a/libraries/AP_Notify/ToshibaLED_I2C.cpp
+++ b/libraries/AP_Notify/ToshibaLED_I2C.cpp
@@ -53,7 +53,7 @@ bool ToshibaLED_I2C::hw_init()
     // give back i2c semaphore
     _dev->get_semaphore()->give();
 
-    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&ToshibaLED_I2C::_timer, bool));
+    _dev->register_periodic_callback(20000, FUNCTOR_BIND_MEMBER(&ToshibaLED_I2C::_timer, void));
     
     return ret;
 }
@@ -65,17 +65,16 @@ bool ToshibaLED_I2C::hw_set_rgb(uint8_t red, uint8_t green, uint8_t blue)
     return true;
 }
 
-bool ToshibaLED_I2C::_timer(void)
+void ToshibaLED_I2C::_timer(void)
 {
     if (!_need_update) {
-        return true;
+        return;
     }
     _need_update = false;
-    
+
     /* 4-bit for each color */
     uint8_t val[4] = { TOSHIBA_LED_PWM0, (uint8_t)(rgb.b >> 4),
                        (uint8_t)(rgb.g / 16), (uint8_t)(rgb.r / 16) };
 
     _dev->transfer(val, sizeof(val), nullptr, 0);
-    return true;
 }
diff --git a/libraries/AP_Notify/ToshibaLED_I2C.h b/libraries/AP_Notify/ToshibaLED_I2C.h
index aa62f95..ecfe3dd 100644
--- a/libraries/AP_Notify/ToshibaLED_I2C.h
+++ b/libraries/AP_Notify/ToshibaLED_I2C.h
@@ -27,7 +27,7 @@ class ToshibaLED_I2C : public ToshibaLED
 
 private:
     AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
-    bool _timer(void);
+    void _timer(void);
     bool _need_update;
     struct {
         uint8_t r, g, b;
diff --git a/libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.cpp b/libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.cpp
index 2eeb1b0..1773d21 100644
--- a/libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.cpp
+++ b/libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.cpp
@@ -88,7 +88,7 @@ bool AP_OpticalFlow_PX4Flow::setup_sensor(void)
         return false;
     }
     // read at 10Hz
-    dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AP_OpticalFlow_PX4Flow::timer, bool));
+    dev->register_periodic_callback(100000, FUNCTOR_BIND_MEMBER(&AP_OpticalFlow_PX4Flow::timer, void));
     return true;
 }
 
@@ -99,11 +99,11 @@ void AP_OpticalFlow_PX4Flow::update(void)
 }
 
 // timer to read sensor
-bool AP_OpticalFlow_PX4Flow::timer(void)
+void AP_OpticalFlow_PX4Flow::timer(void)
 {
     struct i2c_integral_frame frame;
     if (!dev->read_registers(REG_INTEGRAL_FRAME, (uint8_t *)&frame, sizeof(frame))) {
-        return true;
+        return;
     }
     struct OpticalFlow::OpticalFlow_state state {};
     state.device_id = get_bus_id();
@@ -124,6 +124,4 @@ bool AP_OpticalFlow_PX4Flow::timer(void)
     }
 
     _update_frontend(state);
-    
-    return true;
 }
diff --git a/libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.h b/libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.h
index f3a03ee..9ab7657 100644
--- a/libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.h
+++ b/libraries/AP_OpticalFlow/AP_OpticalFlow_PX4Flow.h
@@ -44,5 +44,5 @@ class AP_OpticalFlow_PX4Flow : public OpticalFlow_backend
     // setup sensor
     bool setup_sensor(void);
 
-    bool timer(void);
+    void timer(void);
 };
diff --git a/libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.cpp b/libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.cpp
index fc520a8..6d9e142 100644
--- a/libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.cpp
+++ b/libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.cpp
@@ -149,8 +149,8 @@ bool AP_OpticalFlow_Pixart::setup_sensor(void)
     _dev->get_semaphore()->give();
 
     integral.last_frame_us = AP_HAL::micros();
-    
-    _dev->register_periodic_callback(2000, FUNCTOR_BIND_MEMBER(&AP_OpticalFlow_Pixart::timer, bool));
+
+    _dev->register_periodic_callback(2000, FUNCTOR_BIND_MEMBER(&AP_OpticalFlow_Pixart::timer, void));
     return true;
 
 failed:
@@ -266,10 +266,10 @@ void AP_OpticalFlow_Pixart::motion_burst(void)
     _dev->set_chip_select(false);
 }
 
-bool AP_OpticalFlow_Pixart::timer(void)
+void AP_OpticalFlow_Pixart::timer(void)
 {
     if (AP_HAL::micros() - last_burst_us < 500) {
-        return true;
+        return;
     }
     motion_burst();
     last_burst_us = AP_HAL::micros();
@@ -301,7 +301,6 @@ bool AP_OpticalFlow_Pixart::timer(void)
         sum_x = sum_y = 0;
     }
 #endif
-    return true;
 }
 
 // update - read latest values from sensor and fill in x,y and totals.
diff --git a/libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.h b/libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.h
index 8468a25..dd28b60 100644
--- a/libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.h
+++ b/libraries/AP_OpticalFlow/AP_OpticalFlow_Pixart.h
@@ -62,7 +62,7 @@ class AP_OpticalFlow_Pixart : public OpticalFlow_backend
     void srom_download(void);
     void load_configuration(void);
 
-    bool timer(void);
+    void timer(void);
     void motion_burst(void);
 
     int32_t sum_x;
diff --git a/libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.cpp b/libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.cpp
index b339ae6..df614d8 100644
--- a/libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.cpp
+++ b/libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.cpp
@@ -64,7 +64,7 @@ void AP_RangeFinder_LightWareI2C::init()
 {
     // call timer() at 20Hz
     _dev->register_periodic_callback(50000,
-                                     FUNCTOR_BIND_MEMBER(&AP_RangeFinder_LightWareI2C::timer, bool));
+                                     FUNCTOR_BIND_MEMBER(&AP_RangeFinder_LightWareI2C::timer, void));
 }
 
 // read - return last value measured by sensor
@@ -94,13 +94,12 @@ void AP_RangeFinder_LightWareI2C::update(void)
     // nothing to do - its all done in the timer()
 }
 
-bool AP_RangeFinder_LightWareI2C::timer(void)
+void AP_RangeFinder_LightWareI2C::timer(void)
 {
     if (get_reading(state.distance_cm)) {
         // update range_valid state based on distance measured
         update_status();
     } else {
         set_status(RangeFinder::RangeFinder_NoData);
-    }    
-    return true;
+    }
 }
diff --git a/libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.h b/libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.h
index 13abe64..04b941c 100644
--- a/libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.h
+++ b/libraries/AP_RangeFinder/AP_RangeFinder_LightWareI2C.h
@@ -19,8 +19,8 @@ class AP_RangeFinder_LightWareI2C : public AP_RangeFinder_Backend
     AP_RangeFinder_LightWareI2C(RangeFinder &ranger, uint8_t instance, RangeFinder::RangeFinder_State &_state, AP_HAL::OwnPtr<AP_HAL::I2CDevice> dev);
 
     void init();
-    bool timer();
-    
+    void timer();
+
     // get a reading
     bool get_reading(uint16_t &reading_cm);
     AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;
diff --git a/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.cpp b/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.cpp
index 0540e7f..aa71da0 100644
--- a/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.cpp
+++ b/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.cpp
@@ -90,7 +90,7 @@ bool AP_RangeFinder_MaxsonarI2CXL::_init(void)
     _dev->get_semaphore()->give();
     
     _dev->register_periodic_callback(50000,
-                                     FUNCTOR_BIND_MEMBER(&AP_RangeFinder_MaxsonarI2CXL::_timer, bool));
+                                     FUNCTOR_BIND_MEMBER(&AP_RangeFinder_MaxsonarI2CXL::_timer, void));
     
     return true;
 }
@@ -126,7 +126,7 @@ bool AP_RangeFinder_MaxsonarI2CXL::get_reading(uint16_t &reading_cm)
 /*
   timer called at 20Hz
 */
-bool AP_RangeFinder_MaxsonarI2CXL::_timer(void)
+void AP_RangeFinder_MaxsonarI2CXL::_timer(void)
 {
     uint16_t d;
     if (get_reading(d)) {
@@ -136,9 +136,8 @@ bool AP_RangeFinder_MaxsonarI2CXL::_timer(void)
             _sem->give();
         }
     }
-    return true;
 }
-    
+
 
 /*
    update the state of the sensor
diff --git a/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.h b/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.h
index f65a0e3..304560e 100644
--- a/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.h
+++ b/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.h
@@ -28,8 +28,8 @@ class AP_RangeFinder_MaxsonarI2CXL : public AP_RangeFinder_Backend
     AP_RangeFinder_MaxsonarI2CXL(RangeFinder &ranger, uint8_t instance,
                                  RangeFinder::RangeFinder_State &_state);
 
-    bool _init(void);    
-    bool _timer(void);
+    bool _init(void);
+    void _timer(void);
 
     uint16_t distance;
     bool new_distance;
diff --git a/libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.cpp b/libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.cpp
index 646ad50e..e5bb46fb 100644
--- a/libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.cpp
+++ b/libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.cpp
@@ -71,7 +71,7 @@ AP_RangeFinder_Backend *AP_RangeFinder_PulsedLightLRF::detect(uint8_t bus, Range
 /*
   called at 50Hz
  */
-bool AP_RangeFinder_PulsedLightLRF::timer(void)
+void AP_RangeFinder_PulsedLightLRF::timer(void)
 {
     if (check_reg_counter++ == 10) {
         check_reg_counter = 0;
@@ -110,7 +110,6 @@ bool AP_RangeFinder_PulsedLightLRF::timer(void)
         break;
     }
     }
-    return true;
 }
 
 
@@ -181,7 +180,7 @@ bool AP_RangeFinder_PulsedLightLRF::init(void)
     }
 
     _dev->register_periodic_callback(20000,
-                                     FUNCTOR_BIND_MEMBER(&AP_RangeFinder_PulsedLightLRF::timer, bool));
+                                     FUNCTOR_BIND_MEMBER(&AP_RangeFinder_PulsedLightLRF::timer, void));
     return true;
 }
 
diff --git a/libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.h b/libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.h
index a79fbf0..f9437d3 100644
--- a/libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.h
+++ b/libraries/AP_RangeFinder/AP_RangeFinder_PulsedLightLRF.h
@@ -33,7 +33,7 @@ class AP_RangeFinder_PulsedLightLRF : public AP_RangeFinder_Backend
 
     // start a reading
     bool init(void);
-    bool timer(void);
+    void timer(void);
     bool lidar_transfer(const uint8_t *send, unsigned send_len, uint8_t *recv, unsigned recv_len);
     
     AP_HAL::OwnPtr<AP_HAL::I2CDevice> _dev;

From 58a0a6a2fc9373a55594ea1eaacf70c9cd1b5dae Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 14 Jan 2017 12:40:04 +1100
Subject: [PATCH 114/200] AP_Compass: disable lis3mdl for now

pending investigation of possible hw error
---
 libraries/AP_Compass/AP_Compass.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/libraries/AP_Compass/AP_Compass.cpp b/libraries/AP_Compass/AP_Compass.cpp
index 7e17c76..57df804 100644
--- a/libraries/AP_Compass/AP_Compass.cpp
+++ b/libraries/AP_Compass/AP_Compass.cpp
@@ -517,13 +517,15 @@ void Compass::_detect_backends(void)
                                               both_i2c_external, both_i2c_external?ROTATION_ROLL_180:ROTATION_YAW_270),
                     AP_Compass_HMC5843::name, both_i2c_external);
 
-        // lis3mdl
+#if 0
+        // lis3mdl - this is disabled for now due to an errata on pixhawk2 GPS unit, pending investigation
         ADD_BACKEND(AP_Compass_LIS3MDL::probe(*this, hal.i2c_mgr->get_device(1, HAL_COMPASS_LIS3MDL_I2C_ADDR),
                                                true, ROTATION_YAW_90),
                      AP_Compass_LIS3MDL::name, true);
         ADD_BACKEND(AP_Compass_LIS3MDL::probe(*this, hal.i2c_mgr->get_device(0, HAL_COMPASS_LIS3MDL_I2C_ADDR),
                                               both_i2c_external, both_i2c_external?ROTATION_YAW_90:ROTATION_NONE),
                      AP_Compass_LIS3MDL::name, both_i2c_external);
+#endif
 
         // AK09916
         ADD_BACKEND(AP_Compass_AK09916::probe(*this, hal.i2c_mgr->get_device(1, HAL_COMPASS_AK09916_I2C_ADDR),

From 1ce5e5360a96f2d8ed72767eda79d84ab9c41055 Mon Sep 17 00:00:00 2001
From: mirkix <mirkix@gmail.com>
Date: Thu, 29 Dec 2016 15:45:02 +0100
Subject: [PATCH 115/200] AP_Baro: Add Bosch BMP280 driver

---
 libraries/AP_Baro/AP_Baro.cpp        |   7 ++
 libraries/AP_Baro/AP_Baro_BMP280.cpp | 197 +++++++++++++++++++++++++++++++++++
 libraries/AP_Baro/AP_Baro_BMP280.h   |  38 +++++++
 3 files changed, 242 insertions(+)
 create mode 100644 libraries/AP_Baro/AP_Baro_BMP280.cpp
 create mode 100644 libraries/AP_Baro/AP_Baro_BMP280.h

diff --git a/libraries/AP_Baro/AP_Baro.cpp b/libraries/AP_Baro/AP_Baro.cpp
index f7c2593..95fc329 100644
--- a/libraries/AP_Baro/AP_Baro.cpp
+++ b/libraries/AP_Baro/AP_Baro.cpp
@@ -27,6 +27,7 @@
 #include <AP_BoardConfig/AP_BoardConfig.h>
 
 #include "AP_Baro_BMP085.h"
+#include "AP_Baro_BMP280.h"
 #include "AP_Baro_HIL.h"
 #include "AP_Baro_MS5611.h"
 #include "AP_Baro_PX4.h"
@@ -362,6 +363,12 @@ void AP_Baro::init(void)
     drivers[0] = new AP_Baro_BMP085(*this,
         std::move(hal.i2c_mgr->get_device(HAL_BARO_BMP085_BUS, HAL_BARO_BMP085_I2C_ADDR)));
     _num_drivers = 1;
+#elif HAL_BARO_DEFAULT == HAL_BARO_BMP280_I2C
+    ADD_BACKEND(AP_Baro_BMP280::probe(*this,
+                                      std::move(hal.i2c_mgr->get_device(HAL_BARO_BMP280_BUS, HAL_BARO_BMP280_I2C_ADDR))));
+#elif HAL_BARO_DEFAULT == HAL_BARO_BMP280_SPI
+    ADD_BACKEND(AP_Baro_BMP280::probe(*this,
+                                      std::move(hal.spi->get_device(HAL_BARO_BMP280_NAME))));
 #elif HAL_BARO_DEFAULT == HAL_BARO_MS5611_I2C
     ADD_BACKEND(AP_Baro_MS56XX::probe(*this,
                                       std::move(hal.i2c_mgr->get_device(HAL_BARO_MS5611_I2C_BUS, HAL_BARO_MS5611_I2C_ADDR))));
diff --git a/libraries/AP_Baro/AP_Baro_BMP280.cpp b/libraries/AP_Baro/AP_Baro_BMP280.cpp
new file mode 100644
index 0000000..b9da66d
--- /dev/null
+++ b/libraries/AP_Baro/AP_Baro_BMP280.cpp
@@ -0,0 +1,197 @@
+/*
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "AP_Baro_BMP280.h"
+
+#include <utility>
+
+extern const AP_HAL::HAL &hal;
+
+#define BMP280_MODE_SLEEP  0
+#define BMP280_MODE_FORCED 1
+#define BMP280_MODE_NORMAL 3
+#define BMP280_MODE BMP280_MODE_NORMAL
+
+#define BMP280_OVERSAMPLING_1  1
+#define BMP280_OVERSAMPLING_2  2
+#define BMP280_OVERSAMPLING_4  3
+#define BMP280_OVERSAMPLING_8  4
+#define BMP280_OVERSAMPLING_16 5
+#define BMP280_OVERSAMPLING_P BMP280_OVERSAMPLING_16
+#define BMP280_OVERSAMPLING_T BMP280_OVERSAMPLING_2
+
+#define BMP280_FILTER_COEFFICIENT 2
+
+#define BMP280_ID            0x58
+
+#define BMP280_REG_CALIB     0x88
+#define BMP280_REG_ID        0xD0
+#define BMP280_REG_RESET     0xE0
+#define BMP280_REG_STATUS    0xF3
+#define BMP280_REG_CTRL_MEAS 0xF4
+#define BMP280_REG_CONFIG    0xF5
+#define BMP280_REG_DATA      0xF7
+
+AP_Baro_BMP280::AP_Baro_BMP280(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev)
+    : AP_Baro_Backend(baro)
+    , _dev(std::move(dev))
+{
+}
+
+AP_Baro_Backend *AP_Baro_BMP280::probe(AP_Baro &baro,
+                                       AP_HAL::OwnPtr<AP_HAL::Device> dev)
+{
+    if (!dev) {
+        return nullptr;
+    }
+
+    AP_Baro_BMP280 *sensor = new AP_Baro_BMP280(baro, std::move(dev));
+    if (!sensor || !sensor->_init()) {
+        delete sensor;
+        return nullptr;
+    }
+    return sensor;
+}
+
+bool AP_Baro_BMP280::_init()
+{
+    if (!_dev | !_dev->get_semaphore()->take(0)) {
+        return false;
+    }
+
+    _has_sample = false;
+
+    _dev->set_speed(AP_HAL::Device::SPEED_HIGH);
+
+    uint8_t whoami;
+    if (!_dev->read_registers(BMP280_REG_ID, &whoami, 1)  ||
+        whoami != BMP280_ID) {
+        // not a BMP280
+        _dev->get_semaphore()->give();
+        return false;
+    }
+
+    // read the calibration data
+    uint8_t buf[24];
+    _dev->read_registers(BMP280_REG_CALIB, buf, sizeof(buf));
+
+    _t1 = ((int16_t)buf[1] << 8) | buf[0];
+    _t2 = ((int16_t)buf[3] << 8) | buf[2];
+    _t3 = ((int16_t)buf[5] << 8) | buf[4];
+    _p1 = ((int16_t)buf[7] << 8) | buf[6];
+    _p2 = ((int16_t)buf[9] << 8) | buf[8];
+    _p3 = ((int16_t)buf[11] << 8) | buf[10];
+    _p4 = ((int16_t)buf[13] << 8) | buf[12];
+    _p5 = ((int16_t)buf[15] << 8) | buf[14];
+    _p6 = ((int16_t)buf[17] << 8) | buf[16];
+    _p7 = ((int16_t)buf[19] << 8) | buf[18];
+    _p8 = ((int16_t)buf[21] << 8) | buf[20];
+    _p9 = ((int16_t)buf[23] << 8) | buf[22];
+
+    // SPI write needs bit mask
+    uint8_t mask = 0xFF;
+    if (_dev->bus_type() == AP_HAL::Device::BUS_TYPE_SPI) {
+        mask = 0x7F;
+    }
+
+    _dev->write_register((BMP280_REG_CTRL_MEAS & mask), (BMP280_OVERSAMPLING_T << 5) |
+                         (BMP280_OVERSAMPLING_P << 2) | BMP280_MODE);
+
+    _dev->write_register((BMP280_REG_CONFIG & mask), BMP280_FILTER_COEFFICIENT << 2);
+
+    _instance = _frontend.register_sensor();
+
+    _dev->get_semaphore()->give();
+
+    // request 50Hz update
+    _dev->register_periodic_callback(20 * USEC_PER_MSEC, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP280::_timer, bool));
+
+    return true;
+}
+
+
+
+//  acumulate a new sensor reading
+bool AP_Baro_BMP280::_timer(void)
+{
+    uint8_t buf[6];
+
+    _dev->read_registers(BMP280_REG_DATA, buf, sizeof(buf));
+
+    _update_temperature((buf[3] << 12) | (buf[4] << 4) | (buf[5] >> 4));
+    _update_pressure((buf[0] << 12) | (buf[1] << 4) | (buf[2] >> 4));
+
+    return true;
+}
+
+// transfer data to the frontend
+void AP_Baro_BMP280::update(void)
+{
+    if (_sem->take_nonblocking()) {
+        if (!_has_sample) {
+            _sem->give();
+            return;
+        }
+
+        _copy_to_frontend(_instance, _pressure, _temperature);
+        _has_sample = false;
+        _sem->give();
+    }
+}
+
+// calculate temperature
+void AP_Baro_BMP280::_update_temperature(int32_t temp_raw)
+{
+    int32_t var1, var2, t;
+
+    // according to datasheet page 22
+    var1 = ((((temp_raw >> 3) - ((int32_t)_t1 << 1))) * ((int32_t)_t2)) >> 11;
+    var2 = (((((temp_raw >> 4) - ((int32_t)_t1)) * ((temp_raw >> 4) - ((int32_t)_t1))) >> 12) * ((int32_t)_t3)) >> 14;
+    _t_fine = var1 + var2;
+    t = (_t_fine * 5 + 128) >> 8;
+    if (_sem->take(0)) {
+        _temperature = ((float)t) / 100;
+        _sem->give();
+    }
+}
+
+// calculate pressure
+void AP_Baro_BMP280::_update_pressure(int32_t press_raw)
+{
+    int64_t var1, var2, p;
+
+    // according to datasheet page 22
+    var1 = ((int64_t)_t_fine) - 128000;
+    var2 = var1 * var1 * (int64_t)_p6;
+    var2 = var2 + ((var1 * (int64_t)_p5) << 17);
+    var2 = var2 + (((int64_t)_p4) << 35);
+    var1 = ((var1 * var1 * (int64_t)_p3) >> 8) + ((var1 * (int64_t)_p2) << 12);
+    var1 = (((((int64_t)1) << 47) + var1)) * ((int64_t)_p1) >> 33;
+
+    if (var1 == 0) {
+        return;
+    }
+
+    p = 1048576 - press_raw;
+    p = (((p << 31) - var2) * 3125) / var1;
+    var1 = (((int64_t)_p9) * (p >> 13) * (p >> 13)) >> 25;
+    var2 = (((int64_t)_p8) * p) >> 19;
+    p = ((p + var1 + var2) >> 8) + (((int64_t)_p7) << 4);
+
+    if (_sem->take(0)) {
+        _pressure = (float)p / 25600;
+        _has_sample = true;
+        _sem->give();
+    }
+}
diff --git a/libraries/AP_Baro/AP_Baro_BMP280.h b/libraries/AP_Baro/AP_Baro_BMP280.h
new file mode 100644
index 0000000..bab6707
--- /dev/null
+++ b/libraries/AP_Baro/AP_Baro_BMP280.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include <AP_HAL/AP_HAL.h>
+#include <AP_HAL/Device.h>
+#include <AP_HAL/utility/OwnPtr.h>
+
+#include "AP_Baro_Backend.h"
+
+class AP_Baro_BMP280 : public AP_Baro_Backend
+{
+public:
+    AP_Baro_BMP280(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev);
+
+    /* AP_Baro public interface: */
+    void update();
+
+    static AP_Baro_Backend *probe(AP_Baro &baro, AP_HAL::OwnPtr<AP_HAL::Device> dev);
+
+private:
+    virtual ~AP_Baro_BMP280(void) {};
+
+    bool _init(void);
+    bool _timer(void);
+    void _update_temperature(int32_t);
+    void _update_pressure(int32_t);
+
+    AP_HAL::OwnPtr<AP_HAL::Device> _dev;
+
+    bool _has_sample;
+    uint8_t _instance;
+    int32_t _t_fine;
+    float _pressure;
+    float _temperature;
+
+    // Internal calibration registers
+    int16_t _t2, _t3, _p2, _p3, _p4, _p5, _p6, _p7, _p8, _p9;
+    uint16_t _t1, _p1;
+};

From 4e06be38ac9bd859983c55bac461a27da978cb5e Mon Sep 17 00:00:00 2001
From: mirkix <mirkix@gmail.com>
Date: Thu, 29 Dec 2016 15:53:32 +0100
Subject: [PATCH 116/200] AP_HAL: Add Bosch BMP280 driver

---
 libraries/AP_HAL/AP_HAL_Boards.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libraries/AP_HAL/AP_HAL_Boards.h b/libraries/AP_HAL/AP_HAL_Boards.h
index bb52cc8..17db628 100644
--- a/libraries/AP_HAL/AP_HAL_Boards.h
+++ b/libraries/AP_HAL/AP_HAL_Boards.h
@@ -81,6 +81,8 @@
 #define HAL_BARO_MS5637_I2C  8
 #define HAL_BARO_QFLIGHT     9
 #define HAL_BARO_QURT       10
+#define HAL_BARO_BMP280_I2C 11
+#define HAL_BARA_BMP280_SPI 12
 
 /* Compass driver types */
 #define HAL_COMPASS_HMC5843             1

From 8aa100d16456bda1b14db943422a7e71f14159bb Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sat, 14 Jan 2017 12:53:48 +1100
Subject: [PATCH 117/200] AP_Baro: fix for change to timer API

---
 libraries/AP_Baro/AP_Baro_BMP280.cpp | 6 ++----
 libraries/AP_Baro/AP_Baro_BMP280.h   | 2 +-
 2 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/libraries/AP_Baro/AP_Baro_BMP280.cpp b/libraries/AP_Baro/AP_Baro_BMP280.cpp
index b9da66d..4505e64 100644
--- a/libraries/AP_Baro/AP_Baro_BMP280.cpp
+++ b/libraries/AP_Baro/AP_Baro_BMP280.cpp
@@ -115,7 +115,7 @@ bool AP_Baro_BMP280::_init()
     _dev->get_semaphore()->give();
 
     // request 50Hz update
-    _dev->register_periodic_callback(20 * USEC_PER_MSEC, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP280::_timer, bool));
+    _dev->register_periodic_callback(20 * USEC_PER_MSEC, FUNCTOR_BIND_MEMBER(&AP_Baro_BMP280::_timer, void));
 
     return true;
 }
@@ -123,7 +123,7 @@ bool AP_Baro_BMP280::_init()
 
 
 //  acumulate a new sensor reading
-bool AP_Baro_BMP280::_timer(void)
+void AP_Baro_BMP280::_timer(void)
 {
     uint8_t buf[6];
 
@@ -131,8 +131,6 @@ bool AP_Baro_BMP280::_timer(void)
 
     _update_temperature((buf[3] << 12) | (buf[4] << 4) | (buf[5] >> 4));
     _update_pressure((buf[0] << 12) | (buf[1] << 4) | (buf[2] >> 4));
-
-    return true;
 }
 
 // transfer data to the frontend
diff --git a/libraries/AP_Baro/AP_Baro_BMP280.h b/libraries/AP_Baro/AP_Baro_BMP280.h
index bab6707..da94b74 100644
--- a/libraries/AP_Baro/AP_Baro_BMP280.h
+++ b/libraries/AP_Baro/AP_Baro_BMP280.h
@@ -20,7 +20,7 @@ class AP_Baro_BMP280 : public AP_Baro_Backend
     virtual ~AP_Baro_BMP280(void) {};
 
     bool _init(void);
-    bool _timer(void);
+    void _timer(void);
     void _update_temperature(int32_t);
     void _update_pressure(int32_t);
 

From 6aeef76768f99368807d1b72b4730be47cb35aa6 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 16 Jan 2017 16:35:59 +0900
Subject: [PATCH 118/200] AP_Proximity: fix get_boundary_points in case of
 multiple sensors

---
 libraries/AP_Proximity/AP_Proximity.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_Proximity/AP_Proximity.cpp b/libraries/AP_Proximity/AP_Proximity.cpp
index 1f78760..67d0d1e 100644
--- a/libraries/AP_Proximity/AP_Proximity.cpp
+++ b/libraries/AP_Proximity/AP_Proximity.cpp
@@ -304,7 +304,7 @@ const Vector2f* AP_Proximity::get_boundary_points(uint8_t instance, uint16_t& nu
         return nullptr;
     }
     // get boundary from backend
-    return drivers[primary_instance]->get_boundary_points(num_points);
+    return drivers[instance]->get_boundary_points(num_points);
 }
 
 const Vector2f* AP_Proximity::get_boundary_points(uint16_t& num_points) const

From 0b85921505fa4caa8a558f067e6937a510db63cd Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 16 Jan 2017 16:40:34 +0900
Subject: [PATCH 119/200] Tools: update param file for sitl optflow testing

---
 Tools/autotest/default_params/copter-optflow.parm | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Tools/autotest/default_params/copter-optflow.parm b/Tools/autotest/default_params/copter-optflow.parm
index e7bec61..59eea70 100644
--- a/Tools/autotest/default_params/copter-optflow.parm
+++ b/Tools/autotest/default_params/copter-optflow.parm
@@ -1,5 +1,6 @@
 ARMING_CHECK -33
 EKF_GPS_TYPE 3
+EK2_GPS_TYPE 3
 FLOW_ENABLE 1
 RNGFND_TYPE 1
 RNGFND_MIN_CM 0

From 0d4ca03dcd26844386b2e2978ea7757651600fcf Mon Sep 17 00:00:00 2001
From: Julien Beraud <julien.beraud@parrot.com>
Date: Mon, 16 Jan 2017 15:48:35 +0100
Subject: [PATCH 120/200] AP_HAL_Linux: init SPIDevice speed by default

Else a speed of 0 will be sent at each transfer.
Behaviour has changed when introducing SPIDevice
---
 libraries/AP_HAL_Linux/SPIDevice.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libraries/AP_HAL_Linux/SPIDevice.cpp b/libraries/AP_HAL_Linux/SPIDevice.cpp
index 965ba71..3e74b06 100644
--- a/libraries/AP_HAL_Linux/SPIDevice.cpp
+++ b/libraries/AP_HAL_Linux/SPIDevice.cpp
@@ -209,6 +209,7 @@ SPIDevice::SPIDevice(SPIBus &bus, SPIDesc &device_desc)
 {
     set_device_bus(_bus.bus);
     set_device_address(_desc.subdev);
+    _speed = _desc.highspeed;
     
     if (_desc.cs_pin != SPI_CS_KERNEL) {
         _cs = hal.gpio->channel(_desc.cs_pin);

From 2243d900d578fcf663aaebb99085efbfc531e210 Mon Sep 17 00:00:00 2001
From: "Dr.-Ing. Amilcar Do Carmo Lucas" <amilcar.lucas@iav.de>
Date: Tue, 10 Jan 2017 16:32:19 +0100
Subject: [PATCH 121/200] AP_Gripper: Add missing parameter units

---
 libraries/AP_Gripper/AP_Gripper.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/libraries/AP_Gripper/AP_Gripper.cpp b/libraries/AP_Gripper/AP_Gripper.cpp
index 56831d3..16fa0d2 100644
--- a/libraries/AP_Gripper/AP_Gripper.cpp
+++ b/libraries/AP_Gripper/AP_Gripper.cpp
@@ -31,6 +31,7 @@ const AP_Param::GroupInfo AP_Gripper::var_info[] = {
     // @Description: PWM value sent to Gripper to initiate grabbing the cargo
     // @User: Advanced
     // @Range: 1000 2000
+    // @Units: PWM
     AP_GROUPINFO("GRAB",    2, AP_Gripper, config.grab_pwm, GRIPPER_GRAB_PWM_DEFAULT),
 
     // @Param: RELEASE
@@ -38,6 +39,7 @@ const AP_Param::GroupInfo AP_Gripper::var_info[] = {
     // @Description: PWM value sent to Gripper to release the cargo
     // @User: Advanced
     // @Range: 1000 2000
+    // @Units: PWM
     AP_GROUPINFO("RELEASE", 3, AP_Gripper, config.release_pwm, GRIPPER_RELEASE_PWM_DEFAULT),
 
     // @Param: NEUTRAL
@@ -45,6 +47,7 @@ const AP_Param::GroupInfo AP_Gripper::var_info[] = {
     // @Description: PWM value sent to grabber when not grabbing or releasing
     // @User: Advanced
     // @Range: 1000 2000
+    // @Units: PWM
     AP_GROUPINFO("NEUTRAL", 4, AP_Gripper, config.neutral_pwm, GRIPPER_NEUTRAL_PWM_DEFAULT),
 
     // @Param: REGRAB

From 715d0946787e40196b70db52b19a189e1726e6ea Mon Sep 17 00:00:00 2001
From: "Dr.-Ing. Amilcar Do Carmo Lucas" <amilcar.lucas@iav.de>
Date: Tue, 10 Jan 2017 16:33:29 +0100
Subject: [PATCH 122/200] AP_NavEKF2: Correct display names, bitmask and units

---
 libraries/AP_NavEKF2/AP_NavEKF2.cpp | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/libraries/AP_NavEKF2/AP_NavEKF2.cpp b/libraries/AP_NavEKF2/AP_NavEKF2.cpp
index 47c4f5e..e40abb2 100644
--- a/libraries/AP_NavEKF2/AP_NavEKF2.cpp
+++ b/libraries/AP_NavEKF2/AP_NavEKF2.cpp
@@ -198,7 +198,7 @@ const AP_Param::GroupInfo NavEKF2::var_info[] = {
     // Height measurement parameters
 
     // @Param: ALT_SOURCE
-    // @DisplayName: Primary height source
+    // @DisplayName: Primary altitude sensor source
     // @Description: This parameter controls the primary height sensor used by the EKF. If the selected option cannot be used, it will default to Baro as the primary height source. Setting 0 will use the baro altitude at all times. Setting 1 uses the range finder and is only available in combination with optical flow navigation (EK2_GPS_TYPE = 3). Setting 2 uses GPS. Setting 3 uses the range beacon data. NOTE - the EK2_RNG_USE_HGT parameter can be used to switch to range-finder when close to the ground.
     // @Values: 0:Use Baro, 1:Use Range Finder, 2:Use GPS, 3:Use Range Beacon
     // @User: Advanced
@@ -387,7 +387,7 @@ const AP_Param::GroupInfo NavEKF2::var_info[] = {
     AP_GROUPINFO("WIND_P_NSE", 30, NavEKF2, _windVelProcessNoise, 0.1f),
 
     // @Param: WIND_PSCALE
-    // @DisplayName: Height rate to wind procss noise scaler
+    // @DisplayName: Height rate to wind process noise scaler
     // @Description: This controls how much the process noise on the wind states is increased when gaining or losing altitude to take into account changes in wind speed and direction with altitude. Increasing this parameter increases how rapidly the wind states adapt when changing altitude, but does make wind velocity estimation noiser.
     // @Range: 0.0 1.0
     // @Increment: 0.1
@@ -404,7 +404,7 @@ const AP_Param::GroupInfo NavEKF2::var_info[] = {
     // @Param: IMU_MASK
     // @DisplayName: Bitmask of active IMUs
     // @Description: 1 byte bitmap of IMUs to use in EKF2. A separate instance of EKF2 will be started for each IMU selected. Set to 1 to use the first IMU only (default), set to 2 to use the second IMU only, set to 3 to use the first and second IMU. Additional IMU's can be used up to a maximum of 6 if memory and processing resources permit. There may be insufficient memory and processing resources to run multiple instances. If this occurs EKF2 will fail to start.
-    // @Range: 1 127
+    // @Bitmask: 0:FirstIMU,1:SecondIMU,2:ThirdIMU,3:FourthIMU,4:FifthIMU,5:SixthIMU
     // @User: Advanced
     AP_GROUPINFO("IMU_MASK",     33, NavEKF2, _imuMask, 3),
     
@@ -421,13 +421,13 @@ const AP_Param::GroupInfo NavEKF2::var_info[] = {
     // @Description: This sets the amount of position variation that the EKF allows for when operating without external measurements (eg GPS or optical flow). Increasing this parameter makes the EKF attitude estimate less sensitive to vehicle manoeuvres but more sensitive to IMU errors.
     // @Range: 0.5 50.0
     // @User: Advanced
-    // @Units: m/s
+    // @Units: m
     AP_GROUPINFO("NOAID_M_NSE", 35, NavEKF2, _noaidHorizNoise, 10.0f),
 
     // @Param: LOG_MASK
     // @DisplayName: EKF sensor logging IMU mask
     // @Description: This sets the IMU mask of sensors to do full logging for
-    // @Values: 0:Disabled,1:FirstIMU,3:FirstAndSecondIMU,7:AllIMUs
+    // @Bitmask: 0:FirstIMU,1:SecondIMU,2:ThirdIMU,3:FourthIMU,4:FifthIMU,5:SixthIMU
     // @User: Advanced
     AP_GROUPINFO("LOG_MASK", 36, NavEKF2, _logging_mask, 1),
 
@@ -524,7 +524,7 @@ const AP_Param::GroupInfo NavEKF2::var_info[] = {
     // @Range: 2.0 6.0
     // @Increment: 0.5
     // @User: Advanced
-    // @Units: m
+    // @Units: m/s
     AP_GROUPINFO("RNG_USE_SPD", 47, NavEKF2, _useRngSwSpd, 2.0f),
 
     AP_GROUPEND

From cae557fb4cc02acabd01ad58314de2106533ea92 Mon Sep 17 00:00:00 2001
From: "Dr.-Ing. Amilcar Do Carmo Lucas" <amilcar.lucas@iav.de>
Date: Tue, 10 Jan 2017 16:33:53 +0100
Subject: [PATCH 123/200] AP_NavEKF3: Correct display names, bitmask and units

---
 libraries/AP_NavEKF3/AP_NavEKF3.cpp | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/libraries/AP_NavEKF3/AP_NavEKF3.cpp b/libraries/AP_NavEKF3/AP_NavEKF3.cpp
index a3af429..b31b2f8 100644
--- a/libraries/AP_NavEKF3/AP_NavEKF3.cpp
+++ b/libraries/AP_NavEKF3/AP_NavEKF3.cpp
@@ -377,7 +377,7 @@ const AP_Param::GroupInfo NavEKF3::var_info[] = {
     AP_GROUPINFO("WIND_P_NSE", 30, NavEKF3, _windVelProcessNoise, 0.1f),
 
     // @Param: WIND_PSCALE
-    // @DisplayName: Height rate to wind procss noise scaler
+    // @DisplayName: Height rate to wind process noise scaler
     // @Description: This controls how much the process noise on the wind states is increased when gaining or losing altitude to take into account changes in wind speed and direction with altitude. Increasing this parameter increases how rapidly the wind states adapt when changing altitude, but does make wind velocity estimation noiser.
     // @Range: 0.0 1.0
     // @Increment: 0.1
@@ -394,7 +394,7 @@ const AP_Param::GroupInfo NavEKF3::var_info[] = {
     // @Param: IMU_MASK
     // @DisplayName: Bitmask of active IMUs
     // @Description: 1 byte bitmap of IMUs to use in EKF3. A separate instance of EKF3 will be started for each IMU selected. Set to 1 to use the first IMU only (default), set to 2 to use the second IMU only, set to 3 to use the first and second IMU. Additional IMU's can be used up to a maximum of 6 if memory and processing resources permit. There may be insufficient memory and processing resources to run multiple instances. If this occurs EKF3 will fail to start.
-    // @Range: 1 127
+    // @Bitmask: 0:FirstIMU,1:SecondIMU,2:ThirdIMU,3:FourthIMU,4:FifthIMU,5:SixthIMU
     // @User: Advanced
     AP_GROUPINFO("IMU_MASK",     33, NavEKF3, _imuMask, 3),
     
@@ -411,13 +411,13 @@ const AP_Param::GroupInfo NavEKF3::var_info[] = {
     // @Description: This sets the amount of position variation that the EKF allows for when operating without external measurements (eg GPS or optical flow). Increasing this parameter makes the EKF attitude estimate less sensitive to vehicle manoeuvres but more sensitive to IMU errors.
     // @Range: 0.5 50.0
     // @User: Advanced
-    // @Units: m/s
+    // @Units: m
     AP_GROUPINFO("NOAID_M_NSE", 35, NavEKF3, _noaidHorizNoise, 10.0f),
 
     // @Param: LOG_MASK
     // @DisplayName: EKF sensor logging IMU mask
     // @Description: This sets the IMU mask of sensors to do full logging for
-    // @Values: 0:Disabled,1:FirstIMU,3:FirstAndSecondIMU,7:AllIMUs
+    // @Bitmask: 0:FirstIMU,1:SecondIMU,2:ThirdIMU,3:FourthIMU,4:FifthIMU,5:SixthIMU
     // @User: Advanced
     AP_GROUPINFO("LOG_MASK", 36, NavEKF3, _logging_mask, 1),
 
@@ -514,7 +514,7 @@ const AP_Param::GroupInfo NavEKF3::var_info[] = {
     // @Range: 2.0 6.0
     // @Increment: 0.5
     // @User: Advanced
-    // @Units: m
+    // @Units: m/s
     AP_GROUPINFO("RNG_USE_SPD", 47, NavEKF3, _useRngSwSpd, 2.0f),
 
     // @Param: ACC_BIAS_LIM
@@ -825,7 +825,7 @@ void NavEKF3::getGyroBias(int8_t instance, Vector3f &gyroBias)
     }
 }
 
-// return acceerometer bias estimate in m/s/s
+// return accelerometer bias estimate in m/s/s
 void NavEKF3::getAccelBias(int8_t instance, Vector3f &accelBias)
 {
     if (instance < 0 || instance >= num_cores) instance = primary;

From bebb128d22938224e05dda0db9313557bc2aff4e Mon Sep 17 00:00:00 2001
From: "Dr.-Ing. Amilcar Do Carmo Lucas" <amilcar.lucas@iav.de>
Date: Tue, 10 Jan 2017 16:34:26 +0100
Subject: [PATCH 124/200] AP_Proximity: Add missing parameter units

---
 libraries/AP_Proximity/AP_Proximity.cpp | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/libraries/AP_Proximity/AP_Proximity.cpp b/libraries/AP_Proximity/AP_Proximity.cpp
index 67d0d1e..38966a9 100644
--- a/libraries/AP_Proximity/AP_Proximity.cpp
+++ b/libraries/AP_Proximity/AP_Proximity.cpp
@@ -41,6 +41,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _YAW_CORR
     // @DisplayName: Proximity sensor yaw correction
     // @Description: Proximity sensor yaw correction
+    // @Units: degrees
     // @Range: -180 180
     // @User: Standard
     AP_GROUPINFO("_YAW_CORR", 3, AP_Proximity, _yaw_correction[0], PROXIMITY_YAW_CORRECTION_DEFAULT),
@@ -48,6 +49,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_ANG1
     // @DisplayName: Proximity sensor ignore angle 1
     // @Description: Proximity sensor ignore angle 1
+    // @Units: degrees
     // @Range: 0 360
     // @User: Standard
     AP_GROUPINFO("_IGN_ANG1", 4, AP_Proximity, _ignore_angle_deg[0], 0),
@@ -55,6 +57,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_WID1
     // @DisplayName: Proximity sensor ignore width 1
     // @Description: Proximity sensor ignore width 1
+    // @Units: degrees
     // @Range: 0 45
     // @User: Standard
     AP_GROUPINFO("_IGN_WID1", 5, AP_Proximity, _ignore_width_deg[0], 0),
@@ -62,6 +65,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_ANG2
     // @DisplayName: Proximity sensor ignore angle 2
     // @Description: Proximity sensor ignore angle 2
+    // @Units: degrees
     // @Range: 0 360
     // @User: Standard
     AP_GROUPINFO("_IGN_ANG2", 6, AP_Proximity, _ignore_angle_deg[1], 0),
@@ -69,6 +73,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_WID1
     // @DisplayName: Proximity sensor ignore width 2
     // @Description: Proximity sensor ignore width 2
+    // @Units: degrees
     // @Range: 0 45
     // @User: Standard
     AP_GROUPINFO("_IGN_WID2", 7, AP_Proximity, _ignore_width_deg[1], 0),
@@ -76,6 +81,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_ANG3
     // @DisplayName: Proximity sensor ignore angle 3
     // @Description: Proximity sensor ignore angle 3
+    // @Units: degrees
     // @Range: 0 360
     // @User: Standard
     AP_GROUPINFO("_IGN_ANG3", 8, AP_Proximity, _ignore_angle_deg[2], 0),
@@ -83,6 +89,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_WID3
     // @DisplayName: Proximity sensor ignore width 3
     // @Description: Proximity sensor ignore width 3
+    // @Units: degrees
     // @Range: 0 45
     // @User: Standard
     AP_GROUPINFO("_IGN_WID3", 9, AP_Proximity, _ignore_width_deg[2], 0),
@@ -90,6 +97,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_ANG4
     // @DisplayName: Proximity sensor ignore angle 4
     // @Description: Proximity sensor ignore angle 4
+    // @Units: degrees
     // @Range: 0 360
     // @User: Standard
     AP_GROUPINFO("_IGN_ANG4", 10, AP_Proximity, _ignore_angle_deg[3], 0),
@@ -97,6 +105,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_WID4
     // @DisplayName: Proximity sensor ignore width 4
     // @Description: Proximity sensor ignore width 4
+    // @Units: degrees
     // @Range: 0 45
     // @User: Standard
     AP_GROUPINFO("_IGN_WID4", 11, AP_Proximity, _ignore_width_deg[3], 0),
@@ -104,6 +113,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_ANG5
     // @DisplayName: Proximity sensor ignore angle 5
     // @Description: Proximity sensor ignore angle 5
+    // @Units: degrees
     // @Range: 0 360
     // @User: Standard
     AP_GROUPINFO("_IGN_ANG5", 12, AP_Proximity, _ignore_angle_deg[4], 0),
@@ -111,6 +121,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_WID5
     // @DisplayName: Proximity sensor ignore width 5
     // @Description: Proximity sensor ignore width 5
+    // @Units: degrees
     // @Range: 0 45
     // @User: Standard
     AP_GROUPINFO("_IGN_WID5", 13, AP_Proximity, _ignore_width_deg[4], 0),
@@ -118,6 +129,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_ANG6
     // @DisplayName: Proximity sensor ignore angle 6
     // @Description: Proximity sensor ignore angle 6
+    // @Units: degrees
     // @Range: 0 360
     // @User: Standard
     AP_GROUPINFO("_IGN_ANG6", 14, AP_Proximity, _ignore_angle_deg[5], 0),
@@ -125,6 +137,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: _IGN_WID6
     // @DisplayName: Proximity sensor ignore width 6
     // @Description: Proximity sensor ignore width 6
+    // @Units: degrees
     // @Range: 0 45
     // @User: Standard
     AP_GROUPINFO("_IGN_WID6", 15, AP_Proximity, _ignore_width_deg[5], 0),
@@ -147,6 +160,7 @@ const AP_Param::GroupInfo AP_Proximity::var_info[] = {
     // @Param: 2_YAW_CORR
     // @DisplayName: Second Proximity sensor yaw correction
     // @Description: Second Proximity sensor yaw correction
+    // @Units: degrees
     // @Range: -180 180
     // @User: Standard
     AP_GROUPINFO("2_YAW_CORR", 18, AP_Proximity, _yaw_correction[1], PROXIMITY_YAW_CORRECTION_DEFAULT),

From 363574244b02d502230494d4f94536a9736d8e37 Mon Sep 17 00:00:00 2001
From: "Dr.-Ing. Amilcar Do Carmo Lucas" <amilcar.lucas@iav.de>
Date: Tue, 10 Jan 2017 16:34:47 +0100
Subject: [PATCH 125/200] AP_Stats: Add missing parameter units

---
 libraries/AP_Stats/AP_Stats.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/libraries/AP_Stats/AP_Stats.cpp b/libraries/AP_Stats/AP_Stats.cpp
index 409022b..48fef5f 100644
--- a/libraries/AP_Stats/AP_Stats.cpp
+++ b/libraries/AP_Stats/AP_Stats.cpp
@@ -16,18 +16,21 @@ const AP_Param::GroupInfo AP_Stats::var_info[] = {
     // @Param: _FLTTIME
     // @DisplayName: Total FlightTime
     // @Description: Total FlightTime (seconds)
+    // @Units: seconds
     // @User: Standard
     AP_GROUPINFO("_FLTTIME",    1, AP_Stats, params.flttime, 0),
 
     // @Param: _RUNTIME
     // @DisplayName: Total RunTime
     // @Description: Total time autopilot has run
+    // @Units: seconds
     // @User: Standard
     AP_GROUPINFO("_RUNTIME",    2, AP_Stats, params.runtime, 0),
 
     // @Param: _RESET
     // @DisplayName: Reset time
     // @Description: Seconds since January 1st 2016 (Unix epoch+1451606400) since reset (set to 0 to reset statistics)
+    // @Units: seconds
     // @User: Standard
     AP_GROUPINFO("_RESET",    3, AP_Stats, params.reset, 1),
 

From e0a3caea13120ba9909c7e95188c1dffe39246d8 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 16 Jan 2017 10:18:55 +0100
Subject: [PATCH 126/200] APMRover2: Steering fix style

---
 APMrover2/Steering.cpp | 64 +++++++++++++++++++++++++-------------------------
 1 file changed, 32 insertions(+), 32 deletions(-)

diff --git a/APMrover2/Steering.cpp b/APMrover2/Steering.cpp
index f40b925..579066ee 100644
--- a/APMrover2/Steering.cpp
+++ b/APMrover2/Steering.cpp
@@ -14,7 +14,7 @@ void Rover::throttle_slew_limit(int16_t last_throttle) {
         }
         uint16_t pwm;
         if (SRV_Channels::get_output_pwm(SRV_Channel::k_throttle, pwm)) {
-            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,constrain_int16(pwm, last_throttle - temp, last_throttle + temp));
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle, constrain_int16(pwm, last_throttle - temp, last_throttle + temp));
         }
     }
 }
@@ -103,10 +103,10 @@ void Rover::calc_throttle(float target_speed) {
     // If not autostarting OR we are loitering at a waypoint
     // then set the throttle to minimum
     if (!auto_check_trigger() || in_stationary_loiter()) {
-        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,g.throttle_min.get());
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, g.throttle_min.get());
         // Stop rotation in case of loitering and skid steering
         if (g.skid_steer_out) {
-            SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);
         }
         return;
     }
@@ -127,7 +127,7 @@ void Rover::calc_throttle(float target_speed) {
     float speed_turn_ratio = constrain_float(fabsf(turn_angle / 9000.0f), 0, 1);
     float speed_turn_reduction = (100 - g.speed_turn_gain) * speed_turn_ratio * 0.01f;
 
-    float reduction = 1.0f - steer_rate*speed_turn_reduction;
+    float reduction = 1.0f - steer_rate * speed_turn_reduction;
 
     if (control_mode >= AUTO && wp_distance <= g.speed_turn_dist) {
         // in auto-modes we reduce speed when approaching waypoints
@@ -149,9 +149,9 @@ void Rover::calc_throttle(float target_speed) {
     throttle *= reduction;
 
     if (in_reverse) {
-        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(-throttle, -g.throttle_max, -g.throttle_min));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, constrain_int16(-throttle, -g.throttle_max, -g.throttle_min));
     } else {
-        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(throttle, g.throttle_min, g.throttle_max));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, constrain_int16(throttle, g.throttle_min, g.throttle_max));
     }
 
     if (!in_reverse && g.braking_percent != 0 && groundspeed_error < -g.braking_speederr) {
@@ -164,7 +164,7 @@ void Rover::calc_throttle(float target_speed) {
         // is 2*braking_speederr
         float brake_gain = constrain_float(((-groundspeed_error)-g.braking_speederr)/g.braking_speederr, 0, 1);
         int16_t braking_throttle = g.throttle_max * (g.braking_percent * 0.01f) * brake_gain;
-        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(-braking_throttle, -g.throttle_max, -g.throttle_min));
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, constrain_int16(-braking_throttle, -g.throttle_max, -g.throttle_min));
 
         // temporarily set us in reverse to allow the PWM setting to
         // go negative
@@ -209,9 +209,9 @@ void Rover::calc_lateral_acceleration() {
     if (use_pivot_steering()) {
         int16_t bearing_error = wrap_180_cd(nav_controller->target_bearing_cd() - ahrs.yaw_sensor) / 100;
         if (bearing_error > 0) {
-            lateral_acceleration = g.turn_max_g*GRAVITY_MSS;
+            lateral_acceleration = g.turn_max_g * GRAVITY_MSS;
         } else {
-            lateral_acceleration = -g.turn_max_g*GRAVITY_MSS;
+            lateral_acceleration = -g.turn_max_g * GRAVITY_MSS;
         }
     }
 }
@@ -222,7 +222,7 @@ void Rover::calc_lateral_acceleration() {
 void Rover::calc_nav_steer() {
     // check to see if the rover is loitering
     if (in_stationary_loiter()) {
-        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);
         return;
     }
 
@@ -232,9 +232,9 @@ void Rover::calc_nav_steer() {
     }
 
     // constrain to max G force
-    lateral_acceleration = constrain_float(lateral_acceleration, -g.turn_max_g*GRAVITY_MSS, g.turn_max_g*GRAVITY_MSS);
+    lateral_acceleration = constrain_float(lateral_acceleration, -g.turn_max_g * GRAVITY_MSS, g.turn_max_g * GRAVITY_MSS);
 
-    SRV_Channels::set_output_scaled(SRV_Channel::k_steering,steerController.get_steering_out_lat_accel(lateral_acceleration));
+    SRV_Channels::set_output_scaled(SRV_Channel::k_steering, steerController.get_steering_out_lat_accel(lateral_acceleration));
 }
 
 /*****************************************
@@ -245,41 +245,41 @@ void Rover::set_servos(void) {
 
     if (control_mode == MANUAL || control_mode == LEARNING) {
         // do a direct pass through of radio values
-        SRV_Channels::set_output_pwm(SRV_Channel::k_steering,channel_steer->read());
-        SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,channel_throttle->read());
+        SRV_Channels::set_output_pwm(SRV_Channel::k_steering, channel_steer->read());
+        SRV_Channels::set_output_pwm(SRV_Channel::k_throttle, channel_throttle->read());
         if (failsafe.bits & FAILSAFE_EVENT_THROTTLE) {
             // suppress throttle if in failsafe and manual
-            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,channel_throttle->get_radio_trim());
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle, channel_throttle->get_radio_trim());
             // suppress steer if in failsafe and manual and skid steer mode
             if (g.skid_steer_out) {
-                SRV_Channels::set_output_pwm(SRV_Channel::k_steering,channel_steer->get_radio_trim());
+                SRV_Channels::set_output_pwm(SRV_Channel::k_steering, channel_steer->get_radio_trim());
             }
         }
     } else {
         if (in_reverse) {
-            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, constrain_int16(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
                                           -g.throttle_max,
                                           -g.throttle_min));
         } else {
-            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,constrain_int16(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, constrain_int16(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
                                           g.throttle_min.get(),
                                           g.throttle_max.get()));
         }
 
         if ((failsafe.bits & FAILSAFE_EVENT_THROTTLE) && control_mode < AUTO) {
             // suppress throttle if in failsafe
-            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,0);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);
             // suppress steer if in failsafe and skid steer mode
             if (g.skid_steer_out) {
-                SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
+                SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);
             }
         }
 
         if (!hal.util->get_soft_armed()) {
-            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,0);
+            SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 0);
             // suppress steer if in failsafe and skid steer mode
             if (g.skid_steer_out) {
-                SRV_Channels::set_output_scaled(SRV_Channel::k_steering,0);
+                SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 0);
             }
         }
 
@@ -299,12 +299,12 @@ void Rover::set_servos(void) {
             motor1 = throttle + 0.5*steering
             motor2 = throttle - 0.5*steering
         */
-        float steering_scaled = SRV_Channels::get_output_norm(SRV_Channel::k_steering);
-        float throttle_scaled = SRV_Channels::get_output_norm(SRV_Channel::k_throttle);
-        float motor1 = throttle_scaled + 0.5f*steering_scaled;
-        float motor2 = throttle_scaled - 0.5f*steering_scaled;
-        SRV_Channels::set_output_scaled(SRV_Channel::k_steering,4500*motor1);
-        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle,100*motor2);
+        const float steering_scaled = SRV_Channels::get_output_norm(SRV_Channel::k_steering);
+        const float throttle_scaled = SRV_Channels::get_output_norm(SRV_Channel::k_throttle);
+        float motor1 = throttle_scaled + 0.5f * steering_scaled;
+        float motor2 = throttle_scaled - 0.5f * steering_scaled;
+        SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 4500 * motor1);
+        SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 100 * motor2);
     }
 
     if (!arming.is_armed()) {
@@ -317,17 +317,17 @@ void Rover::set_servos(void) {
             break;
 
         case AP_Arming::YES_ZERO_PWM:
-            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,0);
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle, 0);
             if (g.skid_steer_out) {
-                SRV_Channels::set_output_pwm(SRV_Channel::k_steering,0);
+                SRV_Channels::set_output_pwm(SRV_Channel::k_steering, 0);
             }
             break;
 
         case AP_Arming::YES_MIN_PWM:
         default:
-            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle,channel_throttle->get_radio_trim());
+            SRV_Channels::set_output_pwm(SRV_Channel::k_throttle, channel_throttle->get_radio_trim());
             if (g.skid_steer_out) {
-                SRV_Channels::set_output_pwm(SRV_Channel::k_steering,channel_steer->get_radio_trim());
+                SRV_Channels::set_output_pwm(SRV_Channel::k_steering, channel_steer->get_radio_trim());
             }
             break;
         }

From b31d2a59dae0ac83dd1d0f2fdec04fa78762fbe7 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Mon, 16 Jan 2017 10:19:28 +0100
Subject: [PATCH 127/200] APMRover2: Fix skid steer in when in skid steer out

---
 APMrover2/Steering.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/APMrover2/Steering.cpp b/APMrover2/Steering.cpp
index 579066ee..a326c45 100644
--- a/APMrover2/Steering.cpp
+++ b/APMrover2/Steering.cpp
@@ -242,6 +242,7 @@ void Rover::calc_nav_steer() {
 *****************************************/
 void Rover::set_servos(void) {
     static uint16_t last_throttle;
+    bool apply_skid_mix = true;  // Normaly true, false when the mixage is done by the controler with skid_steer_in = 1
 
     if (control_mode == MANUAL || control_mode == LEARNING) {
         // do a direct pass through of radio values
@@ -255,6 +256,9 @@ void Rover::set_servos(void) {
                 SRV_Channels::set_output_pwm(SRV_Channel::k_steering, channel_steer->get_radio_trim());
             }
         }
+        if (g.skid_steer_in) {
+            apply_skid_mix = false;
+        }
     } else {
         if (in_reverse) {
             SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, constrain_int16(SRV_Channels::get_output_scaled(SRV_Channel::k_throttle),
@@ -303,6 +307,11 @@ void Rover::set_servos(void) {
         const float throttle_scaled = SRV_Channels::get_output_norm(SRV_Channel::k_throttle);
         float motor1 = throttle_scaled + 0.5f * steering_scaled;
         float motor2 = throttle_scaled - 0.5f * steering_scaled;
+
+        if (!apply_skid_mix) {  // Mixage is already done by a controller so just pass the value to motor
+            motor1 = steering_scaled;
+            motor2 = throttle_scaled;
+        }
         SRV_Channels::set_output_scaled(SRV_Channel::k_steering, 4500 * motor1);
         SRV_Channels::set_output_scaled(SRV_Channel::k_throttle, 100 * motor2);
     }

From 362c6e1b9edf1a63ae7d71954196f2c09fc80008 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Mon, 15 Aug 2016 13:37:03 +1000
Subject: [PATCH 128/200] AP_Arming: use callback in place of variable
 reference for home state

---
 libraries/AP_Arming/AP_Arming.cpp | 5 ++---
 libraries/AP_Arming/AP_Arming.h   | 5 +++--
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/libraries/AP_Arming/AP_Arming.cpp b/libraries/AP_Arming/AP_Arming.cpp
index 7bbcc45..ffe7577 100644
--- a/libraries/AP_Arming/AP_Arming.cpp
+++ b/libraries/AP_Arming/AP_Arming.cpp
@@ -75,12 +75,11 @@ const AP_Param::GroupInfo AP_Arming::var_info[] = {
 //The function point is particularly hacky, hacky, tacky
 //but I don't want to reimplement messaging to GCS at the moment:
 AP_Arming::AP_Arming(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
-                     const AP_BattMonitor &battery, const enum HomeState &home_set) :
+                     const AP_BattMonitor &battery) :
     ahrs(ahrs_ref),
     barometer(baro),
     _compass(compass),
     _battery(battery),
-    home_is_set(home_set),
     armed(false),
     arming_method(NONE)
 {
@@ -337,7 +336,7 @@ bool AP_Arming::gps_checks(bool report)
     if ((checks_to_perform & ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_GPS)) {
 
         //GPS OK?
-        if (home_is_set == HOME_UNSET || 
+        if (home_status() == HOME_UNSET ||
             gps.status() < AP_GPS::GPS_OK_FIX_3D) {
             if (report) {
                 GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: Bad GPS Position");
diff --git a/libraries/AP_Arming/AP_Arming.h b/libraries/AP_Arming/AP_Arming.h
index cebfc2c..9271370 100644
--- a/libraries/AP_Arming/AP_Arming.h
+++ b/libraries/AP_Arming/AP_Arming.h
@@ -44,7 +44,7 @@ class AP_Arming {
     };
 
     AP_Arming(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
-              const AP_BattMonitor &battery, const enum HomeState &home_set);
+              const AP_BattMonitor &battery);
 
     ArmingRequired arming_required();
     virtual bool arm(uint8_t method);
@@ -78,7 +78,6 @@ class AP_Arming {
     const AP_Baro           &barometer;
     Compass                 &_compass;
     const AP_BattMonitor    &_battery;
-    const enum HomeState    &home_is_set;
 
     // internal members
     bool                    armed:1;
@@ -108,4 +107,6 @@ class AP_Arming {
     bool board_voltage_checks(bool report);
 
     bool manual_transmitter_checks(bool report);
+
+    virtual enum HomeState home_status() const = 0;
 };

From ddf172c75bcd74ac2195ec7bbcc63836b32dbfad Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Wed, 17 Aug 2016 14:28:16 +1000
Subject: [PATCH 129/200] Rover: AP_Arming: use callback in place of variable
 reference for home state

---
 APMrover2/AP_Arming.cpp |  7 +++++++
 APMrover2/AP_Arming.h   | 21 +++++++++++++++++++++
 APMrover2/Rover.h       |  6 +++---
 3 files changed, 31 insertions(+), 3 deletions(-)
 create mode 100644 APMrover2/AP_Arming.cpp
 create mode 100644 APMrover2/AP_Arming.h

diff --git a/APMrover2/AP_Arming.cpp b/APMrover2/AP_Arming.cpp
new file mode 100644
index 0000000..c786548
--- /dev/null
+++ b/APMrover2/AP_Arming.cpp
@@ -0,0 +1,7 @@
+#include "AP_Arming.h"
+#include "Rover.h"
+
+enum HomeState AP_Arming_Rover::home_status() const
+{
+    return rover.home_is_set;
+}
diff --git a/APMrover2/AP_Arming.h b/APMrover2/AP_Arming.h
new file mode 100644
index 0000000..8037252
--- /dev/null
+++ b/APMrover2/AP_Arming.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include <AP_Arming/AP_Arming.h>
+
+/*
+  a rover-specific arming class
+ */
+class AP_Arming_Rover : public AP_Arming
+{
+public:
+
+    AP_Arming_Rover(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
+                    const AP_BattMonitor &battery) :
+        AP_Arming(ahrs_ref, baro, compass, battery) {
+    }
+
+protected:
+
+    enum HomeState home_status() const override;
+};
+
diff --git a/APMrover2/Rover.h b/APMrover2/Rover.h
index 36e5c35..e07168d 100644
--- a/APMrover2/Rover.h
+++ b/APMrover2/Rover.h
@@ -63,7 +63,7 @@
 #include <AP_BoardConfig/AP_BoardConfig.h>
 #include <AP_Frsky_Telem/AP_Frsky_Telem.h>
 
-#include <AP_Arming/AP_Arming.h>
+#include "AP_Arming.h"
 #include "compat.h"
 
 #include <AP_Notify/AP_Notify.h>                    // Notify library
@@ -93,7 +93,7 @@ class Rover : public AP_HAL::HAL::Callbacks {
     friend class GCS_MAVLINK_Rover;
     friend class Parameters;
     friend class ParametersG2;
-    friend class AP_Arming;
+    friend class AP_Arming_Rover;
 
     Rover(void);
 
@@ -152,7 +152,7 @@ class Rover : public AP_HAL::HAL::Callbacks {
 #endif
 
     // Arming/Disarming management class
-    AP_Arming arming {ahrs, barometer, compass, battery, home_is_set};
+    AP_Arming_Rover arming {ahrs, barometer, compass, battery};
 
     AP_L1_Control L1_controller;
 

From fc28beacea6c9f1603d9b26a2767a413eaca41c1 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Mon, 15 Aug 2016 13:37:28 +1000
Subject: [PATCH 130/200] Plane: AP_Arming: use callback in place of variable
 reference for home state

---
 ArduPlane/Plane.h           | 8 +++++---
 ArduPlane/arming_checks.cpp | 4 ++++
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/ArduPlane/Plane.h b/ArduPlane/Plane.h
index 4ec640a..81a843c 100644
--- a/ArduPlane/Plane.h
+++ b/ArduPlane/Plane.h
@@ -118,8 +118,8 @@ class AP_Arming_Plane : public AP_Arming
 {
 public:
     AP_Arming_Plane(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
-                    const AP_BattMonitor &battery, const enum HomeState &home_set) :
-        AP_Arming(ahrs_ref, baro, compass, battery, home_set) {
+                    const AP_BattMonitor &battery) :
+        AP_Arming(ahrs_ref, baro, compass, battery) {
             AP_Param::setup_object_defaults(this, var_info);
     }
     bool pre_arm_checks(bool report);
@@ -127,8 +127,10 @@ class AP_Arming_Plane : public AP_Arming
 
     // var_info for holding Parameter information
     static const struct AP_Param::GroupInfo var_info[];
+
 protected:
     bool ins_checks(bool report);
+    enum HomeState home_status() const override;
 };
 
 
@@ -766,7 +768,7 @@ class Plane : public AP_HAL::HAL::Callbacks {
 #endif
 
     // Arming/Disarming mangement class
-    AP_Arming_Plane arming {ahrs, barometer, compass, battery, home_is_set };
+    AP_Arming_Plane arming {ahrs, barometer, compass, battery};
 
     AP_Param param_loader {var_info};
 
diff --git a/ArduPlane/arming_checks.cpp b/ArduPlane/arming_checks.cpp
index 6742b14..e383216 100644
--- a/ArduPlane/arming_checks.cpp
+++ b/ArduPlane/arming_checks.cpp
@@ -17,6 +17,10 @@ const AP_Param::GroupInfo AP_Arming_Plane::var_info[] = {
     AP_GROUPEND
 };
 
+enum HomeState AP_Arming_Plane::home_status() const
+{
+    return plane.home_is_set;
+}
 
 bool AP_Arming_Plane::arm(uint8_t method)
 {

From 7cc8b7232c03163880f01280b623641b97e606f9 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 9 Jan 2017 16:56:56 +0900
Subject: [PATCH 131/200] Plane: rename arming_checks to AP_Arming

---
 ArduPlane/AP_Arming.cpp     | 140 ++++++++++++++++++++++++++++++++++++++++++++
 ArduPlane/AP_Arming.h       |  28 +++++++++
 ArduPlane/Plane.h           |  24 +-------
 ArduPlane/arming_checks.cpp | 139 -------------------------------------------
 4 files changed, 169 insertions(+), 162 deletions(-)
 create mode 100644 ArduPlane/AP_Arming.cpp
 create mode 100644 ArduPlane/AP_Arming.h
 delete mode 100644 ArduPlane/arming_checks.cpp

diff --git a/ArduPlane/AP_Arming.cpp b/ArduPlane/AP_Arming.cpp
new file mode 100644
index 0000000..0d75146
--- /dev/null
+++ b/ArduPlane/AP_Arming.cpp
@@ -0,0 +1,140 @@
+/*
+  additional arming checks for plane
+ */
+#include "AP_Arming.h"
+#include "Plane.h"
+
+const AP_Param::GroupInfo AP_Arming_Plane::var_info[] = {
+    // variables from parent vehicle
+    AP_NESTEDGROUPINFO(AP_Arming, 0),
+
+    // @Param: RUDDER
+    // @DisplayName: Rudder Arming
+    // @Description: Control arm/disarm by rudder input. When enabled arming is done with right rudder, disarming with left rudder. Rudder arming only works in manual throttle modes with throttle at zero +- deadzone (RCx_DZ)
+    // @Values: 0:Disabled,1:ArmingOnly,2:ArmOrDisarm
+    // @User: Advanced
+    AP_GROUPINFO("RUDDER",       3,     AP_Arming_Plane,  rudder_arming_value,     ARMING_RUDDER_ARMONLY),
+
+    AP_GROUPEND
+};
+
+enum HomeState AP_Arming_Plane::home_status() const
+{
+    return plane.home_is_set;
+}
+
+bool AP_Arming_Plane::arm(uint8_t method)
+{
+    // start logging here so we can check success or failure in
+    // arm_checks
+    if (plane.g.log_bitmask != NONE &&
+        !plane.DataFlash.logging_started()) {
+        plane.start_logging();
+    }
+
+    return AP_Arming::arm(method);
+}
+
+/*
+  additional arming checks for plane
+
+ */
+bool AP_Arming_Plane::pre_arm_checks(bool report)
+{
+    // call parent class checks
+    bool ret = AP_Arming::pre_arm_checks(report);
+
+    // Check airspeed sensor
+    ret &= AP_Arming::airspeed_checks(report);
+
+    if (plane.aparm.roll_limit_cd < 300) {
+        if (report) {
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: LIM_ROLL_CD too small (%u)", plane.aparm.roll_limit_cd);
+        }
+        ret = false;        
+    }
+
+    if (plane.aparm.pitch_limit_max_cd < 300) {
+        if (report) {
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: LIM_PITCH_MAX too small (%u)", plane.aparm.pitch_limit_max_cd);
+        }
+        ret = false;        
+    }
+
+    if (plane.aparm.pitch_limit_min_cd > -300) {
+        if (report) {
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: LIM_PITCH_MIN too large (%u)", plane.aparm.pitch_limit_min_cd);
+        }
+        ret = false;        
+    }
+
+    if (plane.channel_throttle->get_reverse() && 
+        plane.g.throttle_fs_enabled &&
+        plane.g.throttle_fs_value < 
+        plane.channel_throttle->get_radio_max()) {
+        if (report) {
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: Invalid THR_FS_VALUE for rev throttle");
+        }
+        ret = false;
+    }
+
+    if (plane.quadplane.available() && plane.scheduler.get_loop_rate_hz() < 100) {
+        if (report) {
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: quadplane needs SCHED_LOOP_RATE > 100");
+        }
+        ret = false;
+    }
+
+    if (plane.control_mode == AUTO && plane.mission.num_commands() <= 1) {
+        if (report) {
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: No mission loaded");
+        }
+        ret = false;
+    }
+
+    // check adsb avoidance failsafe
+    if (plane.failsafe.adsb) {
+        if (report) {
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL,"PreArm: ADSB threat detected");
+        }
+        ret = false;
+    }
+
+#if HAVE_PX4_MIXER
+    if (plane.last_mixer_crc == -1) {
+        if (report) {
+            // if you ever get this error, a reboot is recommended.
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL,"PreArm: Mixer error");
+        }
+        ret = false;
+    }
+#endif // CONFIG_HAL_BOARD
+
+    return ret;
+}
+
+bool AP_Arming_Plane::ins_checks(bool report)
+{
+    // call parent class checks
+    if (!AP_Arming::ins_checks(report)) {
+        return false;
+    }
+
+    // additional plane specific checks
+    if ((checks_to_perform & ARMING_CHECK_ALL) ||
+        (checks_to_perform & ARMING_CHECK_INS)) {
+        if (!ahrs.healthy()) {
+            if (report) {
+                const char *reason = ahrs.prearm_failure_reason();
+                if (reason) {
+                    GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: %s", reason);
+                } else {
+                    GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: AHRS not healthy");
+                }
+            }
+            return false;
+        }
+    }
+
+    return true;
+}
diff --git a/ArduPlane/AP_Arming.h b/ArduPlane/AP_Arming.h
new file mode 100644
index 0000000..13ddc2c
--- /dev/null
+++ b/ArduPlane/AP_Arming.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include <AP_Arming/AP_Arming.h>
+
+/*
+  a plane specific arming class
+ */
+class AP_Arming_Plane : public AP_Arming
+{
+public:
+    AP_Arming_Plane(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
+                    const AP_BattMonitor &battery) :
+        AP_Arming(ahrs_ref, baro, compass, battery) {
+            AP_Param::setup_object_defaults(this, var_info);
+    }
+    bool pre_arm_checks(bool report);
+    bool arm(uint8_t method) override;
+
+    // var_info for holding Parameter information
+    static const struct AP_Param::GroupInfo var_info[];
+
+protected:
+    bool ins_checks(bool report);
+    enum HomeState home_status() const override;
+
+    // parameters
+    AP_Int8                 rudder_arming_value;
+};
diff --git a/ArduPlane/Plane.h b/ArduPlane/Plane.h
index 81a843c..7332311 100644
--- a/ArduPlane/Plane.h
+++ b/ArduPlane/Plane.h
@@ -106,35 +106,13 @@
 
 #include "Parameters.h"
 #include "avoidance_adsb.h"
+#include "AP_Arming.h"
 
 #if CONFIG_HAL_BOARD == HAL_BOARD_SITL
 #include <SITL/SITL.h>
 #endif
 
 /*
-  a plane specific arming class
- */
-class AP_Arming_Plane : public AP_Arming
-{
-public:
-    AP_Arming_Plane(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
-                    const AP_BattMonitor &battery) :
-        AP_Arming(ahrs_ref, baro, compass, battery) {
-            AP_Param::setup_object_defaults(this, var_info);
-    }
-    bool pre_arm_checks(bool report);
-    bool arm(uint8_t method) override;
-
-    // var_info for holding Parameter information
-    static const struct AP_Param::GroupInfo var_info[];
-
-protected:
-    bool ins_checks(bool report);
-    enum HomeState home_status() const override;
-};
-
-
-/*
   a plane specific AP_AdvancedFailsafe class
  */
 class AP_AdvancedFailsafe_Plane : public AP_AdvancedFailsafe
diff --git a/ArduPlane/arming_checks.cpp b/ArduPlane/arming_checks.cpp
deleted file mode 100644
index e383216..0000000
--- a/ArduPlane/arming_checks.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
-  additional arming checks for plane
- */
-#include "Plane.h"
-
-const AP_Param::GroupInfo AP_Arming_Plane::var_info[] = {
-    // variables from parent vehicle
-    AP_NESTEDGROUPINFO(AP_Arming, 0),
-
-    // @Param: RUDDER
-    // @DisplayName: Rudder Arming
-    // @Description: Control arm/disarm by rudder input. When enabled arming is done with right rudder, disarming with left rudder. Rudder arming only works in manual throttle modes with throttle at zero +- deadzone (RCx_DZ)
-    // @Values: 0:Disabled,1:ArmingOnly,2:ArmOrDisarm
-    // @User: Advanced
-    AP_GROUPINFO("RUDDER",       3,     AP_Arming_Plane,  rudder_arming_value,     ARMING_RUDDER_ARMONLY),
-
-    AP_GROUPEND
-};
-
-enum HomeState AP_Arming_Plane::home_status() const
-{
-    return plane.home_is_set;
-}
-
-bool AP_Arming_Plane::arm(uint8_t method)
-{
-    // start logging here so we can check success or failure in
-    // arm_checks
-    if (plane.g.log_bitmask != NONE &&
-        !plane.DataFlash.logging_started()) {
-        plane.start_logging();
-    }
-
-    return AP_Arming::arm(method);
-}
-
-/*
-  additional arming checks for plane
-
- */
-bool AP_Arming_Plane::pre_arm_checks(bool report)
-{
-    // call parent class checks
-    bool ret = AP_Arming::pre_arm_checks(report);
-
-    // Check airspeed sensor
-    ret &= AP_Arming::airspeed_checks(report);
-
-    if (plane.aparm.roll_limit_cd < 300) {
-        if (report) {
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: LIM_ROLL_CD too small (%u)", plane.aparm.roll_limit_cd);
-        }
-        ret = false;        
-    }
-
-    if (plane.aparm.pitch_limit_max_cd < 300) {
-        if (report) {
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: LIM_PITCH_MAX too small (%u)", plane.aparm.pitch_limit_max_cd);
-        }
-        ret = false;        
-    }
-
-    if (plane.aparm.pitch_limit_min_cd > -300) {
-        if (report) {
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: LIM_PITCH_MIN too large (%u)", plane.aparm.pitch_limit_min_cd);
-        }
-        ret = false;        
-    }
-
-    if (plane.channel_throttle->get_reverse() && 
-        plane.g.throttle_fs_enabled &&
-        plane.g.throttle_fs_value < 
-        plane.channel_throttle->get_radio_max()) {
-        if (report) {
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: Invalid THR_FS_VALUE for rev throttle");
-        }
-        ret = false;
-    }
-
-    if (plane.quadplane.available() && plane.scheduler.get_loop_rate_hz() < 100) {
-        if (report) {
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: quadplane needs SCHED_LOOP_RATE > 100");
-        }
-        ret = false;
-    }
-
-    if (plane.control_mode == AUTO && plane.mission.num_commands() <= 1) {
-        if (report) {
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: No mission loaded");
-        }
-        ret = false;
-    }
-
-    // check adsb avoidance failsafe
-    if (plane.failsafe.adsb) {
-        if (report) {
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL,"PreArm: ADSB threat detected");
-        }
-        ret = false;
-    }
-
-#if HAVE_PX4_MIXER
-    if (plane.last_mixer_crc == -1) {
-        if (report) {
-            // if you ever get this error, a reboot is recommended.
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL,"PreArm: Mixer error");
-        }
-        ret = false;
-    }
-#endif // CONFIG_HAL_BOARD
-
-    return ret;
-}
-
-bool AP_Arming_Plane::ins_checks(bool report)
-{
-    // call parent class checks
-    if (!AP_Arming::ins_checks(report)) {
-        return false;
-    }
-
-    // additional plane specific checks
-    if ((checks_to_perform & ARMING_CHECK_ALL) ||
-        (checks_to_perform & ARMING_CHECK_INS)) {
-        if (!ahrs.healthy()) {
-            if (report) {
-                const char *reason = ahrs.prearm_failure_reason();
-                if (reason) {
-                    GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: %s", reason);
-                } else {
-                    GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: AHRS not healthy");
-                }
-            }
-            return false;
-        }
-    }
-
-    return true;
-}

From e906310b71547eaa5bdcf95152fa1e60940e5cff Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 9 Jan 2017 17:00:21 +0900
Subject: [PATCH 132/200] Plane: rudder_arming moved to AP_Arming_Plane

---
 ArduPlane/AP_Arming.h | 8 ++++++++
 ArduPlane/radio.cpp   | 6 +++---
 2 files changed, 11 insertions(+), 3 deletions(-)

diff --git a/ArduPlane/AP_Arming.h b/ArduPlane/AP_Arming.h
index 13ddc2c..1ca909a 100644
--- a/ArduPlane/AP_Arming.h
+++ b/ArduPlane/AP_Arming.h
@@ -8,6 +8,12 @@
 class AP_Arming_Plane : public AP_Arming
 {
 public:
+    enum ArmingRudder {
+        ARMING_RUDDER_DISABLED  = 0,
+        ARMING_RUDDER_ARMONLY   = 1,
+        ARMING_RUDDER_ARMDISARM = 2
+    };
+
     AP_Arming_Plane(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
                     const AP_BattMonitor &battery) :
         AP_Arming(ahrs_ref, baro, compass, battery) {
@@ -16,6 +22,8 @@ class AP_Arming_Plane : public AP_Arming
     bool pre_arm_checks(bool report);
     bool arm(uint8_t method) override;
 
+    ArmingRudder rudder_arming() const { return (ArmingRudder)rudder_arming_value.get(); }
+
     // var_info for holding Parameter information
     static const struct AP_Param::GroupInfo var_info[];
 
diff --git a/ArduPlane/radio.cpp b/ArduPlane/radio.cpp
index 9199e9e..cbf0b6d 100644
--- a/ArduPlane/radio.cpp
+++ b/ArduPlane/radio.cpp
@@ -103,9 +103,9 @@ void Plane::init_rc_out_aux()
 */
 void Plane::rudder_arm_disarm_check()
 {
-    AP_Arming::ArmingRudder arming_rudder = arming.rudder_arming();
+    AP_Arming_Plane::ArmingRudder arming_rudder = arming.rudder_arming();
 
-    if (arming_rudder == AP_Arming::ARMING_RUDDER_DISABLED) {
+    if (arming_rudder == AP_Arming_Plane::ARMING_RUDDER_DISABLED) {
         //parameter disallows rudder arming/disabling
         return;
     }
@@ -144,7 +144,7 @@ void Plane::rudder_arm_disarm_check()
 			// not at full right rudder
 			rudder_arm_timer = 0;
 		}
-	} else if (arming_rudder == AP_Arming::ARMING_RUDDER_ARMDISARM && !is_flying()) {
+	} else if (arming_rudder == AP_Arming_Plane::ARMING_RUDDER_ARMDISARM && !is_flying()) {
 		// when armed and not flying, full left rudder starts disarming counter
 		if (channel_rudder->get_control_in() < -4000) {
 			uint32_t now = millis();

From 8159c4b747f5dc21ba6ab596a6e5553a45e89697 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Mon, 15 Aug 2016 21:07:42 +1000
Subject: [PATCH 133/200] AP_Arming: add comments on parameters only currently
 used by plane

---
 libraries/AP_Arming/AP_Arming.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/libraries/AP_Arming/AP_Arming.cpp b/libraries/AP_Arming/AP_Arming.cpp
index ffe7577..2a3ac5e 100644
--- a/libraries/AP_Arming/AP_Arming.cpp
+++ b/libraries/AP_Arming/AP_Arming.cpp
@@ -32,7 +32,7 @@ extern const AP_HAL::HAL& hal;
 const AP_Param::GroupInfo AP_Arming::var_info[] = {
     // @Param: REQUIRE
     // @DisplayName: Require Arming Motors 
-    // @Description: Arming disabled until some requirements are met. If 0, there are no requirements (arm immediately).  If 1, require rudder stick or GCS arming before arming motors and send THR_MIN PWM to throttle channel when disarmed.  If 2, require rudder stick or GCS arming and send 0 PWM to throttle channel when disarmed. See the ARMING_CHECK_* parameters to see what checks are done before arming. Note, if setting this parameter to 0 a reboot is required to arm the plane.  Also note, even with this parameter at 0, if ARMING_CHECK parameter is not also zero the plane may fail to arm throttle at boot due to a pre-arm check failure.
+    // @Description: Arming disabled until some requirements are met. If 0, there are no requirements (arm immediately).  If 1, require rudder stick or GCS arming before arming motors and send THR_MIN PWM to throttle channel when disarmed.  If 2, require rudder stick or GCS arming and send 0 PWM to throttle channel when disarmed. See the ARMING_CHECK_* parameters to see what checks are done before arming. Note, if setting this parameter to 0 a reboot is required to arm the plane.  Also note, even with this parameter at 0, if ARMING_CHECK parameter is not also zero the plane may fail to arm throttle at boot due to a pre-arm check failure. This parameter is relevant for ArduPlane only.
     // @Values: 0:Disabled,1:THR_MIN PWM when disarmed,2:0 PWM when disarmed
     // @User: Advanced
     AP_GROUPINFO_FLAGS("REQUIRE",     0,      AP_Arming,  require,                 1, AP_PARAM_NO_SHIFT),
@@ -55,7 +55,7 @@ const AP_Param::GroupInfo AP_Arming::var_info[] = {
 
     // @Param: MIN_VOLT
     // @DisplayName: Minimum arming voltage on the first battery
-    // @Description: The minimum voltage on the first battery to arm, 0 disabes the check
+    // @Description: The minimum voltage on the first battery to arm, 0 disables the check.  This parameter is relevant for ArduPlane only.
     // @Units: Volts
     // @Increment: 0.1 
     // @User: Standard
@@ -63,7 +63,7 @@ const AP_Param::GroupInfo AP_Arming::var_info[] = {
 
     // @Param: MIN_VOLT2
     // @DisplayName: Minimum arming voltage on the second battery
-    // @Description: The minimum voltage on the first battery to arm, 0 disabes the check
+    // @Description: The minimum voltage on the first battery to arm, 0 disables the check. This parameter is relevant for ArduPlane only.
     // @Units: Volts
     // @Increment: 0.1 
     // @User: Standard

From 1f37366c5b67517134eb3d5cdd049da0d8105407 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Wed, 17 Aug 2016 18:15:38 +1000
Subject: [PATCH 134/200] AP_Arming: make expected magnetic field strength
 available to subclasses

---
 libraries/AP_Arming/AP_Arming.cpp | 6 ++++++
 libraries/AP_Arming/AP_Arming.h   | 5 ++++-
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/libraries/AP_Arming/AP_Arming.cpp b/libraries/AP_Arming/AP_Arming.cpp
index 2a3ac5e..3a8d3e7 100644
--- a/libraries/AP_Arming/AP_Arming.cpp
+++ b/libraries/AP_Arming/AP_Arming.cpp
@@ -21,6 +21,7 @@
 // this can also be overridden for specific boards in the HAL
 #define AP_ARMING_COMPASS_OFFSETS_MAX   600
 #endif
+#define AP_ARMING_COMPASS_MAGFIELD_EXPECTED 530
 #define AP_ARMING_COMPASS_MAGFIELD_MIN  185     // 0.35 * 530 milligauss
 #define AP_ARMING_COMPASS_MAGFIELD_MAX  875     // 1.65 * 530 milligauss
 #define AP_ARMING_BOARD_VOLTAGE_MIN     4.3f
@@ -88,6 +89,11 @@ AP_Arming::AP_Arming(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &comp
     memset(last_gyro_pass_ms, 0, sizeof(last_gyro_pass_ms));
 }
 
+uint16_t AP_Arming::compass_magfield_expected() const
+{
+    return AP_ARMING_COMPASS_MAGFIELD_EXPECTED;
+}
+
 bool AP_Arming::is_armed()
 { 
     return require == NONE || armed; 
diff --git a/libraries/AP_Arming/AP_Arming.h b/libraries/AP_Arming/AP_Arming.h
index 9271370..1820be8 100644
--- a/libraries/AP_Arming/AP_Arming.h
+++ b/libraries/AP_Arming/AP_Arming.h
@@ -65,6 +65,8 @@ class AP_Arming {
 
     static const struct AP_Param::GroupInfo        var_info[];
 
+    uint16_t compass_magfield_expected() const;
+
 protected:
     // Parameters
     AP_Int8                 require;
@@ -96,7 +98,7 @@ class AP_Arming {
 
     virtual bool ins_checks(bool report);
 
-    bool compass_checks(bool report);
+    virtual bool compass_checks(bool report);
 
     bool gps_checks(bool report);
 
@@ -109,4 +111,5 @@ class AP_Arming {
     bool manual_transmitter_checks(bool report);
 
     virtual enum HomeState home_status() const = 0;
+
 };

From 5be3d14648bce00bd39fa1b0fbee6af43794dc40 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Wed, 28 Dec 2016 14:39:36 +0900
Subject: [PATCH 135/200] AP_Arming: rudder_arming moved to AP_Arming_Plane

---
 libraries/AP_Arming/AP_Arming.h | 8 --------
 1 file changed, 8 deletions(-)

diff --git a/libraries/AP_Arming/AP_Arming.h b/libraries/AP_Arming/AP_Arming.h
index 1820be8..cbc3725 100644
--- a/libraries/AP_Arming/AP_Arming.h
+++ b/libraries/AP_Arming/AP_Arming.h
@@ -37,12 +37,6 @@ class AP_Arming {
         YES_ZERO_PWM = 2
     };
 
-    enum ArmingRudder {
-        ARMING_RUDDER_DISABLED  = 0,
-        ARMING_RUDDER_ARMONLY   = 1,
-        ARMING_RUDDER_ARMDISARM = 2
-    };
-
     AP_Arming(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
               const AP_BattMonitor &battery);
 
@@ -50,7 +44,6 @@ class AP_Arming {
     virtual bool arm(uint8_t method);
     bool disarm();
     bool is_armed();
-    ArmingRudder rudder_arming() const { return (ArmingRudder)rudder_arming_value.get(); }
     uint16_t get_enabled_checks();
 
     /*
@@ -70,7 +63,6 @@ class AP_Arming {
 protected:
     // Parameters
     AP_Int8                 require;
-    AP_Int8                 rudder_arming_value;
     AP_Int16                checks_to_perform;      // bitmask for which checks are required
     AP_Float                accel_error_threshold;
     AP_Float                _min_voltage[AP_BATT_MONITOR_MAX_INSTANCES];

From 593f035c5310fb01427440a486a532f28fc6581d Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Wed, 28 Dec 2016 14:41:21 +0900
Subject: [PATCH 136/200] AP_Arming: remove required, min-volt, min-volt2
 params from Copter

---
 libraries/AP_Arming/AP_Arming.cpp | 27 +++++++++++++++++++++++++--
 libraries/AP_Arming/AP_Arming.h   |  1 +
 2 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_Arming/AP_Arming.cpp b/libraries/AP_Arming/AP_Arming.cpp
index 3a8d3e7..608fe56 100644
--- a/libraries/AP_Arming/AP_Arming.cpp
+++ b/libraries/AP_Arming/AP_Arming.cpp
@@ -31,12 +31,15 @@
 extern const AP_HAL::HAL& hal;
 
 const AP_Param::GroupInfo AP_Arming::var_info[] = {
+
+#if !APM_BUILD_TYPE(APM_BUILD_ArduCopter)
     // @Param: REQUIRE
     // @DisplayName: Require Arming Motors 
     // @Description: Arming disabled until some requirements are met. If 0, there are no requirements (arm immediately).  If 1, require rudder stick or GCS arming before arming motors and send THR_MIN PWM to throttle channel when disarmed.  If 2, require rudder stick or GCS arming and send 0 PWM to throttle channel when disarmed. See the ARMING_CHECK_* parameters to see what checks are done before arming. Note, if setting this parameter to 0 a reboot is required to arm the plane.  Also note, even with this parameter at 0, if ARMING_CHECK parameter is not also zero the plane may fail to arm throttle at boot due to a pre-arm check failure. This parameter is relevant for ArduPlane only.
     // @Values: 0:Disabled,1:THR_MIN PWM when disarmed,2:0 PWM when disarmed
     // @User: Advanced
     AP_GROUPINFO_FLAGS("REQUIRE",     0,      AP_Arming,  require,                 1, AP_PARAM_NO_SHIFT),
+#endif
 
     // @Param: CHECK
     // @DisplayName: Arm Checks to Peform (bitmask)
@@ -54,6 +57,7 @@ const AP_Param::GroupInfo AP_Arming::var_info[] = {
     // @User: Advanced
     AP_GROUPINFO("ACCTHRESH",    3,     AP_Arming,  accel_error_threshold,  AP_ARMING_ACCEL_ERROR_THRESHOLD),
 
+#if !APM_BUILD_TYPE(APM_BUILD_ArduCopter)
     // @Param: MIN_VOLT
     // @DisplayName: Minimum arming voltage on the first battery
     // @Description: The minimum voltage on the first battery to arm, 0 disables the check.  This parameter is relevant for ArduPlane only.
@@ -69,6 +73,7 @@ const AP_Param::GroupInfo AP_Arming::var_info[] = {
     // @Increment: 0.1 
     // @User: Standard
     AP_GROUPINFO("MIN_VOLT2",     5,     AP_Arming,  _min_voltage[1],  0),
+#endif
 
     AP_GROUPEND
 };
@@ -85,6 +90,12 @@ AP_Arming::AP_Arming(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &comp
     arming_method(NONE)
 {
     AP_Param::setup_object_defaults(this, var_info);
+
+#if APM_BUILD_TYPE(APM_BUILD_ArduCopter)
+    // default REQUIRE parameter to 1 (needed for Copter which is missing the parameter declaration above)
+    require.set_default(YES_MIN_PWM);
+#endif
+
     memset(last_accel_pass_ms, 0, sizeof(last_accel_pass_ms));
     memset(last_gyro_pass_ms, 0, sizeof(last_gyro_pass_ms));
 }
@@ -95,8 +106,8 @@ uint16_t AP_Arming::compass_magfield_expected() const
 }
 
 bool AP_Arming::is_armed()
-{ 
-    return require == NONE || armed; 
+{
+    return require == NONE || armed;
 }
 
 uint16_t AP_Arming::get_enabled_checks()
@@ -450,11 +461,13 @@ bool AP_Arming::board_voltage_checks(bool report)
 
 bool AP_Arming::pre_arm_checks(bool report)
 {
+#if !APM_BUILD_TYPE(APM_BUILD_ArduCopter)
     if (armed || require == NONE) {
         // if we are already armed or don't need any arming checks
         // then skip the checks
         return true;
     }
+#endif
 
     return hardware_safety_check(report)
         &  barometer_checks(report)
@@ -482,6 +495,10 @@ bool AP_Arming::arm_checks(uint8_t method)
 //returns true if arming occurred successfully
 bool AP_Arming::arm(uint8_t method)
 {
+#if APM_BUILD_TYPE(APM_BUILD_ArduCopter)
+    // Copter should never use this function
+    return false;
+#else
     if (armed) { //already armed
         return false;
     }
@@ -509,11 +526,16 @@ bool AP_Arming::arm(uint8_t method)
     }
 
     return armed;
+#endif
 }
 
 //returns true if disarming occurred successfully
 bool AP_Arming::disarm() 
 {
+#if APM_BUILD_TYPE(APM_BUILD_ArduCopter)
+    // Copter should never use this function
+    return false;
+#else
     if (!armed) { // already disarmed
         return false;
     }
@@ -525,6 +547,7 @@ bool AP_Arming::disarm()
     //Can't do this from this class until there is a unified logging library.
 
     return true;
+#endif
 }
 
 AP_Arming::ArmingRequired AP_Arming::arming_required() 
diff --git a/libraries/AP_Arming/AP_Arming.h b/libraries/AP_Arming/AP_Arming.h
index cbc3725..fcfe6d8 100644
--- a/libraries/AP_Arming/AP_Arming.h
+++ b/libraries/AP_Arming/AP_Arming.h
@@ -40,6 +40,7 @@ class AP_Arming {
     AP_Arming(const AP_AHRS &ahrs_ref, const AP_Baro &baro, Compass &compass,
               const AP_BattMonitor &battery);
 
+    // these functions should not be used by Copter which holds the armed state in the motors library
     ArmingRequired arming_required();
     virtual bool arm(uint8_t method);
     bool disarm();

From 34a850e1a59b7d2eda46882b8fc5a701baeb3c50 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Wed, 28 Dec 2016 14:43:31 +0900
Subject: [PATCH 137/200] AP_Arming: formatting and comment fixes

No functional change
---
 libraries/AP_Arming/AP_Arming.h | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/libraries/AP_Arming/AP_Arming.h b/libraries/AP_Arming/AP_Arming.h
index fcfe6d8..1a3869f 100644
--- a/libraries/AP_Arming/AP_Arming.h
+++ b/libraries/AP_Arming/AP_Arming.h
@@ -45,22 +45,23 @@ class AP_Arming {
     virtual bool arm(uint8_t method);
     bool disarm();
     bool is_armed();
+
+    // get bitmask of enabled checks
     uint16_t get_enabled_checks();
 
-    /*
-      pre_arm_checks() is virtual so it can be modified
-      in a vehicle specific subclass
-    */
+    // pre_arm_checks() is virtual so it can be modified in a vehicle specific subclass
     virtual bool pre_arm_checks(bool report);
+
     // some arming checks have side-effects, or require some form of state
-    // change to have occured, and thus should not be done as pre-arm
+    // change to have occurred, and thus should not be done as pre-arm
     // checks.  Those go here:
     bool arm_checks(uint8_t method);
 
-    static const struct AP_Param::GroupInfo        var_info[];
-
+    // get expected magnetic field strength
     uint16_t compass_magfield_expected() const;
 
+    static const struct AP_Param::GroupInfo        var_info[];
+
 protected:
     // Parameters
     AP_Int8                 require;

From d35a208dae1b55ff880f5346c24e20d153cc6887 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Wed, 28 Dec 2016 14:45:47 +0900
Subject: [PATCH 138/200] AP_Arming: remove unused set_enabled_checks

---
 libraries/AP_Arming/AP_Arming.cpp | 5 -----
 libraries/AP_Arming/AP_Arming.h   | 2 --
 2 files changed, 7 deletions(-)

diff --git a/libraries/AP_Arming/AP_Arming.cpp b/libraries/AP_Arming/AP_Arming.cpp
index 608fe56..6ce24cd 100644
--- a/libraries/AP_Arming/AP_Arming.cpp
+++ b/libraries/AP_Arming/AP_Arming.cpp
@@ -115,11 +115,6 @@ uint16_t AP_Arming::get_enabled_checks()
     return checks_to_perform;
 }
 
-void AP_Arming::set_enabled_checks(uint16_t ap)
-{
-    checks_to_perform = ap;
-}
-
 bool AP_Arming::barometer_checks(bool report)
 {
     if ((checks_to_perform & ARMING_CHECK_ALL) ||
diff --git a/libraries/AP_Arming/AP_Arming.h b/libraries/AP_Arming/AP_Arming.h
index 1a3869f..74c3fad 100644
--- a/libraries/AP_Arming/AP_Arming.h
+++ b/libraries/AP_Arming/AP_Arming.h
@@ -82,8 +82,6 @@ class AP_Arming {
     uint32_t                last_accel_pass_ms[INS_MAX_INSTANCES];
     uint32_t                last_gyro_pass_ms[INS_MAX_INSTANCES];
 
-    void set_enabled_checks(uint16_t);
-
     bool barometer_checks(bool report);
 
     bool airspeed_checks(bool report);

From ae18c2507075c0d2aa2e38732a3753285665bb89 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 9 Jan 2017 16:46:03 +0900
Subject: [PATCH 139/200] Copter: add AP_Arming to build

---
 ArduCopter/make.inc | 1 +
 ArduCopter/wscript  | 3 ++-
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/ArduCopter/make.inc b/ArduCopter/make.inc
index 062ef06..fe541ad 100644
--- a/ArduCopter/make.inc
+++ b/ArduCopter/make.inc
@@ -65,3 +65,4 @@ LIBRARIES += AP_Proximity
 LIBRARIES += AP_Stats
 LIBRARIES += AP_Gripper
 LIBRARIES += AP_Beacon
+LIBRARIES += AP_Arming
diff --git a/ArduCopter/wscript b/ArduCopter/wscript
index 7fc3b27..a778545 100644
--- a/ArduCopter/wscript
+++ b/ArduCopter/wscript
@@ -31,7 +31,8 @@ def build(bld):
             'AP_Proximity',
             'AP_Stats',
             'AP_Gripper',
-            'AP_Beacon'
+            'AP_Beacon',
+            'AP_Arming',
         ],
     )
 

From bd6ffc025ee8f2d82164a368f3f7e4b419b00660 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Mon, 9 Jan 2017 16:45:48 +0900
Subject: [PATCH 140/200] Copter: start conversion to AP_Arming_Copter

---
 ArduCopter/AP_State.cpp        |  12 +--
 ArduCopter/ArduCopter.cpp      |   2 +-
 ArduCopter/Copter.h            |  27 ++----
 ArduCopter/Parameters.cpp      |  10 +--
 ArduCopter/Parameters.h        |   4 +-
 ArduCopter/arming_checks.cpp   | 190 +++++++++++++++++++++++------------------
 ArduCopter/arming_checks.h     |  55 ++++++++++++
 ArduCopter/compassmot.cpp      |   2 +-
 ArduCopter/esc_calibration.cpp |   2 +-
 ArduCopter/motor_test.cpp      |   2 +-
 ArduCopter/motors.cpp          |   2 +-
 ArduCopter/radio.cpp           |   2 +-
 12 files changed, 185 insertions(+), 125 deletions(-)
 create mode 100644 ArduCopter/arming_checks.h

diff --git a/ArduCopter/AP_State.cpp b/ArduCopter/AP_State.cpp
index d0c38b6..26a8c15 100644
--- a/ArduCopter/AP_State.cpp
+++ b/ArduCopter/AP_State.cpp
@@ -101,18 +101,18 @@ void Copter::set_failsafe_gcs(bool b)
 
 // ---------------------------------------------
 
-void Copter::set_pre_arm_check(bool b)
+void AP_Arming_Copter::set_pre_arm_check(bool b)
 {
-    if(ap.pre_arm_check != b) {
-        ap.pre_arm_check = b;
+    if(copter.ap.pre_arm_check != b) {
+        copter.ap.pre_arm_check = b;
         AP_Notify::flags.pre_arm_check = b;
     }
 }
 
-void Copter::set_pre_arm_rc_check(bool b)
+void AP_Arming_Copter::set_pre_arm_rc_check(bool b)
 {
-    if(ap.pre_arm_rc_check != b) {
-        ap.pre_arm_rc_check = b;
+    if(copter.ap.pre_arm_rc_check != b) {
+        copter.ap.pre_arm_rc_check = b;
     }
 }
 
diff --git a/ArduCopter/ArduCopter.cpp b/ArduCopter/ArduCopter.cpp
index 2d472b0..a84c70f 100644
--- a/ArduCopter/ArduCopter.cpp
+++ b/ArduCopter/ArduCopter.cpp
@@ -482,7 +482,7 @@ void Copter::one_hz_loop()
         Log_Write_Data(DATA_AP_STATE, ap.value);
     }
 
-    update_arming_checks();
+    arming.update();
 
     if (!motors->armed()) {
         // make it possible to change ahrs orientation at runtime during initial config
diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index 5a384ea..df6da75 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -90,6 +90,7 @@
 #include <AC_InputManager/AC_InputManager.h>        // Pilot input handling library
 #include <AC_InputManager/AC_InputManager_Heli.h>   // Heli specific pilot input handling library
 #include <AP_Button/AP_Button.h>
+#include <AP_Arming/AP_Arming.h>
 
 // Configuration
 #include "defines.h"
@@ -97,6 +98,7 @@
 
 #include "GCS_Mavlink.h"
 #include "AP_Rally.h"           // Rally point library
+#include "arming_checks.h"
 
 // libraries which are dependent on #defines in defines.h and/or config.h
 #if SPRAYER == ENABLED
@@ -139,6 +141,7 @@ class Copter : public AP_HAL::HAL::Callbacks {
 #if ADVANCED_FAILSAFE == ENABLED
     friend class AP_AdvancedFailsafe_Copter;
 #endif
+    friend class AP_Arming_Copter;
 
     Copter(void);
 
@@ -213,6 +216,9 @@ class Copter : public AP_HAL::HAL::Callbacks {
     // Mission library
     AP_Mission mission;
 
+    // Arming/Disarming mangement class
+    AP_Arming_Copter arming {ahrs, barometer, compass, battery, inertial_nav, ins};
+
     // Optical flow sensor
 #if OPTFLOW == ENABLED
     OpticalFlow optflow{ahrs};
@@ -644,18 +650,6 @@ class Copter : public AP_HAL::HAL::Callbacks {
     void set_failsafe_gcs(bool b);
     void set_land_complete(bool b);
     void set_land_complete_maybe(bool b);
-    void set_pre_arm_check(bool b);
-    void set_pre_arm_rc_check(bool b);
-    bool rc_calibration_checks(bool display_failure);
-    bool gps_checks(bool display_failure);
-    bool fence_checks(bool display_failure);
-    bool compass_checks(bool display_failure);
-    bool ins_checks(bool display_failure);
-    bool board_voltage_checks(bool display_failure);
-    bool parameter_checks(bool display_failure);
-    bool motor_checks(bool display_failure);
-    bool pilot_throttle_checks(bool display_failure);
-    bool barometer_checks(bool display_failure);
     void update_using_interlock();
     void set_motor_emergency_stop(bool b);
     float get_smoothing_gain();
@@ -983,15 +977,6 @@ class Copter : public AP_HAL::HAL::Callbacks {
     void arm_motors_check();
     void auto_disarm_check();
     bool init_arm_motors(bool arming_from_gcs);
-    void update_arming_checks(void);
-    bool all_arming_checks_passing(bool arming_from_gcs);
-    bool pre_arm_checks(bool display_failure);
-    void pre_arm_rc_checks();
-    bool pre_arm_gps_checks(bool display_failure);
-    bool pre_arm_ekf_attitude_check();
-    bool pre_arm_terrain_check(bool display_failure);
-    bool pre_arm_proximity_check(bool display_failure);
-    bool arm_checks(bool display_failure, bool arming_from_gcs);
     void init_disarm_motors();
     void motors_output();
     void lost_vehicle_check();
diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index 1f2d97a..f141e21 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -435,13 +435,9 @@ const AP_Param::Info Copter::var_info[] = {
     // @User: Standard
     GSCALAR(ch12_option, "CH12_OPT",                AUXSW_DO_NOTHING),
 
-    // @Param: ARMING_CHECK
-    // @DisplayName: Arming check
-    // @Description: Allows enabling or disabling of pre-arming checks of receiver, accelerometer, barometer, compass and GPS
-    // @Values: 0:Disabled, 1:Enabled, -3:Skip Baro, -5:Skip Compass, -9:Skip GPS, -17:Skip INS, -33:Skip Params/Rangefinder, -65:Skip RC, 127:Skip Voltage
-    // @Bitmask: 0:All,1:Baro,2:Compass,3:GPS,4:INS,5:Parameters+Rangefinder,6:RC,7:Voltage
-    // @User: Standard
-    GSCALAR(arming_check, "ARMING_CHECK",           ARMING_CHECK_ALL),
+    // @Group: ARMING_
+    // @Path: ../libraries/AP_Arming/AP_Arming.cpp
+    GOBJECT(arming,                 "ARMING_", AP_Arming_Copter),
 
     // @Param: DISARM_DELAY
     // @DisplayName: Disarm delay
diff --git a/ArduCopter/Parameters.h b/ArduCopter/Parameters.h
index 101c2ab..89a7c53 100644
--- a/ArduCopter/Parameters.h
+++ b/ArduCopter/Parameters.h
@@ -102,7 +102,7 @@ class Parameters {
         k_param_circle_rate,                // deprecated - remove
         k_param_rangefinder_gain,
         k_param_ch8_option,
-        k_param_arming_check,
+        k_param_arming_check_old,       // deprecated - remove
         k_param_sprayer,
         k_param_angle_max,
         k_param_gps_hdop_good,
@@ -362,6 +362,7 @@ class Parameters {
         k_param_rtl_climb_min,
         k_param_rpm_sensor,
         k_param_autotune_min_d, // 251
+        k_param_arming, // 252  - AP_Arming
         k_param_DataFlash = 253, // 253 - Logging Group
 
         // 254,255: reserved
@@ -448,7 +449,6 @@ class Parameters {
     AP_Int8         ch10_option;
     AP_Int8         ch11_option;
     AP_Int8         ch12_option;
-    AP_Int8         arming_check;
     AP_Int8         disarm_delay;
 
     AP_Int8         land_repositioning;
diff --git a/ArduCopter/arming_checks.cpp b/ArduCopter/arming_checks.cpp
index 0493150..27cf179 100644
--- a/ArduCopter/arming_checks.cpp
+++ b/ArduCopter/arming_checks.cpp
@@ -1,7 +1,7 @@
 #include "Copter.h"
 
 // performs pre-arm checks. expects to be called at 1hz.
-void Copter::update_arming_checks(void)
+void AP_Arming_Copter::update(void)
 {
     // perform pre-arm checks & display failures every 30 seconds
     static uint8_t pre_arm_display_counter = PREARM_DISPLAY_PERIOD/2;
@@ -18,7 +18,7 @@ void Copter::update_arming_checks(void)
 }
 
 // performs pre-arm checks and arming checks
-bool Copter::all_arming_checks_passing(bool arming_from_gcs)
+bool AP_Arming_Copter::all_checks_passing(bool arming_from_gcs)
 {
     if (pre_arm_checks(true)) {
         set_pre_arm_check(true);
@@ -26,21 +26,22 @@ bool Copter::all_arming_checks_passing(bool arming_from_gcs)
         return false;
     }
 
-    return ap.pre_arm_check && arm_checks(true, arming_from_gcs);
+    return copter.ap.pre_arm_check && arm_checks(true, arming_from_gcs);
 }
 
 // perform pre-arm checks and set ap.pre_arm_check flag
 //  return true if the checks pass successfully
-bool Copter::pre_arm_checks(bool display_failure)
+// NOTE: this does *NOT* call AP_Arming::pre_arm_checks() yet!
+bool AP_Arming_Copter::pre_arm_checks(bool display_failure)
 {
     // exit immediately if already armed
-    if (motors->armed()) {
+    if (copter.motors->armed()) {
         return true;
     }
 
     // check if motor interlock and Emergency Stop aux switches are used
     // at the same time.  This cannot be allowed.
-    if (check_if_auxsw_mode_used(AUXSW_MOTOR_INTERLOCK) && check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
+    if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_INTERLOCK) && copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Interlock/E-Stop Conflict");
         }
@@ -51,7 +52,7 @@ bool Copter::pre_arm_checks(bool display_failure)
     // if it is, switch needs to be in disabled position to arm
     // otherwise exit immediately.  This check to be repeated,
     // as state can change at any time.
-    if (ap.using_interlock && ap.motor_interlock_switch) {
+    if (copter.ap.using_interlock && copter.ap.motor_interlock_switch) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Motor Interlock Enabled");
         }
@@ -59,7 +60,7 @@ bool Copter::pre_arm_checks(bool display_failure)
     }
 
     // exit immediately if we've already successfully performed the pre-arm check
-    if (ap.pre_arm_check) {
+    if (copter.ap.pre_arm_check) {
         // run gps checks because results may change and affect LED colour
         // no need to display failures because arm_checks will do that if the pilot tries to arm
         pre_arm_gps_checks(false);
@@ -67,7 +68,7 @@ bool Copter::pre_arm_checks(bool display_failure)
     }
 
     // succeed if pre arm checks are disabled
-    if (g.arming_check == ARMING_CHECK_NONE) {
+    if (checks_to_perform == ARMING_CHECK_NONE) {
         set_pre_arm_check(true);
         set_pre_arm_rc_check(true);
         return true;
@@ -85,11 +86,11 @@ bool Copter::pre_arm_checks(bool display_failure)
         & pilot_throttle_checks(display_failure);
 }
 
-bool Copter::rc_calibration_checks(bool display_failure)
+bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
 {
     // pre-arm rc checks a prerequisite
     pre_arm_rc_checks();
-    if (!ap.pre_arm_rc_check) {
+    if (!copter.ap.pre_arm_rc_check) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: RC not calibrated");
         }
@@ -98,10 +99,10 @@ bool Copter::rc_calibration_checks(bool display_failure)
     return true;
 }
 
-bool Copter::barometer_checks(bool display_failure)
+bool AP_Arming_Copter::barometer_checks(bool display_failure)
 {
     // check Baro
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_BARO)) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {
         // barometer health check
         if (!barometer.all_healthy()) {
             if (display_failure) {
@@ -115,7 +116,7 @@ bool Copter::barometer_checks(bool display_failure)
         nav_filter_status filt_status = inertial_nav.get_filter_status();
         bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);
         if (using_baro_ref) {
-            if (fabsf(inertial_nav.get_altitude() - baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {
+            if (fabsf(inertial_nav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {
                 if (display_failure) {
                     gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Altitude disparity");
                 }
@@ -126,10 +127,11 @@ bool Copter::barometer_checks(bool display_failure)
     return true;
 }
 
-bool Copter::compass_checks(bool display_failure)
+bool AP_Arming_Copter::compass_checks(bool display_failure)
 {
     // check Compass
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_COMPASS)) {
+    Compass &compass = _compass; // avoid code churn
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_COMPASS)) {
         //check if compass has calibrated and requires reboot
         if (compass.compass_cal_requires_reboot()) {
             if (display_failure) {
@@ -185,7 +187,7 @@ bool Copter::compass_checks(bool display_failure)
     return true;
 }
 
-bool Copter::gps_checks(bool display_failure)
+bool AP_Arming_Copter::gps_checks(bool display_failure)
 {
     // check GPS
     if (!pre_arm_gps_checks(display_failure)) {
@@ -194,11 +196,11 @@ bool Copter::gps_checks(bool display_failure)
     return true;
 }
 
-bool Copter::fence_checks(bool display_failure)
+bool AP_Arming_Copter::fence_checks(bool display_failure)
 {
     #if AC_FENCE == ENABLED
     // check fence is initialised
-    if (!fence.pre_arm_check()) {
+    if (!copter.fence.pre_arm_check()) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check fence");
         }
@@ -208,10 +210,11 @@ bool Copter::fence_checks(bool display_failure)
     return true;
 }
 
-bool Copter::ins_checks(bool display_failure)
+bool AP_Arming_Copter::ins_checks(bool display_failure)
 {
     // check INS
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_INS)) {
+    const AP_InertialSensor &ins = _ins; // avoid code churn
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
         // check accelerometers have been calibrated
         if (!ins.accel_calibrated_ok_all()) {
             if (display_failure) {
@@ -298,12 +301,12 @@ bool Copter::ins_checks(bool display_failure)
     return true;
 }
 
-bool Copter::board_voltage_checks(bool display_failure)
+bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
 {
     #if CONFIG_HAL_BOARD != HAL_BOARD_VRBRAIN
     #ifndef CONFIG_ARCH_BOARD_PX4FMU_V1
     // check board voltage
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_VOLTAGE)) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
         if (hal.analogin->board_voltage() < BOARD_VOLTAGE_MIN || hal.analogin->board_voltage() > BOARD_VOLTAGE_MAX) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check Board Voltage");
@@ -314,9 +317,11 @@ bool Copter::board_voltage_checks(bool display_failure)
     #endif
     #endif
 
+    Parameters &g = copter.g;
+
     // check battery voltage
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_VOLTAGE)) {
-        if (failsafe.battery || (!ap.usb_connected && battery.exhausted(g.fs_batt_voltage, g.fs_batt_mah))) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
+        if (copter.failsafe.battery || (!copter.ap.usb_connected && copter.battery.exhausted(g.fs_batt_voltage, g.fs_batt_mah))) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check Battery");
             }
@@ -327,13 +332,13 @@ bool Copter::board_voltage_checks(bool display_failure)
     return true;
 }
 
-bool Copter::parameter_checks(bool display_failure)
+bool AP_Arming_Copter::parameter_checks(bool display_failure)
 {
     // check various parameter values
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_PARAMETERS)) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
 
         // ensure ch7 and ch8 have different functions
-        if (check_duplicate_auxsw()) {
+        if (copter.check_duplicate_auxsw()) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Duplicate Aux Switch Options");
             }
@@ -341,9 +346,9 @@ bool Copter::parameter_checks(bool display_failure)
         }
 
         // failsafe parameter checks
-        if (g.failsafe_throttle) {
+        if (copter.g.failsafe_throttle) {
             // check throttle min is above throttle failsafe trigger and that the trigger is above ppm encoder's loss-of-signal value of 900
-            if (channel_throttle->get_radio_min() <= g.failsafe_throttle_value+10 || g.failsafe_throttle_value < 910) {
+            if (copter.channel_throttle->get_radio_min() <= copter.g.failsafe_throttle_value+10 || copter.g.failsafe_throttle_value < 910) {
                 if (display_failure) {
                     gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check FS_THR_VALUE");
                 }
@@ -352,7 +357,7 @@ bool Copter::parameter_checks(bool display_failure)
         }
 
         // lean angle parameter check
-        if (aparm.angle_max < 1000 || aparm.angle_max > 8000) {
+        if (copter.aparm.angle_max < 1000 || copter.aparm.angle_max > 8000) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check ANGLE_MAX");
             }
@@ -360,7 +365,7 @@ bool Copter::parameter_checks(bool display_failure)
         }
 
         // acro balance parameter check
-        if ((g.acro_balance_roll > attitude_control->get_angle_roll_p().kP()) || (g.acro_balance_pitch > attitude_control->get_angle_pitch_p().kP())) {
+        if ((copter.g.acro_balance_roll > copter.attitude_control->get_angle_roll_p().kP()) || (copter.g.acro_balance_pitch > copter.attitude_control->get_angle_pitch_p().kP())) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: ACRO_BAL_ROLL/PITCH");
             }
@@ -369,7 +374,7 @@ bool Copter::parameter_checks(bool display_failure)
 
         #if RANGEFINDER_ENABLED == ENABLED && OPTFLOW == ENABLED
         // check range finder if optflow enabled
-        if (optflow.enabled() && !rangefinder.pre_arm_check()) {
+        if (copter.optflow.enabled() && !copter.rangefinder.pre_arm_check()) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check range finder");
             }
@@ -379,7 +384,7 @@ bool Copter::parameter_checks(bool display_failure)
 
         #if FRAME_CONFIG == HELI_FRAME
         // check helicopter parameters
-        if (!motors->parameter_check(display_failure)) {
+        if (!copter.motors->parameter_check(display_failure)) {
             return false;
         }
         #endif // HELI_FRAME
@@ -390,7 +395,7 @@ bool Copter::parameter_checks(bool display_failure)
         }
 
         // check adsb avoidance failsafe
-        if (failsafe.adsb) {
+        if (copter.failsafe.adsb) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: ADSB threat detected");
             }
@@ -419,12 +424,12 @@ bool Copter::motor_checks(bool display_failure)
     return true;
 }
 
-bool Copter::pilot_throttle_checks(bool display_failure)
+bool AP_Arming_Copter::pilot_throttle_checks(bool display_failure)
 {
     // check throttle is above failsafe throttle
     // this is near the bottom to allow other failures to be displayed before checking pilot throttle
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_RC)) {
-        if (g.failsafe_throttle != FS_THR_DISABLED && channel_throttle->get_radio_in() < g.failsafe_throttle_value) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_RC)) {
+        if (copter.g.failsafe_throttle != FS_THR_DISABLED && copter.channel_throttle->get_radio_in() < copter.g.failsafe_throttle_value) {
             if (display_failure) {
                 #if FRAME_CONFIG == HELI_FRAME
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Collective below Failsafe");
@@ -440,19 +445,24 @@ bool Copter::pilot_throttle_checks(bool display_failure)
 }
 
 // perform pre_arm_rc_checks checks and set ap.pre_arm_rc_check flag
-void Copter::pre_arm_rc_checks()
+void AP_Arming_Copter::pre_arm_rc_checks()
 {
     // exit immediately if we've already successfully performed the pre-arm rc check
-    if (ap.pre_arm_rc_check) {
+    if (copter.ap.pre_arm_rc_check) {
         return;
     }
 
     // set rc-checks to success if RC checks are disabled
-    if ((g.arming_check != ARMING_CHECK_ALL) && !(g.arming_check & ARMING_CHECK_RC)) {
+    if ((checks_to_perform != ARMING_CHECK_ALL) && !(checks_to_perform & ARMING_CHECK_RC)) {
         set_pre_arm_rc_check(true);
         return;
     }
 
+    RC_Channel *&channel_roll = copter.channel_roll;
+    RC_Channel *&channel_pitch = copter.channel_pitch;
+    RC_Channel *&channel_throttle = copter.channel_throttle;
+    RC_Channel *&channel_yaw = copter.channel_yaw;
+
     // check if radio has been calibrated
     if (!channel_throttle->min_max_configured()) {
         return;
@@ -483,7 +493,7 @@ void Copter::pre_arm_rc_checks()
 }
 
 // performs pre_arm gps related checks and returns true if passed
-bool Copter::pre_arm_gps_checks(bool display_failure)
+bool AP_Arming_Copter::pre_arm_gps_checks(bool display_failure)
 {
     // always check if inertial nav has started and is ready
     if (!ahrs.healthy()) {
@@ -494,11 +504,11 @@ bool Copter::pre_arm_gps_checks(bool display_failure)
     }
 
     // check if flight mode requires GPS
-    bool gps_required = mode_requires_GPS(control_mode);
+    bool gps_required = copter.mode_requires_GPS(copter.control_mode);
 
     #if AC_FENCE == ENABLED
     // if circular fence is enabled we need GPS
-    if ((fence.get_enabled_fences() & AC_FENCE_TYPE_CIRCLE) != 0) {
+    if ((copter.fence.get_enabled_fences() & AC_FENCE_TYPE_CIRCLE) != 0) {
         gps_required = true;
     }
     #endif
@@ -510,7 +520,7 @@ bool Copter::pre_arm_gps_checks(bool display_failure)
     }
 
     // ensure GPS is ok
-    if (!position_ok()) {
+    if (!copter.position_ok()) {
         if (display_failure) {
             const char *reason = ahrs.prearm_failure_reason();
             if (reason) {
@@ -527,8 +537,8 @@ bool Copter::pre_arm_gps_checks(bool display_failure)
     float vel_variance, pos_variance, hgt_variance, tas_variance;
     Vector3f mag_variance;
     Vector2f offset;
-    ahrs.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance, offset);
-    if (mag_variance.length() >= g.fs_ekf_thresh) {
+    ahrs_navekf.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance, offset);
+    if (mag_variance.length() >= copter.g.fs_ekf_thresh) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: EKF compass variance");
         }
@@ -536,7 +546,7 @@ bool Copter::pre_arm_gps_checks(bool display_failure)
     }
 
     // check home and EKF origin are not too far
-    if (far_from_EKF_origin(ahrs.get_home())) {
+    if (copter.far_from_EKF_origin(ahrs.get_home())) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: EKF-home variance");
         }
@@ -545,27 +555,27 @@ bool Copter::pre_arm_gps_checks(bool display_failure)
     }
 
     // return true immediately if gps check is disabled
-    if (!(g.arming_check == ARMING_CHECK_ALL || g.arming_check & ARMING_CHECK_GPS)) {
+    if (!(checks_to_perform == ARMING_CHECK_ALL || checks_to_perform & ARMING_CHECK_GPS)) {
         AP_Notify::flags.pre_arm_gps_check = true;
         return true;
     }
 
 #if CONFIG_HAL_BOARD != HAL_BOARD_SITL
     // check GPS configuration has completed
-    uint8_t first_unconfigured = gps.first_unconfigured_gps();
+    uint8_t first_unconfigured = copter.gps.first_unconfigured_gps();
     if (first_unconfigured != AP_GPS::GPS_ALL_CONFIGURED) {
         if (display_failure) {
             GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL,
                                              "PreArm: GPS %d failing configuration checks",
                                               first_unconfigured + 1);
-            gps.broadcast_first_configuration_failure_reason();
+            copter.gps.broadcast_first_configuration_failure_reason();
         }
         return false;
     }
 #endif
 
     // warn about hdop separately - to prevent user confusion with no gps lock
-    if (gps.get_hdop() > g.gps_hdop_good) {
+    if (copter.gps.get_hdop() > copter.g.gps_hdop_good) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: High GPS HDOP");
         }
@@ -579,7 +589,7 @@ bool Copter::pre_arm_gps_checks(bool display_failure)
 }
 
 // check ekf attitude is acceptable
-bool Copter::pre_arm_ekf_attitude_check()
+bool AP_Arming_Copter::pre_arm_ekf_attitude_check()
 {
     // get ekf filter status
     nav_filter_status filt_status = inertial_nav.get_filter_status();
@@ -588,24 +598,24 @@ bool Copter::pre_arm_ekf_attitude_check()
 }
 
 // check we have required terrain data
-bool Copter::pre_arm_terrain_check(bool display_failure)
+bool AP_Arming_Copter::pre_arm_terrain_check(bool display_failure)
 {
 #if AP_TERRAIN_AVAILABLE && AC_TERRAIN
     // succeed if not using terrain data
-    if (!terrain_use()) {
+    if (!copter.terrain_use()) {
         return true;
     }
 
     // check if terrain following is enabled, using a range finder but RTL_ALT is higher than rangefinder's max range
     // To-Do: modify RTL return path to fly at or above the RTL_ALT and remove this check
-    if ((rangefinder.num_sensors() > 0) && (g.rtl_altitude > rangefinder.max_distance_cm())) {
+    if ((copter.rangefinder.num_sensors() > 0) && (copter.g.rtl_altitude > copter.rangefinder.max_distance_cm())) {
         gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: RTL_ALT above rangefinder max range");
         return false;
     }
 
     // show terrain statistics
     uint16_t terr_pending, terr_loaded;
-    terrain.get_statistics(terr_pending, terr_loaded);
+    copter.terrain.get_statistics(terr_pending, terr_loaded);
     bool have_all_data = (terr_pending <= 0);
     if (!have_all_data && display_failure) {
         gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Waiting for Terrain data");
@@ -657,15 +667,17 @@ bool Copter::pre_arm_proximity_check(bool display_failure)
 // arm_checks - perform final checks before arming
 //  always called just before arming.  Return true if ok to arm
 //  has side-effect that logging is started
-bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
+bool AP_Arming_Copter::arm_checks(bool display_failure, bool arming_from_gcs)
 {
     #if LOGGING_ENABLED == ENABLED
     // start dataflash
-    start_logging();
+    copter.start_logging();
     #endif
 
+    const AP_InertialSensor &ins = _ins;
+
     // check accels and gyro are healthy
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_INS)) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
         //check if accelerometers have calibrated and require reboot
         if (ins.accel_cal_requires_reboot()) {
             if (display_failure) {
@@ -704,14 +716,14 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
     }
 
     // check compass health
-    if (!compass.healthy()) {
+    if (!_compass.healthy()) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Compass not healthy");
         }
         return false;
     }
 
-    if (compass.is_calibrating()) {
+    if (_compass.is_calibrating()) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Compass calibration running");
         }
@@ -719,15 +731,17 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
     }
 
     //check if compass has calibrated and requires reboot
-    if (compass.compass_cal_requires_reboot()) {
+    if (_compass.compass_cal_requires_reboot()) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL, "PreArm: Compass calibrated requires reboot");
         }
         return false;
     }
 
+    control_mode_t control_mode = copter.control_mode;
+
     // always check if the current mode allows arming
-    if (!mode_allows_arming(control_mode, arming_from_gcs)) {
+    if (!copter.mode_allows_arming(control_mode, arming_from_gcs)) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Mode not armable");
         }
@@ -746,28 +760,28 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
 
     // if we are using motor interlock switch and it's enabled, fail to arm
     // skip check in Throw mode which takes control of the motor interlock
-    if (ap.using_interlock && motors->get_interlock()) {
+    if (copter.ap.using_interlock && copter.motors->get_interlock()) {
         gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Motor Interlock Enabled");
         return false;
     }
 
     // if we are not using Emergency Stop switch option, force Estop false to ensure motors
     // can run normally
-    if (!check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
-        set_motor_emergency_stop(false);
+    if (!copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
+        copter.set_motor_emergency_stop(false);
         // if we are using motor Estop switch, it must not be in Estop position
-    } else if (check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP) && ap.motor_emergency_stop){
+    } else if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP) && copter.ap.motor_emergency_stop){
         gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Motor Emergency Stopped");
         return false;
     }
 
     // succeed if arming checks are disabled
-    if (g.arming_check == ARMING_CHECK_NONE) {
+    if (checks_to_perform == ARMING_CHECK_NONE) {
         return true;
     }
 
     // baro checks
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_BARO)) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {
         // baro health check
         if (!barometer.all_healthy()) {
             if (display_failure) {
@@ -780,7 +794,7 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
         // that may differ from the baro height due to baro drift.
         nav_filter_status filt_status = inertial_nav.get_filter_status();
         bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);
-        if (using_baro_ref && (fabsf(inertial_nav.get_altitude() - baro_alt) > PREARM_MAX_ALT_DISPARITY_CM)) {
+        if (using_baro_ref && (fabsf(inertial_nav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM)) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Altitude disparity");
             }
@@ -790,7 +804,7 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
 
     #if AC_FENCE == ENABLED
     // check vehicle is within fence
-    if (!fence.pre_arm_check()) {
+    if (!copter.fence.pre_arm_check()) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: check fence");
         }
@@ -799,8 +813,8 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
     #endif
 
     // check lean angle
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_INS)) {
-        if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > aparm.angle_max) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
+        if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > copter.aparm.angle_max) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Leaning");
             }
@@ -809,8 +823,8 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
     }
 
     // check battery voltage
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_VOLTAGE)) {
-        if (failsafe.battery || (!ap.usb_connected && battery.exhausted(g.fs_batt_voltage, g.fs_batt_mah))) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
+        if (copter.failsafe.battery || (!copter.ap.usb_connected && copter.battery.exhausted(copter.g.fs_batt_voltage, copter.g.fs_batt_mah))) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Check Battery");
             }
@@ -819,15 +833,15 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
     }
 
     // check for missing terrain data
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_PARAMETERS)) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
         if (!pre_arm_terrain_check(display_failure)) {
             return false;
         }
     }
 
     // check adsb
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_PARAMETERS)) {
-        if (failsafe.adsb) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
+        if (copter.failsafe.adsb) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: ADSB threat detected");
             }
@@ -836,9 +850,9 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
     }
 
     // check throttle
-    if ((g.arming_check == ARMING_CHECK_ALL) || (g.arming_check & ARMING_CHECK_RC)) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_RC)) {
         // check throttle is not too low - must be above failsafe throttle
-        if (g.failsafe_throttle != FS_THR_DISABLED && channel_throttle->get_radio_in() < g.failsafe_throttle_value) {
+        if (copter.g.failsafe_throttle != FS_THR_DISABLED && copter.channel_throttle->get_radio_in() < copter.g.failsafe_throttle_value) {
             if (display_failure) {
                 #if FRAME_CONFIG == HELI_FRAME
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective below Failsafe");
@@ -852,7 +866,7 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
         // check throttle is not too high - skips checks if arming from GCS in Guided
         if (!(arming_from_gcs && (control_mode == GUIDED || control_mode == GUIDED_NOGPS))) {
             // above top of deadband is too always high
-            if (get_pilot_desired_climb_rate(channel_throttle->get_control_in()) > 0.0f) {
+            if (copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in()) > 0.0f) {
                 if (display_failure) {
                     #if FRAME_CONFIG == HELI_FRAME
                     gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective too high");
@@ -863,7 +877,7 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
                 return false;
             }
             // in manual modes throttle must be at zero
-            if ((mode_has_manual_throttle(control_mode) || control_mode == DRIFT) && channel_throttle->get_control_in() > 0) {
+            if ((copter.mode_has_manual_throttle(control_mode) || control_mode == DRIFT) && copter.channel_throttle->get_control_in() > 0) {
                 if (display_failure) {
                     #if FRAME_CONFIG == HELI_FRAME
                     gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective too high");
@@ -887,3 +901,13 @@ bool Copter::arm_checks(bool display_failure, bool arming_from_gcs)
     // if we've gotten this far all is ok
     return true;
 }
+
+enum HomeState AP_Arming_Copter::home_status() const
+{
+    return copter.ap.home_state;
+}
+
+void AP_Arming_Copter::gcs_send_text(MAV_SEVERITY severity, const char *str)
+{
+    copter.gcs_send_text(severity, str);
+}
diff --git a/ArduCopter/arming_checks.h b/ArduCopter/arming_checks.h
new file mode 100644
index 0000000..6591ad3
--- /dev/null
+++ b/ArduCopter/arming_checks.h
@@ -0,0 +1,55 @@
+#pragma once
+
+#include <AP_Arming/AP_Arming.h>
+
+class AP_Arming_Copter : public AP_Arming
+{
+public:
+    AP_Arming_Copter(const AP_AHRS_NavEKF &ahrs_ref, const AP_Baro &baro, Compass &compass,
+                     const AP_BattMonitor &battery, const AP_InertialNav_NavEKF &inav,
+                     const AP_InertialSensor &ins) :
+        AP_Arming(ahrs_ref, baro, compass, battery),
+        inertial_nav(inav),
+        _ins(ins),
+        ahrs_navekf(ahrs_ref)
+        {
+    }
+
+    void update(void);
+    bool all_checks_passing(bool arming_from_gcs);
+    void pre_arm_rc_checks();
+
+protected:
+
+    bool pre_arm_checks(bool display_failure);
+    bool pre_arm_gps_checks(bool display_failure);
+    bool pre_arm_ekf_attitude_check();
+    bool pre_arm_terrain_check(bool display_failure);
+    bool pre_arm_proximity_check(bool display_failure);
+    bool arm_checks(bool display_failure, bool arming_from_gcs);
+
+    // NOTE! the following check functions *DO NOT* call into AP_Arming!
+    bool gps_checks(bool display_failure);
+    bool fence_checks(bool display_failure);
+    bool compass_checks(bool display_failure);
+    bool ins_checks(bool display_failure) override;
+    bool board_voltage_checks(bool display_failure);
+    bool parameter_checks(bool display_failure);
+    bool pilot_throttle_checks(bool display_failure);
+    bool barometer_checks(bool display_failure);
+    bool rc_calibration_checks(bool display_failure);
+
+    void set_pre_arm_check(bool b);
+    void set_pre_arm_rc_check(bool b);
+
+    enum HomeState home_status() const override;
+
+private:
+
+    void gcs_send_text(MAV_SEVERITY severity, const char *str);
+
+    const AP_InertialNav_NavEKF &inertial_nav;
+    const AP_InertialSensor &_ins;
+    const AP_AHRS_NavEKF &ahrs_navekf;
+
+};
diff --git a/ArduCopter/compassmot.cpp b/ArduCopter/compassmot.cpp
index bf9aeef..fc5f6fb 100644
--- a/ArduCopter/compassmot.cpp
+++ b/ArduCopter/compassmot.cpp
@@ -56,7 +56,7 @@ MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
     }
 
     // check if radio is calibrated
-    pre_arm_rc_checks();
+    arming.pre_arm_rc_checks();
     if (!ap.pre_arm_rc_check) {
         gcs[chan-MAVLINK_COMM_0].send_text(MAV_SEVERITY_CRITICAL, "RC not calibrated");
         ap.compass_mot = false;
diff --git a/ArduCopter/esc_calibration.cpp b/ArduCopter/esc_calibration.cpp
index 521abdf..cb5d394 100644
--- a/ArduCopter/esc_calibration.cpp
+++ b/ArduCopter/esc_calibration.cpp
@@ -20,7 +20,7 @@ void Copter::esc_calibration_startup_check()
 {
 #if FRAME_CONFIG != HELI_FRAME
     // exit immediately if pre-arm rc checks fail
-    pre_arm_rc_checks();
+    arming.pre_arm_rc_checks();
     if (!ap.pre_arm_rc_check) {
         // clear esc flag for next time
         if ((g.esc_calibrate != ESCCAL_NONE) && (g.esc_calibrate != ESCCAL_DISABLED)) {
diff --git a/ArduCopter/motor_test.cpp b/ArduCopter/motor_test.cpp
index 8e140a3..8469d4a 100644
--- a/ArduCopter/motor_test.cpp
+++ b/ArduCopter/motor_test.cpp
@@ -73,7 +73,7 @@ void Copter::motor_test_output()
 bool Copter::mavlink_motor_test_check(mavlink_channel_t chan, bool check_rc)
 {
     // check rc has been calibrated
-    pre_arm_rc_checks();
+    arming.pre_arm_rc_checks();
     if(check_rc && !ap.pre_arm_rc_check) {
         gcs[chan-MAVLINK_COMM_0].send_text(MAV_SEVERITY_CRITICAL,"Motor Test: RC not calibrated");
         return false;
diff --git a/ArduCopter/motors.cpp b/ArduCopter/motors.cpp
index 7dbd330..e8813d2 100644
--- a/ArduCopter/motors.cpp
+++ b/ArduCopter/motors.cpp
@@ -137,7 +137,7 @@ bool Copter::init_arm_motors(bool arming_from_gcs)
     }
 
     // run pre-arm-checks and display failures
-    if (!all_arming_checks_passing(arming_from_gcs)) {
+    if (!arming.all_checks_passing(arming_from_gcs)) {
         AP_Notify::events.arming_failed = true;
         in_arm_motors = false;
         return false;
diff --git a/ArduCopter/radio.cpp b/ArduCopter/radio.cpp
index 7ddc268..8ace7de 100644
--- a/ArduCopter/radio.cpp
+++ b/ArduCopter/radio.cpp
@@ -68,7 +68,7 @@ void Copter::init_rc_out()
     esc_calibration_startup_check();
 
     // enable output to motors
-    pre_arm_rc_checks();
+    arming.pre_arm_rc_checks();
     if (ap.pre_arm_rc_check) {
         enable_motor_output();
     }

From f3a31b988ac793d2865908851065f0249fd494f2 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Wed, 17 Aug 2016 13:14:56 +1000
Subject: [PATCH 141/200] Copter: use ins_checks from AP_Arming

Functionality changes:
 - gyros and accels only have to be consistent in last 10 seconds to pass
 - ins.use_accel() is honoured when checking for consistency
 - ins.use_gyro() is honoured when checking for consistency
 - threshold is trippled rather than doubled for accel cal checks
 - checks are reordered
---
 ArduCopter/arming_checks.cpp | 83 +++-----------------------------------------
 ArduCopter/arming_checks.h   |  4 ++-
 ArduCopter/config.h          | 10 ------
 3 files changed, 8 insertions(+), 89 deletions(-)

diff --git a/ArduCopter/arming_checks.cpp b/ArduCopter/arming_checks.cpp
index 27cf179..e9a5016 100644
--- a/ArduCopter/arming_checks.cpp
+++ b/ArduCopter/arming_checks.cpp
@@ -212,93 +212,20 @@ bool AP_Arming_Copter::fence_checks(bool display_failure)
 
 bool AP_Arming_Copter::ins_checks(bool display_failure)
 {
-    // check INS
-    const AP_InertialSensor &ins = _ins; // avoid code churn
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
-        // check accelerometers have been calibrated
-        if (!ins.accel_calibrated_ok_all()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Accels not calibrated");
-            }
-            return false;
-        }
-
-        // check accels are healthy
-        if (!ins.get_accel_health_all()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Accelerometers not healthy");
-            }
-            return false;
-        }
-
-        //check if accelerometers have calibrated and require reboot
-        if (ins.accel_cal_requires_reboot()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL, "PreArm: Accelerometers calibrated requires reboot");
-            }
-            return false;
-        }
+    bool ret = AP_Arming::ins_checks(display_failure);
 
-        // check all accelerometers point in roughly same direction
-        if (ins.get_accel_count() > 1) {
-            const Vector3f &prime_accel_vec = ins.get_accel();
-            for(uint8_t i=0; i<ins.get_accel_count(); i++) {
-                // get next accel vector
-                const Vector3f &accel_vec = ins.get_accel(i);
-                Vector3f vec_diff = accel_vec - prime_accel_vec;
-                float threshold = PREARM_MAX_ACCEL_VECTOR_DIFF;
-                if (i >= 2) {
-                    /*
-                     * for boards with 3 IMUs we only use the first two
-                     * in the EKF. Allow for larger accel discrepancy
-                     * for IMU3 as it may be running at a different temperature
-                     */
-                    threshold *= 2;
-                }
-
-                // EKF is less sensitive to Z-axis error
-                vec_diff.z *= 0.5f;
-
-                if (vec_diff.length() > threshold) {
-                    if (display_failure) {
-                        gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: inconsistent Accelerometers");
-                    }
-                    return false;
-                }
-            }
-        }
-
-        // check gyros are healthy
-        if (!ins.get_gyro_health_all()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Gyros not healthy");
-            }
-            return false;
-        }
-
-        // check all gyros are consistent
-        if (ins.get_gyro_count() > 1) {
-            for(uint8_t i=0; i<ins.get_gyro_count(); i++) {
-                // get rotation rate difference between gyro #i and primary gyro
-                Vector3f vec_diff = ins.get_gyro(i) - ins.get_gyro();
-                if (vec_diff.length() > PREARM_MAX_GYRO_VECTOR_DIFF) {
-                    if (display_failure) {
-                        gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: inconsistent Gyros");
-                    }
-                    return false;
-                }
-            }
-        }
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
 
         // get ekf attitude (if bad, it's usually the gyro biases)
         if (!pre_arm_ekf_attitude_check()) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: gyros still settling");
             }
-            return false;
+            ret = false;
         }
     }
-    return true;
+
+    return ret;
 }
 
 bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
diff --git a/ArduCopter/arming_checks.h b/ArduCopter/arming_checks.h
index 6591ad3..a35ff65 100644
--- a/ArduCopter/arming_checks.h
+++ b/ArduCopter/arming_checks.h
@@ -28,11 +28,13 @@ class AP_Arming_Copter : public AP_Arming
     bool pre_arm_proximity_check(bool display_failure);
     bool arm_checks(bool display_failure, bool arming_from_gcs);
 
+    // NOTE! the following check functions *DO* call into AP_Arming:
+    bool ins_checks(bool display_failure) override;
+
     // NOTE! the following check functions *DO NOT* call into AP_Arming!
     bool gps_checks(bool display_failure);
     bool fence_checks(bool display_failure);
     bool compass_checks(bool display_failure);
-    bool ins_checks(bool display_failure) override;
     bool board_voltage_checks(bool display_failure);
     bool parameter_checks(bool display_failure);
     bool pilot_throttle_checks(bool display_failure);
diff --git a/ArduCopter/config.h b/ArduCopter/config.h
index 630f0c3..6427592 100644
--- a/ArduCopter/config.h
+++ b/ArduCopter/config.h
@@ -188,16 +188,6 @@
  # define PREARM_MAX_ALT_DISPARITY_CM       100     // barometer and inertial nav altitude must be within this many centimeters
 #endif
 
-// arming check's maximum acceptable accelerometer vector difference (in m/s/s) between primary and backup accelerometers
-#ifndef PREARM_MAX_ACCEL_VECTOR_DIFF
-  #define PREARM_MAX_ACCEL_VECTOR_DIFF      0.70f    // pre arm accel check will fail if primary and backup accelerometer vectors differ by 0.7m/s/s
-#endif
-
-// arming check's maximum acceptable rotation rate difference (in rad/sec) between primary and backup gyros
-#ifndef PREARM_MAX_GYRO_VECTOR_DIFF
-  #define PREARM_MAX_GYRO_VECTOR_DIFF       0.0873f  // pre arm gyro check will fail if primary and backup gyro vectors differ by 0.0873 rad/sec (=5deg/sec)
-#endif
-
 //////////////////////////////////////////////////////////////////////////////
 //  EKF Failsafe
 #ifndef FS_EKF_ACTION_DEFAULT

From ac980fdd4739ef640d92ef9253b361ff070f4c5e Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Wed, 17 Aug 2016 21:21:05 +1000
Subject: [PATCH 142/200] Copter: use compass_checks from AP_Arming

User-visible changes:
 - checks will fail if calibration is in progress
 - PX4FMU_V1 will now have COMPASS_OFFSETS_MAX of 600, not 500
 - if the primary compass is not set to be used then compass checks will always pass
---
 ArduCopter/arming_checks.cpp | 56 ++++++--------------------------------------
 ArduCopter/arming_checks.h   |  2 +-
 ArduCopter/compassmot.cpp    |  4 ++--
 ArduCopter/config.h          | 16 -------------
 4 files changed, 10 insertions(+), 68 deletions(-)

diff --git a/ArduCopter/arming_checks.cpp b/ArduCopter/arming_checks.cpp
index e9a5016..cd8fbd1 100644
--- a/ArduCopter/arming_checks.cpp
+++ b/ArduCopter/arming_checks.cpp
@@ -129,62 +129,20 @@ bool AP_Arming_Copter::barometer_checks(bool display_failure)
 
 bool AP_Arming_Copter::compass_checks(bool display_failure)
 {
-    // check Compass
-    Compass &compass = _compass; // avoid code churn
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_COMPASS)) {
-        //check if compass has calibrated and requires reboot
-        if (compass.compass_cal_requires_reboot()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL, "PreArm: Compass calibrated requires reboot");
-            }
-            return false;
-        }
-
-        // check the primary compass is healthy
-        if (!compass.healthy()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Compass not healthy");
-            }
-            return false;
-        }
+    bool ret = AP_Arming::compass_checks(display_failure);
 
-        // check compass learning is on or offsets have been set
-        if (!compass.configured()) {
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_COMPASS)) {
+        // check compass offsets have been set.  AP_Arming only checks
+        // this if learning is off; Copter *always* checks.
+        if (!_compass.configured()) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Compass not calibrated");
             }
-            return false;
-        }
-
-        // check for unreasonable compass offsets
-        Vector3f offsets = compass.get_offsets();
-        if (offsets.length() > COMPASS_OFFSETS_MAX) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Compass offsets too high");
-            }
-            return false;
-        }
-
-        // check for unreasonable mag field length
-        float mag_field = compass.get_field().length();
-        if (mag_field > COMPASS_MAGFIELD_EXPECTED*1.65f || mag_field < COMPASS_MAGFIELD_EXPECTED*0.35f) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check mag field");
-            }
-            return false;
-        }
-
-        // check all compasses point in roughly same direction
-        if (!compass.consistent()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: inconsistent compasses");
-            }
-            return false;
+            ret = false;
         }
-
     }
 
-    return true;
+    return ret;
 }
 
 bool AP_Arming_Copter::gps_checks(bool display_failure)
diff --git a/ArduCopter/arming_checks.h b/ArduCopter/arming_checks.h
index a35ff65..b60c2bc 100644
--- a/ArduCopter/arming_checks.h
+++ b/ArduCopter/arming_checks.h
@@ -30,11 +30,11 @@ class AP_Arming_Copter : public AP_Arming
 
     // NOTE! the following check functions *DO* call into AP_Arming:
     bool ins_checks(bool display_failure) override;
+    bool compass_checks(bool display_failure) override;
 
     // NOTE! the following check functions *DO NOT* call into AP_Arming!
     bool gps_checks(bool display_failure);
     bool fence_checks(bool display_failure);
-    bool compass_checks(bool display_failure);
     bool board_voltage_checks(bool display_failure);
     bool parameter_checks(bool display_failure);
     bool pilot_throttle_checks(bool display_failure);
diff --git a/ArduCopter/compassmot.cpp b/ArduCopter/compassmot.cpp
index fc5f6fb..b8619af 100644
--- a/ArduCopter/compassmot.cpp
+++ b/ArduCopter/compassmot.cpp
@@ -210,12 +210,12 @@ MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
             if (comp_type == AP_COMPASS_MOT_COMP_THROTTLE) {
                 for (uint8_t i=0; i<compass.get_count(); i++) {
                     // interference is impact@fullthrottle / mag field * 100
-                    interference_pct[i] = motor_compensation[i].length() / (float)COMPASS_MAGFIELD_EXPECTED * 100.0f;
+                    interference_pct[i] = motor_compensation[i].length() / (float)arming.compass_magfield_expected() * 100.0f;
                 }
             }else{
                 for (uint8_t i=0; i<compass.get_count(); i++) {
                     // interference is impact/amp * (max current seen / max throttle seen) / mag field * 100
-                    interference_pct[i] = motor_compensation[i].length() * (current_amps_max/throttle_pct_max) / (float)COMPASS_MAGFIELD_EXPECTED * 100.0f;
+                    interference_pct[i] = motor_compensation[i].length() * (current_amps_max/throttle_pct_max) / (float)arming.compass_magfield_expected() * 100.0f;
                 }
             }
 
diff --git a/ArduCopter/config.h b/ArduCopter/config.h
index 6427592..c1df95d 100644
--- a/ArduCopter/config.h
+++ b/ArduCopter/config.h
@@ -207,22 +207,6 @@
  # define MAGNETOMETER                   ENABLED
 #endif
 
-// expected magnetic field strength.  pre-arm checks will fail if 50% higher or lower than this value
-#ifndef COMPASS_MAGFIELD_EXPECTED
- #define COMPASS_MAGFIELD_EXPECTED      530        // pre arm will fail if mag field > 874 or < 185
-#endif
-
-// max compass offset length (i.e. sqrt(offs_x^2+offs_y^2+offs_Z^2))
-#ifndef CONFIG_ARCH_BOARD_PX4FMU_V1
- #ifndef COMPASS_OFFSETS_MAX
-  # define COMPASS_OFFSETS_MAX          600         // PX4 onboard compass has high offsets
- #endif
-#else   // SITL, etc
- #ifndef COMPASS_OFFSETS_MAX
-  # define COMPASS_OFFSETS_MAX          500
- #endif
-#endif
-
 #ifndef COMPASS_CAL_STICK_GESTURE_TIME
  #define COMPASS_CAL_STICK_GESTURE_TIME 2.0f // 2 seconds
 #endif

From 4ea6cf4ce3c0f9f4ba7afadcd48ef0a315867fda Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Fri, 23 Sep 2016 09:59:14 +1000
Subject: [PATCH 143/200] Copter: transfer old ARMING_CHECK value to new
 location

---
 ArduCopter/Parameters.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/ArduCopter/Parameters.cpp b/ArduCopter/Parameters.cpp
index f141e21..71c9849 100644
--- a/ArduCopter/Parameters.cpp
+++ b/ArduCopter/Parameters.cpp
@@ -1040,6 +1040,7 @@ const AP_Param::ConversionInfo conversion_table[] = {
     { Parameters::k_param_serial0_baud,       0,      AP_PARAM_INT16, "SERIAL0_BAUD" },
     { Parameters::k_param_serial1_baud,       0,      AP_PARAM_INT16, "SERIAL1_BAUD" },
     { Parameters::k_param_serial2_baud,       0,      AP_PARAM_INT16, "SERIAL2_BAUD" },
+    { Parameters::k_param_arming_check_old,   0,      AP_PARAM_INT8,  "ARMING_CHECK" },
 };
 
 void Copter::load_parameters(void)

From b89d3564c7cb01fc4c137427e48a4b6cdecd4db3 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 26 Dec 2016 17:03:40 +0900
Subject: [PATCH 144/200] Copter: move set_pre_arm_check to arming_checks

---
 ArduCopter/AP_State.cpp      | 15 ---------------
 ArduCopter/arming_checks.cpp | 15 +++++++++++++++
 2 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/ArduCopter/AP_State.cpp b/ArduCopter/AP_State.cpp
index 26a8c15..cf9e5ae 100644
--- a/ArduCopter/AP_State.cpp
+++ b/ArduCopter/AP_State.cpp
@@ -101,21 +101,6 @@ void Copter::set_failsafe_gcs(bool b)
 
 // ---------------------------------------------
 
-void AP_Arming_Copter::set_pre_arm_check(bool b)
-{
-    if(copter.ap.pre_arm_check != b) {
-        copter.ap.pre_arm_check = b;
-        AP_Notify::flags.pre_arm_check = b;
-    }
-}
-
-void AP_Arming_Copter::set_pre_arm_rc_check(bool b)
-{
-    if(copter.ap.pre_arm_rc_check != b) {
-        copter.ap.pre_arm_rc_check = b;
-    }
-}
-
 void Copter::update_using_interlock()
 {
 #if FRAME_CONFIG == HELI_FRAME
diff --git a/ArduCopter/arming_checks.cpp b/ArduCopter/arming_checks.cpp
index cd8fbd1..2fbf3ef 100644
--- a/ArduCopter/arming_checks.cpp
+++ b/ArduCopter/arming_checks.cpp
@@ -792,6 +792,21 @@ enum HomeState AP_Arming_Copter::home_status() const
     return copter.ap.home_state;
 }
 
+void AP_Arming_Copter::set_pre_arm_check(bool b)
+{
+    if(copter.ap.pre_arm_check != b) {
+        copter.ap.pre_arm_check = b;
+        AP_Notify::flags.pre_arm_check = b;
+    }
+}
+
+void AP_Arming_Copter::set_pre_arm_rc_check(bool b)
+{
+    if(copter.ap.pre_arm_rc_check != b) {
+        copter.ap.pre_arm_rc_check = b;
+    }
+}
+
 void AP_Arming_Copter::gcs_send_text(MAV_SEVERITY severity, const char *str)
 {
     copter.gcs_send_text(severity, str);

From ee9588c674b9085a9f71115ffc11728c19faaf85 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 26 Dec 2016 17:04:13 +0900
Subject: [PATCH 145/200] Copter: fix proximity arming checks

---
 ArduCopter/arming_checks.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/ArduCopter/arming_checks.cpp b/ArduCopter/arming_checks.cpp
index 2fbf3ef..d2b1e59 100644
--- a/ArduCopter/arming_checks.cpp
+++ b/ArduCopter/arming_checks.cpp
@@ -512,17 +512,17 @@ bool AP_Arming_Copter::pre_arm_terrain_check(bool display_failure)
 }
 
 // check nothing is too close to vehicle
-bool Copter::pre_arm_proximity_check(bool display_failure)
+bool AP_Arming_Copter::pre_arm_proximity_check(bool display_failure)
 {
 #if PROXIMITY_ENABLED == ENABLED
 
     // return true immediately if no sensor present
-    if (g2.proximity.get_status() == AP_Proximity::Proximity_NotConnected) {
+    if (copter.g2.proximity.get_status() == AP_Proximity::Proximity_NotConnected) {
         return true;
     }
 
     // return false if proximity sensor unhealthy
-    if (g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
+    if (copter.g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check proximity sensor");
         }
@@ -532,7 +532,7 @@ bool Copter::pre_arm_proximity_check(bool display_failure)
     // get closest object if we might use it for avoidance
 #if AC_AVOID_ENABLED == ENABLED
     float angle_deg, distance;
-    if (avoid.proximity_avoidance_enabled() && g2.proximity.get_closest_object(angle_deg, distance)) {
+    if (copter.avoid.proximity_avoidance_enabled() && copter.g2.proximity.get_closest_object(angle_deg, distance)) {
         // display error if something is within 60cm
         if (distance <= 0.6f) {
             if (display_failure) {

From a52db9f29d86dfe062026f885365b5c3802b1da9 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 9 Jan 2017 14:43:39 +0900
Subject: [PATCH 146/200] Copter: fix motors_checks to AP_Arming

---
 ArduCopter/arming_checks.cpp | 4 ++--
 ArduCopter/arming_checks.h   | 1 +
 2 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/ArduCopter/arming_checks.cpp b/ArduCopter/arming_checks.cpp
index d2b1e59..c1f6d00 100644
--- a/ArduCopter/arming_checks.cpp
+++ b/ArduCopter/arming_checks.cpp
@@ -297,10 +297,10 @@ bool AP_Arming_Copter::parameter_checks(bool display_failure)
 }
 
 // check motor setup was successful
-bool Copter::motor_checks(bool display_failure)
+bool AP_Arming_Copter::motor_checks(bool display_failure)
 {
     // check motors initialised  correctly
-    if (!motors->initialised_ok()) {
+    if (!copter.motors->initialised_ok()) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check firmware or FRAME_CLASS");
         }
diff --git a/ArduCopter/arming_checks.h b/ArduCopter/arming_checks.h
index b60c2bc..863007e 100644
--- a/ArduCopter/arming_checks.h
+++ b/ArduCopter/arming_checks.h
@@ -37,6 +37,7 @@ class AP_Arming_Copter : public AP_Arming
     bool fence_checks(bool display_failure);
     bool board_voltage_checks(bool display_failure);
     bool parameter_checks(bool display_failure);
+    bool motor_checks(bool display_failure);
     bool pilot_throttle_checks(bool display_failure);
     bool barometer_checks(bool display_failure);
     bool rc_calibration_checks(bool display_failure);

From cc217550c0e03c0797eb6ca9c95d11595e9cb0fe Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 26 Dec 2016 17:05:08 +0900
Subject: [PATCH 147/200] Copter: rename arming_checks to AP_Arming

---
 ArduCopter/AP_Arming.cpp     | 813 +++++++++++++++++++++++++++++++++++++++++++
 ArduCopter/AP_Arming.h       |  58 +++
 ArduCopter/Copter.h          |   2 +-
 ArduCopter/arming_checks.cpp | 813 -------------------------------------------
 ArduCopter/arming_checks.h   |  58 ---
 5 files changed, 872 insertions(+), 872 deletions(-)
 create mode 100644 ArduCopter/AP_Arming.cpp
 create mode 100644 ArduCopter/AP_Arming.h
 delete mode 100644 ArduCopter/arming_checks.cpp
 delete mode 100644 ArduCopter/arming_checks.h

diff --git a/ArduCopter/AP_Arming.cpp b/ArduCopter/AP_Arming.cpp
new file mode 100644
index 0000000..c1f6d00
--- /dev/null
+++ b/ArduCopter/AP_Arming.cpp
@@ -0,0 +1,813 @@
+#include "Copter.h"
+
+// performs pre-arm checks. expects to be called at 1hz.
+void AP_Arming_Copter::update(void)
+{
+    // perform pre-arm checks & display failures every 30 seconds
+    static uint8_t pre_arm_display_counter = PREARM_DISPLAY_PERIOD/2;
+    pre_arm_display_counter++;
+    bool display_fail = false;
+    if (pre_arm_display_counter >= PREARM_DISPLAY_PERIOD) {
+        display_fail = true;
+        pre_arm_display_counter = 0;
+    }
+
+    if (pre_arm_checks(display_fail)) {
+        set_pre_arm_check(true);
+    }
+}
+
+// performs pre-arm checks and arming checks
+bool AP_Arming_Copter::all_checks_passing(bool arming_from_gcs)
+{
+    if (pre_arm_checks(true)) {
+        set_pre_arm_check(true);
+    } else {
+        return false;
+    }
+
+    return copter.ap.pre_arm_check && arm_checks(true, arming_from_gcs);
+}
+
+// perform pre-arm checks and set ap.pre_arm_check flag
+//  return true if the checks pass successfully
+// NOTE: this does *NOT* call AP_Arming::pre_arm_checks() yet!
+bool AP_Arming_Copter::pre_arm_checks(bool display_failure)
+{
+    // exit immediately if already armed
+    if (copter.motors->armed()) {
+        return true;
+    }
+
+    // check if motor interlock and Emergency Stop aux switches are used
+    // at the same time.  This cannot be allowed.
+    if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_INTERLOCK) && copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Interlock/E-Stop Conflict");
+        }
+        return false;
+    }
+
+    // check if motor interlock aux switch is in use
+    // if it is, switch needs to be in disabled position to arm
+    // otherwise exit immediately.  This check to be repeated,
+    // as state can change at any time.
+    if (copter.ap.using_interlock && copter.ap.motor_interlock_switch) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Motor Interlock Enabled");
+        }
+        return false;
+    }
+
+    // exit immediately if we've already successfully performed the pre-arm check
+    if (copter.ap.pre_arm_check) {
+        // run gps checks because results may change and affect LED colour
+        // no need to display failures because arm_checks will do that if the pilot tries to arm
+        pre_arm_gps_checks(false);
+        return true;
+    }
+
+    // succeed if pre arm checks are disabled
+    if (checks_to_perform == ARMING_CHECK_NONE) {
+        set_pre_arm_check(true);
+        set_pre_arm_rc_check(true);
+        return true;
+    }
+
+    return barometer_checks(display_failure)
+        & rc_calibration_checks(display_failure)
+        & compass_checks(display_failure)
+        & gps_checks(display_failure)
+        & fence_checks(display_failure)
+        & ins_checks(display_failure)
+        & board_voltage_checks(display_failure)
+        & parameter_checks(display_failure)
+        & motor_checks(display_failure)
+        & pilot_throttle_checks(display_failure);
+}
+
+bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
+{
+    // pre-arm rc checks a prerequisite
+    pre_arm_rc_checks();
+    if (!copter.ap.pre_arm_rc_check) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: RC not calibrated");
+        }
+        return false;
+    }
+    return true;
+}
+
+bool AP_Arming_Copter::barometer_checks(bool display_failure)
+{
+    // check Baro
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {
+        // barometer health check
+        if (!barometer.all_healthy()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Barometer not healthy");
+            }
+            return false;
+        }
+        // Check baro & inav alt are within 1m if EKF is operating in an absolute position mode.
+        // Do not check if intending to operate in a ground relative height mode as EKF will output a ground relative height
+        // that may differ from the baro height due to baro drift.
+        nav_filter_status filt_status = inertial_nav.get_filter_status();
+        bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);
+        if (using_baro_ref) {
+            if (fabsf(inertial_nav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {
+                if (display_failure) {
+                    gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Altitude disparity");
+                }
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+bool AP_Arming_Copter::compass_checks(bool display_failure)
+{
+    bool ret = AP_Arming::compass_checks(display_failure);
+
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_COMPASS)) {
+        // check compass offsets have been set.  AP_Arming only checks
+        // this if learning is off; Copter *always* checks.
+        if (!_compass.configured()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Compass not calibrated");
+            }
+            ret = false;
+        }
+    }
+
+    return ret;
+}
+
+bool AP_Arming_Copter::gps_checks(bool display_failure)
+{
+    // check GPS
+    if (!pre_arm_gps_checks(display_failure)) {
+        return false;
+    }
+    return true;
+}
+
+bool AP_Arming_Copter::fence_checks(bool display_failure)
+{
+    #if AC_FENCE == ENABLED
+    // check fence is initialised
+    if (!copter.fence.pre_arm_check()) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check fence");
+        }
+        return false;
+    }
+    #endif
+    return true;
+}
+
+bool AP_Arming_Copter::ins_checks(bool display_failure)
+{
+    bool ret = AP_Arming::ins_checks(display_failure);
+
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
+
+        // get ekf attitude (if bad, it's usually the gyro biases)
+        if (!pre_arm_ekf_attitude_check()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: gyros still settling");
+            }
+            ret = false;
+        }
+    }
+
+    return ret;
+}
+
+bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
+{
+    #if CONFIG_HAL_BOARD != HAL_BOARD_VRBRAIN
+    #ifndef CONFIG_ARCH_BOARD_PX4FMU_V1
+    // check board voltage
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
+        if (hal.analogin->board_voltage() < BOARD_VOLTAGE_MIN || hal.analogin->board_voltage() > BOARD_VOLTAGE_MAX) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check Board Voltage");
+            }
+            return false;
+        }
+    }
+    #endif
+    #endif
+
+    Parameters &g = copter.g;
+
+    // check battery voltage
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
+        if (copter.failsafe.battery || (!copter.ap.usb_connected && copter.battery.exhausted(g.fs_batt_voltage, g.fs_batt_mah))) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check Battery");
+            }
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool AP_Arming_Copter::parameter_checks(bool display_failure)
+{
+    // check various parameter values
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
+
+        // ensure ch7 and ch8 have different functions
+        if (copter.check_duplicate_auxsw()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Duplicate Aux Switch Options");
+            }
+            return false;
+        }
+
+        // failsafe parameter checks
+        if (copter.g.failsafe_throttle) {
+            // check throttle min is above throttle failsafe trigger and that the trigger is above ppm encoder's loss-of-signal value of 900
+            if (copter.channel_throttle->get_radio_min() <= copter.g.failsafe_throttle_value+10 || copter.g.failsafe_throttle_value < 910) {
+                if (display_failure) {
+                    gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check FS_THR_VALUE");
+                }
+                return false;
+            }
+        }
+
+        // lean angle parameter check
+        if (copter.aparm.angle_max < 1000 || copter.aparm.angle_max > 8000) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check ANGLE_MAX");
+            }
+            return false;
+        }
+
+        // acro balance parameter check
+        if ((copter.g.acro_balance_roll > copter.attitude_control->get_angle_roll_p().kP()) || (copter.g.acro_balance_pitch > copter.attitude_control->get_angle_pitch_p().kP())) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: ACRO_BAL_ROLL/PITCH");
+            }
+            return false;
+        }
+
+        #if RANGEFINDER_ENABLED == ENABLED && OPTFLOW == ENABLED
+        // check range finder if optflow enabled
+        if (copter.optflow.enabled() && !copter.rangefinder.pre_arm_check()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check range finder");
+            }
+            return false;
+        }
+        #endif
+
+        #if FRAME_CONFIG == HELI_FRAME
+        // check helicopter parameters
+        if (!copter.motors->parameter_check(display_failure)) {
+            return false;
+        }
+        #endif // HELI_FRAME
+
+        // check for missing terrain data
+        if (!pre_arm_terrain_check(display_failure)) {
+            return false;
+        }
+
+        // check adsb avoidance failsafe
+        if (copter.failsafe.adsb) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: ADSB threat detected");
+            }
+            return false;
+        }
+
+        // check for something close to vehicle
+        if (!pre_arm_proximity_check(display_failure)) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+// check motor setup was successful
+bool AP_Arming_Copter::motor_checks(bool display_failure)
+{
+    // check motors initialised  correctly
+    if (!copter.motors->initialised_ok()) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check firmware or FRAME_CLASS");
+        }
+        return false;
+    }
+    return true;
+}
+
+bool AP_Arming_Copter::pilot_throttle_checks(bool display_failure)
+{
+    // check throttle is above failsafe throttle
+    // this is near the bottom to allow other failures to be displayed before checking pilot throttle
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_RC)) {
+        if (copter.g.failsafe_throttle != FS_THR_DISABLED && copter.channel_throttle->get_radio_in() < copter.g.failsafe_throttle_value) {
+            if (display_failure) {
+                #if FRAME_CONFIG == HELI_FRAME
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Collective below Failsafe");
+                #else
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Throttle below Failsafe");
+                #endif
+            }
+            return false;
+        }
+    }
+
+    return true;
+}
+
+// perform pre_arm_rc_checks checks and set ap.pre_arm_rc_check flag
+void AP_Arming_Copter::pre_arm_rc_checks()
+{
+    // exit immediately if we've already successfully performed the pre-arm rc check
+    if (copter.ap.pre_arm_rc_check) {
+        return;
+    }
+
+    // set rc-checks to success if RC checks are disabled
+    if ((checks_to_perform != ARMING_CHECK_ALL) && !(checks_to_perform & ARMING_CHECK_RC)) {
+        set_pre_arm_rc_check(true);
+        return;
+    }
+
+    RC_Channel *&channel_roll = copter.channel_roll;
+    RC_Channel *&channel_pitch = copter.channel_pitch;
+    RC_Channel *&channel_throttle = copter.channel_throttle;
+    RC_Channel *&channel_yaw = copter.channel_yaw;
+
+    // check if radio has been calibrated
+    if (!channel_throttle->min_max_configured()) {
+        return;
+    }
+
+    // check channels 1 & 2 have min <= 1300 and max >= 1700
+    if (channel_roll->get_radio_min() > 1300 || channel_roll->get_radio_max() < 1700 || channel_pitch->get_radio_min() > 1300 || channel_pitch->get_radio_max() < 1700) {
+        return;
+    }
+
+    // check channels 3 & 4 have min <= 1300 and max >= 1700
+    if (channel_throttle->get_radio_min() > 1300 || channel_throttle->get_radio_max() < 1700 || channel_yaw->get_radio_min() > 1300 || channel_yaw->get_radio_max() < 1700) {
+        return;
+    }
+
+    // check channels 1 & 2 have trim >= 1300 and <= 1700
+    if (channel_roll->get_radio_trim() < 1300 || channel_roll->get_radio_trim() > 1700 || channel_pitch->get_radio_trim() < 1300 || channel_pitch->get_radio_trim() > 1700) {
+        return;
+    }
+
+    // check channel 4 has trim >= 1300 and <= 1700
+    if (channel_yaw->get_radio_trim() < 1300 || channel_yaw->get_radio_trim() > 1700) {
+        return;
+    }
+
+    // if we've gotten this far rc is ok
+    set_pre_arm_rc_check(true);
+}
+
+// performs pre_arm gps related checks and returns true if passed
+bool AP_Arming_Copter::pre_arm_gps_checks(bool display_failure)
+{
+    // always check if inertial nav has started and is ready
+    if (!ahrs.healthy()) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Waiting for Nav Checks");
+        }
+        return false;
+    }
+
+    // check if flight mode requires GPS
+    bool gps_required = copter.mode_requires_GPS(copter.control_mode);
+
+    #if AC_FENCE == ENABLED
+    // if circular fence is enabled we need GPS
+    if ((copter.fence.get_enabled_fences() & AC_FENCE_TYPE_CIRCLE) != 0) {
+        gps_required = true;
+    }
+    #endif
+
+    // return true if GPS is not required
+    if (!gps_required) {
+        AP_Notify::flags.pre_arm_gps_check = true;
+        return true;
+    }
+
+    // ensure GPS is ok
+    if (!copter.position_ok()) {
+        if (display_failure) {
+            const char *reason = ahrs.prearm_failure_reason();
+            if (reason) {
+                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: %s", reason);
+            } else {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Need 3D Fix");
+            }
+        }
+        AP_Notify::flags.pre_arm_gps_check = false;
+        return false;
+    }
+
+    // check EKF compass variance is below failsafe threshold
+    float vel_variance, pos_variance, hgt_variance, tas_variance;
+    Vector3f mag_variance;
+    Vector2f offset;
+    ahrs_navekf.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance, offset);
+    if (mag_variance.length() >= copter.g.fs_ekf_thresh) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: EKF compass variance");
+        }
+        return false;
+    }
+
+    // check home and EKF origin are not too far
+    if (copter.far_from_EKF_origin(ahrs.get_home())) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: EKF-home variance");
+        }
+        AP_Notify::flags.pre_arm_gps_check = false;
+        return false;
+    }
+
+    // return true immediately if gps check is disabled
+    if (!(checks_to_perform == ARMING_CHECK_ALL || checks_to_perform & ARMING_CHECK_GPS)) {
+        AP_Notify::flags.pre_arm_gps_check = true;
+        return true;
+    }
+
+#if CONFIG_HAL_BOARD != HAL_BOARD_SITL
+    // check GPS configuration has completed
+    uint8_t first_unconfigured = copter.gps.first_unconfigured_gps();
+    if (first_unconfigured != AP_GPS::GPS_ALL_CONFIGURED) {
+        if (display_failure) {
+            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL,
+                                             "PreArm: GPS %d failing configuration checks",
+                                              first_unconfigured + 1);
+            copter.gps.broadcast_first_configuration_failure_reason();
+        }
+        return false;
+    }
+#endif
+
+    // warn about hdop separately - to prevent user confusion with no gps lock
+    if (copter.gps.get_hdop() > copter.g.gps_hdop_good) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: High GPS HDOP");
+        }
+        AP_Notify::flags.pre_arm_gps_check = false;
+        return false;
+    }
+
+    // if we got here all must be ok
+    AP_Notify::flags.pre_arm_gps_check = true;
+    return true;
+}
+
+// check ekf attitude is acceptable
+bool AP_Arming_Copter::pre_arm_ekf_attitude_check()
+{
+    // get ekf filter status
+    nav_filter_status filt_status = inertial_nav.get_filter_status();
+
+    return filt_status.flags.attitude;
+}
+
+// check we have required terrain data
+bool AP_Arming_Copter::pre_arm_terrain_check(bool display_failure)
+{
+#if AP_TERRAIN_AVAILABLE && AC_TERRAIN
+    // succeed if not using terrain data
+    if (!copter.terrain_use()) {
+        return true;
+    }
+
+    // check if terrain following is enabled, using a range finder but RTL_ALT is higher than rangefinder's max range
+    // To-Do: modify RTL return path to fly at or above the RTL_ALT and remove this check
+    if ((copter.rangefinder.num_sensors() > 0) && (copter.g.rtl_altitude > copter.rangefinder.max_distance_cm())) {
+        gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: RTL_ALT above rangefinder max range");
+        return false;
+    }
+
+    // show terrain statistics
+    uint16_t terr_pending, terr_loaded;
+    copter.terrain.get_statistics(terr_pending, terr_loaded);
+    bool have_all_data = (terr_pending <= 0);
+    if (!have_all_data && display_failure) {
+        gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Waiting for Terrain data");
+    }
+    return have_all_data;
+#else
+    return true;
+#endif
+}
+
+// check nothing is too close to vehicle
+bool AP_Arming_Copter::pre_arm_proximity_check(bool display_failure)
+{
+#if PROXIMITY_ENABLED == ENABLED
+
+    // return true immediately if no sensor present
+    if (copter.g2.proximity.get_status() == AP_Proximity::Proximity_NotConnected) {
+        return true;
+    }
+
+    // return false if proximity sensor unhealthy
+    if (copter.g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check proximity sensor");
+        }
+        return false;
+    }
+
+    // get closest object if we might use it for avoidance
+#if AC_AVOID_ENABLED == ENABLED
+    float angle_deg, distance;
+    if (copter.avoid.proximity_avoidance_enabled() && copter.g2.proximity.get_closest_object(angle_deg, distance)) {
+        // display error if something is within 60cm
+        if (distance <= 0.6f) {
+            if (display_failure) {
+                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: Proximity %d deg, %4.2fm", (int)angle_deg, (double)distance);
+            }
+            return false;
+        }
+    }
+#endif
+
+    return true;
+#else
+    return true;
+#endif
+}
+
+// arm_checks - perform final checks before arming
+//  always called just before arming.  Return true if ok to arm
+//  has side-effect that logging is started
+bool AP_Arming_Copter::arm_checks(bool display_failure, bool arming_from_gcs)
+{
+    #if LOGGING_ENABLED == ENABLED
+    // start dataflash
+    copter.start_logging();
+    #endif
+
+    const AP_InertialSensor &ins = _ins;
+
+    // check accels and gyro are healthy
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
+        //check if accelerometers have calibrated and require reboot
+        if (ins.accel_cal_requires_reboot()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL, "PreArm: Accelerometers calibrated requires reboot");
+            }
+            return false;
+        }
+
+        if (!ins.get_accel_health_all()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Accelerometers not healthy");
+            }
+            return false;
+        }
+        if (!ins.get_gyro_health_all()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Gyros not healthy");
+            }
+            return false;
+        }
+        // get ekf attitude (if bad, it's usually the gyro biases)
+        if (!pre_arm_ekf_attitude_check()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: gyros still settling");
+            }
+            return false;
+        }
+    }
+
+    // always check if inertial nav has started and is ready
+    if (!ahrs.healthy()) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Waiting for Nav Checks");
+        }
+        return false;
+    }
+
+    // check compass health
+    if (!_compass.healthy()) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Compass not healthy");
+        }
+        return false;
+    }
+
+    if (_compass.is_calibrating()) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Compass calibration running");
+        }
+        return false;
+    }
+
+    //check if compass has calibrated and requires reboot
+    if (_compass.compass_cal_requires_reboot()) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL, "PreArm: Compass calibrated requires reboot");
+        }
+        return false;
+    }
+
+    control_mode_t control_mode = copter.control_mode;
+
+    // always check if the current mode allows arming
+    if (!copter.mode_allows_arming(control_mode, arming_from_gcs)) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Mode not armable");
+        }
+        return false;
+    }
+
+    // always check gps
+    if (!pre_arm_gps_checks(display_failure)) {
+        return false;
+    }
+
+    // always check motors
+    if (!motor_checks(display_failure)) {
+        return false;
+    }
+
+    // if we are using motor interlock switch and it's enabled, fail to arm
+    // skip check in Throw mode which takes control of the motor interlock
+    if (copter.ap.using_interlock && copter.motors->get_interlock()) {
+        gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Motor Interlock Enabled");
+        return false;
+    }
+
+    // if we are not using Emergency Stop switch option, force Estop false to ensure motors
+    // can run normally
+    if (!copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
+        copter.set_motor_emergency_stop(false);
+        // if we are using motor Estop switch, it must not be in Estop position
+    } else if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP) && copter.ap.motor_emergency_stop){
+        gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Motor Emergency Stopped");
+        return false;
+    }
+
+    // succeed if arming checks are disabled
+    if (checks_to_perform == ARMING_CHECK_NONE) {
+        return true;
+    }
+
+    // baro checks
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {
+        // baro health check
+        if (!barometer.all_healthy()) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Barometer not healthy");
+            }
+            return false;
+        }
+        // Check baro & inav alt are within 1m if EKF is operating in an absolute position mode.
+        // Do not check if intending to operate in a ground relative height mode as EKF will output a ground relative height
+        // that may differ from the baro height due to baro drift.
+        nav_filter_status filt_status = inertial_nav.get_filter_status();
+        bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);
+        if (using_baro_ref && (fabsf(inertial_nav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM)) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Altitude disparity");
+            }
+            return false;
+        }
+    }
+
+    #if AC_FENCE == ENABLED
+    // check vehicle is within fence
+    if (!copter.fence.pre_arm_check()) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: check fence");
+        }
+        return false;
+    }
+    #endif
+
+    // check lean angle
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
+        if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > copter.aparm.angle_max) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Leaning");
+            }
+            return false;
+        }
+    }
+
+    // check battery voltage
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
+        if (copter.failsafe.battery || (!copter.ap.usb_connected && copter.battery.exhausted(copter.g.fs_batt_voltage, copter.g.fs_batt_mah))) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Check Battery");
+            }
+            return false;
+        }
+    }
+
+    // check for missing terrain data
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
+        if (!pre_arm_terrain_check(display_failure)) {
+            return false;
+        }
+    }
+
+    // check adsb
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
+        if (copter.failsafe.adsb) {
+            if (display_failure) {
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: ADSB threat detected");
+            }
+            return false;
+        }
+    }
+
+    // check throttle
+    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_RC)) {
+        // check throttle is not too low - must be above failsafe throttle
+        if (copter.g.failsafe_throttle != FS_THR_DISABLED && copter.channel_throttle->get_radio_in() < copter.g.failsafe_throttle_value) {
+            if (display_failure) {
+                #if FRAME_CONFIG == HELI_FRAME
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective below Failsafe");
+                #else
+                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Throttle below Failsafe");
+                #endif
+            }
+            return false;
+        }
+
+        // check throttle is not too high - skips checks if arming from GCS in Guided
+        if (!(arming_from_gcs && (control_mode == GUIDED || control_mode == GUIDED_NOGPS))) {
+            // above top of deadband is too always high
+            if (copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in()) > 0.0f) {
+                if (display_failure) {
+                    #if FRAME_CONFIG == HELI_FRAME
+                    gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective too high");
+                    #else
+                    gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Throttle too high");
+                    #endif
+                }
+                return false;
+            }
+            // in manual modes throttle must be at zero
+            if ((copter.mode_has_manual_throttle(control_mode) || control_mode == DRIFT) && copter.channel_throttle->get_control_in() > 0) {
+                if (display_failure) {
+                    #if FRAME_CONFIG == HELI_FRAME
+                    gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective too high");
+                    #else
+                    gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Throttle too high");
+                    #endif
+                }
+                return false;
+            }
+        }
+    }
+
+    // check if safety switch has been pushed
+    if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
+        if (display_failure) {
+            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Safety Switch");
+        }
+        return false;
+    }
+
+    // if we've gotten this far all is ok
+    return true;
+}
+
+enum HomeState AP_Arming_Copter::home_status() const
+{
+    return copter.ap.home_state;
+}
+
+void AP_Arming_Copter::set_pre_arm_check(bool b)
+{
+    if(copter.ap.pre_arm_check != b) {
+        copter.ap.pre_arm_check = b;
+        AP_Notify::flags.pre_arm_check = b;
+    }
+}
+
+void AP_Arming_Copter::set_pre_arm_rc_check(bool b)
+{
+    if(copter.ap.pre_arm_rc_check != b) {
+        copter.ap.pre_arm_rc_check = b;
+    }
+}
+
+void AP_Arming_Copter::gcs_send_text(MAV_SEVERITY severity, const char *str)
+{
+    copter.gcs_send_text(severity, str);
+}
diff --git a/ArduCopter/AP_Arming.h b/ArduCopter/AP_Arming.h
new file mode 100644
index 0000000..863007e
--- /dev/null
+++ b/ArduCopter/AP_Arming.h
@@ -0,0 +1,58 @@
+#pragma once
+
+#include <AP_Arming/AP_Arming.h>
+
+class AP_Arming_Copter : public AP_Arming
+{
+public:
+    AP_Arming_Copter(const AP_AHRS_NavEKF &ahrs_ref, const AP_Baro &baro, Compass &compass,
+                     const AP_BattMonitor &battery, const AP_InertialNav_NavEKF &inav,
+                     const AP_InertialSensor &ins) :
+        AP_Arming(ahrs_ref, baro, compass, battery),
+        inertial_nav(inav),
+        _ins(ins),
+        ahrs_navekf(ahrs_ref)
+        {
+    }
+
+    void update(void);
+    bool all_checks_passing(bool arming_from_gcs);
+    void pre_arm_rc_checks();
+
+protected:
+
+    bool pre_arm_checks(bool display_failure);
+    bool pre_arm_gps_checks(bool display_failure);
+    bool pre_arm_ekf_attitude_check();
+    bool pre_arm_terrain_check(bool display_failure);
+    bool pre_arm_proximity_check(bool display_failure);
+    bool arm_checks(bool display_failure, bool arming_from_gcs);
+
+    // NOTE! the following check functions *DO* call into AP_Arming:
+    bool ins_checks(bool display_failure) override;
+    bool compass_checks(bool display_failure) override;
+
+    // NOTE! the following check functions *DO NOT* call into AP_Arming!
+    bool gps_checks(bool display_failure);
+    bool fence_checks(bool display_failure);
+    bool board_voltage_checks(bool display_failure);
+    bool parameter_checks(bool display_failure);
+    bool motor_checks(bool display_failure);
+    bool pilot_throttle_checks(bool display_failure);
+    bool barometer_checks(bool display_failure);
+    bool rc_calibration_checks(bool display_failure);
+
+    void set_pre_arm_check(bool b);
+    void set_pre_arm_rc_check(bool b);
+
+    enum HomeState home_status() const override;
+
+private:
+
+    void gcs_send_text(MAV_SEVERITY severity, const char *str);
+
+    const AP_InertialNav_NavEKF &inertial_nav;
+    const AP_InertialSensor &_ins;
+    const AP_AHRS_NavEKF &ahrs_navekf;
+
+};
diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index df6da75..7f5440a 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -98,7 +98,7 @@
 
 #include "GCS_Mavlink.h"
 #include "AP_Rally.h"           // Rally point library
-#include "arming_checks.h"
+#include "AP_Arming.h"
 
 // libraries which are dependent on #defines in defines.h and/or config.h
 #if SPRAYER == ENABLED
diff --git a/ArduCopter/arming_checks.cpp b/ArduCopter/arming_checks.cpp
deleted file mode 100644
index c1f6d00..0000000
--- a/ArduCopter/arming_checks.cpp
+++ /dev/null
@@ -1,813 +0,0 @@
-#include "Copter.h"
-
-// performs pre-arm checks. expects to be called at 1hz.
-void AP_Arming_Copter::update(void)
-{
-    // perform pre-arm checks & display failures every 30 seconds
-    static uint8_t pre_arm_display_counter = PREARM_DISPLAY_PERIOD/2;
-    pre_arm_display_counter++;
-    bool display_fail = false;
-    if (pre_arm_display_counter >= PREARM_DISPLAY_PERIOD) {
-        display_fail = true;
-        pre_arm_display_counter = 0;
-    }
-
-    if (pre_arm_checks(display_fail)) {
-        set_pre_arm_check(true);
-    }
-}
-
-// performs pre-arm checks and arming checks
-bool AP_Arming_Copter::all_checks_passing(bool arming_from_gcs)
-{
-    if (pre_arm_checks(true)) {
-        set_pre_arm_check(true);
-    } else {
-        return false;
-    }
-
-    return copter.ap.pre_arm_check && arm_checks(true, arming_from_gcs);
-}
-
-// perform pre-arm checks and set ap.pre_arm_check flag
-//  return true if the checks pass successfully
-// NOTE: this does *NOT* call AP_Arming::pre_arm_checks() yet!
-bool AP_Arming_Copter::pre_arm_checks(bool display_failure)
-{
-    // exit immediately if already armed
-    if (copter.motors->armed()) {
-        return true;
-    }
-
-    // check if motor interlock and Emergency Stop aux switches are used
-    // at the same time.  This cannot be allowed.
-    if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_INTERLOCK) && copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Interlock/E-Stop Conflict");
-        }
-        return false;
-    }
-
-    // check if motor interlock aux switch is in use
-    // if it is, switch needs to be in disabled position to arm
-    // otherwise exit immediately.  This check to be repeated,
-    // as state can change at any time.
-    if (copter.ap.using_interlock && copter.ap.motor_interlock_switch) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Motor Interlock Enabled");
-        }
-        return false;
-    }
-
-    // exit immediately if we've already successfully performed the pre-arm check
-    if (copter.ap.pre_arm_check) {
-        // run gps checks because results may change and affect LED colour
-        // no need to display failures because arm_checks will do that if the pilot tries to arm
-        pre_arm_gps_checks(false);
-        return true;
-    }
-
-    // succeed if pre arm checks are disabled
-    if (checks_to_perform == ARMING_CHECK_NONE) {
-        set_pre_arm_check(true);
-        set_pre_arm_rc_check(true);
-        return true;
-    }
-
-    return barometer_checks(display_failure)
-        & rc_calibration_checks(display_failure)
-        & compass_checks(display_failure)
-        & gps_checks(display_failure)
-        & fence_checks(display_failure)
-        & ins_checks(display_failure)
-        & board_voltage_checks(display_failure)
-        & parameter_checks(display_failure)
-        & motor_checks(display_failure)
-        & pilot_throttle_checks(display_failure);
-}
-
-bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
-{
-    // pre-arm rc checks a prerequisite
-    pre_arm_rc_checks();
-    if (!copter.ap.pre_arm_rc_check) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: RC not calibrated");
-        }
-        return false;
-    }
-    return true;
-}
-
-bool AP_Arming_Copter::barometer_checks(bool display_failure)
-{
-    // check Baro
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {
-        // barometer health check
-        if (!barometer.all_healthy()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Barometer not healthy");
-            }
-            return false;
-        }
-        // Check baro & inav alt are within 1m if EKF is operating in an absolute position mode.
-        // Do not check if intending to operate in a ground relative height mode as EKF will output a ground relative height
-        // that may differ from the baro height due to baro drift.
-        nav_filter_status filt_status = inertial_nav.get_filter_status();
-        bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);
-        if (using_baro_ref) {
-            if (fabsf(inertial_nav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {
-                if (display_failure) {
-                    gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Altitude disparity");
-                }
-                return false;
-            }
-        }
-    }
-    return true;
-}
-
-bool AP_Arming_Copter::compass_checks(bool display_failure)
-{
-    bool ret = AP_Arming::compass_checks(display_failure);
-
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_COMPASS)) {
-        // check compass offsets have been set.  AP_Arming only checks
-        // this if learning is off; Copter *always* checks.
-        if (!_compass.configured()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Compass not calibrated");
-            }
-            ret = false;
-        }
-    }
-
-    return ret;
-}
-
-bool AP_Arming_Copter::gps_checks(bool display_failure)
-{
-    // check GPS
-    if (!pre_arm_gps_checks(display_failure)) {
-        return false;
-    }
-    return true;
-}
-
-bool AP_Arming_Copter::fence_checks(bool display_failure)
-{
-    #if AC_FENCE == ENABLED
-    // check fence is initialised
-    if (!copter.fence.pre_arm_check()) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check fence");
-        }
-        return false;
-    }
-    #endif
-    return true;
-}
-
-bool AP_Arming_Copter::ins_checks(bool display_failure)
-{
-    bool ret = AP_Arming::ins_checks(display_failure);
-
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
-
-        // get ekf attitude (if bad, it's usually the gyro biases)
-        if (!pre_arm_ekf_attitude_check()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: gyros still settling");
-            }
-            ret = false;
-        }
-    }
-
-    return ret;
-}
-
-bool AP_Arming_Copter::board_voltage_checks(bool display_failure)
-{
-    #if CONFIG_HAL_BOARD != HAL_BOARD_VRBRAIN
-    #ifndef CONFIG_ARCH_BOARD_PX4FMU_V1
-    // check board voltage
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
-        if (hal.analogin->board_voltage() < BOARD_VOLTAGE_MIN || hal.analogin->board_voltage() > BOARD_VOLTAGE_MAX) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check Board Voltage");
-            }
-            return false;
-        }
-    }
-    #endif
-    #endif
-
-    Parameters &g = copter.g;
-
-    // check battery voltage
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
-        if (copter.failsafe.battery || (!copter.ap.usb_connected && copter.battery.exhausted(g.fs_batt_voltage, g.fs_batt_mah))) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check Battery");
-            }
-            return false;
-        }
-    }
-
-    return true;
-}
-
-bool AP_Arming_Copter::parameter_checks(bool display_failure)
-{
-    // check various parameter values
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
-
-        // ensure ch7 and ch8 have different functions
-        if (copter.check_duplicate_auxsw()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Duplicate Aux Switch Options");
-            }
-            return false;
-        }
-
-        // failsafe parameter checks
-        if (copter.g.failsafe_throttle) {
-            // check throttle min is above throttle failsafe trigger and that the trigger is above ppm encoder's loss-of-signal value of 900
-            if (copter.channel_throttle->get_radio_min() <= copter.g.failsafe_throttle_value+10 || copter.g.failsafe_throttle_value < 910) {
-                if (display_failure) {
-                    gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check FS_THR_VALUE");
-                }
-                return false;
-            }
-        }
-
-        // lean angle parameter check
-        if (copter.aparm.angle_max < 1000 || copter.aparm.angle_max > 8000) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Check ANGLE_MAX");
-            }
-            return false;
-        }
-
-        // acro balance parameter check
-        if ((copter.g.acro_balance_roll > copter.attitude_control->get_angle_roll_p().kP()) || (copter.g.acro_balance_pitch > copter.attitude_control->get_angle_pitch_p().kP())) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: ACRO_BAL_ROLL/PITCH");
-            }
-            return false;
-        }
-
-        #if RANGEFINDER_ENABLED == ENABLED && OPTFLOW == ENABLED
-        // check range finder if optflow enabled
-        if (copter.optflow.enabled() && !copter.rangefinder.pre_arm_check()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check range finder");
-            }
-            return false;
-        }
-        #endif
-
-        #if FRAME_CONFIG == HELI_FRAME
-        // check helicopter parameters
-        if (!copter.motors->parameter_check(display_failure)) {
-            return false;
-        }
-        #endif // HELI_FRAME
-
-        // check for missing terrain data
-        if (!pre_arm_terrain_check(display_failure)) {
-            return false;
-        }
-
-        // check adsb avoidance failsafe
-        if (copter.failsafe.adsb) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: ADSB threat detected");
-            }
-            return false;
-        }
-
-        // check for something close to vehicle
-        if (!pre_arm_proximity_check(display_failure)) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-// check motor setup was successful
-bool AP_Arming_Copter::motor_checks(bool display_failure)
-{
-    // check motors initialised  correctly
-    if (!copter.motors->initialised_ok()) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check firmware or FRAME_CLASS");
-        }
-        return false;
-    }
-    return true;
-}
-
-bool AP_Arming_Copter::pilot_throttle_checks(bool display_failure)
-{
-    // check throttle is above failsafe throttle
-    // this is near the bottom to allow other failures to be displayed before checking pilot throttle
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_RC)) {
-        if (copter.g.failsafe_throttle != FS_THR_DISABLED && copter.channel_throttle->get_radio_in() < copter.g.failsafe_throttle_value) {
-            if (display_failure) {
-                #if FRAME_CONFIG == HELI_FRAME
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Collective below Failsafe");
-                #else
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Throttle below Failsafe");
-                #endif
-            }
-            return false;
-        }
-    }
-
-    return true;
-}
-
-// perform pre_arm_rc_checks checks and set ap.pre_arm_rc_check flag
-void AP_Arming_Copter::pre_arm_rc_checks()
-{
-    // exit immediately if we've already successfully performed the pre-arm rc check
-    if (copter.ap.pre_arm_rc_check) {
-        return;
-    }
-
-    // set rc-checks to success if RC checks are disabled
-    if ((checks_to_perform != ARMING_CHECK_ALL) && !(checks_to_perform & ARMING_CHECK_RC)) {
-        set_pre_arm_rc_check(true);
-        return;
-    }
-
-    RC_Channel *&channel_roll = copter.channel_roll;
-    RC_Channel *&channel_pitch = copter.channel_pitch;
-    RC_Channel *&channel_throttle = copter.channel_throttle;
-    RC_Channel *&channel_yaw = copter.channel_yaw;
-
-    // check if radio has been calibrated
-    if (!channel_throttle->min_max_configured()) {
-        return;
-    }
-
-    // check channels 1 & 2 have min <= 1300 and max >= 1700
-    if (channel_roll->get_radio_min() > 1300 || channel_roll->get_radio_max() < 1700 || channel_pitch->get_radio_min() > 1300 || channel_pitch->get_radio_max() < 1700) {
-        return;
-    }
-
-    // check channels 3 & 4 have min <= 1300 and max >= 1700
-    if (channel_throttle->get_radio_min() > 1300 || channel_throttle->get_radio_max() < 1700 || channel_yaw->get_radio_min() > 1300 || channel_yaw->get_radio_max() < 1700) {
-        return;
-    }
-
-    // check channels 1 & 2 have trim >= 1300 and <= 1700
-    if (channel_roll->get_radio_trim() < 1300 || channel_roll->get_radio_trim() > 1700 || channel_pitch->get_radio_trim() < 1300 || channel_pitch->get_radio_trim() > 1700) {
-        return;
-    }
-
-    // check channel 4 has trim >= 1300 and <= 1700
-    if (channel_yaw->get_radio_trim() < 1300 || channel_yaw->get_radio_trim() > 1700) {
-        return;
-    }
-
-    // if we've gotten this far rc is ok
-    set_pre_arm_rc_check(true);
-}
-
-// performs pre_arm gps related checks and returns true if passed
-bool AP_Arming_Copter::pre_arm_gps_checks(bool display_failure)
-{
-    // always check if inertial nav has started and is ready
-    if (!ahrs.healthy()) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Waiting for Nav Checks");
-        }
-        return false;
-    }
-
-    // check if flight mode requires GPS
-    bool gps_required = copter.mode_requires_GPS(copter.control_mode);
-
-    #if AC_FENCE == ENABLED
-    // if circular fence is enabled we need GPS
-    if ((copter.fence.get_enabled_fences() & AC_FENCE_TYPE_CIRCLE) != 0) {
-        gps_required = true;
-    }
-    #endif
-
-    // return true if GPS is not required
-    if (!gps_required) {
-        AP_Notify::flags.pre_arm_gps_check = true;
-        return true;
-    }
-
-    // ensure GPS is ok
-    if (!copter.position_ok()) {
-        if (display_failure) {
-            const char *reason = ahrs.prearm_failure_reason();
-            if (reason) {
-                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: %s", reason);
-            } else {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Need 3D Fix");
-            }
-        }
-        AP_Notify::flags.pre_arm_gps_check = false;
-        return false;
-    }
-
-    // check EKF compass variance is below failsafe threshold
-    float vel_variance, pos_variance, hgt_variance, tas_variance;
-    Vector3f mag_variance;
-    Vector2f offset;
-    ahrs_navekf.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance, offset);
-    if (mag_variance.length() >= copter.g.fs_ekf_thresh) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: EKF compass variance");
-        }
-        return false;
-    }
-
-    // check home and EKF origin are not too far
-    if (copter.far_from_EKF_origin(ahrs.get_home())) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: EKF-home variance");
-        }
-        AP_Notify::flags.pre_arm_gps_check = false;
-        return false;
-    }
-
-    // return true immediately if gps check is disabled
-    if (!(checks_to_perform == ARMING_CHECK_ALL || checks_to_perform & ARMING_CHECK_GPS)) {
-        AP_Notify::flags.pre_arm_gps_check = true;
-        return true;
-    }
-
-#if CONFIG_HAL_BOARD != HAL_BOARD_SITL
-    // check GPS configuration has completed
-    uint8_t first_unconfigured = copter.gps.first_unconfigured_gps();
-    if (first_unconfigured != AP_GPS::GPS_ALL_CONFIGURED) {
-        if (display_failure) {
-            GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL,
-                                             "PreArm: GPS %d failing configuration checks",
-                                              first_unconfigured + 1);
-            copter.gps.broadcast_first_configuration_failure_reason();
-        }
-        return false;
-    }
-#endif
-
-    // warn about hdop separately - to prevent user confusion with no gps lock
-    if (copter.gps.get_hdop() > copter.g.gps_hdop_good) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: High GPS HDOP");
-        }
-        AP_Notify::flags.pre_arm_gps_check = false;
-        return false;
-    }
-
-    // if we got here all must be ok
-    AP_Notify::flags.pre_arm_gps_check = true;
-    return true;
-}
-
-// check ekf attitude is acceptable
-bool AP_Arming_Copter::pre_arm_ekf_attitude_check()
-{
-    // get ekf filter status
-    nav_filter_status filt_status = inertial_nav.get_filter_status();
-
-    return filt_status.flags.attitude;
-}
-
-// check we have required terrain data
-bool AP_Arming_Copter::pre_arm_terrain_check(bool display_failure)
-{
-#if AP_TERRAIN_AVAILABLE && AC_TERRAIN
-    // succeed if not using terrain data
-    if (!copter.terrain_use()) {
-        return true;
-    }
-
-    // check if terrain following is enabled, using a range finder but RTL_ALT is higher than rangefinder's max range
-    // To-Do: modify RTL return path to fly at or above the RTL_ALT and remove this check
-    if ((copter.rangefinder.num_sensors() > 0) && (copter.g.rtl_altitude > copter.rangefinder.max_distance_cm())) {
-        gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: RTL_ALT above rangefinder max range");
-        return false;
-    }
-
-    // show terrain statistics
-    uint16_t terr_pending, terr_loaded;
-    copter.terrain.get_statistics(terr_pending, terr_loaded);
-    bool have_all_data = (terr_pending <= 0);
-    if (!have_all_data && display_failure) {
-        gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Waiting for Terrain data");
-    }
-    return have_all_data;
-#else
-    return true;
-#endif
-}
-
-// check nothing is too close to vehicle
-bool AP_Arming_Copter::pre_arm_proximity_check(bool display_failure)
-{
-#if PROXIMITY_ENABLED == ENABLED
-
-    // return true immediately if no sensor present
-    if (copter.g2.proximity.get_status() == AP_Proximity::Proximity_NotConnected) {
-        return true;
-    }
-
-    // return false if proximity sensor unhealthy
-    if (copter.g2.proximity.get_status() < AP_Proximity::Proximity_Good) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: check proximity sensor");
-        }
-        return false;
-    }
-
-    // get closest object if we might use it for avoidance
-#if AC_AVOID_ENABLED == ENABLED
-    float angle_deg, distance;
-    if (copter.avoid.proximity_avoidance_enabled() && copter.g2.proximity.get_closest_object(angle_deg, distance)) {
-        // display error if something is within 60cm
-        if (distance <= 0.6f) {
-            if (display_failure) {
-                GCS_MAVLINK::send_statustext_all(MAV_SEVERITY_CRITICAL, "PreArm: Proximity %d deg, %4.2fm", (int)angle_deg, (double)distance);
-            }
-            return false;
-        }
-    }
-#endif
-
-    return true;
-#else
-    return true;
-#endif
-}
-
-// arm_checks - perform final checks before arming
-//  always called just before arming.  Return true if ok to arm
-//  has side-effect that logging is started
-bool AP_Arming_Copter::arm_checks(bool display_failure, bool arming_from_gcs)
-{
-    #if LOGGING_ENABLED == ENABLED
-    // start dataflash
-    copter.start_logging();
-    #endif
-
-    const AP_InertialSensor &ins = _ins;
-
-    // check accels and gyro are healthy
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
-        //check if accelerometers have calibrated and require reboot
-        if (ins.accel_cal_requires_reboot()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL, "PreArm: Accelerometers calibrated requires reboot");
-            }
-            return false;
-        }
-
-        if (!ins.get_accel_health_all()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Accelerometers not healthy");
-            }
-            return false;
-        }
-        if (!ins.get_gyro_health_all()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Gyros not healthy");
-            }
-            return false;
-        }
-        // get ekf attitude (if bad, it's usually the gyro biases)
-        if (!pre_arm_ekf_attitude_check()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: gyros still settling");
-            }
-            return false;
-        }
-    }
-
-    // always check if inertial nav has started and is ready
-    if (!ahrs.healthy()) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Waiting for Nav Checks");
-        }
-        return false;
-    }
-
-    // check compass health
-    if (!_compass.healthy()) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Compass not healthy");
-        }
-        return false;
-    }
-
-    if (_compass.is_calibrating()) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Compass calibration running");
-        }
-        return false;
-    }
-
-    //check if compass has calibrated and requires reboot
-    if (_compass.compass_cal_requires_reboot()) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL, "PreArm: Compass calibrated requires reboot");
-        }
-        return false;
-    }
-
-    control_mode_t control_mode = copter.control_mode;
-
-    // always check if the current mode allows arming
-    if (!copter.mode_allows_arming(control_mode, arming_from_gcs)) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Mode not armable");
-        }
-        return false;
-    }
-
-    // always check gps
-    if (!pre_arm_gps_checks(display_failure)) {
-        return false;
-    }
-
-    // always check motors
-    if (!motor_checks(display_failure)) {
-        return false;
-    }
-
-    // if we are using motor interlock switch and it's enabled, fail to arm
-    // skip check in Throw mode which takes control of the motor interlock
-    if (copter.ap.using_interlock && copter.motors->get_interlock()) {
-        gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Motor Interlock Enabled");
-        return false;
-    }
-
-    // if we are not using Emergency Stop switch option, force Estop false to ensure motors
-    // can run normally
-    if (!copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP)){
-        copter.set_motor_emergency_stop(false);
-        // if we are using motor Estop switch, it must not be in Estop position
-    } else if (copter.check_if_auxsw_mode_used(AUXSW_MOTOR_ESTOP) && copter.ap.motor_emergency_stop){
-        gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Motor Emergency Stopped");
-        return false;
-    }
-
-    // succeed if arming checks are disabled
-    if (checks_to_perform == ARMING_CHECK_NONE) {
-        return true;
-    }
-
-    // baro checks
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_BARO)) {
-        // baro health check
-        if (!barometer.all_healthy()) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Barometer not healthy");
-            }
-            return false;
-        }
-        // Check baro & inav alt are within 1m if EKF is operating in an absolute position mode.
-        // Do not check if intending to operate in a ground relative height mode as EKF will output a ground relative height
-        // that may differ from the baro height due to baro drift.
-        nav_filter_status filt_status = inertial_nav.get_filter_status();
-        bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);
-        if (using_baro_ref && (fabsf(inertial_nav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM)) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Altitude disparity");
-            }
-            return false;
-        }
-    }
-
-    #if AC_FENCE == ENABLED
-    // check vehicle is within fence
-    if (!copter.fence.pre_arm_check()) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: check fence");
-        }
-        return false;
-    }
-    #endif
-
-    // check lean angle
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
-        if (degrees(acosf(ahrs.cos_roll()*ahrs.cos_pitch()))*100.0f > copter.aparm.angle_max) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Leaning");
-            }
-            return false;
-        }
-    }
-
-    // check battery voltage
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_VOLTAGE)) {
-        if (copter.failsafe.battery || (!copter.ap.usb_connected && copter.battery.exhausted(copter.g.fs_batt_voltage, copter.g.fs_batt_mah))) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Check Battery");
-            }
-            return false;
-        }
-    }
-
-    // check for missing terrain data
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
-        if (!pre_arm_terrain_check(display_failure)) {
-            return false;
-        }
-    }
-
-    // check adsb
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_PARAMETERS)) {
-        if (copter.failsafe.adsb) {
-            if (display_failure) {
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: ADSB threat detected");
-            }
-            return false;
-        }
-    }
-
-    // check throttle
-    if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_RC)) {
-        // check throttle is not too low - must be above failsafe throttle
-        if (copter.g.failsafe_throttle != FS_THR_DISABLED && copter.channel_throttle->get_radio_in() < copter.g.failsafe_throttle_value) {
-            if (display_failure) {
-                #if FRAME_CONFIG == HELI_FRAME
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective below Failsafe");
-                #else
-                gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Throttle below Failsafe");
-                #endif
-            }
-            return false;
-        }
-
-        // check throttle is not too high - skips checks if arming from GCS in Guided
-        if (!(arming_from_gcs && (control_mode == GUIDED || control_mode == GUIDED_NOGPS))) {
-            // above top of deadband is too always high
-            if (copter.get_pilot_desired_climb_rate(copter.channel_throttle->get_control_in()) > 0.0f) {
-                if (display_failure) {
-                    #if FRAME_CONFIG == HELI_FRAME
-                    gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective too high");
-                    #else
-                    gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Throttle too high");
-                    #endif
-                }
-                return false;
-            }
-            // in manual modes throttle must be at zero
-            if ((copter.mode_has_manual_throttle(control_mode) || control_mode == DRIFT) && copter.channel_throttle->get_control_in() > 0) {
-                if (display_failure) {
-                    #if FRAME_CONFIG == HELI_FRAME
-                    gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Collective too high");
-                    #else
-                    gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Throttle too high");
-                    #endif
-                }
-                return false;
-            }
-        }
-    }
-
-    // check if safety switch has been pushed
-    if (hal.util->safety_switch_state() == AP_HAL::Util::SAFETY_DISARMED) {
-        if (display_failure) {
-            gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Safety Switch");
-        }
-        return false;
-    }
-
-    // if we've gotten this far all is ok
-    return true;
-}
-
-enum HomeState AP_Arming_Copter::home_status() const
-{
-    return copter.ap.home_state;
-}
-
-void AP_Arming_Copter::set_pre_arm_check(bool b)
-{
-    if(copter.ap.pre_arm_check != b) {
-        copter.ap.pre_arm_check = b;
-        AP_Notify::flags.pre_arm_check = b;
-    }
-}
-
-void AP_Arming_Copter::set_pre_arm_rc_check(bool b)
-{
-    if(copter.ap.pre_arm_rc_check != b) {
-        copter.ap.pre_arm_rc_check = b;
-    }
-}
-
-void AP_Arming_Copter::gcs_send_text(MAV_SEVERITY severity, const char *str)
-{
-    copter.gcs_send_text(severity, str);
-}
diff --git a/ArduCopter/arming_checks.h b/ArduCopter/arming_checks.h
deleted file mode 100644
index 863007e..0000000
--- a/ArduCopter/arming_checks.h
+++ /dev/null
@@ -1,58 +0,0 @@
-#pragma once
-
-#include <AP_Arming/AP_Arming.h>
-
-class AP_Arming_Copter : public AP_Arming
-{
-public:
-    AP_Arming_Copter(const AP_AHRS_NavEKF &ahrs_ref, const AP_Baro &baro, Compass &compass,
-                     const AP_BattMonitor &battery, const AP_InertialNav_NavEKF &inav,
-                     const AP_InertialSensor &ins) :
-        AP_Arming(ahrs_ref, baro, compass, battery),
-        inertial_nav(inav),
-        _ins(ins),
-        ahrs_navekf(ahrs_ref)
-        {
-    }
-
-    void update(void);
-    bool all_checks_passing(bool arming_from_gcs);
-    void pre_arm_rc_checks();
-
-protected:
-
-    bool pre_arm_checks(bool display_failure);
-    bool pre_arm_gps_checks(bool display_failure);
-    bool pre_arm_ekf_attitude_check();
-    bool pre_arm_terrain_check(bool display_failure);
-    bool pre_arm_proximity_check(bool display_failure);
-    bool arm_checks(bool display_failure, bool arming_from_gcs);
-
-    // NOTE! the following check functions *DO* call into AP_Arming:
-    bool ins_checks(bool display_failure) override;
-    bool compass_checks(bool display_failure) override;
-
-    // NOTE! the following check functions *DO NOT* call into AP_Arming!
-    bool gps_checks(bool display_failure);
-    bool fence_checks(bool display_failure);
-    bool board_voltage_checks(bool display_failure);
-    bool parameter_checks(bool display_failure);
-    bool motor_checks(bool display_failure);
-    bool pilot_throttle_checks(bool display_failure);
-    bool barometer_checks(bool display_failure);
-    bool rc_calibration_checks(bool display_failure);
-
-    void set_pre_arm_check(bool b);
-    void set_pre_arm_rc_check(bool b);
-
-    enum HomeState home_status() const override;
-
-private:
-
-    void gcs_send_text(MAV_SEVERITY severity, const char *str);
-
-    const AP_InertialNav_NavEKF &inertial_nav;
-    const AP_InertialSensor &_ins;
-    const AP_AHRS_NavEKF &ahrs_navekf;
-
-};

From f476c706f6111718962f41e523095c223812c1cb Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Thu, 29 Dec 2016 17:28:08 +0900
Subject: [PATCH 148/200] Copter: add override to
 AP_Arming_Copter::pre_arm_checks

---
 ArduCopter/AP_Arming.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ArduCopter/AP_Arming.h b/ArduCopter/AP_Arming.h
index 863007e..712e5c5 100644
--- a/ArduCopter/AP_Arming.h
+++ b/ArduCopter/AP_Arming.h
@@ -21,7 +21,7 @@ class AP_Arming_Copter : public AP_Arming
 
 protected:
 
-    bool pre_arm_checks(bool display_failure);
+    bool pre_arm_checks(bool display_failure) override;
     bool pre_arm_gps_checks(bool display_failure);
     bool pre_arm_ekf_attitude_check();
     bool pre_arm_terrain_check(bool display_failure);

From becc56da0be3c996eab982fb524eade2ad6ae926 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Fri, 30 Dec 2016 13:52:53 +0900
Subject: [PATCH 149/200] Copter: AP_Arming internal references start with
 underscore

---
 ArduCopter/AP_Arming.cpp | 20 +++++++++-----------
 ArduCopter/AP_Arming.h   |  8 ++++----
 2 files changed, 13 insertions(+), 15 deletions(-)

diff --git a/ArduCopter/AP_Arming.cpp b/ArduCopter/AP_Arming.cpp
index c1f6d00..2ae2cb4 100644
--- a/ArduCopter/AP_Arming.cpp
+++ b/ArduCopter/AP_Arming.cpp
@@ -113,10 +113,10 @@ bool AP_Arming_Copter::barometer_checks(bool display_failure)
         // Check baro & inav alt are within 1m if EKF is operating in an absolute position mode.
         // Do not check if intending to operate in a ground relative height mode as EKF will output a ground relative height
         // that may differ from the baro height due to baro drift.
-        nav_filter_status filt_status = inertial_nav.get_filter_status();
+        nav_filter_status filt_status = _inav.get_filter_status();
         bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);
         if (using_baro_ref) {
-            if (fabsf(inertial_nav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {
+            if (fabsf(_inav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM) {
                 if (display_failure) {
                     gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: Altitude disparity");
                 }
@@ -422,7 +422,7 @@ bool AP_Arming_Copter::pre_arm_gps_checks(bool display_failure)
     float vel_variance, pos_variance, hgt_variance, tas_variance;
     Vector3f mag_variance;
     Vector2f offset;
-    ahrs_navekf.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance, offset);
+    _ahrs_navekf.get_variances(vel_variance, pos_variance, hgt_variance, mag_variance, tas_variance, offset);
     if (mag_variance.length() >= copter.g.fs_ekf_thresh) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: EKF compass variance");
@@ -477,7 +477,7 @@ bool AP_Arming_Copter::pre_arm_gps_checks(bool display_failure)
 bool AP_Arming_Copter::pre_arm_ekf_attitude_check()
 {
     // get ekf filter status
-    nav_filter_status filt_status = inertial_nav.get_filter_status();
+    nav_filter_status filt_status = _inav.get_filter_status();
 
     return filt_status.flags.attitude;
 }
@@ -559,25 +559,23 @@ bool AP_Arming_Copter::arm_checks(bool display_failure, bool arming_from_gcs)
     copter.start_logging();
     #endif
 
-    const AP_InertialSensor &ins = _ins;
-
     // check accels and gyro are healthy
     if ((checks_to_perform == ARMING_CHECK_ALL) || (checks_to_perform & ARMING_CHECK_INS)) {
         //check if accelerometers have calibrated and require reboot
-        if (ins.accel_cal_requires_reboot()) {
+        if (_ins.accel_cal_requires_reboot()) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL, "PreArm: Accelerometers calibrated requires reboot");
             }
             return false;
         }
 
-        if (!ins.get_accel_health_all()) {
+        if (!_ins.get_accel_health_all()) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Accelerometers not healthy");
             }
             return false;
         }
-        if (!ins.get_gyro_health_all()) {
+        if (!_ins.get_gyro_health_all()) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Gyros not healthy");
             }
@@ -677,9 +675,9 @@ bool AP_Arming_Copter::arm_checks(bool display_failure, bool arming_from_gcs)
         // Check baro & inav alt are within 1m if EKF is operating in an absolute position mode.
         // Do not check if intending to operate in a ground relative height mode as EKF will output a ground relative height
         // that may differ from the baro height due to baro drift.
-        nav_filter_status filt_status = inertial_nav.get_filter_status();
+        nav_filter_status filt_status = _inav.get_filter_status();
         bool using_baro_ref = (!filt_status.flags.pred_horiz_pos_rel && filt_status.flags.pred_horiz_pos_abs);
-        if (using_baro_ref && (fabsf(inertial_nav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM)) {
+        if (using_baro_ref && (fabsf(_inav.get_altitude() - copter.baro_alt) > PREARM_MAX_ALT_DISPARITY_CM)) {
             if (display_failure) {
                 gcs_send_text(MAV_SEVERITY_CRITICAL,"Arm: Altitude disparity");
             }
diff --git a/ArduCopter/AP_Arming.h b/ArduCopter/AP_Arming.h
index 712e5c5..4f9cfbd 100644
--- a/ArduCopter/AP_Arming.h
+++ b/ArduCopter/AP_Arming.h
@@ -9,9 +9,9 @@ class AP_Arming_Copter : public AP_Arming
                      const AP_BattMonitor &battery, const AP_InertialNav_NavEKF &inav,
                      const AP_InertialSensor &ins) :
         AP_Arming(ahrs_ref, baro, compass, battery),
-        inertial_nav(inav),
+        _inav(inav),
         _ins(ins),
-        ahrs_navekf(ahrs_ref)
+        _ahrs_navekf(ahrs_ref)
         {
     }
 
@@ -51,8 +51,8 @@ class AP_Arming_Copter : public AP_Arming
 
     void gcs_send_text(MAV_SEVERITY severity, const char *str);
 
-    const AP_InertialNav_NavEKF &inertial_nav;
+    const AP_InertialNav_NavEKF &_inav;
     const AP_InertialSensor &_ins;
-    const AP_AHRS_NavEKF &ahrs_navekf;
+    const AP_AHRS_NavEKF &_ahrs_navekf;
 
 };

From c6d2fc3d5d98b093b1e8b5724bba681862519159 Mon Sep 17 00:00:00 2001
From: Leonard Hall <leonardthall@gmail.com>
Date: Wed, 4 Jan 2017 15:49:00 +1030
Subject: [PATCH 150/200] AC_AttitudeControl: add rpy mix manual

This allows adjusting the attitude control vs throttle level in manual
flight modes (Stabilize, ACRO)
---
 libraries/AC_AttitudeControl/AC_AttitudeControl.h  |  7 +++---
 .../AC_AttitudeControl_Multi.cpp                   | 27 +++++++++++++++++++---
 .../AC_AttitudeControl/AC_AttitudeControl_Multi.h  |  3 ++-
 3 files changed, 30 insertions(+), 7 deletions(-)

diff --git a/libraries/AC_AttitudeControl/AC_AttitudeControl.h b/libraries/AC_AttitudeControl/AC_AttitudeControl.h
index 96781db..8332f82 100644
--- a/libraries/AC_AttitudeControl/AC_AttitudeControl.h
+++ b/libraries/AC_AttitudeControl/AC_AttitudeControl.h
@@ -35,9 +35,10 @@
 #define AC_ATTITUDE_CONTROL_ANGLE_LIMIT_TC_DEFAULT      1.0f    // Time constant used to limit lean angle so that vehicle does not lose altitude
 #define AC_ATTITUDE_CONTROL_ANGLE_LIMIT_THROTTLE_MAX    0.8f    // Max throttle used to limit lean angle so that vehicle does not lose altitude
 
-#define AC_ATTITUDE_CONTROL_MIN_DEFAULT                 0.1f    // minimum throttle mix
-#define AC_ATTITUDE_CONTROL_MID_DEFAULT                 0.5f    // manual throttle mix
+#define AC_ATTITUDE_CONTROL_MIN_DEFAULT                 0.1f    // minimum throttle mix default
+#define AC_ATTITUDE_CONTROL_MAN_DEFAULT                 0.5f    // manual throttle mix default
 #define AC_ATTITUDE_CONTROL_MAX_DEFAULT                 0.5f    // maximum throttle mix default
+#define AC_ATTITUDE_CONTROL_MAX                         5.0f    // maximum throttle mix default
 
 #define AC_ATTITUDE_CONTROL_THR_MIX_DEFAULT             0.5f  // ratio controlling the max throttle output during competing requests of low throttle from the pilot (or autopilot) and higher throttle for attitude control.  Higher favours Attitude over pilot input
 
@@ -243,7 +244,7 @@ class AC_AttitudeControl {
 
     // control rpy throttle mix
     virtual void set_throttle_mix_min() {}
-    virtual void set_throttle_mix_mid() {}
+    virtual void set_throttle_mix_man() {}
     virtual void set_throttle_mix_max() {}
 
     // enable use of flybass passthrough on heli
diff --git a/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp b/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp
index 7dd702e..331b41c 100644
--- a/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp
+++ b/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp
@@ -135,6 +135,13 @@ const AP_Param::GroupInfo AC_AttitudeControl_Multi::var_info[] = {
     // @User: Advanced
     AP_GROUPINFO("THR_MIX_MAX", 5, AC_AttitudeControl_Multi, _thr_mix_max, AC_ATTITUDE_CONTROL_MAX_DEFAULT),
 
+    // @Param: THR_MIX_MAN
+    // @DisplayName: Throttle Mix Manual
+    // @Description: Throttle vs attitude control prioritisation used during manual flight (higher values mean we prioritise attitude control over throttle)
+    // @Range: 0.5 0.9
+    // @User: Advanced
+    AP_GROUPINFO("THR_MIX_MAN", 6, AC_AttitudeControl_Multi, _thr_mix_man, AC_ATTITUDE_CONTROL_MAN_DEFAULT),
+
     AP_GROUPEND
 };
 
@@ -219,7 +226,7 @@ void AC_AttitudeControl_Multi::update_throttle_rpy_mix()
         // reduce more slowly (from 0.9 to 0.1 in 1.6 seconds)
         _throttle_rpy_mix -= MIN(0.5f*_dt, _throttle_rpy_mix-_throttle_rpy_mix_desired);
     }
-    _throttle_rpy_mix = constrain_float(_throttle_rpy_mix, 0.1f, 1.0f);
+    _throttle_rpy_mix = constrain_float(_throttle_rpy_mix, 0.1f, AC_ATTITUDE_CONTROL_MAX);
 }
 
 void AC_AttitudeControl_Multi::rate_controller_run()
@@ -238,12 +245,26 @@ void AC_AttitudeControl_Multi::rate_controller_run()
 void AC_AttitudeControl_Multi::parameter_sanity_check()
 {
     // sanity check throttle mix parameters
+    if (_thr_mix_man < 0.1f || _thr_mix_man > 4.0f) {
+        // parameter description recommends thr-mix-man be no higher than 0.9 but we allow up to 4.0
+        // which can be useful for very high powered copters with very low hover throttle
+        _thr_mix_man = AC_ATTITUDE_CONTROL_MAN_DEFAULT;
+        _thr_mix_man.set_and_save(AC_ATTITUDE_CONTROL_MAN_DEFAULT);
+    }
     if (_thr_mix_min < 0.1f || _thr_mix_min > 0.25f) {
         _thr_mix_min = AC_ATTITUDE_CONTROL_MIN_DEFAULT;
+        _thr_mix_min.set_and_save(AC_ATTITUDE_CONTROL_MIN_DEFAULT);
     }
-    if (_thr_mix_max < 0.5f || _thr_mix_max > 2.0f) {
-        // parameter description recommends thr-mix-max be no higher than 0.9 but we allow up to 2.0
+    if (_thr_mix_max < 0.5f || _thr_mix_max > AC_ATTITUDE_CONTROL_MAX) {
+        // parameter description recommends thr-mix-max be no higher than 0.9 but we allow up to 5.0
         // which can be useful for very high powered copters with very low hover throttle
         _thr_mix_max = AC_ATTITUDE_CONTROL_MAX_DEFAULT;
+        _thr_mix_max.set_and_save(AC_ATTITUDE_CONTROL_MAX_DEFAULT);
+    }
+    if (_thr_mix_min > _thr_mix_max) {
+        _thr_mix_min = AC_ATTITUDE_CONTROL_MIN_DEFAULT;
+        _thr_mix_min.set_and_save(AC_ATTITUDE_CONTROL_MIN_DEFAULT);
+        _thr_mix_max = AC_ATTITUDE_CONTROL_MAX_DEFAULT;
+        _thr_mix_max.set_and_save(AC_ATTITUDE_CONTROL_MAX_DEFAULT);
     }
 }
diff --git a/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.h b/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.h
index 18c3977..3935cfa 100644
--- a/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.h
+++ b/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.h
@@ -64,7 +64,7 @@ class AC_AttitudeControl_Multi : public AC_AttitudeControl {
     //  low values favour pilot/autopilot throttle over attitude control, high values favour attitude control over throttle
     //  has no effect when throttle is above hover throttle
     void set_throttle_mix_min() override { _throttle_rpy_mix_desired = _thr_mix_min; }
-    void set_throttle_mix_mid() override { _throttle_rpy_mix_desired = AC_ATTITUDE_CONTROL_MID_DEFAULT; }
+    void set_throttle_mix_man() override { _throttle_rpy_mix_desired = _thr_mix_man; }
     void set_throttle_mix_max() override { _throttle_rpy_mix_desired = _thr_mix_max; }
 
     // are we producing min throttle?
@@ -92,6 +92,7 @@ class AC_AttitudeControl_Multi : public AC_AttitudeControl {
     AC_PID                _pid_rate_pitch;
     AC_PID                _pid_rate_yaw;
 
+    AP_Float              _thr_mix_man;     // throttle vs attitude control prioritisation used when using manual throttle (higher values mean we prioritise attitude control over throttle)
     AP_Float              _thr_mix_min;     // throttle vs attitude control prioritisation used when landing (higher values mean we prioritise attitude control over throttle)
     AP_Float              _thr_mix_max;     // throttle vs attitude control prioritisation used during active flight (higher values mean we prioritise attitude control over throttle)
 };

From 36b6218e31f6a4ecba783320f70a0d37bf88680a Mon Sep 17 00:00:00 2001
From: Leonard Hall <leonardthall@gmail.com>
Date: Wed, 4 Jan 2017 15:49:09 +1030
Subject: [PATCH 151/200] Copter: integrate attitude control's
 set-throttle-mix-manual

---
 ArduCopter/land_detector.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ArduCopter/land_detector.cpp b/ArduCopter/land_detector.cpp
index d13edc4..b1e3694 100644
--- a/ArduCopter/land_detector.cpp
+++ b/ArduCopter/land_detector.cpp
@@ -145,7 +145,7 @@ void Copter::update_throttle_thr_mix()
         if(channel_throttle->get_control_in() <= 0) {
             attitude_control->set_throttle_mix_min();
         } else {
-            attitude_control->set_throttle_mix_mid();
+            attitude_control->set_throttle_mix_man();
         }
     } else {
         // autopilot controlled throttle

From 189b766f2b6a5551f75913fda57df16c4342fa7f Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Tue, 17 Jan 2017 14:55:43 +0900
Subject: [PATCH 152/200] AC_AttControl: remove redundant parameter set

---
 libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp b/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp
index 331b41c..13f1337 100644
--- a/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp
+++ b/libraries/AC_AttitudeControl/AC_AttitudeControl_Multi.cpp
@@ -248,23 +248,18 @@ void AC_AttitudeControl_Multi::parameter_sanity_check()
     if (_thr_mix_man < 0.1f || _thr_mix_man > 4.0f) {
         // parameter description recommends thr-mix-man be no higher than 0.9 but we allow up to 4.0
         // which can be useful for very high powered copters with very low hover throttle
-        _thr_mix_man = AC_ATTITUDE_CONTROL_MAN_DEFAULT;
         _thr_mix_man.set_and_save(AC_ATTITUDE_CONTROL_MAN_DEFAULT);
     }
     if (_thr_mix_min < 0.1f || _thr_mix_min > 0.25f) {
-        _thr_mix_min = AC_ATTITUDE_CONTROL_MIN_DEFAULT;
         _thr_mix_min.set_and_save(AC_ATTITUDE_CONTROL_MIN_DEFAULT);
     }
     if (_thr_mix_max < 0.5f || _thr_mix_max > AC_ATTITUDE_CONTROL_MAX) {
         // parameter description recommends thr-mix-max be no higher than 0.9 but we allow up to 5.0
         // which can be useful for very high powered copters with very low hover throttle
-        _thr_mix_max = AC_ATTITUDE_CONTROL_MAX_DEFAULT;
         _thr_mix_max.set_and_save(AC_ATTITUDE_CONTROL_MAX_DEFAULT);
     }
     if (_thr_mix_min > _thr_mix_max) {
-        _thr_mix_min = AC_ATTITUDE_CONTROL_MIN_DEFAULT;
         _thr_mix_min.set_and_save(AC_ATTITUDE_CONTROL_MIN_DEFAULT);
-        _thr_mix_max = AC_ATTITUDE_CONTROL_MAX_DEFAULT;
         _thr_mix_max.set_and_save(AC_ATTITUDE_CONTROL_MAX_DEFAULT);
     }
 }

From e627bbc912cdd4671fa14f62de0512e8027acc35 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Tue, 17 Jan 2017 10:26:06 +0100
Subject: [PATCH 153/200] AP_HAL: Board fix typo for baro BMP280_SPI

---
 libraries/AP_HAL/AP_HAL_Boards.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_HAL/AP_HAL_Boards.h b/libraries/AP_HAL/AP_HAL_Boards.h
index 17db628..66f246e 100644
--- a/libraries/AP_HAL/AP_HAL_Boards.h
+++ b/libraries/AP_HAL/AP_HAL_Boards.h
@@ -82,7 +82,7 @@
 #define HAL_BARO_QFLIGHT     9
 #define HAL_BARO_QURT       10
 #define HAL_BARO_BMP280_I2C 11
-#define HAL_BARA_BMP280_SPI 12
+#define HAL_BARO_BMP280_SPI 12
 
 /* Compass driver types */
 #define HAL_COMPASS_HMC5843             1

From 8a1f4e048f2e574c0b2773dff67694696202c72c Mon Sep 17 00:00:00 2001
From: Julien Beraud <julien.beraud@parrot.com>
Date: Mon, 16 Jan 2017 15:45:53 +0100
Subject: [PATCH 154/200] RangeFinder_Bebop: fix spi speed

Set spi speed. Else 0 will be sent at each transfer.
---
 libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp b/libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp
index 81947f8..9827e43 100644
--- a/libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp
+++ b/libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp
@@ -327,6 +327,7 @@ void AP_RangeFinder_Bebop::_reconfigure_wave()
  */
 int AP_RangeFinder_Bebop::_configure_wave()
 {
+    _spi->set_speed(AP_HAL::Device::SPEED_HIGH);
     _configure_gpio(0);
     return 0;
 }

From b561837b41d1edd031eb05eef1d3ca66541f0380 Mon Sep 17 00:00:00 2001
From: Julien Beraud <julien.beraud@parrot.com>
Date: Mon, 16 Jan 2017 19:39:02 +0100
Subject: [PATCH 155/200] RangeFinder_Bebop: Fix mode selection

mistakes in selecting mode
---
 libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp b/libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp
index 9827e43..b5c76a5 100644
--- a/libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp
+++ b/libraries/AP_RangeFinder/AP_RangeFinder_Bebop.cpp
@@ -253,8 +253,8 @@ void AP_RangeFinder_Bebop::_loop(void)
         if (max_index >= 0) {
             _altitude = (float)(max_index * RNFD_BEBOP_SOUND_SPEED) /
                 (2 * (RNFD_BEBOP_DEFAULT_ADC_FREQ / _filter_average));
-            _mode = _update_mode(_altitude);
         }
+        _mode = _update_mode(_altitude);
     }
 }
 
@@ -309,6 +309,7 @@ void AP_RangeFinder_Bebop::_reconfigure_wave()
     if (_capture() < 0)
         hal.console->printf("purge could not capture data");
 
+    _tx_buf = _tx[_mode];
     switch (_mode) {
     case 1: /* low voltage */
         _configure_gpio(0);
@@ -450,7 +451,7 @@ int AP_RangeFinder_Bebop::_update_mode(float altitude)
     default:
     case 1:
         if (altitude > RNFD_BEBOP_TRANSITION_LOW_TO_HIGH
-                || !is_zero(altitude)) {
+                || is_zero(altitude)) {
             if (_hysteresis_counter > RNFD_BEBOP_TRANSITION_COUNT) {
                 _mode = 0;
                 _hysteresis_counter = 0;

From e9a0e988633f10bb3999247121552e8ee39502d1 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Thu, 20 Oct 2016 12:02:35 +1100
Subject: [PATCH 156/200] AP_HAL_SITL: use fabs on double values

---
 libraries/AP_HAL_SITL/sitl_ins.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_HAL_SITL/sitl_ins.cpp b/libraries/AP_HAL_SITL/sitl_ins.cpp
index f76ef3d..2a6383e 100644
--- a/libraries/AP_HAL_SITL/sitl_ins.cpp
+++ b/libraries/AP_HAL_SITL/sitl_ins.cpp
@@ -103,8 +103,8 @@ uint16_t SITL_State::_ground_sonar(void)
     }
 
     float voltage = 5.0f;
-    if (fabsf(_sitl->state.rollDeg) < 90 &&
-            fabsf(_sitl->state.pitchDeg) < 90) {
+    if (fabs(_sitl->state.rollDeg) < 90 &&
+        fabs(_sitl->state.pitchDeg) < 90) {
         // adjust for apparent altitude with roll
         altitude /= cosf(radians(_sitl->state.rollDeg)) * cosf(radians(_sitl->state.pitchDeg));
 

From 96d73affaef3c61e6692d341b1bcddbc0e8a6cd6 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Thu, 20 Oct 2016 12:15:55 +1100
Subject: [PATCH 157/200] Copter: fix float warning; get_velocity_z() returns
 float

---
 ArduCopter/baro_ground_effect.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ArduCopter/baro_ground_effect.cpp b/ArduCopter/baro_ground_effect.cpp
index 313c120..2c3764e 100644
--- a/ArduCopter/baro_ground_effect.cpp
+++ b/ArduCopter/baro_ground_effect.cpp
@@ -58,7 +58,7 @@ void Copter::update_ground_effect_detector(void)
 
     bool descent_demanded = pos_control->is_active_z() && des_climb_rate_cms < 0.0f;
     bool slow_descent_demanded = descent_demanded && des_climb_rate_cms >= -100.0f;
-    bool z_speed_low = abs(inertial_nav.get_velocity_z()) <= 60.0f;
+    bool z_speed_low = fabsf(inertial_nav.get_velocity_z()) <= 60.0f;
     bool slow_descent = (slow_descent_demanded || (z_speed_low && descent_demanded));
 
     gndeffect_state.touchdown_expected = slow_horizontal && slow_descent;

From cc86011d20708d59f66689e332d12f484729a9e4 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Thu, 20 Oct 2016 13:30:55 +1100
Subject: [PATCH 158/200] Copter: use abs() on integers; Location alts are in
 integer cm

---
 ArduCopter/control_rtl.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ArduCopter/control_rtl.cpp b/ArduCopter/control_rtl.cpp
index 650b922..8703ec7 100644
--- a/ArduCopter/control_rtl.cpp
+++ b/ArduCopter/control_rtl.cpp
@@ -335,7 +335,7 @@ void Copter::rtl_descent_run()
     attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
 
     // check if we've reached within 20cm of final altitude
-    rtl_state_complete = fabsf(rtl_path.descent_target.alt - current_loc.alt) < 20.0f;
+    rtl_state_complete = abs(rtl_path.descent_target.alt - current_loc.alt) < 20;
 }
 
 // rtl_loiterathome_start - initialise controllers to loiter over home

From 8b38ce666dd69b4cff1b8096265fc49e6fe74252 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Thu, 20 Oct 2016 13:35:57 +1100
Subject: [PATCH 159/200] SITL: SIM_XPlane: fix fabsf/abs warning; location
 alts are in integer cm

---
 libraries/SITL/SIM_XPlane.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/SITL/SIM_XPlane.cpp b/libraries/SITL/SIM_XPlane.cpp
index 51c9cba..71b5dbe 100644
--- a/libraries/SITL/SIM_XPlane.cpp
+++ b/libraries/SITL/SIM_XPlane.cpp
@@ -302,7 +302,7 @@ bool XPlane::receive_data(void)
     accel_earth.z += GRAVITY_MSS;
     
     // the position may slowly deviate due to float accuracy and longitude scaling
-    if (get_distance(loc, location) > 4 || fabsf(loc.alt - location.alt)*0.01 > 2) {
+    if (get_distance(loc, location) > 4 || abs(loc.alt - location.alt)*0.01f > 2.0f) {
         printf("X-Plane home reset dist=%f alt=%.1f/%.1f\n",
                get_distance(loc, location), loc.alt*0.01f, location.alt*0.01f);
         // reset home location

From e903cb99453d0e5d5ddc84f2d3e32ca1823ca550 Mon Sep 17 00:00:00 2001
From: murata <ma2maru@gmail.com>
Date: Sun, 1 Jan 2017 15:28:53 +0900
Subject: [PATCH 160/200] AP_Math: Change mask value to hexadecimal number.

---
 libraries/AP_Math/AP_Math.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_Math/AP_Math.cpp b/libraries/AP_Math/AP_Math.cpp
index c68c749..c0289c6 100644
--- a/libraries/AP_Math/AP_Math.cpp
+++ b/libraries/AP_Math/AP_Math.cpp
@@ -190,8 +190,8 @@ uint16_t get_random16(void)
 {
     static uint32_t m_z = 1234;
     static uint32_t m_w = 76542;
-    m_z = 36969 * (m_z & 65535) + (m_z >> 16);
-    m_w = 18000 * (m_w & 65535) + (m_w >> 16);
+    m_z = 36969 * (m_z & 0xFFFFu) + (m_z >> 16);
+    m_w = 18000 * (m_w & 0xFFFFu) + (m_w >> 16);
     return ((m_z << 16) + m_w) & 0xFFFF;
 }
 

From d2431dafd045b91a79b07fa327819b8d26060e9a Mon Sep 17 00:00:00 2001
From: mirkix <mirkix@gmail.com>
Date: Tue, 17 Jan 2017 19:35:08 +0100
Subject: [PATCH 161/200] AP_AHRS: fix description

---
 libraries/AP_AHRS/AP_AHRS.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_AHRS/AP_AHRS.cpp b/libraries/AP_AHRS/AP_AHRS.cpp
index a450f8c..0d74567 100644
--- a/libraries/AP_AHRS/AP_AHRS.cpp
+++ b/libraries/AP_AHRS/AP_AHRS.cpp
@@ -24,7 +24,7 @@ const AP_Param::GroupInfo AP_AHRS::var_info[] = {
 
     // @Param: GPS_GAIN
     // @DisplayName: AHRS GPS gain
-    // @Description: This controls how how much to use the GPS to correct the attitude. This should never be set to zero for a plane as it would result in the plane losing control in turns. For a plane please use the default value of 1.0.
+    // @Description: This controls how much to use the GPS to correct the attitude. This should never be set to zero for a plane as it would result in the plane losing control in turns. For a plane please use the default value of 1.0.
     // @Range: 0.0 1.0
     // @Increment: .01
     // @User: Advanced

From e7ba2420c184ec46dd27d6ff6288b1480dca7f49 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 16 Jan 2017 13:48:28 +0900
Subject: [PATCH 162/200] AP_InertialNav: expose get_hgt_ctrl_limit to parent
 class

---
 libraries/AP_InertialNav/AP_InertialNav.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/libraries/AP_InertialNav/AP_InertialNav.h b/libraries/AP_InertialNav/AP_InertialNav.h
index afcdc62..d34457c 100644
--- a/libraries/AP_InertialNav/AP_InertialNav.h
+++ b/libraries/AP_InertialNav/AP_InertialNav.h
@@ -105,6 +105,14 @@ class AP_InertialNav
     virtual float       get_altitude() const = 0;
 
     /**
+     * get_hgt_ctrl_limit - get maximum height to be observed by the control loops in cm and a validity flag
+     * this is used to limit height during optical flow navigation
+     * it will return invalid when no limiting is required
+     * @return
+     */
+    virtual bool       get_hgt_ctrl_limit(float& limit) const = 0;
+
+    /**
      * get_velocity_z - returns the current climbrate.
      *
      * @see get_velocity().z

From a47e215a8e7bec295874feaf402396b32d7bcced Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 16 Jan 2017 15:58:14 +0900
Subject: [PATCH 163/200] AP_Proximity: add get_upward_distance

This allow support for upward facing proximity sensor received through a DISTANCE_SENSOR message.
Also added SITL test
---
 libraries/AP_Proximity/AP_Proximity.cpp       | 15 +++++++++++++++
 libraries/AP_Proximity/AP_Proximity.h         |  8 ++++++++
 libraries/AP_Proximity/AP_Proximity_Backend.h |  3 +++
 libraries/AP_Proximity/AP_Proximity_MAV.cpp   | 16 ++++++++++++++++
 libraries/AP_Proximity/AP_Proximity_MAV.h     |  8 ++++++++
 libraries/AP_Proximity/AP_Proximity_SITL.cpp  | 12 ++++++++++++
 libraries/AP_Proximity/AP_Proximity_SITL.h    |  4 ++++
 7 files changed, 66 insertions(+)

diff --git a/libraries/AP_Proximity/AP_Proximity.cpp b/libraries/AP_Proximity/AP_Proximity.cpp
index 38966a9..fbd8c7f 100644
--- a/libraries/AP_Proximity/AP_Proximity.cpp
+++ b/libraries/AP_Proximity/AP_Proximity.cpp
@@ -385,3 +385,18 @@ float AP_Proximity::distance_min() const
     // get minimum distance from backend
     return drivers[primary_instance]->distance_min();
 }
+
+// get distance in meters upwards, returns true on success
+bool AP_Proximity::get_upward_distance(uint8_t instance, float &distance) const
+{
+    if ((drivers[instance] == nullptr) || (_type[instance] == Proximity_Type_None)) {
+        return false;
+    }
+    // get upward distance from backend
+    return drivers[instance]->get_upward_distance(distance);
+}
+
+bool AP_Proximity::get_upward_distance(float &distance) const
+{
+    return get_upward_distance(primary_instance, distance);
+}
diff --git a/libraries/AP_Proximity/AP_Proximity.h b/libraries/AP_Proximity/AP_Proximity.h
index 1908edd..77171f5 100644
--- a/libraries/AP_Proximity/AP_Proximity.h
+++ b/libraries/AP_Proximity/AP_Proximity.h
@@ -107,6 +107,14 @@ class AP_Proximity
         enum Proximity_Status   status;     // sensor status
     };
 
+    //
+    // support for upwardward facing sensors
+    //
+
+    // get distance upwards in meters. returns true on success
+    bool get_upward_distance(uint8_t instance, float &distance) const;
+    bool get_upward_distance(float &distance) const;
+
     // parameter list
     static const struct AP_Param::GroupInfo var_info[];
 
diff --git a/libraries/AP_Proximity/AP_Proximity_Backend.h b/libraries/AP_Proximity/AP_Proximity_Backend.h
index 2410232..f8b50e8 100644
--- a/libraries/AP_Proximity/AP_Proximity_Backend.h
+++ b/libraries/AP_Proximity/AP_Proximity_Backend.h
@@ -39,6 +39,9 @@ class AP_Proximity_Backend
     virtual float distance_max() const = 0;
     virtual float distance_min() const = 0;
 
+    // get distance upwards in meters. returns true on success
+    virtual bool get_upward_distance(float &distance) const { return false; }
+
     // handle mavlink DISTANCE_SENSOR messages
     virtual void handle_msg(mavlink_message_t *msg) {}
 
diff --git a/libraries/AP_Proximity/AP_Proximity_MAV.cpp b/libraries/AP_Proximity/AP_Proximity_MAV.cpp
index 19fef8c..27a1aa2 100644
--- a/libraries/AP_Proximity/AP_Proximity_MAV.cpp
+++ b/libraries/AP_Proximity/AP_Proximity_MAV.cpp
@@ -43,6 +43,16 @@ void AP_Proximity_MAV::update(void)
     }
 }
 
+// get distance upwards in meters. returns true on success
+bool AP_Proximity_MAV::get_upward_distance(float &distance) const
+{
+    if ((_last_upward_update_ms != 0) && (AP_HAL::millis() - _last_upward_update_ms <= PROXIMITY_MAV_TIMEOUT_MS)) {
+        distance = _distance_upward;
+        return true;
+    }
+    return false;
+}
+
 // handle mavlink DISTANCE_SENSOR messages
 void AP_Proximity_MAV::handle_msg(mavlink_message_t *msg)
 {
@@ -60,4 +70,10 @@ void AP_Proximity_MAV::handle_msg(mavlink_message_t *msg)
         _last_update_ms = AP_HAL::millis();
         update_boundary_for_sector(sector);
     }
+
+    // store upward distance
+    if (packet.orientation == MAV_SENSOR_ROTATION_PITCH_90) {
+        _distance_upward = packet.current_distance / 100.0f;
+        _last_upward_update_ms = AP_HAL::millis();
+    }
 }
diff --git a/libraries/AP_Proximity/AP_Proximity_MAV.h b/libraries/AP_Proximity/AP_Proximity_MAV.h
index d898b54..6e75f7c 100644
--- a/libraries/AP_Proximity/AP_Proximity_MAV.h
+++ b/libraries/AP_Proximity/AP_Proximity_MAV.h
@@ -19,6 +19,9 @@ class AP_Proximity_MAV : public AP_Proximity_Backend
     float distance_max() const { return _distance_max; }
     float distance_min() const { return _distance_min; };
 
+    // get distance upwards in meters. returns true on success
+    bool get_upward_distance(float &distance) const;
+
     // handle mavlink DISTANCE_SENSOR messages
     void handle_msg(mavlink_message_t *msg) override;
 
@@ -27,7 +30,12 @@ class AP_Proximity_MAV : public AP_Proximity_Backend
     // initialise sensor (returns true if sensor is succesfully initialised)
     bool initialise();
 
+    // horizontal distance support
     uint32_t _last_update_ms;   // system time of last DISTANCE_SENSOR message received
     float _distance_max;        // max range of sensor in meters
     float _distance_min;        // min range of sensor in meters
+
+    // upward distance support
+    uint32_t _last_upward_update_ms;    // system time of last update distance
+    float _distance_upward;             // upward distance in meters
 };
diff --git a/libraries/AP_Proximity/AP_Proximity_SITL.cpp b/libraries/AP_Proximity/AP_Proximity_SITL.cpp
index 7289b4f..acf3747 100644
--- a/libraries/AP_Proximity/AP_Proximity_SITL.cpp
+++ b/libraries/AP_Proximity/AP_Proximity_SITL.cpp
@@ -38,6 +38,10 @@ AP_Proximity_SITL::AP_Proximity_SITL(AP_Proximity &_frontend,
     if (fence_count == nullptr || ptype != AP_PARAM_INT8) {
         AP_HAL::panic("Proximity_SITL: Failed to find FENCE_TOTAL");
     }
+    fence_alt_max = (AP_Float *)AP_Param::find("FENCE_ALT_MAX", &ptype);
+    if (fence_alt_max == nullptr || ptype != AP_PARAM_FLOAT) {
+        AP_HAL::panic("Proximity_SITL: Failed to find FENCE_ALT_MAX");
+    }
 }
 
 // update the state of the sensor
@@ -125,4 +129,12 @@ float AP_Proximity_SITL::distance_min() const
     return 0.0f;
 }
 
+// get distance upwards in meters. returns true on success
+bool AP_Proximity_SITL::get_upward_distance(float &distance) const
+{
+    // return distance to fence altitude
+    distance = MAX(0.0f, fence_alt_max->get() - sitl->height_agl);
+    return true;
+}
+
 #endif // CONFIG_HAL_BOARD
diff --git a/libraries/AP_Proximity/AP_Proximity_SITL.h b/libraries/AP_Proximity/AP_Proximity_SITL.h
index 81da426..dd20a2a 100644
--- a/libraries/AP_Proximity/AP_Proximity_SITL.h
+++ b/libraries/AP_Proximity/AP_Proximity_SITL.h
@@ -20,10 +20,14 @@ class AP_Proximity_SITL : public AP_Proximity_Backend
     float distance_max() const;
     float distance_min() const;
 
+    // get distance upwards in meters. returns true on success
+    bool get_upward_distance(float &distance) const;
+
 private:
     SITL::SITL *sitl;
     Vector2l *fence;
     AP_Int8 *fence_count;
+    AP_Float *fence_alt_max;
     uint32_t last_load_ms;
     AC_PolyFence_loader fence_loader;
     Location current_loc;

From 12dd6e11fb4038c3644f5168baa91e0b6d656152 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Thu, 5 Jan 2017 15:19:47 +0900
Subject: [PATCH 164/200] AC_Avoidance: constify get_position

---
 libraries/AC_Avoidance/AC_Avoid.cpp | 2 +-
 libraries/AC_Avoidance/AC_Avoid.h   | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/AC_Avoidance/AC_Avoid.cpp b/libraries/AC_Avoidance/AC_Avoid.cpp
index 7bd9b8a..a3d6e5a 100644
--- a/libraries/AC_Avoidance/AC_Avoid.cpp
+++ b/libraries/AC_Avoidance/AC_Avoid.cpp
@@ -289,7 +289,7 @@ void AC_Avoid::limit_velocity(float kP, float accel_cmss, Vector2f &desired_vel,
 /*
  * Gets the current xy-position, relative to home (not relative to EKF origin)
  */
-Vector2f AC_Avoid::get_position()
+Vector2f AC_Avoid::get_position() const
 {
     const Vector3f position_xyz = _inav.get_position();
     const Vector2f position_xy(position_xyz.x,position_xyz.y);
diff --git a/libraries/AC_Avoidance/AC_Avoid.h b/libraries/AC_Avoidance/AC_Avoid.h
index 4590280..087b313 100644
--- a/libraries/AC_Avoidance/AC_Avoid.h
+++ b/libraries/AC_Avoidance/AC_Avoid.h
@@ -85,7 +85,7 @@ class AC_Avoid {
     /*
      * Gets the current position, relative to home (not relative to EKF origin)
      */
-    Vector2f get_position();
+    Vector2f get_position() const;
 
     /*
      * Computes the speed such that the stopping distance

From f73efd5249648eb0bd1f66179a1fd2b7ab3af449 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Thu, 5 Jan 2017 15:21:55 +0900
Subject: [PATCH 165/200] AC_Avoidance: add adjust_velocity_z

This allows reducing the climb rate to slow the vehicle's climb so it does not breach the altitude fence
---
 libraries/AC_Avoidance/AC_Avoid.cpp | 44 +++++++++++++++++++++++++++++++++++++
 libraries/AC_Avoidance/AC_Avoid.h   |  6 ++++-
 2 files changed, 49 insertions(+), 1 deletion(-)

diff --git a/libraries/AC_Avoidance/AC_Avoid.cpp b/libraries/AC_Avoidance/AC_Avoid.cpp
index a3d6e5a..1346296 100644
--- a/libraries/AC_Avoidance/AC_Avoid.cpp
+++ b/libraries/AC_Avoidance/AC_Avoid.cpp
@@ -67,6 +67,41 @@ void AC_Avoid::adjust_velocity(float kP, float accel_cmss, Vector3f &desired_vel
     desired_vel.y = des_vel_xy.y;
 }
 
+// adjust vertical climb rate so vehicle does not break the vertical fence
+void AC_Avoid::adjust_velocity_z(float kP, float accel_cmss, float& climb_rate_cms)
+{
+    // exit immediately if disabled
+    if (_enabled == AC_AVOID_DISABLED) {
+        return;
+    }
+
+    // do not adjust climb_rate if level or descending
+    if (climb_rate_cms <= 0.0f) {
+        return;
+    }
+
+    // limit acceleration
+    float accel_cmss_limited = MIN(accel_cmss, AC_AVOID_ACCEL_CMSS_MAX);
+
+    // stop before breaching fence altitude
+    if ((_enabled & AC_AVOID_STOP_AT_FENCE) > 0) {
+
+        // calculate distance from vehicle to safe altitude
+        float veh_alt = get_alt_above_home();
+        float alt_diff_cm = _fence.get_safe_alt() * 100.0f - veh_alt;
+
+        // do not allow climbing if we've breached the safe altitude
+        if (alt_diff_cm <= 0.0f) {
+            climb_rate_cms = MIN(climb_rate_cms, 0.0f);
+            return;
+        }
+
+        // limit climb rate
+        const float max_speed = get_max_speed(kP, accel_cmss_limited, alt_diff_cm);
+        climb_rate_cms = MIN(max_speed, climb_rate_cms);
+    }
+}
+
 // adjust roll-pitch to push vehicle away from objects
 // roll and pitch value are in centi-degrees
 void AC_Avoid::adjust_roll_pitch(float &roll, float &pitch, float veh_angle_max)
@@ -298,6 +333,15 @@ Vector2f AC_Avoid::get_position() const
 }
 
 /*
+ * Gets the altitude above home in cm
+ */
+float AC_Avoid::get_alt_above_home() const
+{
+    // vehicle's alt above ekf origin + ekf origin's alt above sea level - home's alt above sea level
+    return _inav.get_altitude() + _inav.get_origin().alt - _ahrs.get_home().alt;
+}
+
+/*
  * Computes the speed such that the stopping distance
  * of the vehicle will be exactly the input distance.
  */
diff --git a/libraries/AC_Avoidance/AC_Avoid.h b/libraries/AC_Avoidance/AC_Avoid.h
index 087b313..610b442 100644
--- a/libraries/AC_Avoidance/AC_Avoid.h
+++ b/libraries/AC_Avoidance/AC_Avoid.h
@@ -39,6 +39,9 @@ class AC_Avoid {
     void adjust_velocity(float kP, float accel_cmss, Vector2f &desired_vel);
     void adjust_velocity(float kP, float accel_cmss, Vector3f &desired_vel);
 
+    // adjust vertical climb rate so vehicle does not break the vertical fence
+    void adjust_velocity_z(float kP, float accel_cmss, float& climb_rate_cms);
+
     // adjust roll-pitch to push vehicle away from objects
     // roll and pitch value are in centi-degrees
     // angle_max is the user defined maximum lean angle for the vehicle in centi-degrees
@@ -83,9 +86,10 @@ class AC_Avoid {
     void limit_velocity(float kP, float accel_cmss, Vector2f &desired_vel, const Vector2f& limit_direction, float limit_distance) const;
 
     /*
-     * Gets the current position, relative to home (not relative to EKF origin)
+     * Gets the current position or altitude, relative to home (not relative to EKF origin) in cm
      */
     Vector2f get_position() const;
+    float get_alt_above_home() const;
 
     /*
      * Computes the speed such that the stopping distance

From 2133fd94ca5a3bb8e240755d80dfca90b1602bb6 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 16 Jan 2017 13:49:51 +0900
Subject: [PATCH 166/200] AC_Avoidance: adjust_velocity_z uses inav
 get_hgt_ctrl_limit

inertial navigation's get_hgt_ctrl_limit provides an altitude-above-ekf-origin limit while flying with optical flow
---
 libraries/AC_Avoidance/AC_Avoid.cpp | 22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

diff --git a/libraries/AC_Avoidance/AC_Avoid.cpp b/libraries/AC_Avoidance/AC_Avoid.cpp
index 1346296..9113b93 100644
--- a/libraries/AC_Avoidance/AC_Avoid.cpp
+++ b/libraries/AC_Avoidance/AC_Avoid.cpp
@@ -83,13 +83,29 @@ void AC_Avoid::adjust_velocity_z(float kP, float accel_cmss, float& climb_rate_c
     // limit acceleration
     float accel_cmss_limited = MIN(accel_cmss, AC_AVOID_ACCEL_CMSS_MAX);
 
-    // stop before breaching fence altitude
-    if ((_enabled & AC_AVOID_STOP_AT_FENCE) > 0) {
+    bool limit_alt = false;
+    float alt_diff_cm = 0.0f;   // distance from altitude limit to vehicle in cm (positive means vehicle is below limit)
 
+    // calculate distance below fence
+    if ((_enabled & AC_AVOID_STOP_AT_FENCE) > 0) {
         // calculate distance from vehicle to safe altitude
         float veh_alt = get_alt_above_home();
-        float alt_diff_cm = _fence.get_safe_alt() * 100.0f - veh_alt;
+        alt_diff_cm = _fence.get_safe_alt() * 100.0f - veh_alt;
+        limit_alt = true;
+    }
+
+    // calculate distance to optical flow altitude limit
+    float ekf_alt_limit_cm;
+    if (_inav.get_hgt_ctrl_limit(ekf_alt_limit_cm)) {
+        float ekf_alt_diff_cm = ekf_alt_limit_cm - _inav.get_altitude();
+        if (!limit_alt || ekf_alt_diff_cm < alt_diff_cm) {
+            alt_diff_cm = ekf_alt_diff_cm;
+        }
+        limit_alt = true;
+    }
 
+    // limit climb rate
+    if (limit_alt) {
         // do not allow climbing if we've breached the safe altitude
         if (alt_diff_cm <= 0.0f) {
             climb_rate_cms = MIN(climb_rate_cms, 0.0f);

From e799e3a342f9a95515b6e651af979ec26650dd4b Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 16 Jan 2017 15:58:43 +0900
Subject: [PATCH 167/200] AC_Avoidance: stop based on upward facing proximity
 sensor

---
 libraries/AC_Avoidance/AC_Avoid.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/libraries/AC_Avoidance/AC_Avoid.cpp b/libraries/AC_Avoidance/AC_Avoid.cpp
index 9113b93..b474def 100644
--- a/libraries/AC_Avoidance/AC_Avoid.cpp
+++ b/libraries/AC_Avoidance/AC_Avoid.cpp
@@ -104,6 +104,16 @@ void AC_Avoid::adjust_velocity_z(float kP, float accel_cmss, float& climb_rate_c
         limit_alt = true;
     }
 
+    // get distance from proximity sensor (in meters, convert to cm)
+    float proximity_alt_diff_m;
+    if (_proximity.get_upward_distance(proximity_alt_diff_m)) {
+        float proximity_alt_diff_cm = proximity_alt_diff_m * 100.0f;
+        if (!limit_alt || proximity_alt_diff_cm < alt_diff_cm) {
+            alt_diff_cm = proximity_alt_diff_cm;
+        }
+        limit_alt = true;
+    }
+
     // limit climb rate
     if (limit_alt) {
         // do not allow climbing if we've breached the safe altitude

From 127404acea380ec1e8832cdac44d3873233adfd6 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Thu, 5 Jan 2017 15:23:04 +0900
Subject: [PATCH 168/200] AC_PosControl: add get_pos_z_kP accessor

---
 libraries/AC_AttitudeControl/AC_PosControl.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/libraries/AC_AttitudeControl/AC_PosControl.h b/libraries/AC_AttitudeControl/AC_PosControl.h
index f2ca001..3cfb8f9 100644
--- a/libraries/AC_AttitudeControl/AC_PosControl.h
+++ b/libraries/AC_AttitudeControl/AC_PosControl.h
@@ -172,6 +172,9 @@ class AC_PosControl
     float get_leash_down_z() const { return _leash_down_z; }
     float get_leash_up_z() const { return _leash_up_z; }
 
+    /// get_pos_z_kP - returns z position controller's kP gain
+    float get_pos_z_kP() const { return _p_pos_z.kP(); }
+
     ///
     /// xy position controller
     ///

From ff042528fe8808686d84f282abf1b9e75e282ed4 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 16 Jan 2017 13:52:18 +0900
Subject: [PATCH 169/200] AC_PosControl: remove alt_max

AC_Avoidance enforces the altitude limit
---
 libraries/AC_AttitudeControl/AC_PosControl.cpp | 15 ---------------
 libraries/AC_AttitudeControl/AC_PosControl.h   |  6 ------
 2 files changed, 21 deletions(-)

diff --git a/libraries/AC_AttitudeControl/AC_PosControl.cpp b/libraries/AC_AttitudeControl/AC_PosControl.cpp
index 29149bb..1864a14 100644
--- a/libraries/AC_AttitudeControl/AC_PosControl.cpp
+++ b/libraries/AC_AttitudeControl/AC_PosControl.cpp
@@ -52,7 +52,6 @@ AC_PosControl::AC_PosControl(const AP_AHRS& ahrs, const AP_InertialNav& inav,
     _leash_up_z(POSCONTROL_LEASH_LENGTH_MIN),
     _roll_target(0.0f),
     _pitch_target(0.0f),
-    _alt_max(0.0f),
     _distance_to_target(0.0f),
     _accel_target_jerk_limited(0.0f,0.0f),
     _accel_target_filter(POSCONTROL_ACCEL_FILTER_HZ)
@@ -166,12 +165,6 @@ void AC_PosControl::set_alt_target_from_climb_rate(float climb_rate_cms, float d
         _pos_target.z += climb_rate_cms * dt;
     }
 
-    // do not let target alt get above limit
-    if (_alt_max > 0 && _pos_target.z > _alt_max) {
-        _pos_target.z = _alt_max;
-        _limit.pos_up = true;
-    }
-
     // do not use z-axis desired velocity feed forward
     // vel_desired set to desired climb rate for reporting and land-detector
     _flags.use_desvel_ff_z = false;
@@ -212,14 +205,6 @@ void AC_PosControl::set_alt_target_from_climb_rate_ff(float climb_rate_cms, floa
     if ((_vel_desired.z<0 && (!_motors.limit.throttle_lower || force_descend)) || (_vel_desired.z>0 && !_motors.limit.throttle_upper && !_limit.pos_up)) {
         _pos_target.z += _vel_desired.z * dt;
     }
-
-    // do not let target alt get above limit
-    if (_alt_max > 0 && _pos_target.z > _alt_max) {
-        _pos_target.z = _alt_max;
-        _limit.pos_up = true;
-        // decelerate feed forward to zero
-        _vel_desired.z = constrain_float(0.0f, _vel_desired.z-vel_change_limit, _vel_desired.z+vel_change_limit);
-    }
 }
 
 /// add_takeoff_climb_rate - adjusts alt target up or down using a climb rate in cm/s
diff --git a/libraries/AC_AttitudeControl/AC_PosControl.h b/libraries/AC_AttitudeControl/AC_PosControl.h
index 3cfb8f9..ac7faef 100644
--- a/libraries/AC_AttitudeControl/AC_PosControl.h
+++ b/libraries/AC_AttitudeControl/AC_PosControl.h
@@ -76,11 +76,6 @@ class AC_PosControl
     /// z position controller
     ///
 
-    /// set_alt_max - sets maximum altitude above the ekf origin in cm
-    ///   only enforced when set_alt_target_from_climb_rate is used
-    ///   set to zero to disable limit
-    void set_alt_max(float alt) { _alt_max = alt; }
-
     /// set_speed_z - sets maximum climb and descent rates
     ///     speed_down can be positive or negative but will always be interpreted as a descent speed
     ///     leash length will be recalculated the next time update_z_controller() is called
@@ -417,7 +412,6 @@ class AC_PosControl
     Vector3f    _accel_error;           // desired acceleration in cm/s/s  // To-Do: are xy actually required?
     Vector3f    _accel_feedforward;     // feedforward acceleration in cm/s/s
     Vector2f    _vehicle_horiz_vel;     // velocity to use if _flags.vehicle_horiz_vel_override is set
-    float       _alt_max;               // max altitude - should be updated from the main code with altitude limit from fence
     float       _distance_to_target;    // distance to position target - for reporting only
     LowPassFilterFloat _vel_error_filter;   // low-pass-filter on z-axis velocity error
 

From ebbfa9391d8b34f49a2a9ad63c9e0b7fc722a5d4 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Thu, 5 Jan 2017 15:25:10 +0900
Subject: [PATCH 170/200] Copter: remove comments from package place

---
 ArduCopter/control_auto.cpp | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/ArduCopter/control_auto.cpp b/ArduCopter/control_auto.cpp
index 6619ffb..a387bdc 100644
--- a/ArduCopter/control_auto.cpp
+++ b/ArduCopter/control_auto.cpp
@@ -855,9 +855,7 @@ void Copter::auto_payload_place_run_loiter()
     const float target_yaw_rate = 0;
     attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(wp_nav->get_roll(), wp_nav->get_pitch(), target_yaw_rate, get_smoothing_gain());
 
-    // update altitude target and call position controller
-    // const float target_climb_rate = 0;
-    // pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
+    // call position controller
     pos_control->update_z_controller();
 }
 

From b15d3418507915de3f551bd9497539a737055967 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Thu, 5 Jan 2017 15:32:01 +0900
Subject: [PATCH 171/200] Copter: add avoidance adjusted climb rate

---
 ArduCopter/Attitude.cpp | 30 ++++++++++++++----------------
 ArduCopter/Copter.h     |  1 +
 2 files changed, 15 insertions(+), 16 deletions(-)

diff --git a/ArduCopter/Attitude.cpp b/ArduCopter/Attitude.cpp
index 03c6ce7..a55d9ad 100644
--- a/ArduCopter/Attitude.cpp
+++ b/ArduCopter/Attitude.cpp
@@ -282,6 +282,17 @@ float Copter::get_surface_tracking_climb_rate(int16_t target_rate, float current
 #endif
 }
 
+// get target climb rate reduced to avoid obstacles and altitude fence
+float Copter::get_avoidance_adjusted_climbrate(float target_rate)
+{
+#if AC_AVOID_ENABLED == ENABLED
+    avoid.adjust_velocity_z(pos_control->get_pos_z_kP(), pos_control->get_accel_z(), target_rate);
+    return target_rate;
+#else
+    return target_rate;
+#endif
+}
+
 // set_accel_throttle_I_from_pilot_throttle - smoothes transition from pilot controlled throttle to autopilot throttle
 void Copter::set_accel_throttle_I_from_pilot_throttle()
 {
@@ -294,25 +305,12 @@ void Copter::set_accel_throttle_I_from_pilot_throttle()
 // updates position controller's maximum altitude using fence and EKF limits
 void Copter::update_poscon_alt_max()
 {
-    float alt_limit_cm = 0.0f;  // interpreted as no limit if left as zero
-
-#if AC_FENCE == ENABLED
-    // set fence altitude limit in position controller
-    if ((fence.get_enabled_fences() & AC_FENCE_TYPE_ALT_MAX) != 0) {
-        alt_limit_cm = pv_alt_above_origin(fence.get_safe_alt()*100.0f);
-    }
-#endif
-
     // get alt limit from EKF (limited during optical flow flight)
-    float ekf_limit_cm = 0.0f;
+    float ekf_limit_cm;
     if (inertial_nav.get_hgt_ctrl_limit(ekf_limit_cm)) {
-        if ((alt_limit_cm <= 0.0f) || (ekf_limit_cm < alt_limit_cm)) {
-            alt_limit_cm = ekf_limit_cm;
-        }
+        // pass limit to pos controller
+        pos_control->set_alt_max(ekf_limit_cm);
     }
-
-    // pass limit to pos controller
-    pos_control->set_alt_max(alt_limit_cm);
 }
 
 // rotate vector from vehicle's perspective to North-East frame
diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index 7f5440a..f49b099 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -664,6 +664,7 @@ class Copter : public AP_HAL::HAL::Callbacks {
     float get_pilot_desired_climb_rate(float throttle_control);
     float get_non_takeoff_throttle();
     float get_surface_tracking_climb_rate(int16_t target_rate, float current_alt_target, float dt);
+    float get_avoidance_adjusted_climbrate(float target_rate);
     void auto_takeoff_set_start_alt(void);
     void auto_takeoff_attitude_run(float target_yaw_rate);
     void set_accel_throttle_I_from_pilot_throttle();

From 62a4867cd428bfb7c1bc225faecd31de748a4970 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Thu, 5 Jan 2017 15:24:02 +0900
Subject: [PATCH 172/200] Copter: use avoidance adjusted climb rate in all
 modes

---
 ArduCopter/control_althold.cpp  | 6 ++++++
 ArduCopter/control_autotune.cpp | 3 +++
 ArduCopter/control_guided.cpp   | 3 +++
 ArduCopter/control_loiter.cpp   | 6 ++++++
 ArduCopter/control_poshold.cpp  | 4 ++++
 ArduCopter/control_sport.cpp    | 6 ++++++
 6 files changed, 28 insertions(+)

diff --git a/ArduCopter/control_althold.cpp b/ArduCopter/control_althold.cpp
index 1a31481..e22c215 100644
--- a/ArduCopter/control_althold.cpp
+++ b/ArduCopter/control_althold.cpp
@@ -108,6 +108,9 @@ void Copter::althold_run()
         // get take-off adjusted pilot and takeoff climb rates
         takeoff_get_climb_rates(target_climb_rate, takeoff_climb_rate);
 
+        // get avoidance adjusted climb rate
+        target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);
+
         // call attitude controller
         attitude_control->input_euler_angle_roll_pitch_euler_rate_yaw(target_roll, target_pitch, target_yaw_rate, get_smoothing_gain());
 
@@ -149,6 +152,9 @@ void Copter::althold_run()
             target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
         }
 
+        // get avoidance adjusted climb rate
+        target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);
+
         // call position controller
         pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
         pos_control->update_z_controller();
diff --git a/ArduCopter/control_autotune.cpp b/ArduCopter/control_autotune.cpp
index d6f587e..fa489c5 100644
--- a/ArduCopter/control_autotune.cpp
+++ b/ArduCopter/control_autotune.cpp
@@ -285,6 +285,9 @@ void Copter::autotune_run()
     // get pilot desired climb rate
     target_climb_rate = get_pilot_desired_climb_rate(channel_throttle->get_control_in());
 
+    // get avoidance adjusted climb rate
+    target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);
+
     // check for pilot requested take-off - this should not actually be possible because of autotune_init() checks
     if (ap.land_complete && target_climb_rate > 0) {
         // indicate we are taking off
diff --git a/ArduCopter/control_guided.cpp b/ArduCopter/control_guided.cpp
index 59ae772..fe61acd 100644
--- a/ArduCopter/control_guided.cpp
+++ b/ArduCopter/control_guided.cpp
@@ -580,6 +580,9 @@ void Copter::guided_angle_control_run()
     // constrain climb rate
     float climb_rate_cms = constrain_float(guided_angle_state.climb_rate_cms, -fabsf(wp_nav->get_speed_down()), wp_nav->get_speed_up());
 
+    // get avoidance adjusted climb rate
+    climb_rate_cms = get_avoidance_adjusted_climbrate(climb_rate_cms);
+
     // check for timeout - set lean angles and climb rate to zero if no updates received for 3 seconds
     uint32_t tnow = millis();
     if (tnow - guided_angle_state.update_time_ms > GUIDED_ATTITUDE_TIMEOUT_MS) {
diff --git a/ArduCopter/control_loiter.cpp b/ArduCopter/control_loiter.cpp
index 53c0542..4e8eb9d 100644
--- a/ArduCopter/control_loiter.cpp
+++ b/ArduCopter/control_loiter.cpp
@@ -162,6 +162,9 @@ void Copter::loiter_run()
         // get takeoff adjusted pilot and takeoff climb rates
         takeoff_get_climb_rates(target_climb_rate, takeoff_climb_rate);
 
+        // get avoidance adjusted climb rate
+        target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);
+
         // run loiter controller
         wp_nav->update_loiter(ekfGndSpdLimit, ekfNavVelGainScaler);
 
@@ -212,6 +215,9 @@ void Copter::loiter_run()
             target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
         }
 
+        // get avoidance adjusted climb rate
+        target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);
+
         // update altitude target and call position controller
         pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
         pos_control->update_z_controller();
diff --git a/ArduCopter/control_poshold.cpp b/ArduCopter/control_poshold.cpp
index bbf986a..2ff9b19 100644
--- a/ArduCopter/control_poshold.cpp
+++ b/ArduCopter/control_poshold.cpp
@@ -538,6 +538,10 @@ void Copter::poshold_run()
             // if rangefinder is ok, use surface tracking
             target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
         }
+
+        // get avoidance adjusted climb rate
+        target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);
+
         // update altitude target and call position controller
         pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
         pos_control->add_takeoff_climb_rate(takeoff_climb_rate, G_Dt);
diff --git a/ArduCopter/control_sport.cpp b/ArduCopter/control_sport.cpp
index 3c56b8c..492abb2 100644
--- a/ArduCopter/control_sport.cpp
+++ b/ArduCopter/control_sport.cpp
@@ -119,6 +119,9 @@ void Copter::sport_run()
         // get take-off adjusted pilot and takeoff climb rates
         takeoff_get_climb_rates(target_climb_rate, takeoff_climb_rate);
 
+        // get avoidance adjusted climb rate
+        target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);
+
         // call attitude controller
         attitude_control->input_euler_rate_roll_pitch_yaw(target_roll_rate, target_pitch_rate, target_yaw_rate);
 
@@ -154,6 +157,9 @@ void Copter::sport_run()
             target_climb_rate = get_surface_tracking_climb_rate(target_climb_rate, pos_control->get_alt_target(), G_Dt);
         }
 
+        // get avoidance adjusted climb rate
+        target_climb_rate = get_avoidance_adjusted_climbrate(target_climb_rate);
+
         // call position controller
         pos_control->set_alt_target_from_climb_rate_ff(target_climb_rate, G_Dt, false);
         pos_control->update_z_controller();

From cb1f7ba4bb0b11c798e5d6c8d9bf431e3697b640 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Mon, 16 Jan 2017 13:51:07 +0900
Subject: [PATCH 173/200] Copter: remove setting position control's altitude
 max

AC_Avoid now takes responsibility for enforcing the alt limit and accesses inertial nav's limit directly
---
 ArduCopter/ArduCopter.cpp |  3 ---
 ArduCopter/Attitude.cpp   | 11 -----------
 ArduCopter/Copter.h       |  1 -
 3 files changed, 15 deletions(-)

diff --git a/ArduCopter/ArduCopter.cpp b/ArduCopter/ArduCopter.cpp
index a84c70f..32a49de 100644
--- a/ArduCopter/ArduCopter.cpp
+++ b/ArduCopter/ArduCopter.cpp
@@ -504,9 +504,6 @@ void Copter::one_hz_loop()
 
     check_usb_mux();
 
-    // update position controller alt limits
-    update_poscon_alt_max();
-
     // enable/disable raw gyro/accel logging
     ins.set_raw_logging(should_log(MASK_LOG_IMU_RAW));
 
diff --git a/ArduCopter/Attitude.cpp b/ArduCopter/Attitude.cpp
index a55d9ad..fa2ac89 100644
--- a/ArduCopter/Attitude.cpp
+++ b/ArduCopter/Attitude.cpp
@@ -302,17 +302,6 @@ void Copter::set_accel_throttle_I_from_pilot_throttle()
     g.pid_accel_z.set_integrator((pilot_throttle-motors->get_throttle_hover()) * 1000.0f);
 }
 
-// updates position controller's maximum altitude using fence and EKF limits
-void Copter::update_poscon_alt_max()
-{
-    // get alt limit from EKF (limited during optical flow flight)
-    float ekf_limit_cm;
-    if (inertial_nav.get_hgt_ctrl_limit(ekf_limit_cm)) {
-        // pass limit to pos controller
-        pos_control->set_alt_max(ekf_limit_cm);
-    }
-}
-
 // rotate vector from vehicle's perspective to North-East frame
 void Copter::rotate_body_frame_to_NE(float &x, float &y)
 {
diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index f49b099..ab0cec2 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -668,7 +668,6 @@ class Copter : public AP_HAL::HAL::Callbacks {
     void auto_takeoff_set_start_alt(void);
     void auto_takeoff_attitude_run(float target_yaw_rate);
     void set_accel_throttle_I_from_pilot_throttle();
-    void update_poscon_alt_max();
     void rotate_body_frame_to_NE(float &x, float &y);
     void gcs_send_heartbeat(void);
     void gcs_send_deferred(void);

From c696137a425337b7930ead5a94388431c481b107 Mon Sep 17 00:00:00 2001
From: Michael du Breuil <wicked.shell.scripts@gmail.com>
Date: Tue, 10 Jan 2017 02:58:42 -0700
Subject: [PATCH 174/200] AP_GPS: Update the number of leapseconds

---
 libraries/AP_GPS/AP_GPS.cpp      | 2 +-
 libraries/AP_GPS/AP_GPS.h        | 3 +++
 libraries/AP_GPS/GPS_Backend.cpp | 4 ++--
 3 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/libraries/AP_GPS/AP_GPS.cpp b/libraries/AP_GPS/AP_GPS.cpp
index ef84204..7ed4b8e 100644
--- a/libraries/AP_GPS/AP_GPS.cpp
+++ b/libraries/AP_GPS/AP_GPS.cpp
@@ -590,7 +590,7 @@ AP_GPS::setHIL(uint8_t instance, GPS_Status _status, uint64_t time_epoch_ms,
     istate.hdop = hdop;
     istate.num_sats = _num_sats;
     istate.last_gps_time_ms = tnow;
-    uint64_t gps_time_ms = time_epoch_ms - (17000ULL*86400ULL + 52*10*7000ULL*86400ULL - 15000ULL);
+    uint64_t gps_time_ms = time_epoch_ms - (17000ULL*86400ULL + 52*10*7000ULL*86400ULL - GPS_LEAPSECONDS_MILLIS);
     istate.time_week     = gps_time_ms / (86400*7*(uint64_t)1000);
     istate.time_week_ms  = gps_time_ms - istate.time_week*(86400*7*(uint64_t)1000);
     timing[instance].last_message_time_ms = tnow;
diff --git a/libraries/AP_GPS/AP_GPS.h b/libraries/AP_GPS/AP_GPS.h
index 093960f..e4df08c 100644
--- a/libraries/AP_GPS/AP_GPS.h
+++ b/libraries/AP_GPS/AP_GPS.h
@@ -31,6 +31,9 @@
 #define GPS_MAX_INSTANCES 2
 #define GPS_RTK_INJECT_TO_ALL 127
 
+// the number of GPS leap seconds
+#define GPS_LEAPSECONDS_MILLIS 18000ULL
+
 class DataFlash_Class;
 class AP_GPS_Backend;
 
diff --git a/libraries/AP_GPS/GPS_Backend.cpp b/libraries/AP_GPS/GPS_Backend.cpp
index 800f711..3e900ce 100644
--- a/libraries/AP_GPS/GPS_Backend.cpp
+++ b/libraries/AP_GPS/GPS_Backend.cpp
@@ -64,7 +64,7 @@ int16_t AP_GPS_Backend::swap_int16(int16_t v) const
 uint64_t AP_GPS::time_epoch_convert(uint16_t gps_week, uint32_t gps_ms)
 {
     const uint64_t ms_per_week = 7000ULL*86400ULL;
-    const uint64_t unix_offset = 17000ULL*86400ULL + 52*10*7000ULL*86400ULL - 15000ULL;
+    const uint64_t unix_offset = 17000ULL*86400ULL + 52*10*7000ULL*86400ULL - GPS_LEAPSECONDS_MILLIS;
     uint64_t fix_time_ms = unix_offset + gps_week*ms_per_week + gps_ms;
     return fix_time_ms;
 }
@@ -110,7 +110,7 @@ void AP_GPS_Backend::make_gps_time(uint32_t bcd_date, uint32_t bcd_milliseconds)
     }
 
     // get time in seconds since unix epoch
-    uint32_t ret = (year/4) - 15 + 367*rmon/12 + day;
+    uint32_t ret = (year/4) - (GPS_LEAPSECONDS_MILLIS / 1000UL) + 367*rmon/12 + day;
     ret += year*365 + 10501;
     ret = ret*24 + hour;
     ret = ret*60 + min;

From d5a5a97a3d79021898710fe527999c10671309f6 Mon Sep 17 00:00:00 2001
From: Michael du Breuil <wicked.shell.scripts@gmail.com>
Date: Tue, 10 Jan 2017 02:59:02 -0700
Subject: [PATCH 175/200] SITL: Use the GPS_LEAPSECOND define

---
 libraries/AP_HAL_SITL/sitl_gps.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_HAL_SITL/sitl_gps.cpp b/libraries/AP_HAL_SITL/sitl_gps.cpp
index afd8dd4..d06842f 100644
--- a/libraries/AP_HAL_SITL/sitl_gps.cpp
+++ b/libraries/AP_HAL_SITL/sitl_gps.cpp
@@ -177,7 +177,7 @@ static void gps_time(uint16_t *time_week, uint32_t *time_week_ms)
 {
     struct timeval tv;
     simulation_timeval(&tv);
-    const uint32_t epoch = 86400*(10*365 + (1980-1969)/4 + 1 + 6 - 2) - 15;
+    const uint32_t epoch = 86400*(10*365 + (1980-1969)/4 + 1 + 6 - 2) - (GPS_LEAPSECONDS_MILLIS / 1000ULL);
     uint32_t epoch_seconds = tv.tv_sec - epoch;
     *time_week = epoch_seconds / (86400*7UL);
     uint32_t t_ms = tv.tv_usec / 1000;

From fdb2a9c99bffa65313778d3d2039fb70e59496d2 Mon Sep 17 00:00:00 2001
From: Mathieu OTHACEHE <mathieu.othacehe@parrot.com>
Date: Wed, 18 Jan 2017 16:56:56 +0100
Subject: [PATCH 176/200] AP_HAL: Bebop & Disco: rename APM to ardupilot in
 paths

Rename APM to ardupilot for Bebop and Disco's HAL_BOARD_LOG_DIRECTORY and
HAL_BOARD_TERRAIN_DIRECTORY.
---
 libraries/AP_HAL/board/linux.h | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/libraries/AP_HAL/board/linux.h b/libraries/AP_HAL/board/linux.h
index 58b9a5b..bd2845f 100644
--- a/libraries/AP_HAL/board/linux.h
+++ b/libraries/AP_HAL/board/linux.h
@@ -34,8 +34,8 @@
 #define HAL_GPIO_LED_ON           LOW
 #define HAL_GPIO_LED_OFF          HIGH
 #elif CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_BEBOP
-#define HAL_BOARD_LOG_DIRECTORY "/data/ftp/internal_000/APM/logs"
-#define HAL_BOARD_TERRAIN_DIRECTORY "/data/ftp/internal_000/APM/terrain"
+#define HAL_BOARD_LOG_DIRECTORY "/data/ftp/internal_000/ardupilot/logs"
+#define HAL_BOARD_TERRAIN_DIRECTORY "/data/ftp/internal_000/ardupilot/terrain"
 #define HAL_INS_DEFAULT HAL_INS_MPU60XX_I2C
 #define HAL_INS_DEFAULT_ROTATION ROTATION_YAW_270
 #define HAL_INS_MPU60x0_I2C_BUS 2
@@ -76,8 +76,8 @@
 #define HAL_RANGEFINDER_LIGHTWARE_I2C_BUS 0
 #define HAL_FLOW_PX4_FOCAL_LENGTH_MILLIPX (2.5 / (3.6 * 2.0 * 240 / 64))
 #elif CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_DISCO
-#define HAL_BOARD_LOG_DIRECTORY "/data/ftp/internal_000/APM/logs"
-#define HAL_BOARD_TERRAIN_DIRECTORY "/data/ftp/internal_000/APM/terrain"
+#define HAL_BOARD_LOG_DIRECTORY "/data/ftp/internal_000/ardupilot/logs"
+#define HAL_BOARD_TERRAIN_DIRECTORY "/data/ftp/internal_000/ardupilot/terrain"
 #define HAL_INS_DEFAULT HAL_INS_MPU60XX_I2C
 #define HAL_INS_DEFAULT_ROTATION ROTATION_PITCH_180_YAW_90
 #define HAL_INS_MPU60x0_I2C_BUS 2

From bad1c879d9a71f0fca6b1deed8dd64da1707e94d Mon Sep 17 00:00:00 2001
From: Mathieu OTHACEHE <mathieu.othacehe@parrot.com>
Date: Wed, 18 Jan 2017 17:04:30 +0100
Subject: [PATCH 177/200] AP_HAL: Bebop & Disco: move default param file path

In future Bebop & Disco releases, no ardupilot binary nor default param file
will be provided.

So move HAL_PARAM_DEFAULTS_PATH to ardupilot folder in RW memory.
---
 libraries/AP_HAL/board/linux.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libraries/AP_HAL/board/linux.h b/libraries/AP_HAL/board/linux.h
index bd2845f..0932ce2 100644
--- a/libraries/AP_HAL/board/linux.h
+++ b/libraries/AP_HAL/board/linux.h
@@ -68,7 +68,7 @@
 #define HAL_FLOW_PX4_MAX_FLOW_PIXEL 4
 #define HAL_FLOW_PX4_BOTTOM_FLOW_FEATURE_THRESHOLD 30
 #define HAL_FLOW_PX4_BOTTOM_FLOW_VALUE_THRESHOLD 5000
-#define HAL_PARAM_DEFAULTS_PATH "/etc/arducopter/bebop.parm"
+#define HAL_PARAM_DEFAULTS_PATH "/data/ftp/internal_000/ardupilot/bebop.parm"
 #define HAL_RCOUT_BEBOP_BLDC_I2C_BUS 1
 #define HAL_RCOUT_BEBOP_BLDC_I2C_ADDR 0x08
 /* focal length 3.6 um, 2x binning in each direction
@@ -111,7 +111,7 @@
 #define HAL_FLOW_PX4_BOTTOM_FLOW_VALUE_THRESHOLD 5000
 #define HAL_RCOUT_DISCO_BLDC_I2C_BUS 1
 #define HAL_RCOUT_DISCO_BLDC_I2C_ADDR 0x08
-#define HAL_PARAM_DEFAULTS_PATH "/etc/arduplane/disco.parm"
+#define HAL_PARAM_DEFAULTS_PATH "/data/ftp/internal_000/ardupilot/disco.parm"
 /* focal length 3.6 um, 2x binning in each direction
  * 240x240 crop rescaled to 64x64 */
 #define HAL_FLOW_PX4_FOCAL_LENGTH_MILLIPX (2.5 / (3.6 * 2.0 * 240 / 64))

From dd0d09175bade7fb06b976f43b303bc78ad37ef6 Mon Sep 17 00:00:00 2001
From: murata <ma2maru@gmail.com>
Date: Sat, 31 Dec 2016 19:35:56 +0900
Subject: [PATCH 178/200] AP_Beacon: Changed if statements to switch statement.

---
 libraries/AP_Beacon/AP_Beacon_Pozyx.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/libraries/AP_Beacon/AP_Beacon_Pozyx.cpp b/libraries/AP_Beacon/AP_Beacon_Pozyx.cpp
index c27f392..e8d9592 100644
--- a/libraries/AP_Beacon/AP_Beacon_Pozyx.cpp
+++ b/libraries/AP_Beacon/AP_Beacon_Pozyx.cpp
@@ -68,13 +68,16 @@ void AP_Beacon_Pozyx::update(void)
 
             case ParseState_WaitingForMsgId:
                 parse_msg_id = c;
-                if (parse_msg_id == AP_BEACON_POZYX_MSGID_BEACON_CONFIG ||
-                    parse_msg_id == AP_BEACON_POZYX_MSGID_BEACON_DIST ||
-                    parse_msg_id == AP_BEACON_POZYX_MSGID_POSITION) {
+                switch (parse_msg_id) {
+                case AP_BEACON_POZYX_MSGID_BEACON_CONFIG:
+                case AP_BEACON_POZYX_MSGID_BEACON_DIST:
+                case AP_BEACON_POZYX_MSGID_POSITION:
                     parse_state = ParseState_WaitingForLen;
-                } else {
+                    break;
+                default:
                     // invalid message id
                     parse_state = ParseState_WaitingForHeader;
+                    break;
                 }
                 break;
 

From 7d4d14a409e9f96f28f586bfb3a91d8cf919877d Mon Sep 17 00:00:00 2001
From: Mathieu OTHACEHE <mathieu.othacehe@parrot.com>
Date: Thu, 5 Jan 2017 09:52:22 +0100
Subject: [PATCH 179/200] AP_HAL_Linux: add Led_Sysfs class.

Add a class to control leds via linux sysfs API.
---
 libraries/AP_HAL_Linux/Led_Sysfs.cpp | 92 ++++++++++++++++++++++++++++++++++++
 libraries/AP_HAL_Linux/Led_Sysfs.h   | 41 ++++++++++++++++
 2 files changed, 133 insertions(+)
 create mode 100644 libraries/AP_HAL_Linux/Led_Sysfs.cpp
 create mode 100644 libraries/AP_HAL_Linux/Led_Sysfs.h

diff --git a/libraries/AP_HAL_Linux/Led_Sysfs.cpp b/libraries/AP_HAL_Linux/Led_Sysfs.cpp
new file mode 100644
index 0000000..4094a54
--- /dev/null
+++ b/libraries/AP_HAL_Linux/Led_Sysfs.cpp
@@ -0,0 +1,92 @@
+/*
+   Copyright (C) 2017 Mathieu Othacehe. All rights reserved.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "Led_Sysfs.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <unistd.h>
+
+#include <AP_HAL/AP_HAL.h>
+
+static const AP_HAL::HAL &hal = AP_HAL::get_HAL();
+
+namespace Linux {
+
+Led_Sysfs::Led_Sysfs(const char *led_name)
+    : _led_name(led_name)
+{
+}
+
+Led_Sysfs::~Led_Sysfs()
+{
+    if (_brightness_fd) {
+        close(_brightness_fd);
+    }
+}
+
+bool Led_Sysfs::init()
+{
+    char *br_path;
+    char *max_br_path;
+
+    if (asprintf(&br_path, "/sys/class/leds/%s/brightness", _led_name) == -1) {
+        AP_HAL::panic("LinuxLed_Sysfs : Couldn't allocate brightness path\n");
+    }
+
+    _brightness_fd = open(br_path, O_WRONLY | O_CLOEXEC);
+    if (_brightness_fd < 0) {
+        printf("LinuxLed_Sysfs: Unable to open file %s\n", br_path);
+        free(br_path);
+        return false;
+    }
+
+    if (asprintf(&max_br_path, "/sys/class/leds/%s/max_brightness", _led_name) == -1) {
+        AP_HAL::panic("LinuxLed_Sysfs : Couldn't allocate max_brightness path\n");
+    }
+
+    if (Util::from(hal.util)->read_file(max_br_path, "%u", &_max_brightness) < 0) {
+        AP_HAL::panic("LinuxLed_Sysfs : Unable to read max_brightness in %s\n",
+                      max_br_path);
+    }
+
+    free(max_br_path);
+    free(br_path);
+
+    return true;
+}
+
+bool Led_Sysfs::set_brightness(uint8_t brightness)
+{
+    if (_brightness_fd < 0) {
+        return false;
+    }
+
+    int br = brightness * _max_brightness / UINT8_MAX;
+
+    /* Don't log fails since this could spam the console */
+    if (dprintf(_brightness_fd, "%u", br) < 0) {
+        return false;
+    }
+
+    return true;
+}
+
+}
diff --git a/libraries/AP_HAL_Linux/Led_Sysfs.h b/libraries/AP_HAL_Linux/Led_Sysfs.h
new file mode 100644
index 0000000..a6c4c2c
--- /dev/null
+++ b/libraries/AP_HAL_Linux/Led_Sysfs.h
@@ -0,0 +1,41 @@
+/*
+  Copyright (C) 2017 Mathieu Othacehe. All rights reserved.
+
+  This program is free software: you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation, either version 3 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <AP_HAL/AP_HAL.h>
+
+#include "AP_HAL_Linux.h"
+#include "Util.h"
+
+#pragma once
+
+namespace Linux {
+
+class Led_Sysfs {
+public:
+    bool init();
+    bool set_brightness(uint8_t brightness);
+
+    Led_Sysfs(const char* led_name);
+    ~Led_Sysfs();
+
+private:
+    int _brightness_fd = -1;
+    int _max_brightness = 0;
+    const char *_led_name = nullptr;
+};
+
+}

From 701d91f20ca07fcc7ab22a05344fbf7a88fa32ed Mon Sep 17 00:00:00 2001
From: Mathieu OTHACEHE <mathieu.othacehe@parrot.com>
Date: Wed, 4 Jan 2017 09:25:07 +0100
Subject: [PATCH 180/200] AP_Notify: Disco: use new led sysfs backend or, if
 not available, legacy pwm backend to drive leds.

In new Disco releases, the led sysfs api will replace the pwm sysfs
api to drive the tricolor led.

Keep pwm sysfs api for compatibility reasons.
---
 libraries/AP_Notify/DiscoLED.cpp | 38 ++++++++++++++++++++++++++++++++++----
 libraries/AP_Notify/DiscoLED.h   | 12 ++++++++++++
 2 files changed, 46 insertions(+), 4 deletions(-)

diff --git a/libraries/AP_Notify/DiscoLED.cpp b/libraries/AP_Notify/DiscoLED.cpp
index 3dbdd2e..8399e6a 100644
--- a/libraries/AP_Notify/DiscoLED.cpp
+++ b/libraries/AP_Notify/DiscoLED.cpp
@@ -18,6 +18,7 @@
 #include <AP_HAL/AP_HAL.h>
 #if CONFIG_HAL_BOARD == HAL_BOARD_LINUX
 #include <AP_HAL_Linux/PWM_Sysfs.h>
+#include <AP_HAL_Linux/Led_Sysfs.h>
 #include "DiscoLED.h"
 
 #define RED_PWM_INDEX   9
@@ -29,16 +30,33 @@
 #define DISCO_LED_HIGH   0xFF
 #define DISCO_LED_OFF    0x00
 
+#define DISCO_LED_RED_NAME   "evinrude:red"
+#define DISCO_LED_GREEN_NAME "evinrude:green"
+#define DISCO_LED_BLUE_NAME  "evinrude:blue"
+
 DiscoLED::DiscoLED():
     RGBLed(DISCO_LED_OFF, DISCO_LED_HIGH, DISCO_LED_MEDIUM, DISCO_LED_LOW),
     red_pwm(RED_PWM_INDEX),
     green_pwm(GREEN_PWM_INDEX),
-    blue_pwm(BLUE_PWM_INDEX)
+    blue_pwm(BLUE_PWM_INDEX),
+
+    red_led(DISCO_LED_RED_NAME),
+    green_led(DISCO_LED_GREEN_NAME),
+    blue_led(DISCO_LED_BLUE_NAME)
 {
 }
 
 bool DiscoLED::hw_init()
 {
+    /* If led sysfs api is present, use it, else use pwm sysfs api to
+       drive Disco leds */
+    if (red_led.init() && green_led.init() && blue_led.init()) {
+        backend = LED_SYSFS;
+        return true;
+    }
+
+    backend = PWM_SYSFS;
+
     red_pwm_period = red_pwm.get_period();
     green_pwm_period = green_pwm.get_period();
     blue_pwm_period = blue_pwm.get_period();
@@ -56,9 +74,21 @@ bool DiscoLED::hw_init()
 
 bool DiscoLED::hw_set_rgb(uint8_t red, uint8_t green, uint8_t blue)
 {
-    red_pwm.set_duty_cycle(red / UINT8_MAX * red_pwm_period);
-    green_pwm.set_duty_cycle(green / UINT8_MAX * green_pwm_period);
-    blue_pwm.set_duty_cycle(blue / UINT8_MAX * blue_pwm_period);
+
+    switch (backend) {
+    case PWM_SYSFS:
+        red_pwm.set_duty_cycle(red / UINT8_MAX * red_pwm_period);
+        green_pwm.set_duty_cycle(green / UINT8_MAX * green_pwm_period);
+        blue_pwm.set_duty_cycle(blue / UINT8_MAX * blue_pwm_period);
+        break;
+    case LED_SYSFS:
+        red_led.set_brightness(red);
+        green_led.set_brightness(green);
+        blue_led.set_brightness(blue);
+        break;
+    default:
+        return false;
+    }
 
     return true;
 }
diff --git a/libraries/AP_Notify/DiscoLED.h b/libraries/AP_Notify/DiscoLED.h
index 32cf82a1..760d096 100644
--- a/libraries/AP_Notify/DiscoLED.h
+++ b/libraries/AP_Notify/DiscoLED.h
@@ -19,6 +19,7 @@
 #include <AP_HAL/AP_HAL.h>
 #if CONFIG_HAL_BOARD == HAL_BOARD_LINUX
 #include <AP_HAL_Linux/PWM_Sysfs.h>
+#include <AP_HAL_Linux/Led_Sysfs.h>
 #include "RGBLed.h"
 
 class DiscoLED: public RGBLed
@@ -32,8 +33,19 @@ class DiscoLED: public RGBLed
     Linux::PWM_Sysfs_Bebop green_pwm;
     Linux::PWM_Sysfs_Bebop blue_pwm;
 
+    Linux::Led_Sysfs red_led;
+    Linux::Led_Sysfs green_led;
+    Linux::Led_Sysfs blue_led;
+
     uint32_t red_pwm_period;
     uint32_t green_pwm_period;
     uint32_t blue_pwm_period;
+
+    enum led_backend {
+        LED_SYSFS,
+        PWM_SYSFS
+    };
+
+    enum led_backend backend;
 };
 #endif

From c27c414e5a18cd4669653065bcc9bb4dfe133e2a Mon Sep 17 00:00:00 2001
From: Lucas De Marchi <lucas.demarchi@intel.com>
Date: Thu, 19 Jan 2017 08:56:32 -0800
Subject: [PATCH 181/200] AP_HAL_Linux: Led_Sysfs: small fixes

  - avoid trying to close fd when it's -1

  - Keep includes sorted

  - AP_HAL::panic() doesn't need \n terminator

  - %u requires unsigned type

  - #pragma once is the first thing on a header
---
 libraries/AP_HAL_Linux/Led_Sysfs.cpp | 12 ++++++------
 libraries/AP_HAL_Linux/Led_Sysfs.h   |  3 +--
 2 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/libraries/AP_HAL_Linux/Led_Sysfs.cpp b/libraries/AP_HAL_Linux/Led_Sysfs.cpp
index 4094a54..5758cf6 100644
--- a/libraries/AP_HAL_Linux/Led_Sysfs.cpp
+++ b/libraries/AP_HAL_Linux/Led_Sysfs.cpp
@@ -19,9 +19,9 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include <inttypes.h>
 #include <unistd.h>
 
 #include <AP_HAL/AP_HAL.h>
@@ -37,7 +37,7 @@ Led_Sysfs::Led_Sysfs(const char *led_name)
 
 Led_Sysfs::~Led_Sysfs()
 {
-    if (_brightness_fd) {
+    if (_brightness_fd >= 0) {
         close(_brightness_fd);
     }
 }
@@ -48,7 +48,7 @@ bool Led_Sysfs::init()
     char *max_br_path;
 
     if (asprintf(&br_path, "/sys/class/leds/%s/brightness", _led_name) == -1) {
-        AP_HAL::panic("LinuxLed_Sysfs : Couldn't allocate brightness path\n");
+        AP_HAL::panic("LinuxLed_Sysfs : Couldn't allocate brightness path");
     }
 
     _brightness_fd = open(br_path, O_WRONLY | O_CLOEXEC);
@@ -59,11 +59,11 @@ bool Led_Sysfs::init()
     }
 
     if (asprintf(&max_br_path, "/sys/class/leds/%s/max_brightness", _led_name) == -1) {
-        AP_HAL::panic("LinuxLed_Sysfs : Couldn't allocate max_brightness path\n");
+        AP_HAL::panic("LinuxLed_Sysfs : Couldn't allocate max_brightness path");
     }
 
     if (Util::from(hal.util)->read_file(max_br_path, "%u", &_max_brightness) < 0) {
-        AP_HAL::panic("LinuxLed_Sysfs : Unable to read max_brightness in %s\n",
+        AP_HAL::panic("LinuxLed_Sysfs : Unable to read max_brightness in %s",
                       max_br_path);
     }
 
@@ -79,7 +79,7 @@ bool Led_Sysfs::set_brightness(uint8_t brightness)
         return false;
     }
 
-    int br = brightness * _max_brightness / UINT8_MAX;
+    unsigned int br = brightness * _max_brightness / UINT8_MAX;
 
     /* Don't log fails since this could spam the console */
     if (dprintf(_brightness_fd, "%u", br) < 0) {
diff --git a/libraries/AP_HAL_Linux/Led_Sysfs.h b/libraries/AP_HAL_Linux/Led_Sysfs.h
index a6c4c2c..ac57e90 100644
--- a/libraries/AP_HAL_Linux/Led_Sysfs.h
+++ b/libraries/AP_HAL_Linux/Led_Sysfs.h
@@ -14,14 +14,13 @@
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
+#pragma once
 
 #include <AP_HAL/AP_HAL.h>
 
 #include "AP_HAL_Linux.h"
 #include "Util.h"
 
-#pragma once
-
 namespace Linux {
 
 class Led_Sysfs {

From fd0e4164b946f3700d1080dce7717e893602498f Mon Sep 17 00:00:00 2001
From: Lucas De Marchi <lucas.demarchi@intel.com>
Date: Thu, 19 Jan 2017 08:59:00 -0800
Subject: [PATCH 182/200] AP_Notify: DiscoLED: keep includes sorted

---
 libraries/AP_Notify/DiscoLED.cpp | 8 ++++----
 libraries/AP_Notify/DiscoLED.h   | 4 +++-
 2 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/libraries/AP_Notify/DiscoLED.cpp b/libraries/AP_Notify/DiscoLED.cpp
index 8399e6a..327551b 100644
--- a/libraries/AP_Notify/DiscoLED.cpp
+++ b/libraries/AP_Notify/DiscoLED.cpp
@@ -14,13 +14,14 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-
 #include <AP_HAL/AP_HAL.h>
+
 #if CONFIG_HAL_BOARD == HAL_BOARD_LINUX
-#include <AP_HAL_Linux/PWM_Sysfs.h>
-#include <AP_HAL_Linux/Led_Sysfs.h>
 #include "DiscoLED.h"
 
+#include <AP_HAL_Linux/Led_Sysfs.h>
+#include <AP_HAL_Linux/PWM_Sysfs.h>
+
 #define RED_PWM_INDEX   9
 #define GREEN_PWM_INDEX 8
 #define BLUE_PWM_INDEX  15
@@ -74,7 +75,6 @@ bool DiscoLED::hw_init()
 
 bool DiscoLED::hw_set_rgb(uint8_t red, uint8_t green, uint8_t blue)
 {
-
     switch (backend) {
     case PWM_SYSFS:
         red_pwm.set_duty_cycle(red / UINT8_MAX * red_pwm_period);
diff --git a/libraries/AP_Notify/DiscoLED.h b/libraries/AP_Notify/DiscoLED.h
index 760d096..344a125 100644
--- a/libraries/AP_Notify/DiscoLED.h
+++ b/libraries/AP_Notify/DiscoLED.h
@@ -17,9 +17,11 @@
 #pragma once
 
 #include <AP_HAL/AP_HAL.h>
+
 #if CONFIG_HAL_BOARD == HAL_BOARD_LINUX
-#include <AP_HAL_Linux/PWM_Sysfs.h>
 #include <AP_HAL_Linux/Led_Sysfs.h>
+#include <AP_HAL_Linux/PWM_Sysfs.h>
+
 #include "RGBLed.h"
 
 class DiscoLED: public RGBLed

From 83c7217911e2df822f28161e9e3b759cf67bb496 Mon Sep 17 00:00:00 2001
From: Pierre Kancir <pierre.kancir@retdtechfrance.com>
Date: Thu, 19 Jan 2017 15:17:08 +0100
Subject: [PATCH 183/200] AP_IRLock_SITL: correct packet timestamp

---
 libraries/AP_IRLock/AP_IRLock_SITL.cpp | 11 +++++------
 libraries/AP_IRLock/AP_IRLock_SITL.h   |  2 +-
 2 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/libraries/AP_IRLock/AP_IRLock_SITL.cpp b/libraries/AP_IRLock/AP_IRLock_SITL.cpp
index 3ff5b28..f02d52d 100644
--- a/libraries/AP_IRLock/AP_IRLock_SITL.cpp
+++ b/libraries/AP_IRLock/AP_IRLock_SITL.cpp
@@ -62,19 +62,18 @@ bool AP_IRLock_SITL::update()
     // receive packet from Gazebo IRLock plugin
     irlock_packet pkt;
     const int wait_ms = 0;
-    size_t s = sock.recv(&pkt, sizeof(irlock_packet), wait_ms);
+    ssize_t s = sock.recv(&pkt, sizeof(irlock_packet), wait_ms);
 
     bool new_data = false;
-    
-    // fprintf(stderr, "sitl %d %d\n", i, _num_targets);
-    if (s == sizeof(irlock_packet) && pkt.timestamp/1000 > _last_timestamp) {
+
+    if (s == sizeof(irlock_packet) && pkt.timestamp > _last_timestamp) {
         // fprintf(stderr, "     posx %f posy %f sizex %f sizey %f\n", pkt.pos_x, pkt.pos_y, pkt.size_x, pkt.size_y);
-        _target_info.timestamp = pkt.timestamp / 1000;
+        _target_info.timestamp = pkt.timestamp;
         _target_info.pos_x = pkt.pos_x;
         _target_info.pos_y = pkt.pos_y;
         _target_info.size_x = pkt.size_x;
         _target_info.size_y = pkt.size_y;
-        _last_timestamp = pkt.timestamp/1000;
+        _last_timestamp = pkt.timestamp;
         _last_update_ms = _last_timestamp;
         new_data = true;
     }
diff --git a/libraries/AP_IRLock/AP_IRLock_SITL.h b/libraries/AP_IRLock/AP_IRLock_SITL.h
index 2d7a8aa..2f5d5cd 100644
--- a/libraries/AP_IRLock/AP_IRLock_SITL.h
+++ b/libraries/AP_IRLock/AP_IRLock_SITL.h
@@ -27,7 +27,7 @@ class AP_IRLock_SITL : public IRLock
       reply packet sent from simulator to ArduPilot
      */
     struct irlock_packet {
-        uint64_t timestamp;
+        uint64_t timestamp;  // in miliseconds
         uint16_t num_targets;
         float pos_x;
         float pos_y;

From 8a32d09264ab6c2bb602158bd4c83aba65a1ae14 Mon Sep 17 00:00:00 2001
From: murata <ma2maru@gmail.com>
Date: Wed, 28 Dec 2016 23:30:08 +0900
Subject: [PATCH 184/200] AP_Notify: Change arming time count check.

---
 libraries/AP_Notify/AP_BoardLED.cpp | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/libraries/AP_Notify/AP_BoardLED.cpp b/libraries/AP_Notify/AP_BoardLED.cpp
index a1c0277..be8dc06 100644
--- a/libraries/AP_Notify/AP_BoardLED.cpp
+++ b/libraries/AP_Notify/AP_BoardLED.cpp
@@ -119,19 +119,17 @@ void AP_BoardLED::update(void)
             switch(arm_counter) {
                 case 0:
                 case 1:
-                    hal.gpio->write(HAL_GPIO_A_LED_PIN, HAL_GPIO_LED_ON);
-                    break;
-                case 2:
-                    hal.gpio->write(HAL_GPIO_A_LED_PIN, HAL_GPIO_LED_OFF);
-                    break;
                 case 3:
                 case 4:
                     hal.gpio->write(HAL_GPIO_A_LED_PIN, HAL_GPIO_LED_ON);
                     break;
+
+                case 2:
                 case 5:
                 case 6:
                     hal.gpio->write(HAL_GPIO_A_LED_PIN, HAL_GPIO_LED_OFF);
                     break;
+
                 default:
                     arm_counter = -1;
                     break;

From 332820aa88cbdc264e4e419e76aaff7a5759f780 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 20 Jan 2017 11:19:20 +1100
Subject: [PATCH 185/200] Copter: fixed load of var_info for attitude_control
 and motors

we need to pass the var_info for the specific class we are using, not
the parent class.

Fixes issue #5585

thanks to Julien for noticing!
---
 ArduCopter/system.cpp | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index 9ecff11..cbf8aff 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -535,6 +535,8 @@ const char* Copter::get_frame_string()
  */
 void Copter::allocate_motors(void)
 {
+    const struct AP_Param::GroupInfo *var_info;
+    
     switch ((AP_Motors::motor_frame_class)g2.frame_class.get()) {
 #if FRAME_CONFIG != HELI_FRAME
         case AP_Motors::MOTOR_FRAME_QUAD:
@@ -544,37 +546,44 @@ void Copter::allocate_motors(void)
         case AP_Motors::MOTOR_FRAME_OCTAQUAD:
         default:
             motors = new AP_MotorsMatrix(MAIN_LOOP_RATE);
+            var_info = AP_MotorsMatrix::var_info;
             break;
         case AP_Motors::MOTOR_FRAME_TRI:
             motors = new AP_MotorsTri(MAIN_LOOP_RATE);
+            var_info = AP_MotorsTri::var_info;
             break;
         case AP_Motors::MOTOR_FRAME_SINGLE:
             motors = new AP_MotorsSingle(MAIN_LOOP_RATE);
+            var_info = AP_MotorsSingle::var_info;
             break;
         case AP_Motors::MOTOR_FRAME_COAX:
             motors = new AP_MotorsCoax(MAIN_LOOP_RATE);
+            var_info = AP_MotorsCoax::var_info;
             break;
 #else // FRAME_CONFIG == HELI_FRAME
         case AP_Motors::MOTOR_FRAME_HELI:
         default:
             motors = new AP_MotorsHeli_Single(MAIN_LOOP_RATE);
+            var_info = AP_MotorsHeli::var_info;
             break;            
 #endif
     }
     if (motors == nullptr) {
         AP_HAL::panic("Unable to allocate FRAME_CLASS=%u", (unsigned)g2.frame_class.get());
     }
-    AP_Param::load_object_from_eeprom(motors, motors->var_info);
+    AP_Param::load_object_from_eeprom(motors, var_info);
 
 #if FRAME_CONFIG != HELI_FRAME
     attitude_control = new AC_AttitudeControl_Multi(ahrs, aparm, *motors, MAIN_LOOP_SECONDS);
+    var_info = AC_AttitudeControl_Multi::var_info;
 #else
     attitude_control = new AC_AttitudeControl_Heli(ahrs, aparm, *motors, MAIN_LOOP_SECONDS);
+    var_info = AC_AttitudeControl_Heli::var_info;
 #endif
     if (attitude_control == nullptr) {
         AP_HAL::panic("Unable to allocate AttitudeControl");
     }
-    AP_Param::load_object_from_eeprom(attitude_control, attitude_control->var_info);
+    AP_Param::load_object_from_eeprom(attitude_control, var_info);
         
     pos_control = new AC_PosControl(ahrs, inertial_nav, *motors, *attitude_control,
                                     g.p_alt_hold, g.p_vel_z, g.pid_accel_z,

From a6ecb94d247f419c670f2c1e7be05fd6e787208d Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 20 Jan 2017 11:24:05 +1100
Subject: [PATCH 186/200] AP_Motors: MotorsTri does not need its own var_info
 now

---
 libraries/AP_Motors/AP_MotorsTri.cpp | 11 -----------
 libraries/AP_Motors/AP_MotorsTri.h   |  4 ----
 2 files changed, 15 deletions(-)

diff --git a/libraries/AP_Motors/AP_MotorsTri.cpp b/libraries/AP_Motors/AP_MotorsTri.cpp
index 8633bc1..824f1fb 100644
--- a/libraries/AP_Motors/AP_MotorsTri.cpp
+++ b/libraries/AP_Motors/AP_MotorsTri.cpp
@@ -25,17 +25,6 @@
 
 extern const AP_HAL::HAL& hal;
 
-const AP_Param::GroupInfo AP_MotorsTri::var_info[] = {
-    // variables from parent vehicle
-    AP_NESTEDGROUPINFO(AP_MotorsMulticopter, 0),
-
-    // parameters 1 ~ 29 were reserved for tradheli
-    // parameters 30 ~ 39 reserved for tricopter
-    // parameters 40 ~ 49 for single copter and coax copter (these have identical parameter files)
-
-    AP_GROUPEND
-};
-
 // init
 void AP_MotorsTri::init(motor_frame_class frame_class, motor_frame_type frame_type)
 {
diff --git a/libraries/AP_Motors/AP_MotorsTri.h b/libraries/AP_Motors/AP_MotorsTri.h
index 87d8c12..1efd27d 100644
--- a/libraries/AP_Motors/AP_MotorsTri.h
+++ b/libraries/AP_Motors/AP_MotorsTri.h
@@ -21,7 +21,6 @@ class AP_MotorsTri : public AP_MotorsMulticopter {
     AP_MotorsTri(uint16_t loop_rate, uint16_t speed_hz = AP_MOTORS_SPEED_DEFAULT) :
         AP_MotorsMulticopter(loop_rate, speed_hz)
     {
-        AP_Param::setup_object_defaults(this, var_info);
     };
 
     // init
@@ -48,9 +47,6 @@ class AP_MotorsTri : public AP_MotorsMulticopter {
     //  this can be used to ensure other pwm outputs (i.e. for servos) do not conflict
     virtual uint16_t    get_motor_mask();
 
-    // var_info for holding Parameter information
-    static const struct AP_Param::GroupInfo var_info[];
-
 protected:
     // output - sends commands to the motors
     void                output_armed_stabilizing();

From 055acd2a89466958cb2285cffcab8e03822998c0 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Fri, 20 Jan 2017 11:24:18 +0900
Subject: [PATCH 187/200] Build: add description of where binaries will appear

---
 BUILD.md | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/BUILD.md b/BUILD.md
index 820f99b..5f58d09 100644
--- a/BUILD.md
+++ b/BUILD.md
@@ -34,6 +34,8 @@ list some basic and more used commands as example.
     ./waf copter
     ```
 
+    The "arducopter" and "arducopter-heli" binaries should appear in the build/<board-name>/bin directory.
+
 * **List available boards**
 
 

From fdc536e02471364eb1f4dd1ccf35cc57dd226f06 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Fri, 20 Jan 2017 12:16:30 +0900
Subject: [PATCH 188/200] Build: update build.md to add bebop2 instructions

---
 BUILD.md | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/BUILD.md b/BUILD.md
index 5f58d09..e9fbe73 100644
--- a/BUILD.md
+++ b/BUILD.md
@@ -34,7 +34,14 @@ list some basic and more used commands as example.
     ./waf copter
     ```
 
-    The "arducopter" and "arducopter-heli" binaries should appear in the build/<board-name>/bin directory.
+    If building for the bebop2 the binary must be built statically:
+
+    ```sh
+    ./waf configure --board bebop --static
+    ./waf copter
+    ```    
+
+    The "arducopter" and "arducopter-heli" binaries should appear in the `build/<board-name>/bin` directory.
 
 * **List available boards**
 

From 078866046ace4c8cd83eea2dcf2bf649156583ee Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Fri, 20 Jan 2017 13:04:22 +1100
Subject: [PATCH 189/200] Copter: correct rc-arming checks concerning trims

Trims should always be between min and max
---
 ArduCopter/AP_Arming.cpp | 48 +++++++++++++++++++++++++-----------------------
 1 file changed, 25 insertions(+), 23 deletions(-)

diff --git a/ArduCopter/AP_Arming.cpp b/ArduCopter/AP_Arming.cpp
index 2ae2cb4..439b9ec 100644
--- a/ArduCopter/AP_Arming.cpp
+++ b/ArduCopter/AP_Arming.cpp
@@ -343,34 +343,36 @@ void AP_Arming_Copter::pre_arm_rc_checks()
         return;
     }
 
-    RC_Channel *&channel_roll = copter.channel_roll;
-    RC_Channel *&channel_pitch = copter.channel_pitch;
-    RC_Channel *&channel_throttle = copter.channel_throttle;
-    RC_Channel *&channel_yaw = copter.channel_yaw;
-
     // check if radio has been calibrated
-    if (!channel_throttle->min_max_configured()) {
-        return;
-    }
-
-    // check channels 1 & 2 have min <= 1300 and max >= 1700
-    if (channel_roll->get_radio_min() > 1300 || channel_roll->get_radio_max() < 1700 || channel_pitch->get_radio_min() > 1300 || channel_pitch->get_radio_max() < 1700) {
+    if (!copter.channel_throttle->min_max_configured()) {
         return;
     }
 
-    // check channels 3 & 4 have min <= 1300 and max >= 1700
-    if (channel_throttle->get_radio_min() > 1300 || channel_throttle->get_radio_max() < 1700 || channel_yaw->get_radio_min() > 1300 || channel_yaw->get_radio_max() < 1700) {
-        return;
-    }
+    const RC_Channel *channels[] = {
+        copter.channel_roll,
+        copter.channel_pitch,
+        copter.channel_throttle,
+        copter.channel_yaw
+    };
 
-    // check channels 1 & 2 have trim >= 1300 and <= 1700
-    if (channel_roll->get_radio_trim() < 1300 || channel_roll->get_radio_trim() > 1700 || channel_pitch->get_radio_trim() < 1300 || channel_pitch->get_radio_trim() > 1700) {
-        return;
-    }
-
-    // check channel 4 has trim >= 1300 and <= 1700
-    if (channel_yaw->get_radio_trim() < 1300 || channel_yaw->get_radio_trim() > 1700) {
-        return;
+    for (uint8_t i=0; i<ARRAY_SIZE(channels);i++) {
+        const RC_Channel *channel = channels[i];
+        if (channel->get_radio_min() > 1300) {
+            return;
+        }
+        if (channel->get_radio_max() < 1700) {
+            return;
+        }
+        if (i == 2) {
+            // skip checking trim for throttle as older code did not check it
+            continue;
+        }
+        if (channel->get_radio_trim() < channel->get_radio_min()) {
+            return;
+        }
+        if (channel->get_radio_trim() > channel->get_radio_max()) {
+            return;
+        }
     }
 
     // if we've gotten this far rc is ok

From ab13b3beaf382b91de8098d94ebe3852e252169c Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Fri, 20 Jan 2017 13:28:36 +1100
Subject: [PATCH 190/200] Copter: make rc checks verbose on failure

---
 ArduCopter/AP_Arming.cpp       | 18 ++++++++++++++++--
 ArduCopter/AP_Arming.h         |  2 +-
 ArduCopter/compassmot.cpp      |  2 +-
 ArduCopter/esc_calibration.cpp |  2 +-
 ArduCopter/motor_test.cpp      |  2 +-
 ArduCopter/radio.cpp           |  2 +-
 6 files changed, 21 insertions(+), 7 deletions(-)

diff --git a/ArduCopter/AP_Arming.cpp b/ArduCopter/AP_Arming.cpp
index 439b9ec..aad4b29 100644
--- a/ArduCopter/AP_Arming.cpp
+++ b/ArduCopter/AP_Arming.cpp
@@ -89,7 +89,7 @@ bool AP_Arming_Copter::pre_arm_checks(bool display_failure)
 bool AP_Arming_Copter::rc_calibration_checks(bool display_failure)
 {
     // pre-arm rc checks a prerequisite
-    pre_arm_rc_checks();
+    pre_arm_rc_checks(display_failure);
     if (!copter.ap.pre_arm_rc_check) {
         if (display_failure) {
             gcs_send_text(MAV_SEVERITY_CRITICAL,"PreArm: RC not calibrated");
@@ -330,7 +330,7 @@ bool AP_Arming_Copter::pilot_throttle_checks(bool display_failure)
 }
 
 // perform pre_arm_rc_checks checks and set ap.pre_arm_rc_check flag
-void AP_Arming_Copter::pre_arm_rc_checks()
+void AP_Arming_Copter::pre_arm_rc_checks(const bool display_failure)
 {
     // exit immediately if we've already successfully performed the pre-arm rc check
     if (copter.ap.pre_arm_rc_check) {
@@ -354,13 +354,21 @@ void AP_Arming_Copter::pre_arm_rc_checks()
         copter.channel_throttle,
         copter.channel_yaw
     };
+    const char *channel_names[] = { "Roll", "Pitch", "Throttle", "Yaw" };
 
     for (uint8_t i=0; i<ARRAY_SIZE(channels);i++) {
         const RC_Channel *channel = channels[i];
+        const char *channel_name = channel_names[i];
         if (channel->get_radio_min() > 1300) {
+            if (display_failure) {
+                copter.gcs_send_text_fmt(MAV_SEVERITY_CRITICAL,"PreArm: %s radio min too high", channel_name);
+            }
             return;
         }
         if (channel->get_radio_max() < 1700) {
+            if (display_failure) {
+                copter.gcs_send_text_fmt(MAV_SEVERITY_CRITICAL,"PreArm: %s radio max too low", channel_name);
+            }
             return;
         }
         if (i == 2) {
@@ -368,9 +376,15 @@ void AP_Arming_Copter::pre_arm_rc_checks()
             continue;
         }
         if (channel->get_radio_trim() < channel->get_radio_min()) {
+            if (display_failure) {
+                copter.gcs_send_text_fmt(MAV_SEVERITY_CRITICAL,"PreArm: %s radio trim below min", channel_name);
+            }
             return;
         }
         if (channel->get_radio_trim() > channel->get_radio_max()) {
+            if (display_failure) {
+                copter.gcs_send_text_fmt(MAV_SEVERITY_CRITICAL,"PreArm: %s radio trim above max", channel_name);
+            }
             return;
         }
     }
diff --git a/ArduCopter/AP_Arming.h b/ArduCopter/AP_Arming.h
index 4f9cfbd..f2e8903 100644
--- a/ArduCopter/AP_Arming.h
+++ b/ArduCopter/AP_Arming.h
@@ -17,7 +17,7 @@ class AP_Arming_Copter : public AP_Arming
 
     void update(void);
     bool all_checks_passing(bool arming_from_gcs);
-    void pre_arm_rc_checks();
+    void pre_arm_rc_checks(bool display_failure);
 
 protected:
 
diff --git a/ArduCopter/compassmot.cpp b/ArduCopter/compassmot.cpp
index b8619af..addbbec 100644
--- a/ArduCopter/compassmot.cpp
+++ b/ArduCopter/compassmot.cpp
@@ -56,7 +56,7 @@ MAV_RESULT Copter::mavlink_compassmot(mavlink_channel_t chan)
     }
 
     // check if radio is calibrated
-    arming.pre_arm_rc_checks();
+    arming.pre_arm_rc_checks(true);
     if (!ap.pre_arm_rc_check) {
         gcs[chan-MAVLINK_COMM_0].send_text(MAV_SEVERITY_CRITICAL, "RC not calibrated");
         ap.compass_mot = false;
diff --git a/ArduCopter/esc_calibration.cpp b/ArduCopter/esc_calibration.cpp
index cb5d394..3e3bf59 100644
--- a/ArduCopter/esc_calibration.cpp
+++ b/ArduCopter/esc_calibration.cpp
@@ -20,7 +20,7 @@ void Copter::esc_calibration_startup_check()
 {
 #if FRAME_CONFIG != HELI_FRAME
     // exit immediately if pre-arm rc checks fail
-    arming.pre_arm_rc_checks();
+    arming.pre_arm_rc_checks(true);
     if (!ap.pre_arm_rc_check) {
         // clear esc flag for next time
         if ((g.esc_calibrate != ESCCAL_NONE) && (g.esc_calibrate != ESCCAL_DISABLED)) {
diff --git a/ArduCopter/motor_test.cpp b/ArduCopter/motor_test.cpp
index 8469d4a..4e871a3 100644
--- a/ArduCopter/motor_test.cpp
+++ b/ArduCopter/motor_test.cpp
@@ -73,7 +73,7 @@ void Copter::motor_test_output()
 bool Copter::mavlink_motor_test_check(mavlink_channel_t chan, bool check_rc)
 {
     // check rc has been calibrated
-    arming.pre_arm_rc_checks();
+    arming.pre_arm_rc_checks(true);
     if(check_rc && !ap.pre_arm_rc_check) {
         gcs[chan-MAVLINK_COMM_0].send_text(MAV_SEVERITY_CRITICAL,"Motor Test: RC not calibrated");
         return false;
diff --git a/ArduCopter/radio.cpp b/ArduCopter/radio.cpp
index 8ace7de..3816ae0 100644
--- a/ArduCopter/radio.cpp
+++ b/ArduCopter/radio.cpp
@@ -68,7 +68,7 @@ void Copter::init_rc_out()
     esc_calibration_startup_check();
 
     // enable output to motors
-    arming.pre_arm_rc_checks();
+    arming.pre_arm_rc_checks(true);
     if (ap.pre_arm_rc_check) {
         enable_motor_output();
     }

From a481e5286186e091ba4187f360d999056e2560f1 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Fri, 20 Jan 2017 13:29:17 +1100
Subject: [PATCH 191/200] AP_Param: make configured() const

---
 libraries/AP_Param/AP_Param.cpp | 4 ++--
 libraries/AP_Param/AP_Param.h   | 6 +++---
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/libraries/AP_Param/AP_Param.cpp b/libraries/AP_Param/AP_Param.cpp
index d18cecc..907f0bd 100644
--- a/libraries/AP_Param/AP_Param.cpp
+++ b/libraries/AP_Param/AP_Param.cpp
@@ -1070,7 +1070,7 @@ bool AP_Param::load(void)
     return true;
 }
 
-bool AP_Param::configured_in_storage(void)
+bool AP_Param::configured_in_storage(void) const
 {
     uint32_t group_element = 0;
     const struct GroupInfo *ginfo;
@@ -1100,7 +1100,7 @@ bool AP_Param::configured_in_storage(void)
     return scan(&phdr, &ofs) && (phdr.type == AP_PARAM_VECTOR3F || idx == 0);
 }
 
-bool AP_Param::configured_in_defaults_file(void)
+bool AP_Param::configured_in_defaults_file(void) const
 {
     uint32_t group_element = 0;
     const struct GroupInfo *ginfo;
diff --git a/libraries/AP_Param/AP_Param.h b/libraries/AP_Param/AP_Param.h
index e5c43a3..3f231a4 100644
--- a/libraries/AP_Param/AP_Param.h
+++ b/libraries/AP_Param/AP_Param.h
@@ -350,13 +350,13 @@ class AP_Param
     static bool             check_var_info(void);
 
     // return true if the parameter is configured in the defaults file
-    bool configured_in_defaults_file(void);
+    bool configured_in_defaults_file(void) const;
 
     // return true if the parameter is configured in EEPROM/FRAM
-    bool configured_in_storage(void);
+    bool configured_in_storage(void) const;
 
     // return true if the parameter is configured
-    bool configured(void) { return configured_in_defaults_file() || configured_in_storage(); }
+    bool configured(void) const { return configured_in_defaults_file() || configured_in_storage(); }
 
     // count of parameters in tree
     static uint16_t count_parameters(void);

From d2b2ddcb02e14ad555d277070134ecb9702a8ca2 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Fri, 20 Jan 2017 13:29:37 +1100
Subject: [PATCH 192/200] RC_Channel: make min_max_configured const

---
 libraries/RC_Channel/RC_Channel.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/RC_Channel/RC_Channel.h b/libraries/RC_Channel/RC_Channel.h
index 0e44341..7540dae 100644
--- a/libraries/RC_Channel/RC_Channel.h
+++ b/libraries/RC_Channel/RC_Channel.h
@@ -95,7 +95,7 @@ class RC_Channel {
     void       set_radio_trim(int16_t val) { radio_trim.set(val);}
     void       save_radio_trim() { radio_trim.save();}
 
-    bool min_max_configured()
+    bool min_max_configured() const
     {
         return radio_min.configured() && radio_max.configured();
     }

From e7d3219a587511559267fe2ba532391354a36e12 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Fri, 20 Jan 2017 13:40:42 +1100
Subject: [PATCH 193/200] Copter: check all channels have been configured, not
 just throttle

---
 ArduCopter/AP_Arming.cpp | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/ArduCopter/AP_Arming.cpp b/ArduCopter/AP_Arming.cpp
index aad4b29..a72534e 100644
--- a/ArduCopter/AP_Arming.cpp
+++ b/ArduCopter/AP_Arming.cpp
@@ -343,11 +343,6 @@ void AP_Arming_Copter::pre_arm_rc_checks(const bool display_failure)
         return;
     }
 
-    // check if radio has been calibrated
-    if (!copter.channel_throttle->min_max_configured()) {
-        return;
-    }
-
     const RC_Channel *channels[] = {
         copter.channel_roll,
         copter.channel_pitch,
@@ -359,6 +354,13 @@ void AP_Arming_Copter::pre_arm_rc_checks(const bool display_failure)
     for (uint8_t i=0; i<ARRAY_SIZE(channels);i++) {
         const RC_Channel *channel = channels[i];
         const char *channel_name = channel_names[i];
+        // check if radio has been calibrated
+        if (!channel->min_max_configured()) {
+            if (display_failure) {
+                copter.gcs_send_text_fmt(MAV_SEVERITY_CRITICAL,"PreArm: %s not configured", channel_name);
+            }
+            return;
+        }
         if (channel->get_radio_min() > 1300) {
             if (display_failure) {
                 copter.gcs_send_text_fmt(MAV_SEVERITY_CRITICAL,"PreArm: %s radio min too high", channel_name);

From 01b1916de52e1e1db690cbd25dc57dd43fd4e149 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Fri, 20 Jan 2017 13:57:40 +1100
Subject: [PATCH 194/200] Copter: ensure logging is working as part of prearm

---
 ArduCopter/AP_Arming.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/ArduCopter/AP_Arming.cpp b/ArduCopter/AP_Arming.cpp
index a72534e..ab2d8e2 100644
--- a/ArduCopter/AP_Arming.cpp
+++ b/ArduCopter/AP_Arming.cpp
@@ -81,6 +81,7 @@ bool AP_Arming_Copter::pre_arm_checks(bool display_failure)
         & fence_checks(display_failure)
         & ins_checks(display_failure)
         & board_voltage_checks(display_failure)
+        & logging_checks(display_failure)
         & parameter_checks(display_failure)
         & motor_checks(display_failure)
         & pilot_throttle_checks(display_failure);

From b27e4dbd0ca54256d227a8e266e8b1335c400e75 Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Fri, 20 Jan 2017 16:29:04 +1100
Subject: [PATCH 195/200] autotest: added FRAME_CLASS for gazebo-iris

---
 Tools/autotest/default_params/gazebo-iris.parm | 1 +
 1 file changed, 1 insertion(+)

diff --git a/Tools/autotest/default_params/gazebo-iris.parm b/Tools/autotest/default_params/gazebo-iris.parm
index 7e7b756..b6bf0d6 100644
--- a/Tools/autotest/default_params/gazebo-iris.parm
+++ b/Tools/autotest/default_params/gazebo-iris.parm
@@ -3,6 +3,7 @@ PLND_TYPE       2
 POS_XY_P        2
 VEL_XY_P        0.6
 # Iris is X frame
+FRAME_CLASS	1
 FRAME_TYPE	1
 
 COMPASS_OFS_X   5

From 0c4e3cd8e4c5b974c8baf7caad39071653f6f782 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Sat, 21 Jan 2017 10:15:11 +0900
Subject: [PATCH 196/200] Compass: pixracer calibration fitness default relaxed

---
 libraries/AP_Compass/AP_Compass.cpp | 2 +-
 libraries/AP_Compass/AP_Compass.h   | 6 ++++++
 2 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/libraries/AP_Compass/AP_Compass.cpp b/libraries/AP_Compass/AP_Compass.cpp
index 57df804..f21806f 100644
--- a/libraries/AP_Compass/AP_Compass.cpp
+++ b/libraries/AP_Compass/AP_Compass.cpp
@@ -401,7 +401,7 @@ const AP_Param::GroupInfo Compass::var_info[] = {
     // @Values: 4:Very Strict,8:Default,16:Relaxed,32:Very Relaxed
     // @Increment: 0.1
     // @User: Advanced
-    AP_GROUPINFO("CAL_FIT", 30, Compass, _calibration_threshold, 8.0f),
+    AP_GROUPINFO("CAL_FIT", 30, Compass, _calibration_threshold, AP_COMPASS_CALIBRATION_FITNESS_DEFAULT),
 
     AP_GROUPEND
 };
diff --git a/libraries/AP_Compass/AP_Compass.h b/libraries/AP_Compass/AP_Compass.h
index cb28461..397d948 100644
--- a/libraries/AP_Compass/AP_Compass.h
+++ b/libraries/AP_Compass/AP_Compass.h
@@ -29,6 +29,12 @@
 # define MAG_BOARD_ORIENTATION ROTATION_NONE
 #endif
 
+// define default compass calibration fitness
+#if CONFIG_HAL_BOARD == HAL_BOARD_PX4 && CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_PX4_V4
+# define AP_COMPASS_CALIBRATION_FITNESS_DEFAULT 16.0f
+#else
+# define AP_COMPASS_CALIBRATION_FITNESS_DEFAULT 8.0f
+#endif
 /**
    maximum number of compass instances available on this platform. If more
    than 1 then redundant sensors may be available

From 53d1585ebfe0ccfe394cf8ec4cd9dcb11b239be5 Mon Sep 17 00:00:00 2001
From: Randy Mackay <rmackay9@yahoo.com>
Date: Sat, 21 Jan 2017 12:08:35 +0900
Subject: [PATCH 197/200] Compass: relax compass consistency checks for
 pixracer

---
 libraries/AP_Compass/AP_Compass.h | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/libraries/AP_Compass/AP_Compass.h b/libraries/AP_Compass/AP_Compass.h
index 397d948..6cebbea 100644
--- a/libraries/AP_Compass/AP_Compass.h
+++ b/libraries/AP_Compass/AP_Compass.h
@@ -29,11 +29,17 @@
 # define MAG_BOARD_ORIENTATION ROTATION_NONE
 #endif
 
-// define default compass calibration fitness
+// define default compass calibration fitness and consistency checks
 #if CONFIG_HAL_BOARD == HAL_BOARD_PX4 && CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_PX4_V4
 # define AP_COMPASS_CALIBRATION_FITNESS_DEFAULT 16.0f
+# define AP_COMPASS_MAX_XYZ_ANG_DIFF radians(75.0f)
+# define AP_COMPASS_MAX_XY_ANG_DIFF radians(45.0f)
+# define AP_COMPASS_MAX_XY_LENGTH_DIFF 150.0f
 #else
 # define AP_COMPASS_CALIBRATION_FITNESS_DEFAULT 8.0f
+# define AP_COMPASS_MAX_XYZ_ANG_DIFF radians(50.0f)
+# define AP_COMPASS_MAX_XY_ANG_DIFF radians(30.0f)
+# define AP_COMPASS_MAX_XY_LENGTH_DIFF 100.0f
 #endif
 /**
    maximum number of compass instances available on this platform. If more
@@ -42,10 +48,6 @@
 #define COMPASS_MAX_INSTANCES 3
 #define COMPASS_MAX_BACKEND   3
 
-#define AP_COMPASS_MAX_XYZ_ANG_DIFF radians(50.0f)
-#define AP_COMPASS_MAX_XY_ANG_DIFF radians(30.0f)
-#define AP_COMPASS_MAX_XY_LENGTH_DIFF 100.0f
-
 class Compass
 {
 friend class AP_Compass_Backend;

From 591bb32496e2556be977af4f9bc0ee8167dfc810 Mon Sep 17 00:00:00 2001
From: Peter Barker <pbarker@barker.dropbear.id.au>
Date: Sat, 21 Jan 2017 15:54:02 +1100
Subject: [PATCH 198/200] AP_Mission: correct off-by-one check when fetching
 mission items

---
 libraries/AP_Mission/AP_Mission.cpp | 2 +-
 libraries/AP_Mission/AP_Mission.h   | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/libraries/AP_Mission/AP_Mission.cpp b/libraries/AP_Mission/AP_Mission.cpp
index 7cfc797..7433e8d 100644
--- a/libraries/AP_Mission/AP_Mission.cpp
+++ b/libraries/AP_Mission/AP_Mission.cpp
@@ -429,7 +429,7 @@ bool AP_Mission::set_current_cmd(uint16_t index)
 bool AP_Mission::read_cmd_from_storage(uint16_t index, Mission_Command& cmd) const
 {
     // exit immediately if index is beyond last command but we always let cmd #0 (i.e. home) be read
-    if (index > (unsigned)_cmd_total && index != 0) {
+    if (index >= (unsigned)_cmd_total && index != 0) {
         return false;
     }
 
diff --git a/libraries/AP_Mission/AP_Mission.h b/libraries/AP_Mission/AP_Mission.h
index 45346bf..019169a 100644
--- a/libraries/AP_Mission/AP_Mission.h
+++ b/libraries/AP_Mission/AP_Mission.h
@@ -294,6 +294,7 @@ class AP_Mission {
     mission_state state() const { return _flags.state; }
 
     /// num_commands - returns total number of commands in the mission
+    ///                 this number includes offset 0, the home location
     uint16_t num_commands() const { return _cmd_total; }
 
     /// num_commands_max - returns maximum number of commands that can be stored

From d472fbde0c76192e2e5ceb3337a01d36848403f9 Mon Sep 17 00:00:00 2001
From: Francisco Ferreira <francisco-ferreira@mail.telepac.pt>
Date: Sat, 21 Jan 2017 20:26:28 +0000
Subject: [PATCH 199/200] AP_GPS: fix PX4 GPS driver leap seconds

---
 libraries/AP_GPS/AP_GPS_PX4.cpp | 13 +++++--------
 1 file changed, 5 insertions(+), 8 deletions(-)

diff --git a/libraries/AP_GPS/AP_GPS_PX4.cpp b/libraries/AP_GPS/AP_GPS_PX4.cpp
index 23fd525..a2edff4 100644
--- a/libraries/AP_GPS/AP_GPS_PX4.cpp
+++ b/libraries/AP_GPS/AP_GPS_PX4.cpp
@@ -42,11 +42,6 @@ AP_GPS_PX4::~AP_GPS_PX4()
 	orb_unsubscribe(_gps_sub);
 }
 
-
-const uint64_t MS_PER_WEEK            = ((uint64_t)7)*24*3600*1000;
-const uint64_t DELTA_POSIX_GPS_EPOCH  = ((uint64_t)3657)*24*3600*1000;
-const uint64_t LEAP_MS_GPS_2016       = ((uint64_t)17)*1000;
-
 // update internal state if new GPS information is available
 bool
 AP_GPS_PX4::read(void)
@@ -72,10 +67,12 @@ AP_GPS_PX4::read(void)
 
                 // convert epoch timestamp back to gps epoch - evil hack until we get the genuine
                 // raw week information (or APM switches to Posix epoch ;-) )
+                const uint64_t posix_offset = 3657ULL * 24 * 3600 * 1000 - GPS_LEAPSECONDS_MILLIS;
+                const uint64_t ms_per_week = 7ULL * 24 * 3600 * 1000;
                 uint64_t epoch_ms = _gps_pos.time_utc_usec/1000;
-                uint64_t gps_ms = epoch_ms - DELTA_POSIX_GPS_EPOCH + LEAP_MS_GPS_2016;
-                state.time_week = (uint16_t)(gps_ms / MS_PER_WEEK);
-                state.time_week_ms = (uint32_t)(gps_ms - (state.time_week)*MS_PER_WEEK);
+                uint64_t gps_ms = epoch_ms - posix_offset;
+                state.time_week = (uint16_t)(gps_ms / ms_per_week);
+                state.time_week_ms = (uint32_t)(gps_ms - (state.time_week) * ms_per_week);
 
                 if (_gps_pos.time_utc_usec == 0) {
                   // This is a work-around for https://github.com/PX4/Firmware/issues/1474

From 09c969477ff66c39c6ee3163eea6bed5ab065e2c Mon Sep 17 00:00:00 2001
From: Andrew Tridgell <andrew@tridgell.net>
Date: Sun, 22 Jan 2017 13:39:54 +1100
Subject: [PATCH 200/200] AP_AHRS: fixed fallback to DCM for get_position

this fixes dead-reckoning on fixed wing on GPS loss, and fallback to
DCM on loss of EKF position in fixed wing

This was broken by the EKF3 merge
---
 libraries/AP_AHRS/AP_AHRS_NavEKF.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp b/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp
index 1834e6b..ec6703a 100644
--- a/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp
+++ b/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp
@@ -323,7 +323,7 @@ bool AP_AHRS_NavEKF::get_position(struct Location &loc) const
     Location origin;
     switch (active_EKF_type()) {
     case EKF_TYPE_NONE:
-        return false;
+        return AP_AHRS_DCM::get_position(loc);
 
     case EKF_TYPE2:
         if (EKF2.getLLH(loc) && EKF2.getPosD(-1,ned_pos.z) && EKF2.getOriginLLH(origin)) {
