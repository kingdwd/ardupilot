# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/polygon.cpp"
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot//"
# 1 "<built-in>"
#define __STDC__ 1
#define __cplusplus 201103L
#define __STDC_HOSTED__ 1
#define __GNUC__ 4
#define __GNUC_MINOR__ 9
#define __GNUC_PATCHLEVEL__ 3
#define __VERSION__ "4.9.3 20141119 (release) [ARM/embedded-4_9-branch revision 218278]"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __OPTIMIZE_SIZE__ 1
#define __OPTIMIZE__ 1
#define __FINITE_MATH_ONLY__ 0
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 4
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 8
#define __SIZEOF_SIZE_T__ 4
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 8
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 4
#define __GNUG__ 4
#define __SIZE_TYPE__ unsigned int
#define __PTRDIFF_TYPE__ int
#define __WCHAR_TYPE__ unsigned int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long long int
#define __UINTMAX_TYPE__ long long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ long unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ long int
#define __INT64_TYPE__ long long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ long unsigned int
#define __UINT64_TYPE__ long long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ long int
#define __INT_LEAST64_TYPE__ long long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ long unsigned int
#define __UINT_LEAST64_TYPE__ long long unsigned int
#define __INT_FAST8_TYPE__ int
#define __INT_FAST16_TYPE__ int
#define __INT_FAST32_TYPE__ int
#define __INT_FAST64_TYPE__ long long int
#define __UINT_FAST8_TYPE__ unsigned int
#define __UINT_FAST16_TYPE__ unsigned int
#define __UINT_FAST32_TYPE__ unsigned int
#define __UINT_FAST64_TYPE__ long long unsigned int
#define __INTPTR_TYPE__ int
#define __UINTPTR_TYPE__ unsigned int
#define __has_include(STR) __has_include__(STR)
#define __has_include_next(STR) __has_include_next__(STR)
#define __GXX_WEAK__ 1
#define __DEPRECATED 1
#define __GXX_EXPERIMENTAL_CXX0X__ 1
#define __cpp_binary_literals 201304
#define __cpp_unicode_characters 200704
#define __cpp_raw_strings 200710
#define __cpp_unicode_literals 200710
#define __cpp_user_defined_literals 200809
#define __cpp_lambdas 200907
#define __cpp_constexpr 200704
#define __cpp_static_assert 200410
#define __cpp_decltype 200707
#define __cpp_attributes 200809
#define __cpp_rvalue_reference 200610
#define __cpp_variadic_templates 200704
#define __cpp_alias_templates 200704
#define __GXX_ABI_VERSION 1002
#define __SCHAR_MAX__ 127
#define __SHRT_MAX__ 32767
#define __INT_MAX__ 2147483647
#define __LONG_MAX__ 2147483647L
#define __LONG_LONG_MAX__ 9223372036854775807LL
#define __WCHAR_MAX__ 4294967295U
#define __WCHAR_MIN__ 0U
#define __WINT_MAX__ 4294967295U
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 2147483647
#define __SIZE_MAX__ 4294967295U
#define __INTMAX_MAX__ 9223372036854775807LL
#define __INTMAX_C(c) c ## LL
#define __UINTMAX_MAX__ 18446744073709551615ULL
#define __UINTMAX_C(c) c ## ULL
#define __SIG_ATOMIC_MAX__ 2147483647
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __INT8_MAX__ 127
#define __INT16_MAX__ 32767
#define __INT32_MAX__ 2147483647L
#define __INT64_MAX__ 9223372036854775807LL
#define __UINT8_MAX__ 255
#define __UINT16_MAX__ 65535
#define __UINT32_MAX__ 4294967295UL
#define __UINT64_MAX__ 18446744073709551615ULL
#define __INT_LEAST8_MAX__ 127
#define __INT8_C(c) c
#define __INT_LEAST16_MAX__ 32767
#define __INT16_C(c) c
#define __INT_LEAST32_MAX__ 2147483647L
#define __INT32_C(c) c ## L
#define __INT_LEAST64_MAX__ 9223372036854775807LL
#define __INT64_C(c) c ## LL
#define __UINT_LEAST8_MAX__ 255
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 65535
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 4294967295UL
#define __UINT32_C(c) c ## UL
#define __UINT_LEAST64_MAX__ 18446744073709551615ULL
#define __UINT64_C(c) c ## ULL
#define __INT_FAST8_MAX__ 2147483647
#define __INT_FAST16_MAX__ 2147483647
#define __INT_FAST32_MAX__ 2147483647
#define __INT_FAST64_MAX__ 9223372036854775807LL
#define __UINT_FAST8_MAX__ 4294967295U
#define __UINT_FAST16_MAX__ 4294967295U
#define __UINT_FAST32_MAX__ 4294967295U
#define __UINT_FAST64_MAX__ 18446744073709551615ULL
#define __INTPTR_MAX__ 2147483647
#define __UINTPTR_MAX__ 4294967295U
#define __GCC_IEC_559 0
#define __GCC_IEC_559_COMPLEX 0
#define __FLT_EVAL_METHOD__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.4028234663852886e+38F
#define __FLT_MIN__ 1.1754943508222875e-38F
#define __FLT_EPSILON__ 1.1920928955078125e-7F
#define __FLT_DENORM_MIN__ 1.4012984643248171e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __FP_FAST_FMAF 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ double(1.7976931348623157e+308L)
#define __DBL_MIN__ double(2.2250738585072014e-308L)
#define __DBL_EPSILON__ double(2.2204460492503131e-16L)
#define __DBL_DENORM_MIN__ double(4.9406564584124654e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 53
#define __LDBL_DIG__ 15
#define __LDBL_MIN_EXP__ (-1021)
#define __LDBL_MIN_10_EXP__ (-307)
#define __LDBL_MAX_EXP__ 1024
#define __LDBL_MAX_10_EXP__ 308
#define __DECIMAL_DIG__ 17
#define __LDBL_MAX__ 1.7976931348623157e+308L
#define __LDBL_MIN__ 2.2250738585072014e-308L
#define __LDBL_EPSILON__ 2.2204460492503131e-16L
#define __LDBL_DENORM_MIN__ 4.9406564584124654e-324L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __SFRACT_FBIT__ 7
#define __SFRACT_IBIT__ 0
#define __SFRACT_MIN__ (-0.5HR-0.5HR)
#define __SFRACT_MAX__ 0X7FP-7HR
#define __SFRACT_EPSILON__ 0x1P-7HR
#define __USFRACT_FBIT__ 8
#define __USFRACT_IBIT__ 0
#define __USFRACT_MIN__ 0.0UHR
#define __USFRACT_MAX__ 0XFFP-8UHR
#define __USFRACT_EPSILON__ 0x1P-8UHR
#define __FRACT_FBIT__ 15
#define __FRACT_IBIT__ 0
#define __FRACT_MIN__ (-0.5R-0.5R)
#define __FRACT_MAX__ 0X7FFFP-15R
#define __FRACT_EPSILON__ 0x1P-15R
#define __UFRACT_FBIT__ 16
#define __UFRACT_IBIT__ 0
#define __UFRACT_MIN__ 0.0UR
#define __UFRACT_MAX__ 0XFFFFP-16UR
#define __UFRACT_EPSILON__ 0x1P-16UR
#define __LFRACT_FBIT__ 31
#define __LFRACT_IBIT__ 0
#define __LFRACT_MIN__ (-0.5LR-0.5LR)
#define __LFRACT_MAX__ 0X7FFFFFFFP-31LR
#define __LFRACT_EPSILON__ 0x1P-31LR
#define __ULFRACT_FBIT__ 32
#define __ULFRACT_IBIT__ 0
#define __ULFRACT_MIN__ 0.0ULR
#define __ULFRACT_MAX__ 0XFFFFFFFFP-32ULR
#define __ULFRACT_EPSILON__ 0x1P-32ULR
#define __LLFRACT_FBIT__ 63
#define __LLFRACT_IBIT__ 0
#define __LLFRACT_MIN__ (-0.5LLR-0.5LLR)
#define __LLFRACT_MAX__ 0X7FFFFFFFFFFFFFFFP-63LLR
#define __LLFRACT_EPSILON__ 0x1P-63LLR
#define __ULLFRACT_FBIT__ 64
#define __ULLFRACT_IBIT__ 0
#define __ULLFRACT_MIN__ 0.0ULLR
#define __ULLFRACT_MAX__ 0XFFFFFFFFFFFFFFFFP-64ULLR
#define __ULLFRACT_EPSILON__ 0x1P-64ULLR
#define __SACCUM_FBIT__ 7
#define __SACCUM_IBIT__ 8
#define __SACCUM_MIN__ (-0X1P7HK-0X1P7HK)
#define __SACCUM_MAX__ 0X7FFFP-7HK
#define __SACCUM_EPSILON__ 0x1P-7HK
#define __USACCUM_FBIT__ 8
#define __USACCUM_IBIT__ 8
#define __USACCUM_MIN__ 0.0UHK
#define __USACCUM_MAX__ 0XFFFFP-8UHK
#define __USACCUM_EPSILON__ 0x1P-8UHK
#define __ACCUM_FBIT__ 15
#define __ACCUM_IBIT__ 16
#define __ACCUM_MIN__ (-0X1P15K-0X1P15K)
#define __ACCUM_MAX__ 0X7FFFFFFFP-15K
#define __ACCUM_EPSILON__ 0x1P-15K
#define __UACCUM_FBIT__ 16
#define __UACCUM_IBIT__ 16
#define __UACCUM_MIN__ 0.0UK
#define __UACCUM_MAX__ 0XFFFFFFFFP-16UK
#define __UACCUM_EPSILON__ 0x1P-16UK
#define __LACCUM_FBIT__ 31
#define __LACCUM_IBIT__ 32
#define __LACCUM_MIN__ (-0X1P31LK-0X1P31LK)
#define __LACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LK
#define __LACCUM_EPSILON__ 0x1P-31LK
#define __ULACCUM_FBIT__ 32
#define __ULACCUM_IBIT__ 32
#define __ULACCUM_MIN__ 0.0ULK
#define __ULACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULK
#define __ULACCUM_EPSILON__ 0x1P-32ULK
#define __LLACCUM_FBIT__ 31
#define __LLACCUM_IBIT__ 32
#define __LLACCUM_MIN__ (-0X1P31LLK-0X1P31LLK)
#define __LLACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LLK
#define __LLACCUM_EPSILON__ 0x1P-31LLK
#define __ULLACCUM_FBIT__ 32
#define __ULLACCUM_IBIT__ 32
#define __ULLACCUM_MIN__ 0.0ULLK
#define __ULLACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULLK
#define __ULLACCUM_EPSILON__ 0x1P-32ULLK
#define __QQ_FBIT__ 7
#define __QQ_IBIT__ 0
#define __HQ_FBIT__ 15
#define __HQ_IBIT__ 0
#define __SQ_FBIT__ 31
#define __SQ_IBIT__ 0
#define __DQ_FBIT__ 63
#define __DQ_IBIT__ 0
#define __TQ_FBIT__ 127
#define __TQ_IBIT__ 0
#define __UQQ_FBIT__ 8
#define __UQQ_IBIT__ 0
#define __UHQ_FBIT__ 16
#define __UHQ_IBIT__ 0
#define __USQ_FBIT__ 32
#define __USQ_IBIT__ 0
#define __UDQ_FBIT__ 64
#define __UDQ_IBIT__ 0
#define __UTQ_FBIT__ 128
#define __UTQ_IBIT__ 0
#define __HA_FBIT__ 7
#define __HA_IBIT__ 8
#define __SA_FBIT__ 15
#define __SA_IBIT__ 16
#define __DA_FBIT__ 31
#define __DA_IBIT__ 32
#define __TA_FBIT__ 63
#define __TA_IBIT__ 64
#define __UHA_FBIT__ 8
#define __UHA_IBIT__ 8
#define __USA_FBIT__ 16
#define __USA_IBIT__ 16
#define __UDA_FBIT__ 32
#define __UDA_IBIT__ 32
#define __UTA_FBIT__ 64
#define __UTA_IBIT__ 64
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __GNUC_STDC_INLINE__ 1
#define __CHAR_UNSIGNED__ 1
#define __WCHAR_UNSIGNED__ 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __GCC_ATOMIC_LLONG_LOCK_FREE 1
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 4
#define __ARM_FEATURE_DSP 1
#define __ARM_FEATURE_QBIT 1
#define __ARM_FEATURE_SAT 1
#define __ARM_FEATURE_UNALIGNED 1
#define __ARM_32BIT_STATE 1
#define __ARM_FEATURE_LDREX 7
#define __ARM_FEATURE_CLZ 1
#define __ARM_FEATURE_SIMD32 1
#define __ARM_SIZEOF_MINIMAL_ENUM 1
#define __ARM_SIZEOF_WCHAR_T 32
#define __ARM_ARCH_PROFILE 77
#define __arm__ 1
#define __ARM_ARCH 7
#define __APCS_32__ 1
#define __thumb__ 1
#define __thumb2__ 1
#define __ARM_ARCH_ISA_THUMB 2
#define __ARMEL__ 1
#define __THUMBEL__ 1
#define __VFP_FP__ 1
#define __ARM_FP 4
#define __ARM_FEATURE_FMA 1
#define __ARM_NEON_FP 4
#define __THUMB_INTERWORK__ 1
#define __ARM_ARCH_7EM__ 1
#define __ARM_PCS_VFP 1
#define __ARM_EABI__ 1
#define __ARM_ARCH_EXT_IDIV__ 1
#define __GXX_TYPEINFO_EQUALITY_INLINE 0
#define __ELF__ 1
# 1 "<command-line>"
#define __USES_INITFINI__ 1
#define __CUSTOM_FILE_IO__ 1
#define CONFIG_ARCH_BOARD_PX4FMU_V2 1
#define __PX4_NUTTX 1
#define CONFIG_WCHAR_BUILTIN 1
#define ARDUPILOT_BUILD 1
#define TESTS_MATHLIB_DISABLE 1
#define CONFIG_HAL_BOARD HAL_BOARD_PX4
#define SKETCHNAME "ArduPlane"
#define SKETCH_MAIN ArduPilot_main
#define APM_BUILD_DIRECTORY APM_BUILD_ArduPlane
#define GIT_VERSION "90516f10"
#define MAVLINK_PROTOCOL_VERSION 2
#define NUTTX_GIT_VERSION "be6ff61a"
#define PX4_GIT_VERSION "3df5644c"
#define UAVCAN 1
#define __STDC_FORMAT_MACROS 1
#define HAVE_STD_NULLPTR_T 0
#define HAVE_ENDIAN_H 0
#define HAVE_BYTESWAP_H 0
#define HAVE_OCLOEXEC 0
#define PX4_MAIN ArduPilot_app_main
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/src/include/visibility.h" 1
# 43 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/src/include/visibility.h"
#define __SYSTEMLIB_VISIBILITY_H 




#define __EXPORT __attribute__ ((visibility ("default")))




#define __PRIVATE __attribute__ ((visibility ("hidden")))


#define __BEGIN_DECLS extern "C" {
#define __END_DECLS }
# 1 "<command-line>" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/polygon.cpp"
# 19 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/polygon.cpp"
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 1
       

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/missing/cmath" 1
       

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/cxx/cmath" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/cxx/cmath"
#define __INCLUDE_CXX_CMATH 





# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/config.h" 1



#define __INCLUDE_NUTTX_CONFIG_H 



#define CONFIG_NUTTX_NEWCONFIG 1
#define CONFIG_HOST_OSX 1
#define CONFIG_RAW_BINARY 1
#define CONFIG_ARCH_MATH_H 1
#undef CONFIG_DEBUG
#undef CONFIG_DEBUG_VERBOSE
#define CONFIG_DEBUG_DMA 1
#define CONFIG_DEBUG_SYMBOLS 1
#define CONFIG_ARCH_ARM 1
#define CONFIG_ARCH "arm"
#define CONFIG_ARCH_CHIP_STM32 1
#define CONFIG_ARCH_CORTEXM4 1
#define CONFIG_ARCH_FAMILY "armv7-m"
#define CONFIG_ARCH_CHIP "stm32"
#define CONFIG_ARMV7M_USEBASEPRI 1
#define CONFIG_ARCH_HAVE_CMNVECTOR 1
#define CONFIG_ARMV7M_CMNVECTOR 1
#define CONFIG_ARCH_HAVE_FPU 1
#define CONFIG_ARCH_FPU 1
#define CONFIG_ARCH_HAVE_MPU 1
#define CONFIG_ARMV7M_TOOLCHAIN_GNU_EABI 1
#undef CONFIG_ARMV7M_STACKCHECK
#define CONFIG_SERIAL_TERMIOS 1
#define CONFIG_SDIO_DMA 1
#define CONFIG_SDIO_DMAPRIO 0x00010000
#define CONFIG_ARCH_CHIP_STM32F427V 1
#define CONFIG_STM32_STM32F40XX 1
#define CONFIG_STM32_STM32F427 1
#define CONFIG_STM32_ADC1 1
#define CONFIG_STM32_BKPSRAM 1
#define CONFIG_STM32_CCMDATARAM 1
#define CONFIG_STM32_DMA1 1
#define CONFIG_STM32_DMA2 1
#define CONFIG_STM32_I2C1 1
#define CONFIG_STM32_I2C2 1
#define CONFIG_STM32_OTGFS 1
#define CONFIG_STM32_PWR 1
#define CONFIG_STM32_SDIO 1
#define CONFIG_STM32_SPI1 1
#define CONFIG_STM32_SPI2 1
#define CONFIG_STM32_SPI4 1
#define CONFIG_STM32_SYSCFG 1
#define CONFIG_STM32_TIM1 1
#define CONFIG_STM32_TIM3 1
#define CONFIG_STM32_TIM4 1
#define CONFIG_STM32_TIM9 1
#define CONFIG_STM32_TIM10 1
#define CONFIG_STM32_TIM11 1
#define CONFIG_STM32_USART1 1
#define CONFIG_STM32_USART2 1
#define CONFIG_STM32_USART3 1
#define CONFIG_STM32_UART4 1
#define CONFIG_STM32_USART6 1
#define CONFIG_STM32_UART7 1
#define CONFIG_STM32_UART8 1
#define CONFIG_STM32_WWDG 1
#define CONFIG_STM32_ADC 1
#define CONFIG_STM32_SPI 1
#define CONFIG_STM32_I2C 1
#define CONFIG_STM32_FLASH_PREFETCH 1
#define CONFIG_STM32_JTAG_SW_ENABLE 1
#define CONFIG_STM32_DISABLE_IDLE_SLEEP_DURING_DEBUG 1
#define CONFIG_STM32_DMACAPABLE 1
#define CONFIG_STM32_USART 1
#define CONFIG_STM32_RXDMA_BUFFER_SIZE_OVERRIDE 256
#define CONFIG_USART2_RXDMA 1
#define CONFIG_USART3_RXDMA 1
#define CONFIG_UART4_RXDMA 1
#define CONFIG_UART5_RXDMA 1
#define CONFIG_USART6_RXDMA 1
#define CONFIG_UART8_RXDMA 1
#define CONFIG_SERIAL_DISABLE_REORDERING 1
#define CONFIG_STM32_USART_SINGLEWIRE 1
#define CONFIG_STM32_SPI_DMA 1
#define CONFIG_STM32_I2CTIMEOSEC 0
#define CONFIG_STM32_I2CTIMEOMS 10
#define CONFIG_SDIO_PRI 128
#define CONFIG_ARCH_DMA 1
#define CONFIG_ARCH_HAVE_VFORK 1
#define CONFIG_ARCH_STACKDUMP 1
#define CONFIG_ARCH_HAVE_RAMVECTORS 1
#define CONFIG_BOARD_LOOPSPERMSEC 16717
#define CONFIG_DRAM_START 0x20000000
#define CONFIG_DRAM_SIZE 262144
#define CONFIG_ARCH_HAVE_INTERRUPTSTACK 1
#define CONFIG_ARCH_INTERRUPTSTACK 750
#define CONFIG_BOOT_RUNFROMFLASH 1
#define CONFIG_ARCH_BOARD_PX4FMU_V2 1
#define CONFIG_ARCH_BOARD_CUSTOM 1
#define CONFIG_ARCH_BOARD ""
#define CONFIG_NSH_MMCSDMINOR 0
#define CONFIG_NSH_MMCSDSLOTNO 0
#define CONFIG_MMCSD_HAVE_SDIOWAIT_WRCOMPLETE 1
#define CONFIG_MSEC_PER_TICK 1
#define CONFIG_RR_INTERVAL 0
#define CONFIG_SCHED_INSTRUMENTATION 1
#define CONFIG_TASK_NAME_SIZE 24
#define CONFIG_START_YEAR 1970
#define CONFIG_START_MONTH 1
#define CONFIG_START_DAY 1
#define CONFIG_DEV_CONSOLE 1
#define CONFIG_PRIORITY_INHERITANCE 1
#define CONFIG_SEM_PREALLOCHOLDERS 0
#define CONFIG_SEM_NNESTPRIO 8
#define CONFIG_FDCLONE_STDIO 1
#define CONFIG_SDCLONE_DISABLE 1
#define CONFIG_SCHED_WAITPID 1
#define CONFIG_SCHED_ATEXIT 1
#define CONFIG_SCHED_ATEXIT_MAX 1
#define CONFIG_USER_ENTRYPOINT nsh_main
#define CONFIG_SIG_SIGUSR1 1
#define CONFIG_SIG_SIGUSR2 2
#define CONFIG_SIG_SIGALARM 3
#define CONFIG_SIG_SIGCONDTIMEDOUT 16
#define CONFIG_SIG_SIGWORK 4
#define CONFIG_MAX_TASKS 32
#define CONFIG_MAX_TASK_ARGS 10
#define CONFIG_NPTHREAD_KEYS 4
#define CONFIG_NFILE_DESCRIPTORS 50
#define CONFIG_NFILE_STREAMS 8
#define CONFIG_NAME_MAX 32
#define CONFIG_PREALLOC_MQ_MSGS 4
#define CONFIG_MQ_MAXMSGSIZE 32
#define CONFIG_MAX_WDOGPARMS 2
#define CONFIG_PREALLOC_WDOGS 50
#define CONFIG_PREALLOC_TIMERS 50
#define CONFIG_IDLETHREAD_STACKSIZE 1000
#define CONFIG_USERMAIN_STACKSIZE 2500
#define CONFIG_PTHREAD_STACK_MIN 512
#define CONFIG_PTHREAD_STACK_DEFAULT 2048
#define CONFIG_DEV_NULL 1
#define CONFIG_I2C 1
#define CONFIG_I2C_TRANSFER 1
#define CONFIG_ARCH_HAVE_I2CRESET 1
#define CONFIG_I2C_RESET 1
#define CONFIG_SPI 1
#define CONFIG_SPI_EXCHANGE 1
#define CONFIG_RTC 1
#define CONFIG_RTC_DATETIME 1
#define CONFIG_RTC_HSECLOCK 1
#define CONFIG_WATCHDOG 1
#define CONFIG_MMCSD 1
#define CONFIG_MMCSD_NSLOTS 1
#define CONFIG_MMCSD_MULTIBLOCK_DISABLE 1
#define CONFIG_MMCSD_SDIO 1
#define CONFIG_MTD 1
#define CONFIG_MTD_PARTITION 1
#define CONFIG_MTD_BYTE_WRITE 1
#define CONFIG_MTD_RAMTRON 1
#define CONFIG_PIPES 1
#define CONFIG_SERIAL 1
#define CONFIG_SERIAL_REMOVABLE 1
#define CONFIG_ARCH_HAVE_UART4 1
#define CONFIG_ARCH_HAVE_UART7 1
#define CONFIG_ARCH_HAVE_UART8 1
#define CONFIG_ARCH_HAVE_USART1 1
#define CONFIG_ARCH_HAVE_USART2 1
#define CONFIG_ARCH_HAVE_USART3 1
#define CONFIG_ARCH_HAVE_USART6 1
#define CONFIG_MCU_SERIAL 1
#define CONFIG_STANDARD_SERIAL 1
#define CONFIG_SERIAL_NPOLLWAITERS 2
#define CONFIG_UART7_SERIAL_CONSOLE 1
#define CONFIG_USART1_RXBUFSIZE 128
#define CONFIG_USART1_TXBUFSIZE 32
#define CONFIG_USART1_BAUD 115200
#define CONFIG_USART1_BITS 8
#define CONFIG_USART1_PARITY 0
#define CONFIG_USART1_2STOP 0
#define CONFIG_USART2_RXBUFSIZE 600
#define CONFIG_USART2_TXBUFSIZE 1100
#define CONFIG_USART2_BAUD 57600
#define CONFIG_USART2_BITS 8
#define CONFIG_USART2_PARITY 0
#define CONFIG_USART2_2STOP 0
#define CONFIG_USART2_IFLOWCONTROL 1
#define CONFIG_USART2_OFLOWCONTROL 1
#define CONFIG_USART3_RXBUFSIZE 300
#define CONFIG_USART3_TXBUFSIZE 300
#define CONFIG_USART3_BAUD 57600
#define CONFIG_USART3_BITS 8
#define CONFIG_USART3_PARITY 0
#define CONFIG_USART3_2STOP 0
#define CONFIG_USART3_IFLOWCONTROL 1
#define CONFIG_USART3_OFLOWCONTROL 1
#define CONFIG_UART4_RXBUFSIZE 300
#define CONFIG_UART4_TXBUFSIZE 300
#define CONFIG_UART4_BAUD 57600
#define CONFIG_UART4_BITS 8
#define CONFIG_UART4_PARITY 0
#define CONFIG_UART4_2STOP 0
#define CONFIG_USART6_RXBUFSIZE 300
#define CONFIG_USART6_TXBUFSIZE 300
#define CONFIG_USART6_BAUD 57600
#define CONFIG_USART6_BITS 8
#define CONFIG_USART6_PARITY 0
#define CONFIG_USART6_2STOP 0
#define CONFIG_UART7_RXBUFSIZE 300
#define CONFIG_UART7_TXBUFSIZE 300
#define CONFIG_UART7_BAUD 57600
#define CONFIG_UART7_BITS 8
#define CONFIG_UART7_PARITY 0
#define CONFIG_UART7_2STOP 0
#define CONFIG_UART8_RXBUFSIZE 300
#define CONFIG_UART8_TXBUFSIZE 300
#define CONFIG_UART8_BAUD 57600
#define CONFIG_UART8_BITS 8
#define CONFIG_UART8_PARITY 0
#define CONFIG_UART8_2STOP 0
#define CONFIG_SERIAL_IFLOWCONTROL 1
#define CONFIG_SERIAL_OFLOWCONTROL 1
#define CONFIG_USBDEV 1
#define CONFIG_USBDEV_BUSPOWERED 1
#define CONFIG_USBDEV_MAXPOWER 500
#define CONFIG_CDCACM 1
#define CONFIG_CDCACM_EP0MAXPACKET 64
#define CONFIG_CDCACM_EPINTIN 1
#define CONFIG_CDCACM_EPINTIN_FSSIZE 64
#define CONFIG_CDCACM_EPINTIN_HSSIZE 64
#define CONFIG_CDCACM_EPBULKOUT 3
#define CONFIG_CDCACM_EPBULKOUT_FSSIZE 64
#define CONFIG_CDCACM_EPBULKOUT_HSSIZE 512
#define CONFIG_CDCACM_EPBULKIN 2
#define CONFIG_CDCACM_EPBULKIN_FSSIZE 64
#define CONFIG_CDCACM_EPBULKIN_HSSIZE 512
#define CONFIG_CDCACM_NWRREQS 4
#define CONFIG_CDCACM_NRDREQS 4
#define CONFIG_CDCACM_BULKIN_REQLEN 96
#define CONFIG_CDCACM_RXBUFSIZE 600
#define CONFIG_CDCACM_TXBUFSIZE 8000
#define CONFIG_CDCACM_VENDORID 0x26ac
#define CONFIG_CDCACM_PRODUCTID 0x0011
#define CONFIG_CDCACM_VENDORSTR "3D Robotics"
#define CONFIG_CDCACM_PRODUCTSTR "PX4 FMU v2.x"
#define CONFIG_FS_FAT 1
#define CONFIG_FAT_LCNAMES 1
#define CONFIG_FAT_LFN 1
#define CONFIG_FAT_MAXFNAME 32
#define CONFIG_FS_FATTIME 1
#define CONFIG_FAT_DMAMEMORY 1
#define CONFIG_FS_ROMFS 1
#define CONFIG_FS_BINFS 1
#define CONFIG_MM_REGIONS 2
#define CONFIG_GRAN 1
#define CONFIG_BUILTIN 1
#define CONFIG_STDIO_BUFFER_SIZE 32
#define CONFIG_STDIO_LINEBUFFER 1
#define CONFIG_NUNGET_CHARS 2
#define CONFIG_LIB_HOMEDIR "/"
#define CONFIG_LIBC_FLOATINGPOINT 1
#define CONFIG_LIB_RAND_ORDER 1
#define CONFIG_EOL_IS_EITHER_CRLF 1
#define CONFIG_POSIX_SPAWN_PROXY_STACKSIZE 1024
#define CONFIG_TASK_SPAWN_DEFAULT_STACKSIZE 2048
#define CONFIG_LIBC_STRERROR 1
#define CONFIG_ARCH_LOWPUTC 1
#define CONFIG_LIB_SENDFILE_BUFSIZE 512
#define CONFIG_ARCH_OPTIMIZED_FUNCTIONS 1
#define CONFIG_ARCH_MEMCPY 1
#define CONFIG_SCHED_WORKQUEUE 1
#define CONFIG_SCHED_HPWORK 1
#define CONFIG_SCHED_WORKPRIORITY 192
#define CONFIG_SCHED_WORKPERIOD 5000
#define CONFIG_SCHED_WORKSTACKSIZE 1600
#define CONFIG_SCHED_LPWORK 1
#define CONFIG_SCHED_LPWORKPRIORITY 50
#define CONFIG_SCHED_LPWORKPERIOD 50000
#define CONFIG_SCHED_LPWORKSTACKSIZE 1600
#define CONFIG_C99_BOOL8 1
#define CONFIG_HAVE_CXX 1
#define CONFIG_HAVE_CXXINITIALIZE 1
#define CONFIG_BUILTIN_PROXY_STACKSIZE 1024
#define CONFIG_EXAMPLES_CDCACM 1
#define CONFIG_EXAMPLES_MOUNT 1
#define CONFIG_EXAMPLES_NSH 1
#define CONFIG_NSH_LIBRARY 1
#define CONFIG_NSH_BUILTIN_APPS 1
#define CONFIG_NSH_CODECS_BUFSIZE 128
#define CONFIG_NSH_FILEIOSIZE 512
#define CONFIG_NSH_STRERROR 1
#define CONFIG_NSH_LINELEN 128
#define CONFIG_NSH_MAXARGUMENTS 12
#define CONFIG_NSH_NESTDEPTH 8
#define CONFIG_NSH_ROMFSETC 1
#define CONFIG_NSH_ROMFSMOUNTPT "/etc"
#define CONFIG_NSH_INITSCRIPT "init.d/rcS"
#define CONFIG_NSH_ROMFSDEVNO 0
#define CONFIG_NSH_ROMFSSECTSIZE 128
#define CONFIG_NSH_ARCHROMFS 1
#define CONFIG_NSH_FATDEVNO 1
#define CONFIG_NSH_FATSECTSIZE 512
#define CONFIG_NSH_FATNSECTORS 1024
#define CONFIG_NSH_FATMOUNTPT "/tmp"
#define CONFIG_NSH_CONSOLE 1
#define CONFIG_NSH_ARCHINIT 1
#define CONFIG_SYSTEM_READLINE 1
#define CONFIG_READLINE_ECHO 1
#define CONFIG_SYSTEM_SYSINFO 1
#define CONFIG_NSOCKET_DESCRIPTORS 0
#define CONFIG_STM32_FLASH_CONFIG_I 1
#define CONFIG_APPS_DIR "../apps"
# 416 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/config.h"
#define CONFIG_DRAM_END (CONFIG_DRAM_START+CONFIG_DRAM_SIZE)
# 457 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/config.h"
#undef CONFIG_FS_READABLE
#undef CONFIG_FS_WRITABLE



#define CONFIG_FS_READABLE 1




#define CONFIG_FS_WRITABLE 1





#undef CONFIG_NET







#undef CONFIG_NSOCKET_DESCRIPTORS
#define CONFIG_NSOCKET_DESCRIPTORS 0





#undef CONFIG_NET_TCP
#undef CONFIG_NET_UDP
#undef CONFIG_NET_ICMP





#undef CONFIG_NFS





#undef CONFIG_DEBUG_VERBOSE
#undef CONFIG_DEBUG_SCHED
#undef CONFIG_DEBUG_MM
#undef CONFIG_DEBUG_PAGING
#undef CONFIG_DEBUG_DMA
#undef CONFIG_DEBUG_FS
#undef CONFIG_DEBUG_LIB
#undef CONFIG_DEBUG_BINFMT
#undef CONFIG_DEBUG_NET
#undef CONFIG_DEBUG_USB
#undef CONFIG_DEBUG_GRAPHICS
#undef CONFIG_DEBUG_GPIO
#undef CONFIG_DEBUG_SPI
#undef CONFIG_DEBUG_STACK
# 44 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/cxx/cmath" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/compiler.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/compiler.h"
#define __INCLUDE_NUTTX_COMPILER_H 
# 53 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/compiler.h"
#define CONFIG_CPP_HAVE_VARARGS 1
#define CONFIG_CPP_HAVE_WARNING 1



#define CONFIG_HAVE_FUNCTIONNAME 1
#define CONFIG_HAVE_FILENAME 1
# 68 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/compiler.h"
#define CONFIG_HAVE_WEAKFUNCTIONS 1
#define weak_alias(name,aliasname) extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));

#define weak_function __attribute__ ((weak))
#define weak_const_function __attribute__ ((weak, __const__))
# 82 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/compiler.h"
#define noreturn_function __attribute__ ((noreturn))





#define farcall_function __attribute__ ((long_call))





#define packed_struct __attribute__ ((packed))



#define reentrant_function 





#define naked_function __attribute__ ((naked,no_instrument_function))






#define inline_function __attribute__ ((always_inline,no_instrument_function))
#define noinline_function __attribute__ ((noinline))



#define FAR 
#define NEAR 
#define DSEG 
#define CODE 
# 188 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/compiler.h"
#undef CONFIG_SMALL_MEMORY



#undef CONFIG_LONG_IS_NOT_INT



#undef CONFIG_PTR_IS_NOT_INT




#define CONFIG_HAVE_INLINE 1



#define CONFIG_HAVE_LONG_LONG 1
#define CONFIG_HAVE_FLOAT 1
#define CONFIG_HAVE_DOUBLE 1
#define CONFIG_HAVE_LONG_DOUBLE 1



#define CONFIG_CAN_PASS_STRUCTS 1
# 480 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/nuttx/compiler.h"
#define EXTERN extern "C"
extern "C" {





#undef EXTERN

}
# 45 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/cxx/cmath" 2

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/math.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/math.h"
#define __INCLUDE_NUTTX_MATH_H 
# 52 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/math.h"
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h" 1


#define _MATH_H_ 

# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 60 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/machine/ieeefp.h" 3
#define __IEEE_LITTLE_ENDIAN 
# 6 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h" 2
# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/_ansi.h" 1 3
# 13 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/_ansi.h" 3
#define _ANSIDECL_H_ 

# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/newlib.h" 1 3







#define __NEWLIB_H__ 1





#define _NEWLIB_VERSION "2.1.0"






#define _WANT_IO_LONG_LONG 1


#define _WANT_REGISTER_FINI 1
# 40 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/newlib.h" 3
#define _MB_LEN_MAX 1
# 50 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/newlib.h" 3
#define HAVE_INITFINI_ARRAY 1



#define _ATEXIT_DYNAMIC_ALLOC 1


#define _HAVE_LONG_DOUBLE 1


#define _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL 1


#define _LDBL_EQ_DBL 1
# 72 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/newlib.h" 3
#define _FVWRITE_IN_STREAMIO 1


#define _FSEEK_OPTIMIZATION 1


#define _WIDE_ORIENT 1


#define _UNBUF_STREAM_OPT 1
# 16 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/_ansi.h" 2 3
# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/sys/config.h" 1 3

#define __SYS_CONFIG_H__ 

# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/machine/ieeefp.h" 1 3
# 5 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/sys/config.h" 2 3
# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/sys/features.h" 1 3
# 22 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/sys/features.h" 3
#define _SYS_FEATURES_H 


extern "C" {





#define __NEWLIB__ 2
#define __NEWLIB_MINOR__ 1




#define __GNUC_PREREQ(maj,min) ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))






#define __GNUC_PREREQ__(ma,mi) __GNUC_PREREQ(ma, mi)
# 233 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/sys/features.h" 3
}
# 6 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/sys/config.h" 2 3
# 216 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/sys/config.h" 3
#define _POINTER_INT long





#undef __RAND_MAX



#define __RAND_MAX 0x7fffffff
# 248 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/sys/config.h" 3
#define __IMPORT 






#define _READ_WRITE_RETURN_TYPE int





#define _READ_WRITE_BUFSIZE_TYPE int
# 17 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/_ansi.h" 2 3






#define _HAVE_STDC 
# 34 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/_ansi.h" 3
#define _BEGIN_STD_C extern "C" {
#define _END_STD_C }


#define _NOTHROW __attribute__ ((__nothrow__))
# 50 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/_ansi.h" 3
#define _PTR void *
#define _AND ,
#define _NOARGS void
#define _CONST const
#define _VOLATILE volatile
#define _SIGNED signed
#define _DOTS , ...
#define _VOID void






#define _EXFUN_NOTHROW(name,proto) name proto _NOTHROW
#define _EXFUN(name,proto) name proto
#define _EXPARM(name,proto) (* name) proto
#define _EXFNPTR(name,proto) (* name) proto

#define _DEFUN(name,arglist,args) name(args)
#define _DEFUN_VOID(name) name(_NOARGS)
#define _CAST_VOID (void)

#define _LONG_DOUBLE long double


#define _PARAMS(paramlist) paramlist
# 101 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/_ansi.h" 3
#define _ATTRIBUTE(attrs) __attribute__ (attrs)
# 127 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/_ansi.h" 3
#define _ELIDABLE_INLINE static __inline__



#define _NOINLINE __attribute__ ((__noinline__))
#define _NOINLINE_STATIC _NOINLINE static
# 7 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h" 2

extern "C" {


#define _M_LN2 0.693147180559945309417
# 20 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h"
#define HUGE_VAL (__builtin_huge_val())



#define HUGE_VALF (__builtin_huge_valf())



#define HUGE_VALL (__builtin_huge_vall())



#define INFINITY (__builtin_inff())



#define NAN (__builtin_nanf(""))
# 87 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h"
extern double atan (double);
extern double cos (double);
extern double sin (double);
extern double tan (double);
extern double tanh (double);
extern double frexp (double, int *);
extern double modf (double, double *);
extern double ceil (double);
extern double fabs (double);
extern double floor (double);






extern double acos (double);
extern double asin (double);
extern double atan2 (double, double);
extern double cosh (double);
extern double sinh (double);
extern double exp (double);
extern double ldexp (double, int);
extern double log (double);
extern double log10 (double);
extern double pow (double, double);
extern double sqrt (double);
extern double fmod (double, double);
# 123 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h"
#define FLT_EVAL_METHOD 0
typedef float float_t;
typedef double double_t;


#define FP_NAN 0
#define FP_INFINITE 1
#define FP_ZERO 2
#define FP_SUBNORMAL 3
#define FP_NORMAL 4


#define FP_ILOGB0 (-INT_MAX)


#define FP_ILOGBNAN INT_MAX



#define MATH_ERRNO 1


#define MATH_ERREXCEPT 2


#define math_errhandling MATH_ERRNO


extern int __isinff (float x);
extern int __isinfd (double x);
extern int __isnanf (float x);
extern int __isnand (double x);
extern int __fpclassifyf (float x);
extern int __fpclassifyd (double x);
extern int __signbitf (float x);
extern int __signbitd (double x);

#define fpclassify(__x) ((sizeof(__x) == sizeof(float)) ? __fpclassifyf(__x) : __fpclassifyd(__x))




#define isfinite(__y) (__extension__ ({int __cy = fpclassify(__y); __cy != FP_INFINITE && __cy != FP_NAN;}))
# 177 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h"
#define isinf(y) (fpclassify(y) == FP_INFINITE)



#define isnan(y) (fpclassify(y) == FP_NAN)


#define isnormal(y) (fpclassify(y) == FP_NORMAL)
#define signbit(__x) ((sizeof(__x) == sizeof(float)) ? __signbitf(__x) : __signbitd(__x))



#define isgreater(x,y) (__extension__ ({__typeof__(x) __x = (x); __typeof__(y) __y = (y); !isunordered(__x,__y) && (__x > __y);}))


#define isgreaterequal(x,y) (__extension__ ({__typeof__(x) __x = (x); __typeof__(y) __y = (y); !isunordered(__x,__y) && (__x >= __y);}))


#define isless(x,y) (__extension__ ({__typeof__(x) __x = (x); __typeof__(y) __y = (y); !isunordered(__x,__y) && (__x < __y);}))


#define islessequal(x,y) (__extension__ ({__typeof__(x) __x = (x); __typeof__(y) __y = (y); !isunordered(__x,__y) && (__x <= __y);}))


#define islessgreater(x,y) (__extension__ ({__typeof__(x) __x = (x); __typeof__(y) __y = (y); !isunordered(__x,__y) && (__x < __y || __x > __y);}))



#define isunordered(a,b) (__extension__ ({__typeof__(a) __a = (a); __typeof__(b) __b = (b); fpclassify(__a) == FP_NAN || fpclassify(__b) == FP_NAN;}))





extern double infinity (void);
extern double nan (const char *);
extern int finite (double);
extern double copysign (double, double);
extern double logb (double);
extern int ilogb (double);

extern double asinh (double);
extern double cbrt (double);
extern double nextafter (double, double);
extern double rint (double);
extern double scalbn (double, int);

extern double exp2 (double);
extern double scalbln (double, long int);
extern double tgamma (double);
extern double nearbyint (double);
extern long int lrint (double);
extern long long int llrint (double);
extern double round (double);
extern long int lround (double);
extern long long int llround (double);
extern double trunc (double);
extern double remquo (double, double, int *);
extern double fdim (double, double);
extern double fmax (double, double);
extern double fmin (double, double);
extern double fma (double, double, double);


extern double log1p (double);
extern double expm1 (double);



extern double acosh (double);
extern double atanh (double);
extern double remainder (double, double);
extern double gamma (double);
extern double lgamma (double);
extern double erf (double);
extern double erfc (double);
extern double log2 (double);





extern double hypot (double, double);






extern float atanf (float);
extern float cosf (float);
extern float sinf (float);
extern float tanf (float);
extern float tanhf (float);
extern float frexpf (float, int *);
extern float modff (float, float *);
extern float ceilf (float);
extern float fabsf (float);
extern float floorf (float);


extern float acosf (float);
extern float asinf (float);
extern float atan2f (float, float);
extern float coshf (float);
extern float sinhf (float);
extern float expf (float);
extern float ldexpf (float, int);
extern float logf (float);
extern float log10f (float);
extern float powf (float, float);
extern float sqrtf (float);
extern float fmodf (float, float);




extern float exp2f (float);
extern float scalblnf (float, long int);
extern float tgammaf (float);
extern float nearbyintf (float);
extern long int lrintf (float);
extern long long llrintf (float);
extern float roundf (float);
extern long int lroundf (float);
extern long long int llroundf (float);
extern float truncf (float);
extern float remquof (float, float, int *);
extern float fdimf (float, float);
extern float fmaxf (float, float);
extern float fminf (float, float);
extern float fmaf (float, float, float);

extern float infinityf (void);
extern float nanf (const char *);
extern int finitef (float);
extern float copysignf (float, float);
extern float logbf (float);
extern int ilogbf (float);

extern float asinhf (float);
extern float cbrtf (float);
extern float nextafterf (float, float);
extern float rintf (float);
extern float scalbnf (float, int);
extern float log1pf (float);
extern float expm1f (float);


extern float acoshf (float);
extern float atanhf (float);
extern float remainderf (float, float);
extern float gammaf (float);
extern float lgammaf (float);
extern float erff (float);
extern float erfcf (float);
extern float log2f (float);



extern float hypotf (float, float);






extern long double atanl (long double);
extern long double cosl (long double);
extern long double sinl (long double);
extern long double tanl (long double);
extern long double tanhl (long double);
extern long double frexpl (long double value, int *);
extern long double modfl (long double, long double *);
extern long double ceill (long double);
extern long double fabsl (long double);
extern long double floorl (long double);
extern long double log1pl (long double);
extern long double expm1l (long double);




extern long double acosl (long double);
extern long double asinl (long double);
extern long double atan2l (long double, long double);
extern long double coshl (long double);
extern long double sinhl (long double);
extern long double expl (long double);
extern long double ldexpl (long double, int);
extern long double logl (long double);
extern long double log2l (long double);
extern long double log10l (long double);
extern long double powl (long double, long double);
extern long double sqrtl (long double);
extern long double fmodl (long double, long double);
extern long double hypotl (long double, long double);


extern long double copysignl (long double, long double);
extern long double nanl (const char *);
extern int ilogbl (long double);
extern long double asinhl (long double);
extern long double cbrtl (long double);
extern long double nextafterl (long double, long double);
extern long double rintl (long double);
extern long double scalbnl (long double, int);
extern long double exp2l (long double);
extern long double scalblnl (long double, long);
extern long double tgammal (long double);
extern long double nearbyintl (long double);
extern long int lrintl (long double);
extern long long int llrintl (long double);
extern long double roundl (long double);
extern long lroundl (long double);
extern long long int llroundl (long double);
extern long double truncl (long double);
extern long double remquol (long double, long double, int *);
extern long double fdiml (long double, long double);
extern long double fmaxl (long double, long double);
extern long double fminl (long double, long double);
extern long double fmal (long double, long double, long double);

extern long double acoshl (long double);
extern long double atanhl (long double);
extern long double remainderl (long double, long double);
extern long double lgammal (long double);
extern long double erfl (long double);
extern long double erfcl (long double);
# 420 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h"
extern double drem (double, double);
extern void sincos (double, double *, double *);
extern double gamma_r (double, int *);
extern double lgamma_r (double, int *);

extern double y0 (double);
extern double y1 (double);
extern double yn (int, double);
extern double j0 (double);
extern double j1 (double);
extern double jn (int, double);

extern float dremf (float, float);
extern void sincosf (float, float *, float *);
extern float gammaf_r (float, int *);
extern float lgammaf_r (float, int *);

extern float y0f (float);
extern float y1f (float);
extern float ynf (int, float);
extern float j0f (float);
extern float j1f (float);
extern float jnf (int, float);



extern double exp10 (double);


extern double pow10 (double);


extern float exp10f (float);


extern float pow10f (float);
# 464 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/math.h"
#define signgam (*__signgam())
extern int *__signgam (void);


#define __signgam_r(ptr) _REENT_SIGNGAM(ptr)





struct __exception



{
  int type;
  char *name;
  double arg1;
  double arg2;
  double retval;
  int err;
};


extern int matherr (struct __exception *e);






#define DOMAIN 1
#define SING 2
#define OVERFLOW 3
#define UNDERFLOW 4
#define TLOSS 5
#define PLOSS 6



#define MAXFLOAT 3.40282347e+38F

#define M_E 2.7182818284590452354
#define M_LOG2E 1.4426950408889634074
#define M_LOG10E 0.43429448190325182765
#define M_LN2 _M_LN2
#define M_LN10 2.30258509299404568402
#define M_PI 3.14159265358979323846
#define M_TWOPI (M_PI * 2.0)
#define M_PI_2 1.57079632679489661923
#define M_PI_4 0.78539816339744830962
#define M_3PI_4 2.3561944901923448370E0
#define M_SQRTPI 1.77245385090551602792981
#define M_1_PI 0.31830988618379067154
#define M_2_PI 0.63661977236758134308
#define M_2_SQRTPI 1.12837916709551257390
#define M_DEG_TO_RAD 0.01745329251994
#define M_RAD_TO_DEG 57.2957795130823
#define M_SQRT2 1.41421356237309504880
#define M_SQRT1_2 0.70710678118654752440
#define M_LN2LO 1.9082149292705877000E-10
#define M_LN2HI 6.9314718036912381649E-1
#define M_SQRT3 1.73205080756887719000
#define M_IVLN10 0.43429448190325182765
#define M_LOG2_E _M_LN2
#define M_INVLN2 1.4426950408889633870E0


#define M_E_F 2.7182818284590452354f
#define M_LOG2E_F 1.4426950408889634074f
#define M_LOG10E_F 0.43429448190325182765f
#define M_LN2_F _M_LN2_F
#define M_LN10_F 2.30258509299404568402f
#define M_PI_F 3.14159265358979323846f
#define M_TWOPI_F (M_PI_F * 2.0f)
#define M_PI_2_F 1.57079632679489661923f
#define M_PI_4_F 0.78539816339744830962f
#define M_3PI_4_F 2.3561944901923448370E0f
#define M_SQRTPI_F 1.77245385090551602792981f
#define M_1_PI_F 0.31830988618379067154f
#define M_2_PI_F 0.63661977236758134308f
#define M_2_SQRTPI_F 1.12837916709551257390f
#define M_DEG_TO_RAD_F 0.01745329251994f
#define M_RAD_TO_DEG_F 57.2957795130823f
#define M_SQRT2_F 1.41421356237309504880f
#define M_SQRT1_2_F 0.70710678118654752440f
#define M_LN2LO_F 1.9082149292705877000E-10f
#define M_LN2HI_F 6.9314718036912381649E-1f
#define M_SQRT3_F 1.73205080756887719000f
#define M_IVLN10_F 0.43429448190325182765f
#define M_LOG2_E_F _M_LN2_F
#define M_INVLN2_F 1.4426950408889633870E0f



enum __fdlibm_version
{
  __fdlibm_ieee = -1,
  __fdlibm_svid,
  __fdlibm_xopen,
  __fdlibm_posix
};

#define _LIB_VERSION_TYPE enum __fdlibm_version
#define _LIB_VERSION __fdlib_version

extern enum __fdlibm_version __fdlib_version;

#define _IEEE_ __fdlibm_ieee
#define _SVID_ __fdlibm_svid
#define _XOPEN_ __fdlibm_xopen
#define _POSIX_ __fdlibm_posix



}
# 53 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/math.h" 2
# 47 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/cxx/cmath" 2





namespace std
{

  using ::acosf;
  using ::asinf;
  using ::atanf;
  using ::atan2f;
  using ::ceilf;
  using ::cosf;
  using ::coshf;
  using ::expf;
  using ::fabsf;
  using ::floorf;
  using ::fmodf;
  using ::frexpf;
  using ::ldexpf;
  using ::logf;
  using ::log10f;
  using ::log2f;
  using ::modff;
  using ::roundf;
  using ::powf;
  using ::sinf;
  using ::sinhf;
  using ::sqrtf;
  using ::tanf;
  using ::tanhf;



  using ::acos;
  using ::asin;
  using ::atan;
  using ::atan2;
  using ::ceil;
  using ::cos;
  using ::cosh;
  using ::exp;
  using ::fabs;
  using ::floor;
  using ::fmod;
  using ::frexp;
  using ::ldexp;
  using ::log;
  using ::log10;
  using ::log2;
  using ::modf;
  using ::round;
  using ::pow;
  using ::sin;
  using ::sinh;
  using ::sqrt;
  using ::tan;
  using ::tanh;



  using ::acosl;
  using ::asinl;
  using ::atanl;
  using ::atan2l;
  using ::ceill;
  using ::cosl;
  using ::coshl;
  using ::expl;
  using ::fabsl;
  using ::floorl;
  using ::fmodl;
  using ::frexpl;
  using ::ldexpl;
  using ::logl;
  using ::log10l;
  using ::log2l;
  using ::modfl;
  using ::roundl;
  using ::powl;
  using ::sinl;
  using ::sinhl;
  using ::sqrtl;
  using ::tanl;
  using ::tanhl;


}
# 4 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/missing/cmath" 2
# 13 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/missing/cmath"
#define GLIBC_FIX_NEEDED 0
# 4 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 1 3
# 38 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 3
#define _GLIBCXX_NUMERIC_LIMITS 1

       
# 41 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 3

# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 1 3
# 31 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_CXX_CONFIG_H 1


#define __GLIBCXX__ 20141119
# 43 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_PURE __attribute__ ((__pure__))



#define _GLIBCXX_CONST __attribute__ ((__const__))



#define _GLIBCXX_NORETURN __attribute__ ((__noreturn__))
# 64 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY 1


#define _GLIBCXX_VISIBILITY(V) __attribute__ ((__visibility__ (#V)))
# 78 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_USE_DEPRECATED 1



#define _GLIBCXX_DEPRECATED __attribute__ ((__deprecated__))






#define _GLIBCXX_ABI_TAG_CXX11 __attribute ((__abi_tag__ ("cxx11")))
# 98 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_CONSTEXPR constexpr
#define _GLIBCXX_USE_CONSTEXPR constexpr
# 109 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_NOEXCEPT noexcept
#define _GLIBCXX_USE_NOEXCEPT noexcept
#define _GLIBCXX_THROW(_EXC) 
# 120 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_NOTHROW _GLIBCXX_USE_NOEXCEPT






#define _GLIBCXX_THROW_OR_ABORT(_EXC) (__builtin_abort())
# 141 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_EXTERN_TEMPLATE 1
# 186 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}



#define _GLIBCXX_INLINE_VERSION 0
# 240 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_BEGIN_NAMESPACE_VERSION 
#define _GLIBCXX_END_NAMESPACE_VERSION 
# 321 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_STD_A std



#define _GLIBCXX_STD_C std



#define _GLIBCXX_BEGIN_NAMESPACE_ALGO 



#define _GLIBCXX_END_NAMESPACE_ALGO 



#define _GLIBCXX_BEGIN_NAMESPACE_CONTAINER 



#define _GLIBCXX_END_NAMESPACE_CONTAINER 




#undef _GLIBCXX_LONG_DOUBLE_COMPAT
# 358 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_NAMESPACE_LDBL 
#define _GLIBCXX_BEGIN_NAMESPACE_LDBL 
#define _GLIBCXX_END_NAMESPACE_LDBL 




#define __glibcxx_assert(_Condition) 
# 411 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(A) 


#define _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(A) 



#define _GLIBCXX_BEGIN_EXTERN_C extern "C" {
#define _GLIBCXX_END_EXTERN_C }
# 430 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/os_defines.h" 1 3
# 31 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/os_defines.h" 3
#define _GLIBCXX_OS_DEFINES 1
# 431 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 2 3


# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/cpu_defines.h" 1 3
# 31 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/cpu_defines.h" 3
#define _GLIBCXX_CPU_DEFINES 1
# 434 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 2 3




#define _GLIBCXX_PSEUDO_VISIBILITY(V) 






#define _GLIBCXX_WEAK_DEFINITION 
# 456 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_FAST_MATH 0






#define __N(msgid) (msgid)


#undef min
#undef max






#define _GLIBCXX_HAVE_ACOSF 1





#define _GLIBCXX_HAVE_ASINF 1





#define _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE 1


#define _GLIBCXX_HAVE_ATAN2F 1





#define _GLIBCXX_HAVE_ATANF 1
# 507 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_CEILF 1





#define _GLIBCXX_HAVE_COMPLEX_H 1


#define _GLIBCXX_HAVE_COSF 1


#define _GLIBCXX_HAVE_COSHF 1
# 531 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_EBADMSG 1


#define _GLIBCXX_HAVE_ECANCELED 1


#define _GLIBCXX_HAVE_ECHILD 1


#define _GLIBCXX_HAVE_EIDRM 1





#define _GLIBCXX_HAVE_ENODATA 1


#define _GLIBCXX_HAVE_ENOLINK 1


#define _GLIBCXX_HAVE_ENOSPC 1


#define _GLIBCXX_HAVE_ENOSR 1


#define _GLIBCXX_HAVE_ENOSTR 1


#define _GLIBCXX_HAVE_ENOTRECOVERABLE 1


#define _GLIBCXX_HAVE_ENOTSUP 1


#define _GLIBCXX_HAVE_EOVERFLOW 1


#define _GLIBCXX_HAVE_EOWNERDEAD 1


#define _GLIBCXX_HAVE_EPERM 1


#define _GLIBCXX_HAVE_EPROTO 1


#define _GLIBCXX_HAVE_ETIME 1


#define _GLIBCXX_HAVE_ETIMEDOUT 1


#define _GLIBCXX_HAVE_ETXTBSY 1


#define _GLIBCXX_HAVE_EWOULDBLOCK 1





#define _GLIBCXX_HAVE_EXPF 1





#define _GLIBCXX_HAVE_FABSF 1
# 618 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_FLOAT_H 1


#define _GLIBCXX_HAVE_FLOORF 1





#define _GLIBCXX_HAVE_FMODF 1
# 639 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_FREXPF 1





#define _GLIBCXX_HAVE_GETIPINFO 1


#define _GLIBCXX_HAVE_GETS 1


#define _GLIBCXX_HAVE_HYPOT 1
# 660 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_ICONV 1


#define _GLIBCXX_HAVE_IEEEFP_H 1


#define _GLIBCXX_HAVE_INT64_T 1





#define _GLIBCXX_HAVE_INT64_T_LONG_LONG 1


#define _GLIBCXX_HAVE_INTTYPES_H 1
# 696 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_ISWBLANK 1


#define _GLIBCXX_HAVE_LC_MESSAGES 1


#define _GLIBCXX_HAVE_LDEXPF 1
# 729 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_LOCALE_H 1


#define _GLIBCXX_HAVE_LOG10F 1





#define _GLIBCXX_HAVE_LOGF 1





#define _GLIBCXX_HAVE_MACHINE_ENDIAN_H 1


#define _GLIBCXX_HAVE_MACHINE_PARAM_H 1


#define _GLIBCXX_HAVE_MBSTATE_T 1
# 759 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_MODFF 1
# 771 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_POWF 1
# 795 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_SINF 1


#define _GLIBCXX_HAVE_SINHF 1
# 807 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_SLEEP 1


#define _GLIBCXX_HAVE_SQRTF 1





#define _GLIBCXX_HAVE_STDALIGN_H 1


#define _GLIBCXX_HAVE_STDBOOL_H 1


#define _GLIBCXX_HAVE_STDINT_H 1


#define _GLIBCXX_HAVE_STDLIB_H 1





#define _GLIBCXX_HAVE_STRERROR_R 1


#define _GLIBCXX_HAVE_STRINGS_H 1


#define _GLIBCXX_HAVE_STRING_H 1


#define _GLIBCXX_HAVE_STRTOF 1
# 868 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_SYS_PARAM_H 1


#define _GLIBCXX_HAVE_SYS_RESOURCE_H 1
# 880 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_SYS_STAT_H 1





#define _GLIBCXX_HAVE_SYS_TIME_H 1


#define _GLIBCXX_HAVE_SYS_TYPES_H 1
# 898 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_S_ISREG 1


#define _GLIBCXX_HAVE_TANF 1


#define _GLIBCXX_HAVE_TANHF 1
# 913 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_HAVE_TGMATH_H 1





#define _GLIBCXX_HAVE_UNISTD_H 1


#define _GLIBCXX_HAVE_USLEEP 1


#define _GLIBCXX_HAVE_VFWSCANF 1


#define _GLIBCXX_HAVE_VSWSCANF 1


#define _GLIBCXX_HAVE_VWSCANF 1


#define _GLIBCXX_HAVE_WCHAR_H 1


#define _GLIBCXX_HAVE_WCSTOF 1


#define _GLIBCXX_HAVE_WCTYPE_H 1
# 1142 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define LT_OBJDIR ".libs/"





#define _GLIBCXX_PACKAGE_BUGREPORT ""


#define _GLIBCXX_PACKAGE_NAME "package-unused"


#define _GLIBCXX_PACKAGE_STRING "package-unused version-unused"


#define _GLIBCXX_PACKAGE_TARNAME "libstdc++"


#define _GLIBCXX_PACKAGE_URL ""


#define _GLIBCXX_PACKAGE__GLIBCXX_VERSION "version-unused"
# 1181 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define STDC_HEADERS 1





#define _GLIBCXX_ATOMIC_BUILTINS 1






#define _GLIBCXX_FULLY_DYNAMIC_STRING 0





#define _GLIBCXX_HOSTED 1




#define _GLIBCXX_PTRDIFF_T_IS_INT 1





#define _GLIBCXX_SIZE_T_IS_UINT 1





#define _GLIBCXX_STDIO_EOF -1


#define _GLIBCXX_STDIO_SEEK_CUR 1


#define _GLIBCXX_STDIO_SEEK_END 2
# 1256 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_USE_C99_CTYPE_TR1 1







#define _GLIBCXX_USE_C99_INTTYPES_TR1 1



#define _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1 1



#define _GLIBCXX_USE_C99_MATH 1







#define _GLIBCXX_USE_C99_STDINT_TR1 1
# 1300 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_USE_GETTIMEOFDAY 1
# 1312 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_USE_LONG_LONG 1
# 1331 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_USE_SC_NPROCESSORS_ONLN 1
# 1340 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/arm-none-eabi/armv7e-m/fpu/bits/c++config.h" 3
#define _GLIBCXX_USE_TMPNAM 1


#define _GLIBCXX_USE_WCHAR_T 1


#define _GLIBCXX_VERBOSE 1





#define _GTHREAD_USE_MUTEX_TIMEDLOCK 1
# 43 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 2 3
# 80 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 3
#define __glibcxx_integral_traps true
# 89 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 3
#define __glibcxx_float_has_denorm_loss false


#define __glibcxx_float_traps false


#define __glibcxx_float_tinyness_before false







#define __glibcxx_double_has_denorm_loss false


#define __glibcxx_double_traps false


#define __glibcxx_double_tinyness_before false







#define __glibcxx_long_double_has_denorm_loss false


#define __glibcxx_long_double_traps false


#define __glibcxx_long_double_tinyness_before false




#define __glibcxx_signed(T) ((T)(-1) < 0)

#define __glibcxx_min(T) (__glibcxx_signed (T) ? -__glibcxx_max (T) - 1 : (T)0)


#define __glibcxx_max(T) (__glibcxx_signed (T) ? (((((T)1 << (__glibcxx_digits (T) - 1)) - 1) << 1) + 1) : ~(T)0)



#define __glibcxx_digits(T) (sizeof(T) * __CHAR_BIT__ - __glibcxx_signed (T))



#define __glibcxx_digits10(T) (__glibcxx_digits (T) * 643L / 2136)


#define __glibcxx_max_digits10(T) (2 + (T) * 643L / 2136)


namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 277 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 303 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -2147483647L - 1; }

      static constexpr long
      max() noexcept { return 2147483647L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 2147483647L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1552 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.1754943508222875e-38F; }

      static constexpr float
      max() noexcept { return 3.4028234663852886e+38F; }


      static constexpr float
      lowest() noexcept { return -3.4028234663852886e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.1920928955078125e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.4012984643248171e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };

#undef __glibcxx_float_has_denorm_loss
#undef __glibcxx_float_traps
#undef __glibcxx_float_tinyness_before


  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.2250738585072014e-308L); }

      static constexpr double
      max() noexcept { return double(1.7976931348623157e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.7976931348623157e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.2204460492503131e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.9406564584124654e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };

#undef __glibcxx_double_has_denorm_loss
#undef __glibcxx_double_traps
#undef __glibcxx_double_tinyness_before


  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 2.2250738585072014e-308L; }

      static constexpr long double
      max() noexcept { return 1.7976931348623157e+308L; }


      static constexpr long double
      lowest() noexcept { return -1.7976931348623157e+308L; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 2.2204460492503131e-16L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 4.9406564584124654e-324L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };

#undef __glibcxx_long_double_has_denorm_loss
#undef __glibcxx_long_double_traps
#undef __glibcxx_long_double_tinyness_before


}

#undef __glibcxx_signed
#undef __glibcxx_min
#undef __glibcxx_max
#undef __glibcxx_digits
#undef __glibcxx_digits10
#undef __glibcxx_max_digits10
# 5 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h"
#define __INCLUDE_STDINT_H 
# 49 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h"
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/types.h" 1
# 41 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/types.h"
#define __ARCH_ARM_INCLUDE_TYPES_H 
# 68 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/types.h"
typedef signed char _int8_t;
typedef unsigned char _uint8_t;

typedef signed short _int16_t;
typedef unsigned short _uint16_t;

typedef signed int _int32_t;
typedef unsigned int _uint32_t;

typedef signed long long _int64_t;
typedef unsigned long long _uint64_t;
#define __INT64_DEFINED 



typedef signed int _intptr_t;
typedef unsigned int _uintptr_t;
# 93 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/types.h"
typedef unsigned char irqstate_t;
# 50 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/limits.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/limits.h"
#define __INCLUDE_LIMITS_H 
# 47 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/limits.h"
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/limits.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/limits.h"
#define __ARCH_ARM_INCLUDE_LIMITS_H 
# 47 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/arch/limits.h"
#define CHAR_BIT 8
#define SCHAR_MIN (-SCHAR_MAX - 1)
#define SCHAR_MAX 127
#define UCHAR_MAX 255




#define CHAR_MIN 0
#define CHAR_MAX UCHAR_MAX





#define SHRT_MIN (-SHRT_MAX - 1)
#define SHRT_MAX 32767
#define USHRT_MAX 65535U

#define INT_MIN (-INT_MAX - 1)
#define INT_MAX 2147483647
#define UINT_MAX 4294967295U



#define LONG_MIN (-LONG_MAX - 1)
#define LONG_MAX 2147483647L
#define ULONG_MAX 4294967295UL

#define LLONG_MIN (-LLONG_MAX - 1)
#define LLONG_MAX 9223372036854775807LL
#define ULLONG_MAX 18446744073709551615ULL



#define PTR_MIN (-PTR_MAX - 1)
#define PTR_MAX 2147483647
#define UPTR_MAX 4294967295U
# 48 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/limits.h" 2
# 65 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/limits.h"
#define CONFIG_PATH_MAX (4*CONFIG_NAME_MAX + 1)
# 116 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/limits.h"
#define _POSIX_ARG_MAX 4096
#define _POSIX_CHILD_MAX 6
#define _POSIX_LINK_MAX 8
#define _POSIX_MAX_CANON 255
#define _POSIX_MAX_INPUT 255
#define _POSIX_NAME_MAX CONFIG_NAME_MAX
#define _POSIX_NGROUPS_MAX 0
#define _POSIX_OPEN_MAX CONFIG_NFILE_DESCRIPTORS
#define _POSIX_PATH_MAX CONFIG_PATH_MAX
#define _POSIX_PIPE_BUF 512
#define _POSIX_SSIZE_MAX INT_MAX
#define _POSIX_STREAM_MAX CONFIG_NFILE_STREAMS
#define _POSIX_TZNAME_MAX 3



#define _POSIX_RTSIG_MAX 31
#define _POSIX_SIGQUEUE_MAX 32
# 148 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/limits.h"
#define _POSIX_DELAYTIMER_MAX 32
#define _POSIX_TIMER_MAX 32


#define _POSIX_CLOCKRES_MIN ((CONFIG_MSEC_PER_TICK)*1000000)






#define _POSIX_AIO_LISTIO_MAX 2
#define _POSIX_AIO_MAX 1



#define _POSIX_MQ_OPEN_MAX 8
#define _POSIX_MQ_PRIO_MAX UCHAR_MAX



#define _POSIX_SEM_NSEMS_MAX INT_MAX
#define _POSIX_SEM_VALUE_MAX 0x7fff





#define ARG_MAX _POSIX_ARG_MAX
#define CHILD_MAX _POSIX_CHILD_MAX
#define LINK_MAX _POSIX_LINK_MAX
#define MAX_CANON _POSIX_MAX_CANON
#define MAX_INPUT _POSIX_MAX_INPUT
#define NAME_MAX _POSIX_NAME_MAX
#define NGROUPS_MAX _POSIX_NGROUPS_MAX
#define OPEN_MAX _POSIX_OPEN_MAX
#define PATH_MAX _POSIX_PATH_MAX
#define PIPE_BUF _POSIX_PIPE_BUF
#define SSIZE_MAX _POSIX_SSIZE_MAX
#define STREAM_MAX _POSIX_STREAM_MAX
#define TZNAME_MAX _POSIX_TZNAME_MAX

#define RTSIG_MAX _POSIX_RTSIG_MAX
#define SIGQUEUE_MAX _POSIX_SIGQUEUE_MAX

#define DELAYTIMER_MAX _POSIX_DELAYTIMER_MAX
#define TIMER_MAX _POSIX_TIMER_MAX
#define CLOCKRES_MIN _POSIX_CLOCKRES_MIN



#define AIO_LISTIO_MAX _POSIX_AIO_LISTIO_MAX
#define AIO_MAX _POSIX_AIO_MAX



#define MQ_OPEN_MAX _POSIX_MQ_OPEN_MAX
#define MQ_PRIO_MAX _POSIX_MQ_PRIO_MAX



#define SEM_NSEMS_MAX _POSIX_SEM_NSEMS_MAX
#define SEM_VALUE_MAX _POSIX_SEM_VALUE_MAX
# 51 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h" 2







#define INT8_MIN (-INT8_MAX - 1)
#define INT8_MAX 127
#define UINT8_MAX 255

#define INT16_MIN (-INT16_MAX - 1)
#define INT16_MAX 32767
#define UINT16_MAX 65535u







#define INT32_MIN (-INT32_MAX - 1)
#define INT32_MAX 2147483647
#define UINT32_MAX 4294967295u


#define INT64_MIN (-INT64_MAX - 1ll)
#define INT64_MAX 9223372036854775807ll
#define UINT64_MAX 18446744073709551615ull




#define INT_LEAST8_MIN INT8_MIN
#define INT_LEAST8_MAX INT8_MAX
#define UINT_LEAST8_MAX UINT8_MAX

#define INT_LEAST16_MIN INT16_MIN
#define INT_LEAST16_MAX INT16_MAX
#define UINT_LEAST16_MAX UINT16_MAX







#define INT_LEAST32_MIN INT32_MIN
#define INT_LEAST32_MAX INT32_MAX
#define UINT_LEAST32_MAX UINT32_MAX


#define INT_LEAST64_MIN INT64_MIN
#define INT_LEAST64_MAX INT64_MAX
#define UINT_LEAST64_MAX UINT64_MAX




#define INT_FAST8_MIN INT8_MIN
#define INT_FAST8_MAX INT8_MAX
#define UINT_FAST8_MAX UINT8_MAX

#define INT_FAST16_MIN INT16_MIN
#define INT_FAST16_MAX INT16_MAX
#define UINT_FAST16_MAX UINT16_MAX







#define INT_FAST32_MIN INT32_MIN
#define INT_FAST32_MAX INT32_MAX
#define UINT_FAST32_MAX UINT32_MAX


#define INT_FAST64_MIN INT64_MIN
#define INT_FAST64_MAX INT64_MAX
#define UINT_FAST64_MAX UINT64_MAX




#define INTPTR_MIN PTR_MIN
#define INTPTR_MAX PTR_MIN
#define UINTPTR_MAX UPTR_MAX




#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX

#define UINTMAX_MIN UINT64_MIN
#define UINTMAX_MAX UINT64_MAX
# 173 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h"
#define INTMAX_C(x) x ## ll
#define UINTMAX_C(x) x ## ull
# 194 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h"
#define SIZE_MAX UINT32_MAX
#define RSIZE_MAX UINT32_MAX
# 219 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h"
typedef _int8_t int8_t;
typedef _uint8_t uint8_t;

typedef _int16_t int16_t;
typedef _uint16_t uint16_t;






typedef _int32_t int32_t;
typedef _uint32_t uint32_t;


typedef _int64_t int64_t;
typedef _uint64_t uint64_t;




typedef _int8_t int_least8_t;
typedef _uint8_t uint_least8_t;

typedef _int16_t int_least16_t;
typedef _uint16_t uint_least16_t;





typedef _int32_t int_least24_t;
typedef _uint32_t uint_least24_t;


typedef _int32_t int_least32_t;
typedef _uint32_t uint_least32_t;


typedef _int64_t int_least64_t;
typedef _uint64_t uint_least64_t;




typedef _int8_t int_fast8_t;
typedef _uint8_t uint_fast8_t;

typedef int int_fast16_t;
typedef unsigned int uint_fast16_t;





typedef _int32_t int_fast24_t;
typedef _uint32_t uint_fast24_t;


typedef _int32_t int_fast32_t;
typedef _uint32_t uint_fast32_t;


typedef _int64_t int_fast64_t;
typedef _uint64_t uint_fast64_t;




typedef _intptr_t intptr_t;
typedef _uintptr_t uintptr_t;
# 303 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdint.h"
typedef _int64_t intmax_t;
typedef _uint64_t uintmax_t;
# 6 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/missing/type_traits" 1
       


# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 1 3
# 30 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
#define _GLIBCXX_TYPE_TRAITS 1

       
# 33 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
# 42 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef long unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }



    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;



  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 253 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 281 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &&>
    : public true_type { };

  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args...)>
    : public true_type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args......)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };




  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 850 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };
# 1286 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>::type
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };
# 1482 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };
# 1539 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1611 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
# 1708 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;
# 1766 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };
# 1803 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };
# 1842 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1862 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };




  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;




  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __success_type<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };
# 2240 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3
#define _GLIBCXX_HAS_NESTED_TYPE(_NTYPE) template<typename _Tp> class __has_ ##_NTYPE ##_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::_NTYPE>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_ ##_NTYPE : public __has_ ##_NTYPE ##_helper <typename remove_cv<_Tp>::type>::type { };
# 2264 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/arm-none-eabi/include/c++/4.9.3/type_traits" 3

}
# 5 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/missing/type_traits" 2
# 7 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h" 1
# 21 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h"
       

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Boards.h" 1






       

#define HAL_BOARD_SITL 3
#define HAL_BOARD_SMACCM 4
#define HAL_BOARD_PX4 5
#define HAL_BOARD_LINUX 7
#define HAL_BOARD_VRBRAIN 8
#define HAL_BOARD_QURT 9
#define HAL_BOARD_EMPTY 99


#define HAL_BOARD_SUBTYPE_NONE -1


#define HAL_BOARD_SUBTYPE_LINUX_NONE 1000
#define HAL_BOARD_SUBTYPE_LINUX_ERLEBOARD 1001
#define HAL_BOARD_SUBTYPE_LINUX_PXF 1002
#define HAL_BOARD_SUBTYPE_LINUX_NAVIO 1003
#define HAL_BOARD_SUBTYPE_LINUX_ZYNQ 1004
#define HAL_BOARD_SUBTYPE_LINUX_BBBMINI 1005
#define HAL_BOARD_SUBTYPE_LINUX_BEBOP 1006
#define HAL_BOARD_SUBTYPE_LINUX_RASPILOT 1007
#define HAL_BOARD_SUBTYPE_LINUX_MINLURE 1008
#define HAL_BOARD_SUBTYPE_LINUX_ERLEBRAIN2 1009
#define HAL_BOARD_SUBTYPE_LINUX_BH 1010
#define HAL_BOARD_SUBTYPE_LINUX_QFLIGHT 1011
#define HAL_BOARD_SUBTYPE_LINUX_PXFMINI 1012
#define HAL_BOARD_SUBTYPE_LINUX_NAVIO2 1013
#define HAL_BOARD_SUBTYPE_LINUX_DISCO 1014
#define HAL_BOARD_SUBTYPE_LINUX_AERO 1015
#define HAL_BOARD_SUBTYPE_LINUX_DARK 1016
#define HAL_BOARD_SUBTYPE_LINUX_URUS 1017


#define HAL_BOARD_SUBTYPE_PX4_V1 2000
#define HAL_BOARD_SUBTYPE_PX4_V2 2001
#define HAL_BOARD_SUBTYPE_PX4_V4 2002
#define HAL_BOARD_SUBTYPE_PX4_V3 2003


#define HAL_BOARD_SUBTYPE_VRBRAIN_V45 4000
#define HAL_BOARD_SUBTYPE_VRBRAIN_V51 4001
#define HAL_BOARD_SUBTYPE_VRBRAIN_V52 4002
#define HAL_BOARD_SUBTYPE_VRUBRAIN_V51 4003
#define HAL_BOARD_SUBTYPE_VRUBRAIN_V52 4004
#define HAL_BOARD_SUBTYPE_VRCORE_V10 4005
#define HAL_BOARD_SUBTYPE_VRBRAIN_V54 4006


#define HAL_INS_MPU60XX_SPI 2
#define HAL_INS_MPU60XX_I2C 3
#define HAL_INS_HIL 4
#define HAL_INS_PX4 5
#define HAL_INS_L3G4200D 7
#define HAL_INS_VRBRAIN 8
#define HAL_INS_MPU9250_SPI 9
#define HAL_INS_L3GD20 10
#define HAL_INS_LSM9DS0 11
#define HAL_INS_RASPILOT 12
#define HAL_INS_MPU9250_I2C 13
#define HAL_INS_BH 14
#define HAL_INS_QFLIGHT 15
#define HAL_INS_QURT 16
#define HAL_INS_BBBMINI 17
#define HAL_INS_AERO 18


#define HAL_BARO_BMP085 1
#define HAL_BARO_MS5611_I2C 2
#define HAL_BARO_MS5611_SPI 3
#define HAL_BARO_MS5607_I2C 4
#define HAL_BARO_PX4 5
#define HAL_BARO_HIL 6
#define HAL_BARO_VRBRAIN 7
#define HAL_BARO_MS5637_I2C 8
#define HAL_BARO_QFLIGHT 9
#define HAL_BARO_QURT 10


#define HAL_COMPASS_HMC5843 1
#define HAL_COMPASS_PX4 2
#define HAL_COMPASS_HIL 3
#define HAL_COMPASS_VRBRAIN 4
#define HAL_COMPASS_AK8963_MPU9250 5
#define HAL_COMPASS_AK8963_I2C 6
#define HAL_COMPASS_HMC5843_MPU6000 7
#define HAL_COMPASS_RASPILOT 8
#define HAL_COMPASS_AK8963_MPU9250_I2C 9
#define HAL_COMPASS_BH 10
#define HAL_COMPASS_QFLIGHT 11
#define HAL_COMPASS_QURT 12
#define HAL_COMPASS_BBBMINI 13
#define HAL_COMPASS_NAVIO2 14
#define HAL_COMPASS_NAVIO 15
#define HAL_COMPASS_AERO 16


#define HAL_LINUX_HEAT_PWM 1





#define HAL_CPU_CLASS_16 1



#define HAL_CPU_CLASS_150 3

#define HAL_CPU_CLASS_1000 4
# 131 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Boards.h"
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/board/px4.h" 1
       

#define HAL_BOARD_NAME "PX4"
#define HAL_CPU_CLASS HAL_CPU_CLASS_150
#define HAL_OS_POSIX_IO 1
#define HAL_BOARD_LOG_DIRECTORY "/fs/microsd/APM/LOGS"
#define HAL_BOARD_TERRAIN_DIRECTORY "/fs/microsd/APM/TERRAIN"
#define HAL_PARAM_DEFAULTS_PATH "/etc/defaults.parm"
#define HAL_INS_DEFAULT HAL_INS_PX4
#define HAL_BARO_DEFAULT HAL_BARO_PX4
#define HAL_COMPASS_DEFAULT HAL_COMPASS_PX4
#define HAL_SERIAL0_BAUD_DEFAULT 115200





#define CONFIG_HAL_BOARD_SUBTYPE HAL_BOARD_SUBTYPE_PX4_V2
#define HAL_STORAGE_SIZE 16384
#define HAL_HAVE_IMU_HEATER 1
#define HAL_IMU_TEMP_DEFAULT -1
# 36 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/board/px4.h"
#define HAL_GPIO_A_LED_PIN 27
#define HAL_GPIO_B_LED_PIN 26
#define HAL_GPIO_C_LED_PIN 25
#define HAL_GPIO_LED_ON LOW
#define HAL_GPIO_LED_OFF HIGH

#define HAL_BARO_MS5611_NAME "ms5611"
#define HAL_BARO_MS5611_SPI_INT_NAME "ms5611_int"
#define HAL_BARO_MS5611_SPI_EXT_NAME "ms5611_ext"

#define HAL_INS_MPU60x0_NAME "mpu6000"
#define HAL_INS_MPU60x0_EXT_NAME "mpu6000_ext"

#define HAL_INS_LSM9DS0_G_NAME "lsm9ds0_g"
#define HAL_INS_LSM9DS0_A_NAME "lsm9ds0_am"

#define HAL_INS_LSM9DS0_EXT_G_NAME "lsm9ds0_ext_g"
#define HAL_INS_LSM9DS0_EXT_A_NAME "lsm9ds0_ext_am"

#define HAL_INS_MPU9250_NAME "mpu9250"
#define HAL_INS_MPU9250_EXT_NAME "mpu9250_ext"

#define HAL_INS_ICM20608_NAME "icm20608"
#define HAL_INS_ICM20608_AM_NAME "icm20608-am"
#define HAL_INS_ICM20608_EXT_NAME "icm20608_ext"

#define HAL_COMPASS_HMC5843_NAME "hmc5843"
# 132 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Boards.h" 2
# 153 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Boards.h"
#define HAL_OS_SOCKETS 0
# 165 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Boards.h"
#define HAL_RANGEFINDER_LIGHTWARE_I2C_BUS 1



#define HAL_COMPASS_HMC5843_I2C_ADDR 0x1E



#define HAL_WITH_UAVCAN 0
# 24 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h" 2

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdlib.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdlib.h"
#define __INCLUDE_STDLIB_H 







# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h"
#define __INCLUDE_SYS_TYPES_H 
# 57 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h"
#define TRUE 1


#define FALSE 0
# 71 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h"
#define NULL (0)
# 84 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h"
#undef OK
#define OK 0



#define PRIOR_RR_MIN 0
#define PRIOR_RR_MAX 255
#define PRIOR_FIFO_MIN 0
#define PRIOR_FIFO_MAX 255
#define PRIOR_OTHER_MIN 0
#define PRIOR_OTHER_MAX 255




#define SCHED_PRIORITY_MAX 255
#define SCHED_PRIORITY_DEFAULT 100
#define SCHED_PRIORITY_MIN 1
#define SCHED_PRIORITY_IDLE 0
# 112 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h"
typedef float float32;




typedef double double_t;
typedef double float64;
# 128 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h"
typedef unsigned int mode_t;
# 138 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h"
typedef uint32_t size_t;
typedef int32_t ssize_t;






typedef int16_t uid_t;
typedef int16_t gid_t;



typedef uint16_t dev_t;



typedef uint16_t ino_t;





typedef int16_t pid_t;





typedef int16_t id_t;



typedef intptr_t ptrdiff_t;
# 191 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/sys/types.h"
typedef uint32_t blkcnt_t;
typedef int32_t off_t;
typedef off_t fpos_t;




typedef int64_t off64_t;
typedef int64_t fpos64_t;




typedef int16_t blksize_t;



typedef unsigned int socklen_t;
typedef uint16_t sa_family_t;



typedef uint32_t clock_t;







typedef uint32_t useconds_t;
typedef int32_t suseconds_t;



typedef int (*main_t)(int argc, char *argv[]);
# 46 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdlib.h" 2
# 57 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdlib.h"
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1







#define MAX_RAND 32767





#define MB_CUR_MAX 1







#define environ get_environ_ptr()






struct mallinfo
{
  int arena;

  int ordblks;
  int mxordblk;
  int uordblks;

  int fordblks;

};
# 107 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stdlib.h"
#undef EXTERN

#define EXTERN extern "C"
extern "C"
{






void srand(unsigned int seed);
int rand(void);




 char **get_environ_ptr( void );
 char *getenv( const char *name);
int putenv( const char *string);
int clearenv(void);
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);




void exit(int status) __attribute__ ((noreturn));
void abort(void) __attribute__ ((noreturn));

int atexit( void (*func)(void));







void _exit(int status);
#define _Exit(s) _exit(s)



long strtol(const char *, char **, int);
unsigned long strtoul(const char *, char **, int);

long long strtoll(const char *, char **, int);
unsigned long long strtoull(const char *, char **, int);

double_t strtod(const char *, char **);

#define atoi(nptr) strtol((nptr), NULL, 10)
#define atol(nptr) strtol((nptr), NULL, 10)

#define atoll(nptr) strtoll((nptr), NULL, 10)

#define atof(nptr) strtod((nptr), NULL)



char *itoa(int value, char *str, int base);



 void *malloc(size_t);
void free( void*);
 void *realloc( void*, size_t);
 void *memalign(size_t, size_t);
 void *zalloc(size_t);
 void *calloc(size_t, size_t);



int abs(int j);
long int labs(long int j);

long long int llabs(long long int j);




void qsort(void *base, size_t nmemb, size_t size,
               int(*compar)(const void *, const void *));


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"
struct mallinfo mallinfo(void);
#pragma GCC diagnostic pop




#undef EXTERN

}
# 26 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h" 2


#define PACKED __attribute__((__packed__))


#define UNUSED_FUNCTION __attribute__((unused))


#define OPTIMIZE(level) __attribute__((optimize(level)))


#define NOINLINE __attribute__((noinline))

#define FMT_PRINTF(a,b) __attribute__((format(printf, a, b)))
#define FMT_SCANF(a,b) __attribute__((format(scanf, a, b)))

#define ToRad(x) radians(x)
#define ToDeg(x) degrees(x)



#define DEFINE_BYTE_ARRAY_METHODS inline uint8_t &operator[](size_t i) { return reinterpret_cast<uint8_t *>(this)[i]; } inline uint8_t operator[](size_t i) const { return reinterpret_cast<const uint8_t *>(this)[i]; }



#define LOCATION_ALT_MAX_M 83000





#define BIT_IS_SET(value,bitnumber) (((value) & (1U<<(bitnumber))) != 0)


#define LOWBYTE(i) ((uint8_t)(i))
#define HIGHBYTE(i) ((uint8_t)(((uint16_t)(i))>>8))

template <typename T, size_t N>
char (&_ARRAY_SIZE_HELPER(T (&_arr)[N]))[N];

template <typename T>
char (&_ARRAY_SIZE_HELPER(T (&_arr)[0]))[0];

#define ARRAY_SIZE(_arr) sizeof(_ARRAY_SIZE_HELPER(_arr))
# 78 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h"
#define _UNUSED_RESULT(uniq_,expr_) do { decltype(expr_) uniq_ __attribute__((unused)); uniq_ = expr_; } while (0)
# 90 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h"
#define UNUSED_RESULT(expr_) _UNUSED_RESULT(__unique_name_ ##__COUNTER__, expr_)
# 110 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h"
struct __attribute__((__packed__)) Location_Option_Flags {
    uint8_t relative_alt : 1;
    uint8_t unused1 : 1;
    uint8_t loiter_ccw : 1;
    uint8_t terrain_alt : 1;
    uint8_t origin_alt : 1;
    uint8_t loiter_xtrack : 1;
};

struct __attribute__((__packed__)) Location {
    union {
        Location_Option_Flags flags;
        uint8_t options;
    };




    int32_t alt:24;
    int32_t lat;
    int32_t lng;
};




enum HomeState {
    HOME_UNSET,
    HOME_SET_NOT_LOCKED,
    HOME_SET_AND_LOCKED
};
# 155 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h"
bool is_bounded_int32(int32_t value, int32_t lower_bound, int32_t upper_bound);
# 167 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/AP_Common.h"
#define SITL_printf(fmt,args...) 
# 9 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h" 1
# 20 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
       

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stddef.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stddef.h"
#define __INCLUDE_STDDEF_H 
# 48 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/stddef.h"
typedef uint32_t wint_t;
# 23 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/string.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/string.h"
#define __INCLUDE_STRING_H 
# 53 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/string.h"
#define bzero(s,n) (void)memset(s,0,n)


#define bcopy(b1,b2,len) (void)memmove(b2,b1,len)





#undef EXTERN

#define EXTERN extern "C"
extern "C" {




extern "C" char *strdup( const char *s);
extern "C" char *strndup( const char *s, size_t size);
extern "C" const char *strerror(int);
extern "C" size_t strlen( const char *);
extern "C" size_t strnlen( const char *, size_t);
extern "C" char *strcat( char *, const char *);
extern "C" char *strncat( char *, const char *, size_t);
extern "C" int strcmp( const char *, const char *);
extern "C" int strncmp( const char *, const char *, size_t);
extern "C" int strcasecmp( const char *, const char *);
extern "C" int strncasecmp( const char *, const char *, size_t);
extern "C" char *strcpy(char *dest, const char *src);
extern "C" char *strncpy(char *, const char *, size_t);
extern "C" char *strpbrk( const char *, const char *);
extern "C" char *strchr( const char *s, int c);
extern "C" char *strrchr( const char *s, int c);
extern "C" size_t strspn( const char *, const char *);
extern "C" size_t strcspn( const char *, const char *);
extern "C" char *strstr( const char *, const char *);
extern "C" char *strcasestr( const char *, const char *);
extern "C" char *strtok( char *, const char *);
extern "C" char *strtok_r( char *, const char *, char **);

extern "C" void *memchr( const void *s, int c, size_t n);
extern "C" void *memccpy( void *s1, const void *s2, int c, size_t n);
extern "C" int memcmp( const void *s1, const void *s2, size_t n);
extern "C" void *memcpy( void *dest, const void *src, size_t n);
extern "C" void *memmove( void *dest, const void *src, size_t count);
extern "C" void *memset( void *s, int c, size_t n);

#undef EXTERN

}
# 24 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h" 2



# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL.h" 1
       



# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Namespace.h" 1
       


# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/functor.h" 1
# 18 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/functor.h"
       



#define FUNCTOR_TYPEDEF(name,rettype,...) typedef Functor<rettype, ## __VA_ARGS__> name


#define FUNCTOR_DECLARE(name,rettype,...) Functor<rettype, ## __VA_ARGS__> name


#define FUNCTOR_BIND(obj,func,rettype,...) Functor<rettype, ## __VA_ARGS__>::bind<std::remove_reference<decltype(*obj)>::type, func>(obj)


#define FUNCTOR_BIND_MEMBER(func,rettype,...) Functor<rettype, ## __VA_ARGS__>::bind<std::remove_reference<decltype(*this)>::type, func>(this)


template <class RetType, class... Args>
class Functor
{
public:
    constexpr Functor(void *obj, RetType (*method)(void *obj, Args...))
        : _obj(obj)
        , _method(method)
    {
    }


    constexpr Functor(decltype(nullptr))
        : Functor(nullptr, nullptr) { }

    constexpr Functor()
        : Functor(nullptr, nullptr) { }


    RetType operator()(Args... args) const
    {
        return _method(_obj, args...);
    }



    inline bool operator==(const Functor<RetType, Args...>& rhs)
    {
        return _obj == rhs._obj && _method == rhs._method;
    }


    explicit operator bool() const
    {
        return _method != nullptr;
    }

    template<class T, RetType (T::*method)(Args...)>
    static constexpr Functor bind(T *obj)
    {
        return { obj, method_wrapper<T, method> };
    }

private:
    void *_obj;
    RetType (*_method)(void *obj, Args...);

    template<class T, RetType (T::*method)(Args...)>
    static RetType method_wrapper(void *obj, Args... args)
    {
        T *t = static_cast<T*>(obj);
        return (t->*method)(args...);
    }
};
# 5 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Namespace.h" 2

namespace AP_HAL {


    class HAL;


    class UARTDriver;
    class I2CDevice;
    class I2CDeviceManager;
    class Device;

    class SPIDevice;
    class SPIDeviceDriver;
    class SPIDeviceManager;

    class AnalogSource;
    class AnalogIn;
    class Storage;
    class DigitalSource;
    class GPIO;
    class RCInput;
    class RCOutput;
    class Scheduler;
    class Semaphore;
    class OpticalFlow;

    class Util;


    class Print;
    class Stream;
    class BetterStream;






    typedef void(*Proc)(void);
    typedef Functor<void> MemberProc;





    enum SPIDeviceType {

        SPIDevice_Type = -1,
    };


    const HAL& get_HAL();
}
# 6 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL.h" 2

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Macros.h" 1
       






#define WARN_IF_UNUSED __attribute__ ((warn_unused_result))
# 19 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Macros.h"
#define NORETURN __attribute__ ((noreturn))
# 8 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Main.h" 1
# 17 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Main.h"
       

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 1
       



# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AnalogIn.h" 1
       

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/inttypes.h" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/inttypes.h"
#define __INCLUDE_INTTYPES_H 
# 160 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/inttypes.h"
typedef void *imaxdiv_t;






#define EXTERN extern "C"
extern "C" {
# 177 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/inttypes.h"
extern "C" intmax_t imaxabs(intmax_t);
extern "C" imaxdiv_t imaxdiv(intmax_t, intmax_t);
extern "C" intmax_t strtoimax(const char *, char **, int);
extern "C" uintmax_t strtoumax(const char *, char **, int);

extern "C" intmax_t wcstoimax(const wchar_t *, wchar_t **, int);
extern "C" uintmax_t wcstoumax(const wchar_t *, wchar_t **, int);

#undef EXTERN

}
# 4 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AnalogIn.h" 2



class AP_HAL::AnalogSource {
public:
    virtual float read_average() = 0;
    virtual float read_latest() = 0;
    virtual void set_pin(uint8_t p) = 0;






    virtual void set_stop_pin(uint8_t p) = 0;






    virtual void set_settle_time(uint16_t settle_time_ms) = 0;



    virtual float voltage_average() = 0;



    virtual float voltage_latest() = 0;



    virtual float voltage_average_ratiometric() = 0;
};

class AP_HAL::AnalogIn {
public:
    virtual void init() = 0;
    virtual AP_HAL::AnalogSource* channel(int16_t n) = 0;


    virtual float board_voltage(void) = 0;


    virtual float servorail_voltage(void) { return 0; }


    virtual uint16_t power_status_flags(void) { return 0; }
};

#define ANALOG_INPUT_BOARD_VCC 254
#define ANALOG_INPUT_NONE 255
# 6 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/GPIO.h" 1
       





#define HAL_GPIO_INPUT 0
#define HAL_GPIO_OUTPUT 1
#define HAL_GPIO_ALT 2
#define HAL_GPIO_INTERRUPT_LOW 0
#define HAL_GPIO_INTERRUPT_HIGH 1
#define HAL_GPIO_INTERRUPT_FALLING 2
#define HAL_GPIO_INTERRUPT_RISING 3

class AP_HAL::DigitalSource {
public:
    virtual void mode(uint8_t output) = 0;
    virtual uint8_t read() = 0;
    virtual void write(uint8_t value) = 0;
    virtual void toggle() = 0;
};

class AP_HAL::GPIO {
public:
    GPIO() {}
    virtual void init() = 0;
    virtual void pinMode(uint8_t pin, uint8_t output) = 0;


    virtual void pinMode(uint8_t pin, uint8_t output, uint8_t alt) {};

    virtual uint8_t read(uint8_t pin) = 0;
    virtual void write(uint8_t pin, uint8_t value) = 0;
    virtual void toggle(uint8_t pin) = 0;
    virtual int8_t analogPinToDigitalPin(uint8_t pin) = 0;


    virtual AP_HAL::DigitalSource* channel(uint16_t n) = 0;


    virtual bool attach_interrupt(uint8_t interrupt_num, AP_HAL::Proc p,
            uint8_t mode) = 0;


    virtual bool usb_connected(void) = 0;
};
# 7 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/RCInput.h" 1
       



#define RC_INPUT_MIN_PULSEWIDTH 900
#define RC_INPUT_MAX_PULSEWIDTH 2100

class AP_HAL::RCInput {
public:






    virtual void init() = 0;
    virtual void teardown() {};







    virtual bool new_input() = 0;




    virtual uint8_t num_channels() = 0;


    virtual uint16_t read(uint8_t ch) = 0;


    virtual uint8_t read(uint16_t* periods, uint8_t len) = 0;
# 48 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/RCInput.h"
    virtual bool set_overrides(int16_t *overrides, uint8_t len) = 0;

    virtual bool set_override(uint8_t channel, int16_t override) = 0;

    virtual void clear_overrides() = 0;


    virtual bool rc_bind(int dsmMode) { return false; }
};
# 8 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/RCOutput.h" 1
       



#define RC_OUTPUT_MIN_PULSEWIDTH 400
#define RC_OUTPUT_MAX_PULSEWIDTH 2100



#define CH_1 0
#define CH_2 1
#define CH_3 2
#define CH_4 3
#define CH_5 4
#define CH_6 5
#define CH_7 6
#define CH_8 7
#define CH_9 8
#define CH_10 9
#define CH_11 10
#define CH_12 11
#define CH_13 12
#define CH_14 13
#define CH_15 14
#define CH_16 15
#define CH_17 16
#define CH_18 17
#define CH_NONE 255



class AP_HAL::RCOutput {
public:
    virtual void init() = 0;


    virtual void set_freq(uint32_t chmask, uint16_t freq_hz) = 0;
    virtual uint16_t get_freq(uint8_t ch) = 0;



    virtual void enable_ch(uint8_t ch) = 0;
    virtual void disable_ch(uint8_t ch) = 0;





    virtual void write(uint8_t ch, uint16_t period_us) = 0;






    virtual void cork() = 0;





    virtual void push() = 0;





    virtual uint16_t read(uint8_t ch) = 0;
    virtual void read(uint16_t* period_us, uint8_t len) = 0;


    virtual uint16_t read_last_sent(uint8_t ch) { return read(ch); }
    virtual void read_last_sent(uint16_t* period_us, uint8_t len) { read(period_us, len); };





    virtual void set_safety_pwm(uint32_t chmask, uint16_t period_us) {}




    virtual void set_failsafe_pwm(uint32_t chmask, uint16_t period_us) {}






    virtual bool force_safety_on(void) { return false; }




    virtual void force_safety_off(void) {}




    virtual void force_safety_no_wait(void) {}







    virtual void set_esc_scaling(uint16_t min_pwm, uint16_t max_pwm) {}




    virtual bool enable_sbus_out(uint16_t rate_gz) { return false; }




    enum output_mode {
        MODE_PWM_NORMAL,
        MODE_PWM_ONESHOT,
        MODE_PWM_BRUSHED16KHZ
    };
    virtual void set_output_mode(enum output_mode mode) {}
};
# 9 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/SPIDevice.h" 1
# 17 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/SPIDevice.h"
       




# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Device.h" 1
# 17 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Device.h"
       
# 27 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Device.h"
class AP_HAL::Device {
public:
    enum BusType {
        BUS_TYPE_UNKNOWN = 0,
        BUS_TYPE_I2C = 1,
        BUS_TYPE_SPI = 2,
        BUS_TYPE_UAVCAN = 3
    };

    enum Speed {
        SPEED_HIGH,
        SPEED_LOW,
    };

    typedef Functor<bool> PeriodicCb;
    typedef void* PeriodicHandle;

    Device(enum BusType type)
    {
        _bus_id.devid_s.bus_type = type;
    }


    enum BusType bus_type(void) const {
        return _bus_id.devid_s.bus_type;
    }


    uint8_t bus_num(void) const {
        return _bus_id.devid_s.bus;
    }


    uint32_t get_bus_id(void) const {
        return _bus_id.devid;
    }


    uint8_t get_bus_address(void) const {
        return _bus_id.devid_s.address;
    }


    void set_device_type(uint8_t devtype) {
        _bus_id.devid_s.devtype = devtype;
    }


    virtual ~Device() {
        if (_checked.regs != nullptr) {
            delete[] _checked.regs;
        }
    }
# 88 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Device.h"
    virtual bool set_speed(Speed speed) = 0;







    virtual bool transfer(const uint8_t *send, uint32_t send_len,
                          uint8_t *recv, uint32_t recv_len) = 0;
# 107 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Device.h"
    bool read_registers(uint8_t first_reg, uint8_t *recv, uint32_t recv_len)
    {
        first_reg |= _read_flag;
        return transfer(&first_reg, 1, recv, recv_len);
    }






    bool read_uint16_le(uint8_t first_reg, uint16_t &value);






    bool read_uint16_be(uint8_t first_reg, uint16_t &value);







    bool write_register(uint8_t reg, uint8_t val, bool checked=false)
    {
        uint8_t buf[2] = { reg, val };
        if (checked) {
            set_checked_register(reg, val);
        }
        return transfer(buf, sizeof(buf), nullptr, 0);
    }




    void set_checked_register(uint8_t reg, uint8_t val);





    bool setup_checked_registers(uint8_t num_regs, uint8_t frequency=10);





    bool check_next_register(void);






    bool read(uint8_t *recv, uint32_t recv_len)
    {
        return transfer(nullptr, 0, recv, recv_len);
    }





    virtual AP_HAL::Semaphore *get_semaphore() = 0;
# 189 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Device.h"
    virtual PeriodicHandle register_periodic_callback(uint32_t period_usec, PeriodicCb) = 0;
# 198 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Device.h"
    virtual bool adjust_periodic_callback(PeriodicHandle h, uint32_t period_usec) = 0;







    virtual bool unregister_callback(PeriodicHandle h) { return false; }






    virtual bool set_chip_select(bool set) { return false; }






    void set_read_flag(uint8_t flag)
    {
        _read_flag = flag;
    }







    static uint32_t make_bus_id(enum BusType bus_type, uint8_t bus, uint8_t address, uint8_t devtype) {
        union DeviceId d;
        d.devid_s.bus_type = bus_type;
        d.devid_s.bus = bus;
        d.devid_s.address = address;
        d.devid_s.devtype = devtype;
        return d.devid;
    }





    static uint32_t change_bus_id(uint32_t old_id, uint8_t devtype) {
        union DeviceId d;
        d.devid = old_id;
        d.devid_s.devtype = devtype;
        return d.devid;
    }




    uint32_t get_bus_id_devtype(uint8_t devtype) {
        return change_bus_id(get_bus_id(), devtype);
    }


    virtual void set_retries(uint8_t retries) {};

protected:
    uint8_t _read_flag = 0;







    struct DeviceStructure {
        enum BusType bus_type : 3;
        uint8_t bus: 5;
        uint8_t address;
        uint8_t devtype;
    };

    union DeviceId {
        struct DeviceStructure devid_s;
        uint32_t devid;
    };

    union DeviceId _bus_id;


    void set_device_address(uint8_t address) {
        _bus_id.devid_s.address = address;
    }


    void set_device_bus(uint8_t bus) {
        _bus_id.devid_s.bus = bus;
    }

private:

    struct checkreg {
        uint8_t regnum;
        uint8_t value;
    };
    struct {
        uint8_t n_allocated;
        uint8_t n_set;
        uint8_t next;
        uint8_t frequency;
        uint8_t counter;
        struct checkreg *regs;
    } _checked;
};
# 23 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/SPIDevice.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/OwnPtr.h" 1
# 17 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/OwnPtr.h"
       

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/missing/cstddef" 1
       

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/cxx/cstddef" 1
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/cxx/cstddef"
#define __INCLUDE_CXX_CSTDDEF 
# 52 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/modules/PX4Firmware/Build/px4fmu-v2_APM.build/nuttx-export/include/cxx/cstddef"
namespace std
{


  using ::float32;




  using ::double_t;
  using ::float64;

  using ::mode_t;
  using ::size_t;
  using ::ssize_t;
  using ::off_t;
  using ::blksize_t;
  using ::blkcnt_t;
  using ::fpos_t;
  using ::uid_t;
  using ::gid_t;
  using ::dev_t;
  using ::ino_t;
  using ::pid_t;

  using ::socklen_t;
  using ::sa_family_t;
}
# 4 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Common/missing/cstddef" 2



namespace std {
    typedef decltype(nullptr) nullptr_t;
}
# 20 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/OwnPtr.h" 2

namespace AP_HAL {
# 39 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/OwnPtr.h"
template<typename T>
class OwnPtr {
public:
    OwnPtr() : _ptr(nullptr) { }
    OwnPtr(std::nullptr_t) : _ptr(nullptr) { }


    OwnPtr(const OwnPtr<T> &other) = delete;


    template<typename U>
    OwnPtr(OwnPtr<U>&& other) : _ptr(other.leak()) { }

    OwnPtr(T *ptr) : _ptr(ptr) { }

    OwnPtr<T>& operator=(std::nullptr_t) { clear(); return *this; }

    template<typename U>
    OwnPtr<T>& operator=(OwnPtr<U>&& other)
    {
        T *old = _ptr;
        _ptr = other.leak();
        delete old;
        return *this;
    }

    template<typename U>
    OwnPtr<T>& operator=(U *other)
    {
        T *old = _ptr;
        _ptr = other;
        delete old;
        return *this;
    }

    ~OwnPtr() { delete _ptr; }

    void clear()
    {
        delete leak();
    }

    T *leak()
    {
        T *old = _ptr;
        _ptr = nullptr;
        return old;
    }

    T *get() const
    {
        return _ptr;
    }

    T& operator*() const { return *_ptr; }
    T *operator->() const { return _ptr; }
    bool operator !() const { return !_ptr; }
    explicit operator bool() const { return _ptr != nullptr; }

private:
    T *_ptr;
};

template<typename T>
inline bool operator==(T* a, const OwnPtr<T>& b)
{
    return a == b.get();
}

template<typename T>
inline bool operator==(const OwnPtr<T>& a, T* b)
{
    return a.get() == b;
}

template<typename T>
inline bool operator!=(T* a, const OwnPtr<T>& b)
{
    return a != b.get();
}

template<typename T>
inline bool operator!=(const OwnPtr<T>& a, T* b)
{
    return a.get() != b;
}

}
# 24 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/SPIDevice.h" 2

namespace AP_HAL {

class SPIDevice : public Device {
public:
    SPIDevice() : Device(BUS_TYPE_SPI) { }

    virtual ~SPIDevice() { }



    virtual bool set_speed(Device::Speed speed) override = 0;


    virtual bool transfer(const uint8_t *send, uint32_t send_len,
                          uint8_t *recv, uint32_t recv_len) override = 0;





    virtual bool transfer_fullduplex(const uint8_t *send, uint8_t *recv,
                                     uint32_t len) = 0;


    virtual Semaphore *get_semaphore() override = 0;


    virtual Device::PeriodicHandle register_periodic_callback(
        uint32_t period_usec, Device::PeriodicCb) override = 0;


    virtual bool adjust_periodic_callback(
        PeriodicHandle h, uint32_t period_usec) override { return false; }
};

class SPIDeviceManager {
public:
    virtual OwnPtr<SPIDevice> get_device(const char *name)
    {
        return nullptr;
    }
};

}
# 10 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Storage.h" 1
       




class AP_HAL::Storage {
public:
    virtual void init() = 0;
    virtual void read_block(void *dst, uint16_t src, size_t n) = 0;
    virtual void write_block(uint16_t dst, const void* src, size_t n) = 0;
};
# 11 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/UARTDriver.h" 1
       






# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/BetterStream.h" 1
# 20 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/BetterStream.h"
       

# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/lib/gcc/arm-none-eabi/4.9.3/include/stdarg.h" 1 3 4
# 31 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/lib/gcc/arm-none-eabi/4.9.3/include/stdarg.h" 3 4
#define _STDARG_H 
#define _ANSI_STDARG_H_ 

#undef __need___va_list




#define __GNUC_VA_LIST 
typedef __builtin_va_list __gnuc_va_list;






#define va_start(v,l) __builtin_va_start(v,l)
#define va_end(v) __builtin_va_end(v)
#define va_arg(v,l) __builtin_va_arg(v,l)

#define va_copy(d,s) __builtin_va_copy(d,s)

#define __va_copy(d,s) __builtin_va_copy(d,s)
# 98 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/lib/gcc/arm-none-eabi/4.9.3/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;





#define _VA_LIST_ 


#define _VA_LIST 


#define _VA_LIST_DEFINED 


#define _VA_LIST_T_H 


#define __va_list__ 
# 23 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/BetterStream.h" 2




# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/Stream.h" 1
       


# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/Print.h" 1
# 19 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/Print.h"
       
# 33 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/Print.h"
enum {
    BASE_DEFAULT = 0,
    BASE_BIN = 2,
    BASE_OCT = 8,
    BASE_DEC = 10,
    BASE_HEX = 16
};


class AP_HAL::Print {
  private:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(float, uint8_t);
  public:
    Print() {}

    virtual size_t write(uint8_t) = 0;
    virtual size_t write(const uint8_t *buffer, size_t size) = 0;

    size_t write(const char *str) { return write((const uint8_t *)str, strlen(str)); }
  public:
    size_t print(const char[]);
    size_t print(char);
    size_t print(unsigned char, int = BASE_DEC);
    size_t print(int, int = BASE_DEC);
    size_t print(unsigned int, int = BASE_DEC);
    size_t print(long, int = BASE_DEC);
    size_t print(unsigned long, int = BASE_DEC);
    size_t print(float , int = 2);
    size_t print(double , int = 2);

    size_t println(const char[]);
    size_t println(char);
    size_t println(unsigned char, int = BASE_DEC);
    size_t println(int, int = BASE_DEC);
    size_t println(unsigned int, int = BASE_DEC);
    size_t println(long, int = BASE_DEC);
    size_t println(unsigned long, int = BASE_DEC);
    size_t println(float , int = 2);
    size_t println(double , int = 2);
    size_t println(void);

};
# 5 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/Stream.h" 2




class AP_HAL::Stream : public AP_HAL::Print {
public:
    virtual uint32_t available() = 0;


    virtual uint32_t txspace() = 0;



    virtual int16_t read() = 0;

};
# 28 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/utility/BetterStream.h" 2

class AP_HAL::BetterStream : public AP_HAL::Stream {
public:
    BetterStream(void) {}

    virtual void printf(const char *, ...) __attribute__((format(printf, 2, 3))) = 0;
    virtual void vprintf(const char *, va_list) = 0;
};
# 9 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/UARTDriver.h" 2


class AP_HAL::UARTDriver : public AP_HAL::BetterStream {
public:
    UARTDriver() {}
    virtual void begin(uint32_t baud) = 0;
# 35 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/UARTDriver.h"
    virtual void begin(uint32_t baud, uint16_t rxSpace, uint16_t txSpace) = 0;
    virtual void end() = 0;
    virtual void flush() = 0;
    virtual bool is_initialized() = 0;
    virtual void set_blocking_writes(bool blocking) = 0;
    virtual bool tx_pending() = 0;

    enum flow_control {
        FLOW_CONTROL_DISABLE=0, FLOW_CONTROL_ENABLE=1, FLOW_CONTROL_AUTO=2
    };
    virtual void set_flow_control(enum flow_control flow_control_setting) {};
    virtual enum flow_control get_flow_control(void) { return FLOW_CONTROL_DISABLE; }





    void printf(const char *s, ...) __attribute__((format(printf, 2, 3)));
    void vprintf(const char *s, va_list ap);
};
# 12 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/system.h" 1
       







namespace AP_HAL {

void init();

void panic(const char *errormsg, ...) __attribute__((format(printf, 1, 2))) __attribute__ ((noreturn));

uint32_t micros();
uint32_t millis();
uint64_t micros64();
uint64_t millis64();

}
# 13 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/OpticalFlow.h" 1
# 15 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/OpticalFlow.h"
       

class AP_HAL::OpticalFlow {
public:
    class Data_Frame {
    public:
        float pixel_flow_x_integral;
        float pixel_flow_y_integral;
        float gyro_x_integral;
        float gyro_y_integral;
        uint32_t delta_time;
        uint8_t quality;
    };

    typedef Functor<void, float&, float&, float&> Gyro_Cb;

    virtual void init(Gyro_Cb) = 0;
    virtual bool read(Data_Frame& frame) = 0;
};
# 14 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/HAL.h" 2

class AP_HAL::HAL {
public:
    HAL(AP_HAL::UARTDriver* _uartA,
        AP_HAL::UARTDriver* _uartB,
        AP_HAL::UARTDriver* _uartC,
        AP_HAL::UARTDriver* _uartD,
        AP_HAL::UARTDriver* _uartE,
        AP_HAL::UARTDriver* _uartF,
        AP_HAL::I2CDeviceManager* _i2c_mgr,
        AP_HAL::SPIDeviceManager* _spi,
        AP_HAL::AnalogIn* _analogin,
        AP_HAL::Storage* _storage,
        AP_HAL::UARTDriver* _console,
        AP_HAL::GPIO* _gpio,
        AP_HAL::RCInput* _rcin,
        AP_HAL::RCOutput* _rcout,
        AP_HAL::Scheduler* _scheduler,
        AP_HAL::Util* _util,
        AP_HAL::OpticalFlow *_opticalflow)
        :
        uartA(_uartA),
        uartB(_uartB),
        uartC(_uartC),
        uartD(_uartD),
        uartE(_uartE),
        uartF(_uartF),
        i2c_mgr(_i2c_mgr),
        spi(_spi),
        analogin(_analogin),
        storage(_storage),
        console(_console),
        gpio(_gpio),
        rcin(_rcin),
        rcout(_rcout),
        scheduler(_scheduler),
        util(_util),
        opticalflow(_opticalflow)
    {
        AP_HAL::init();
    }

    struct Callbacks {
        virtual void setup() = 0;
        virtual void loop() = 0;
    };

    struct FunCallbacks : public Callbacks {
        FunCallbacks(void (*setup_fun)(void), void (*loop_fun)(void));

        void setup() override { _setup(); }
        void loop() override { _loop(); }

    private:
        void (*_setup)(void);
        void (*_loop)(void);
    };

    virtual void run(int argc, char * const argv[], Callbacks* callbacks) const = 0;

    AP_HAL::UARTDriver* uartA;
    AP_HAL::UARTDriver* uartB;
    AP_HAL::UARTDriver* uartC;
    AP_HAL::UARTDriver* uartD;
    AP_HAL::UARTDriver* uartE;
    AP_HAL::UARTDriver* uartF;
    AP_HAL::I2CDeviceManager* i2c_mgr;
    AP_HAL::SPIDeviceManager* spi;
    AP_HAL::AnalogIn* analogin;
    AP_HAL::Storage* storage;
    AP_HAL::UARTDriver* console;
    AP_HAL::GPIO* gpio;
    AP_HAL::RCInput* rcin;
    AP_HAL::RCOutput* rcout;
    AP_HAL::Scheduler* scheduler;
    AP_HAL::Util *util;
    AP_HAL::OpticalFlow *opticalflow;
};
# 20 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Main.h" 2


#define AP_MAIN __EXPORT ArduPilot_main






#define AP_HAL_MAIN() AP_HAL::HAL::FunCallbacks callbacks(setup, loop); extern "C" { int AP_MAIN(int argc, char* const argv[]); int AP_MAIN(int argc, char* const argv[]) { hal.run(argc, argv, &callbacks); return 0; } }
# 39 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL_Main.h"
#define AP_HAL_MAIN_CALLBACKS(CALLBACKS) extern "C" { int AP_MAIN(int argc, char* const argv[]); int AP_MAIN(int argc, char* const argv[]) { hal.run(argc, argv, CALLBACKS); return 0; } }
# 9 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL.h" 2
# 17 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL.h"
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Scheduler.h" 1
       
# 11 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Scheduler.h"
class AP_HAL::Scheduler {
public:
    Scheduler() {}
    virtual void init() = 0;
    virtual void delay(uint16_t ms) = 0;





    virtual void delay_microseconds(uint16_t us) = 0;
# 30 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Scheduler.h"
    virtual void delay_microseconds_boost(uint16_t us) { delay_microseconds(us); }

    virtual void register_delay_callback(AP_HAL::Proc,
                                             uint16_t min_time_ms) = 0;


    virtual void register_timer_process(AP_HAL::MemberProc) = 0;
    virtual bool register_timer_process(AP_HAL::MemberProc proc, uint8_t freq_div)
    {
        register_timer_process(proc);
        return false;
    }


    virtual void register_io_process(AP_HAL::MemberProc) = 0;


    virtual void suspend_timer_procs() = 0;
    virtual void resume_timer_procs() = 0;

    virtual bool in_timerprocess() = 0;

    virtual void register_timer_failsafe(AP_HAL::Proc,
                                             uint32_t period_us) = 0;

    virtual void system_initialized() = 0;

    virtual void reboot(bool hold_in_bootloader) = 0;




    virtual void stop_clock(uint64_t time_usec) {}
};
# 18 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Semaphores.h" 1
       



#define HAL_SEMAPHORE_BLOCK_FOREVER 0

class AP_HAL::Semaphore {
public:
    virtual bool take(uint32_t timeout_ms) __attribute__ ((warn_unused_result)) = 0 ;
    virtual bool take_nonblocking() __attribute__ ((warn_unused_result)) = 0;
    virtual bool give() = 0;
    virtual ~Semaphore(void) {}
};
# 19 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Util.h" 1
       




class AP_HAL::Util {
public:
    int snprintf(char* str, size_t size,
                 const char *format, ...);

    int vsnprintf(char* str, size_t size,
                  const char *format, va_list ap);

    void set_soft_armed(const bool b) { soft_armed = b; }
    bool get_soft_armed() const { return soft_armed; }

    void set_capabilities(uint64_t cap) { capabilities |= cap; }
    void clear_capabilities(uint64_t cap) { capabilities &= ~(cap); }
    uint64_t get_capabilities() const { return capabilities; }

    virtual const char* get_custom_log_directory() { return nullptr; }
    virtual const char* get_custom_terrain_directory() const { return nullptr; }


    virtual const char* get_custom_defaults_file() const {
        return "/etc/defaults.parm";
    }




    virtual bool run_debug_shell(AP_HAL::BetterStream *stream) = 0;

    enum safety_state {
        SAFETY_NONE, SAFETY_DISARMED, SAFETY_ARMED
    };




    virtual enum safety_state safety_switch_state(void) { return SAFETY_NONE; }




    virtual void set_system_clock(uint64_t time_utc_usec) {}




    uint64_t get_system_clock_ms() const;




    void get_system_clock_utc(int32_t &hour, int32_t &min, int32_t &sec, int32_t &ms) const;

    uint32_t get_time_utc(int32_t hour, int32_t min, int32_t sec, int32_t ms) const;
# 67 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/Util.h"
    virtual bool get_system_id(char buf[40]) { return false; }




    virtual uint32_t available_memory(void) { return 4096; }




    virtual void commandline_arguments(uint8_t &argc, char * const *&argv) { argc = 0; }




    virtual bool toneAlarm_init() { return false;}
    virtual void toneAlarm_set_tune(uint8_t tune) {}
    virtual void _toneAlarm_timer_tick() {}




    virtual AP_HAL::Stream *get_shell_stream() { return nullptr; }


    virtual void set_imu_temp(float current) {}


    virtual void set_imu_target_temp(int8_t *target) {}




    enum perf_counter_type {
        PC_COUNT,
        PC_ELAPSED,
        PC_INTERVAL
    };
    typedef void *perf_counter_t;
    virtual perf_counter_t perf_alloc(perf_counter_type t, const char *name) { return nullptr; }
    virtual void perf_begin(perf_counter_t h) {}
    virtual void perf_end(perf_counter_t h) {}
    virtual void perf_count(perf_counter_t h) {}


    virtual Semaphore *new_semaphore(void) { return nullptr; }


    virtual void *dma_allocate(size_t size) { return malloc(size); }
    virtual void dma_free(void *ptr, size_t size) { return free(ptr); }

protected:


    bool soft_armed = false;
    uint64_t capabilities = 0;
};
# 20 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_HAL/AP_HAL.h" 2
# 28 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/StorageManager/StorageManager.h" 1
# 21 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/StorageManager/StorageManager.h"
       
# 30 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/StorageManager/StorageManager.h"
#define STORAGE_NUM_AREAS 13
# 42 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/StorageManager/StorageManager.h"
class StorageManager {
    friend class StorageAccess;
public:
    enum StorageType {
        StorageParam = 0,
        StorageFence = 1,
        StorageRally = 2,
        StorageMission = 3,
        StorageKeys = 4
    };


    static void erase(void);


    static void set_layout_copter(void) { layout = layout_copter; }

private:
    struct StorageArea {
        StorageType type;
        uint16_t offset;
        uint16_t length;
    };


    static const StorageArea layout_copter[13];
    static const StorageArea layout_default[13];
    static const StorageArea *layout;
};




class StorageAccess {
public:

    StorageAccess(StorageManager::StorageType _type);


    uint16_t size(void) const { return total_size; }


    bool read_block(void *dst, uint16_t src, size_t n) const;
    bool write_block(uint16_t dst, const void* src, size_t n) const;


    uint8_t read_byte(uint16_t loc) const;
    uint16_t read_uint16(uint16_t loc) const;
    uint32_t read_uint32(uint16_t loc) const;

    void write_byte(uint16_t loc, uint8_t value) const;
    void write_uint16(uint16_t loc, uint16_t value) const;
    void write_uint32(uint16_t loc, uint32_t value) const;

private:
    const StorageManager::StorageType type;
    uint16_t total_size;
};
# 29 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h" 2

# 1 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/lib/gcc/arm-none-eabi/4.9.3/include/float.h" 1 3 4
# 29 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/lib/gcc/arm-none-eabi/4.9.3/include/float.h" 3 4
#define _FLOAT_H___ 


#undef FLT_RADIX
#define FLT_RADIX __FLT_RADIX__


#undef FLT_MANT_DIG
#undef DBL_MANT_DIG
#undef LDBL_MANT_DIG
#define FLT_MANT_DIG __FLT_MANT_DIG__
#define DBL_MANT_DIG __DBL_MANT_DIG__
#define LDBL_MANT_DIG __LDBL_MANT_DIG__
# 50 "/usr/local/gcc-arm-none-eabi-4_9-2014q4/lib/gcc/arm-none-eabi/4.9.3/include/float.h" 3 4
#undef FLT_DIG
#undef DBL_DIG
#undef LDBL_DIG
#define FLT_DIG __FLT_DIG__
#define DBL_DIG __DBL_DIG__
#define LDBL_DIG __LDBL_DIG__


#undef FLT_MIN_EXP
#undef DBL_MIN_EXP
#undef LDBL_MIN_EXP
#define FLT_MIN_EXP __FLT_MIN_EXP__
#define DBL_MIN_EXP __DBL_MIN_EXP__
#define LDBL_MIN_EXP __LDBL_MIN_EXP__






#undef FLT_MIN_10_EXP
#undef DBL_MIN_10_EXP
#undef LDBL_MIN_10_EXP
#define FLT_MIN_10_EXP __FLT_MIN_10_EXP__
#define DBL_MIN_10_EXP __DBL_MIN_10_EXP__
#define LDBL_MIN_10_EXP __LDBL_MIN_10_EXP__


#undef FLT_MAX_EXP
#undef DBL_MAX_EXP
#undef LDBL_MAX_EXP
#define FLT_MAX_EXP __FLT_MAX_EXP__
#define DBL_MAX_EXP __DBL_MAX_EXP__
#define LDBL_MAX_EXP __LDBL_MAX_EXP__






#undef FLT_MAX_10_EXP
#undef DBL_MAX_10_EXP
#undef LDBL_MAX_10_EXP
#define FLT_MAX_10_EXP __FLT_MAX_10_EXP__
#define DBL_MAX_10_EXP __DBL_MAX_10_EXP__
#define LDBL_MAX_10_EXP __LDBL_MAX_10_EXP__





#undef FLT_MAX
#undef DBL_MAX
#undef LDBL_MAX
#define FLT_MAX __FLT_MAX__
#define DBL_MAX __DBL_MAX__
#define LDBL_MAX __LDBL_MAX__



#undef FLT_EPSILON
#undef DBL_EPSILON
#undef LDBL_EPSILON
#define FLT_EPSILON __FLT_EPSILON__
#define DBL_EPSILON __DBL_EPSILON__
#define LDBL_EPSILON __LDBL_EPSILON__


#undef FLT_MIN
#undef DBL_MIN
#undef LDBL_MIN
#define FLT_MIN __FLT_MIN__
#define DBL_MIN __DBL_MIN__
#define LDBL_MIN __LDBL_MIN__



#undef FLT_ROUNDS
#define FLT_ROUNDS 1
# 31 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h" 2

#define AP_MAX_NAME_SIZE 16






#define AP_PARAM_FLAG_NESTED_OFFSET 1


#define AP_PARAM_FLAG_POINTER 2



#define AP_PARAM_FLAG_ENABLE 4



#define AP_PARAM_NO_SHIFT 8




#define AP_VAROFFSET(type,element) (((ptrdiff_t)(&((const type *)1)->element))-1)


#define AP_CLASSTYPE(clazz,element) ((uint8_t)(((const clazz *) 1)->element.vtype))


#define AP_GROUPINFO_FLAGS(name,idx,clazz,element,def,flags) { AP_CLASSTYPE(clazz, element), idx, name, AP_VAROFFSET(clazz, element), {def_value : def}, flags }


#define AP_GROUPINFO(name,idx,clazz,element,def) AP_GROUPINFO_FLAGS(name, idx, clazz, element, def, 0)


#define AP_NESTEDGROUPINFO(clazz,idx) { AP_PARAM_GROUP, idx, "", 0, { group_info : clazz::var_info }, 0 }



#define AP_SUBGROUPINFO(element,name,idx,thisclazz,elclazz) { AP_PARAM_GROUP, idx, name, AP_VAROFFSET(thisclazz, element), { group_info : elclazz::var_info }, AP_PARAM_FLAG_NESTED_OFFSET }


#define AP_SUBGROUPPTR(element,name,idx,thisclazz,elclazz) { AP_PARAM_GROUP, idx, name, AP_VAROFFSET(thisclazz, element), { group_info : elclazz::var_info }, AP_PARAM_FLAG_POINTER }

#define AP_GROUPEND { AP_PARAM_NONE, 0xFF, "", 0, { group_info : nullptr } }
#define AP_VAREND { AP_PARAM_NONE, "", 0, nullptr, { group_info : nullptr } }

enum ap_var_type {
    AP_PARAM_NONE = 0,
    AP_PARAM_INT8,
    AP_PARAM_INT16,
    AP_PARAM_INT32,
    AP_PARAM_FLOAT,
    AP_PARAM_VECTOR3F,
    AP_PARAM_GROUP
};






class AP_Param
{
public:



    struct GroupInfo {
        uint8_t type;
        uint8_t idx;
        const char *name;
        ptrdiff_t offset;
        union {
            const struct GroupInfo *group_info;
            const float def_value;
        };
        uint8_t flags;
    };
    struct Info {
        uint8_t type;
        const char *name;
        uint16_t key;
        const void *ptr;
        union {
            const struct GroupInfo *group_info;
            const float def_value;
        };
        uint8_t flags;
    };
    struct ConversionInfo {
        uint16_t old_key;
        uint8_t old_group_element;
        enum ap_var_type type;
        const char *new_name;
    };




    static bool setup();


    AP_Param(const struct Info *info)
    {
        _var_info = info;
        uint16_t i;
        for (i=0; info[i].type != AP_PARAM_NONE; i++) ;
        _num_vars = i;
    }


    AP_Param() {}


    typedef struct {
        uint32_t key : 9;
        uint32_t idx : 5;
        uint32_t group_element : 18;
    } ParamToken;



    struct GroupNesting {
        static const uint8_t numlevels = 2;
        uint8_t level;
        const struct GroupInfo *group_ret[numlevels];
    };


    static bool initialised(void);







    static uint32_t group_id(const struct GroupInfo *grpinfo, uint32_t base, uint8_t i, uint8_t shift);
# 184 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
    void copy_name_info(const struct AP_Param::Info *info,
                        const struct GroupInfo *ginfo,
                        const struct GroupNesting &group_nesting,
                        uint8_t idx, char *buffer, size_t bufferSize, bool force_scalar=false) const;





    void copy_name_token(const ParamToken &token, char *buffer, size_t bufferSize, bool force_scalar=false) const;
# 203 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
    static AP_Param * find(const char *name, enum ap_var_type *ptype);






    static bool set_default_by_name(const char *name, float value);
# 219 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
    static AP_Param * find_by_index(uint16_t idx, enum ap_var_type *ptype, ParamToken *token);







    static bool find_key_by_pointer_group(const void *ptr, uint16_t vindex, const struct GroupInfo *group_info,
                                          ptrdiff_t offset, uint16_t &key);
    static bool find_key_by_pointer(const void *ptr, uint16_t &key);







    static AP_Param * find_object(const char *name);



    void notify() const;







    bool save(bool force_save=false);





    bool load(void);
# 265 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
    static bool load_all(void);

    static void load_object_from_eeprom(const void *object_pointer, const struct GroupInfo *group_info);


    static void set_value(enum ap_var_type type, void *ptr, float def_value);




    void set_float(float value, enum ap_var_type var_type);


    static void setup_object_defaults(const void *object_pointer, const struct GroupInfo *group_info);




    static bool set_object_value(const void *object_pointer,
                                 const struct GroupInfo *group_info,
                                 const char *name, float value);



    static void setup_sketch_defaults(void);


    static bool find_old_parameter(const struct ConversionInfo *info, AP_Param *value);


    static void convert_old_parameters(const struct ConversionInfo *conversion_table, uint8_t table_size);


    static void convert_old_parameter(const struct ConversionInfo *info, float scaler);



    static void erase_all(void);


    static void show_all(AP_HAL::BetterStream *port, bool showKeyValues=false);


    static void show(const AP_Param *param,
                             const char *name,
                             enum ap_var_type ptype,
                             AP_HAL::BetterStream *port);


    static void show(const AP_Param *param,
                             const ParamToken &token,
                             enum ap_var_type ptype,
                             AP_HAL::BetterStream *port);






    static AP_Param * first(ParamToken *token, enum ap_var_type *ptype);



    static AP_Param * next(ParamToken *token, enum ap_var_type *ptype);



    static AP_Param * next_scalar(ParamToken *token, enum ap_var_type *ptype);


    float cast_to_float(enum ap_var_type type) const;


    static bool check_var_info(void);


    bool configured_in_defaults_file(void);


    bool configured_in_storage(void);


    bool configured(void) { return configured_in_defaults_file() || configured_in_storage(); }


    static uint16_t count_parameters(void);

    static void set_hide_disabled_groups(bool value) { _hide_disabled_groups = value; }

private:





    struct EEPROM_header {
        uint8_t magic[2];
        uint8_t revision;
        uint8_t spare;
    };
# 378 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
    struct Param_header {

        uint32_t key_low : 8;
        uint32_t type : 5;
        uint32_t key_high : 1;
        uint32_t group_element : 18;
    };


    static const uint8_t _group_level_shift = 6;
    static const uint8_t _group_bits = 18;

    static const uint16_t _sentinal_key = 0x1FF;
    static const uint8_t _sentinal_type = 0x1F;
    static const uint8_t _sentinal_group = 0xFF;

    static bool check_group_info(const struct GroupInfo *group_info, uint16_t *total_size,
                                                 uint8_t max_bits, uint8_t prefix_length);
    static bool duplicate_key(uint16_t vindex, uint16_t key);

    static bool adjust_group_offset(uint16_t vindex, const struct GroupInfo &group_info, ptrdiff_t &new_offset);
    static bool get_base(const struct Info &info, ptrdiff_t &base);

    const struct Info * find_var_info_group(
                                    const struct GroupInfo * group_info,
                                    uint16_t vindex,
                                    uint32_t group_base,
                                    uint8_t group_shift,
                                    ptrdiff_t group_offset,
                                    uint32_t * group_element,
                                    const struct GroupInfo * &group_ret,
                                    struct GroupNesting &group_nesting,
                                    uint8_t * idx) const;
    const struct Info * find_var_info(
                                    uint32_t * group_element,
                                    const struct GroupInfo * &group_ret,
                                    struct GroupNesting &group_nesting,
                                    uint8_t * idx) const;
    const struct Info * find_var_info_token(const ParamToken &token,
                                                    uint32_t * group_element,
                                                    const struct GroupInfo * &group_ret,
                                                    struct GroupNesting &group_nesting,
                                                    uint8_t * idx) const;
    static const struct Info * find_by_header_group(
                                    struct Param_header phdr, void **ptr,
                                    uint16_t vindex,
                                    const struct GroupInfo *group_info,
                                    uint32_t group_base,
                                    uint8_t group_shift,
                                    ptrdiff_t group_offset);
    static const struct Info * find_by_header(
                                    struct Param_header phdr,
                                    void **ptr);
    void add_vector3f_suffix(
                                    char *buffer,
                                    size_t buffer_size,
                                    uint8_t idx) const;
    static AP_Param * find_group(
                                    const char *name,
                                    uint16_t vindex,
                                    ptrdiff_t group_offset,
                                    const struct GroupInfo *group_info,
                                    enum ap_var_type *ptype);
    static void write_sentinal(uint16_t ofs);
    static uint16_t get_key(const Param_header &phdr);
    static void set_key(Param_header &phdr, uint16_t key);
    static bool is_sentinal(const Param_header &phrd);
    static bool scan(
                                    const struct Param_header *phdr,
                                    uint16_t *pofs);
    static uint8_t type_size(enum ap_var_type type);
    static void eeprom_write_check(
                                    const void *ptr,
                                    uint16_t ofs,
                                    uint8_t size);
    static AP_Param * next_group(
                                    uint16_t vindex,
                                    const struct GroupInfo *group_info,
                                    bool *found_current,
                                    uint32_t group_base,
                                    uint8_t group_shift,
                                    ptrdiff_t group_offset,
                                    ParamToken *token,
                                    enum ap_var_type *ptype);


    static float get_default_value(const float *def_value_ptr);




    static const float *find_def_value_ptr(const char *name);





    static bool parse_param_line(char *line, char **vname, float &value);
    static bool load_defaults_file(const char *filename);



    void send_parameter(const char *name, enum ap_var_type param_header_type, uint8_t idx) const;

    static StorageAccess _storage;
    static uint16_t _num_vars;
    static uint16_t _parameter_count;
    static const struct Info * _var_info;




    struct param_override {
        const float *def_value_ptr;
        float value;
    };
    static struct param_override *param_overrides;
    static uint16_t num_param_overrides;


    static const uint8_t k_EEPROM_magic0 = 0x50;
    static const uint8_t k_EEPROM_magic1 = 0x41;
    static const uint8_t k_EEPROM_revision = 6;

    static bool _hide_disabled_groups;
};
# 513 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
template<typename T, ap_var_type PT>
class AP_ParamT : public AP_Param
{
public:
    static const ap_var_type vtype = PT;



    const T &get(void) const {
        return _value;
    }



    void set(const T &v) {
        _value = v;
    }



    void set_default(const T &v) {
        if (!configured()) {
            set(v);
        }
    }



    void set_and_notify(const T &v) {
        if (v != _value) {
            set(v);
            notify();
        }
    }



    bool set_and_save(const T &v) {
        bool force = fabsf((float)(_value - v)) < 1.1920928955078125e-7F;
        set(v);
        return save(force);
    }






    bool set_and_save_ifchanged(const T &v) {
        if (v == _value) {
            return true;
        }
        set(v);
        return save(true);
    }





    operator const T &() const {
        return _value;
    }



    AP_ParamT<T,PT>& operator= (const T &v) {
        _value = v;
        return *this;
    }



    AP_ParamT<T,PT>& operator |=(const T &v) {
        _value |= v;
        return *this;
    }

    AP_ParamT<T,PT>& operator &=(const T &v) {
        _value &= v;
        return *this;
    }

    AP_ParamT<T,PT>& operator +=(const T &v) {
        _value += v;
        return *this;
    }

    AP_ParamT<T,PT>& operator -=(const T &v) {
        _value -= v;
        return *this;
    }



    float cast_to_float(void) const {
        return (float)_value;
    }

protected:
    T _value;
};
# 625 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
template<typename T, ap_var_type PT>
class AP_ParamV : public AP_Param
{
public:

    static const ap_var_type vtype = PT;



    const T &get(void) const {
        return _value;
    }



    void set(const T &v) {
        _value = v;
    }



    void set_and_notify(const T &v) {
        if (v != _value) {
            set(v);
            notify();
        }
    }



    bool set_and_save(const T &v) {
        bool force = (_value != v);
        set(v);
        return save(force);
    }





    operator const T &() const {
        return _value;
    }



    AP_ParamV<T,PT>& operator=(const T &v) {
        _value = v;
        return *this;
    }

protected:
    T _value;
};
# 690 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
template<typename T, uint8_t N, ap_var_type PT>
class AP_ParamA : public AP_Param
{
public:

    static const ap_var_type vtype = PT;





    const T & operator[](uint8_t i) {
        return _value[i];
    }

    const T & operator[](int8_t i) {
        return _value[(uint8_t)i];
    }





    T get(uint8_t i) const {
        if (i < N) {
            return _value[i];
        } else {
            return (T)0;
        }
    }





    void set(uint8_t i, const T &v) {
        if (i < N) {
            _value[i] = v;
        }
    }

protected:
    T _value[N];
};
# 743 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Param/AP_Param.h"
#define AP_PARAMDEF(_t,_suffix,_pt) typedef AP_ParamT<_t, _pt> AP_ ## _suffix;
typedef AP_ParamT<float, AP_PARAM_FLOAT> AP_Float;;
typedef AP_ParamT<int8_t, AP_PARAM_INT8> AP_Int8;;
typedef AP_ParamT<int16_t, AP_PARAM_INT16> AP_Int16;;
typedef AP_ParamT<int32_t, AP_PARAM_INT32> AP_Int32;;






#define AP_PARAMDEFV(_t,_suffix,_pt) typedef AP_ParamV<_t, _pt> AP_ ## _suffix;
# 10 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2

# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/definitions.h" 1
       
# 20 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/definitions.h"
#undef M_PI

#define M_PI (3.141592653589793f)


#undef M_PI_2

#define M_PI_2 (M_PI / 2)

#define M_GOLDEN 1.6180339f


#define M_2PI (M_PI * 2)







#define MATH_CHECK_INDEXES 0


#define DEG_TO_RAD (M_PI / 180.0f)
#define RAD_TO_DEG (180.0f / M_PI)




#define DEG_TO_RAD_DOUBLE 0.0174532925199432954743716805978692718781530857086181640625
#define RAD_TO_DEG_DOUBLE 57.29577951308232286464772187173366546630859375

#define RadiansToCentiDegrees(x) (static_cast<float>(x) * RAD_TO_DEG * static_cast<float>(100))


#define GRAVITY_MSS 9.80665f


#define RADIUS_OF_EARTH 6378100



#define LATLON_TO_M 0.01113195f
#define LATLON_TO_CM 1.113195f


#define WGS84_A 6378137.0

#define WGS84_IF 298.257223563

#define WGS84_F (1.0 / WGS84_IF)

#define WGS84_B (WGS84_A * (1 - WGS84_F))

#define WGS84_E (sqrt(2 * WGS84_F - WGS84_F * WGS84_F))

#define NSEC_PER_SEC 1000000000ULL
#define NSEC_PER_USEC 1000ULL
#define USEC_PER_SEC 1000000ULL
#define USEC_PER_MSEC 1000ULL
# 12 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/edc.h" 1
# 18 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/edc.h"
       



uint16_t crc16_ccitt(const uint8_t *buf, uint32_t len, uint16_t crc);
# 13 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/location.h" 1
       






# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/vector2.h" 1
# 30 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/vector2.h"
       



template <typename T>
struct Vector2
{
    T x, y;


    constexpr Vector2<T>()
        : x(0)
        , y(0) {}


    constexpr Vector2<T>(const T x0, const T y0)
        : x(x0)
        , y(y0) {}


    void operator ()(const T x0, const T y0)
    {
        x= x0; y= y0;
    }


    bool operator ==(const Vector2<T> &v) const;


    bool operator !=(const Vector2<T> &v) const;


    Vector2<T> operator -(void) const;


    Vector2<T> operator +(const Vector2<T> &v) const;


    Vector2<T> operator -(const Vector2<T> &v) const;


    Vector2<T> operator *(const T num) const;


    Vector2<T> operator /(const T num) const;


    Vector2<T> &operator +=(const Vector2<T> &v);


    Vector2<T> &operator -=(const Vector2<T> &v);


    Vector2<T> &operator *=(const T num);


    Vector2<T> &operator /=(const T num);


    T operator *(const Vector2<T> &v) const;


    T operator %(const Vector2<T> &v) const;


    float angle(const Vector2<T> &v2) const;


    T angle(void) const;


    bool is_nan(void) const;


    bool is_inf(void) const;


    bool is_zero(void) const { return (fabsf(x) < 1.1920928955078125e-7F) && (fabsf(y) < 1.1920928955078125e-7F); }

    const T & operator[](uint8_t i) const {
        const T *_v = &x;



        return _v[i];
    }


    void zero()
    {
        x = y = 0;
    }


    T length_squared() const
    {
        return (T)(*this * *this);
    }


    float length(void) const;


    void normalize()
    {
        *this/=length();
    }


    Vector2<T> normalized() const
    {
        return *this/length();
    }


    void reflect(const Vector2<T> &n)
    {
        Vector2<T> orig(*this);
        project(n);
        *this= *this*2 - orig;
    }


    void project(const Vector2<T> &v)
    {
        *this= v * (*this * v)/(v*v);
    }


    Vector2<T> projected(const Vector2<T> &v)
    {
        return v * (*this * v)/(v*v);
    }



    static Vector2<T> perpendicular(const Vector2<T> &pos_delta, const Vector2<T> &v1)
    {
        Vector2<T> perpendicular1 = Vector2<T>(-v1[1], v1[0]);
        Vector2<T> perpendicular2 = Vector2<T>(v1[1], -v1[0]);
        T d1 = perpendicular1 * pos_delta;
        T d2 = perpendicular2 * pos_delta;
        if (d1 > d2) {
            return perpendicular1;
        }
        return perpendicular2;
    }







    static Vector2<T> closest_point(const Vector2<T> &p, const Vector2<T> &v, const Vector2<T> &w)
    {

        const float l2 = (v - w).length_squared();
        if (l2 < 1.1920928955078125e-7F) {

            return v;
        }




        const float t = ((p - v) * (w - v)) / l2;
        if (t <= 0) {
            return v;
        } else if (t >= 1) {
            return w;
        } else {
            return v + (w - v)*t;
        }
    }




    static float closest_distance_between_radial_and_point(const Vector2<T> &w,
                                                           const Vector2<T> &p)
    {
        const Vector2<T> closest = closest_point(p, Vector2<T>(0,0), w);
        const Vector2<T> delta = closest - p;
        return delta.length();
    }

};

typedef Vector2<int16_t> Vector2i;
typedef Vector2<uint16_t> Vector2ui;
typedef Vector2<int32_t> Vector2l;
typedef Vector2<uint32_t> Vector2ul;
typedef Vector2<float> Vector2f;
# 9 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/location.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/vector3.h" 1
# 48 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/vector3.h"
       
# 57 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/vector3.h"
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/rotations.h" 1
# 18 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/rotations.h"
       
# 27 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/rotations.h"
enum Rotation {
    ROTATION_NONE = 0,
    ROTATION_YAW_45 = 1,
    ROTATION_YAW_90 = 2,
    ROTATION_YAW_135 = 3,
    ROTATION_YAW_180 = 4,
    ROTATION_YAW_225 = 5,
    ROTATION_YAW_270 = 6,
    ROTATION_YAW_315 = 7,
    ROTATION_ROLL_180 = 8,
    ROTATION_ROLL_180_YAW_45 = 9,
    ROTATION_ROLL_180_YAW_90 = 10,
    ROTATION_ROLL_180_YAW_135 = 11,
    ROTATION_PITCH_180 = 12,
    ROTATION_ROLL_180_YAW_225 = 13,
    ROTATION_ROLL_180_YAW_270 = 14,
    ROTATION_ROLL_180_YAW_315 = 15,
    ROTATION_ROLL_90 = 16,
    ROTATION_ROLL_90_YAW_45 = 17,
    ROTATION_ROLL_90_YAW_90 = 18,
    ROTATION_ROLL_90_YAW_135 = 19,
    ROTATION_ROLL_270 = 20,
    ROTATION_ROLL_270_YAW_45 = 21,
    ROTATION_ROLL_270_YAW_90 = 22,
    ROTATION_ROLL_270_YAW_135 = 23,
    ROTATION_PITCH_90 = 24,
    ROTATION_PITCH_270 = 25,
    ROTATION_PITCH_180_YAW_90 = 26,
    ROTATION_PITCH_180_YAW_270 = 27,
    ROTATION_ROLL_90_PITCH_90 = 28,
    ROTATION_ROLL_180_PITCH_90 = 29,
    ROTATION_ROLL_270_PITCH_90 = 30,
    ROTATION_ROLL_90_PITCH_180 = 31,
    ROTATION_ROLL_270_PITCH_180 = 32,
    ROTATION_ROLL_90_PITCH_270 = 33,
    ROTATION_ROLL_180_PITCH_270 = 34,
    ROTATION_ROLL_270_PITCH_270 = 35,
    ROTATION_ROLL_90_PITCH_180_YAW_90 = 36,
    ROTATION_ROLL_90_YAW_270 = 37,
    ROTATION_ROLL_90_PITCH_68_YAW_293 = 38,
    ROTATION_MAX
};
# 58 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/vector3.h" 2

template <typename T>
class Matrix3;

template <typename T>
class Vector3
{

public:
    T x, y, z;


    constexpr Vector3<T>()
        : x(0)
        , y(0)
        , z(0) {}


    constexpr Vector3<T>(const T x0, const T y0, const T z0)
        : x(x0)
        , y(y0)
        , z(z0) {}


    void operator ()(const T x0, const T y0, const T z0)
    {
        x= x0; y= y0; z= z0;
    }


    bool operator ==(const Vector3<T> &v) const;


    bool operator !=(const Vector3<T> &v) const;


    Vector3<T> operator -(void) const;


    Vector3<T> operator +(const Vector3<T> &v) const;


    Vector3<T> operator -(const Vector3<T> &v) const;


    Vector3<T> operator *(const T num) const;


    Vector3<T> operator /(const T num) const;


    Vector3<T> &operator +=(const Vector3<T> &v);


    Vector3<T> &operator -=(const Vector3<T> &v);


    Vector3<T> &operator *=(const T num);


    Vector3<T> &operator /=(const T num);


    T & operator[](uint8_t i) {
        T *_v = &x;



        return _v[i];
    }

    const T & operator[](uint8_t i) const {
        const T *_v = &x;



        return _v[i];
    }


    T operator *(const Vector3<T> &v) const;


    Vector3<T> operator *(const Matrix3<T> &m) const;


    Matrix3<T> mul_rowcol(const Vector3<T> &v) const;


    Vector3<T> operator %(const Vector3<T> &v) const;


    float angle(const Vector3<T> &v2) const;


    bool is_nan(void) const;


    bool is_inf(void) const;


    bool is_zero(void) const { return (fabsf(x) < 1.1920928955078125e-7F) && (fabsf(y) < 1.1920928955078125e-7F) && (fabsf(z) < 1.1920928955078125e-7F); }



    void rotate(enum Rotation rotation);
    void rotate_inverse(enum Rotation rotation);


    T length_squared() const
    {
        return (T)(*this * *this);
    }


    float length(void) const;


    void normalize()
    {
        *this /= length();
    }


    void zero()
    {
        x = y = z = 0;
    }


    Vector3<T> normalized() const
    {
        return *this/length();
    }


    void reflect(const Vector3<T> &n)
    {
        Vector3<T> orig(*this);
        project(n);
        *this = *this*2 - orig;
    }


    void project(const Vector3<T> &v)
    {
        *this= v * (*this * v)/(v*v);
    }


    Vector3<T> projected(const Vector3<T> &v) const
    {
        return v * (*this * v)/(v*v);
    }





    static Vector3<T> perpendicular(const Vector3<T> &p1, const Vector3<T> &v1)
    {
        T d = p1 * v1;
        if (fabsf(d) < 1.1920928955078125e-7F) {
            return p1;
        }
        Vector3<T> parallel = (v1 * d) / v1.length_squared();
        Vector3<T> perpendicular = p1 - parallel;

        return perpendicular;
    }

};

typedef Vector3<int16_t> Vector3i;
typedef Vector3<uint16_t> Vector3ui;
typedef Vector3<int32_t> Vector3l;
typedef Vector3<uint32_t> Vector3ul;
typedef Vector3<float> Vector3f;
typedef Vector3<double> Vector3d;
# 10 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/location.h" 2



#define LOCATION_SCALING_FACTOR 0.011131884502145034f

#define LOCATION_SCALING_FACTOR_INV 89.83204953368922f






float longitude_scale(const struct Location &loc);


float get_distance(const struct Location &loc1, const struct Location &loc2);


uint32_t get_distance_cm(const struct Location &loc1, const struct Location &loc2);


int32_t get_bearing_cd(const struct Location &loc1, const struct Location &loc2);






bool location_passed_point(const struct Location & location,
                                  const struct Location & point1,
                                  const struct Location & point2);





float location_path_proportion(const struct Location &location,
                               const struct Location &point1,
                               const struct Location &point2);


void location_update(struct Location &loc, float bearing, float distance);


void location_offset(struct Location &loc, float ofs_north, float ofs_east);





Vector2f location_diff(const struct Location &loc1, const struct Location &loc2);




bool locations_are_same(const struct Location &loc1, const struct Location &loc2);




bool location_sanitize(const struct Location &defaultLoc, struct Location &loc);




void print_latlon(AP_HAL::BetterStream *s, int32_t lat_or_lon);




void wgsllh2ecef(const Vector3d &llh, Vector3d &ecef);




void wgsecef2llh(const Vector3d &ecef, Vector3d &llh);


bool check_lat(float lat);
bool check_lng(float lng);
bool check_lat(int32_t lat);
bool check_lng(int32_t lng);
bool check_latlng(float lat, float lng);
bool check_latlng(int32_t lat, int32_t lng);
bool check_latlng(Location loc);
# 14 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/matrix3.h" 1
# 38 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/matrix3.h"
       




template <typename T>
class Matrix3 {
public:


    Vector3<T> a, b, c;



    constexpr Matrix3<T>() {}


    constexpr Matrix3<T>(const Vector3<T> &a0, const Vector3<T> &b0, const Vector3<T> &c0)
        : a(a0)
        , b(b0)
        , c(c0) {}


    constexpr Matrix3<T>(const T ax, const T ay, const T az,
                         const T bx, const T by, const T bz,
                         const T cx, const T cy, const T cz)
        : a(ax,ay,az)
        , b(bx,by,bz)
        , c(cx,cy,cz) {}


    void operator () (const Vector3<T> &a0, const Vector3<T> &b0, const Vector3<T> &c0)
    {
        a = a0; b = b0; c = c0;
    }


    bool operator == (const Matrix3<T> &m)
    {
        return (a==m.a && b==m.b && c==m.c);
    }


    bool operator != (const Matrix3<T> &m)
    {
        return (a!=m.a || b!=m.b || c!=m.c);
    }


    Matrix3<T> operator - (void) const
    {
        return Matrix3<T>(-a,-b,-c);
    }


    Matrix3<T> operator + (const Matrix3<T> &m) const
    {
        return Matrix3<T>(a+m.a, b+m.b, c+m.c);
    }
    Matrix3<T> &operator += (const Matrix3<T> &m)
    {
        return *this = *this + m;
    }


    Matrix3<T> operator - (const Matrix3<T> &m) const
    {
        return Matrix3<T>(a-m.a, b-m.b, c-m.c);
    }
    Matrix3<T> &operator -= (const Matrix3<T> &m)
    {
        return *this = *this - m;
    }


    Matrix3<T> operator * (const T num) const
    {
        return Matrix3<T>(a*num, b*num, c*num);
    }
    Matrix3<T> &operator *= (const T num)
    {
        return *this = *this * num;
    }
    Matrix3<T> operator / (const T num) const
    {
        return Matrix3<T>(a/num, b/num, c/num);
    }
    Matrix3<T> &operator /= (const T num)
    {
        return *this = *this / num;
    }


    Vector3<T> & operator[](uint8_t i) {
        Vector3<T> *_v = &a;



        return _v[i];
    }

    const Vector3<T> & operator[](uint8_t i) const {
        const Vector3<T> *_v = &a;



        return _v[i];
    }


    Vector3<T> operator *(const Vector3<T> &v) const;


    Vector3<T> mul_transpose(const Vector3<T> &v) const;


    Vector2<T> mulXY(const Vector3<T> &v) const;


    Vector3<T> colx(void) const
    {
        return Vector3<T>(a.x, b.x, c.x);
    }


    Vector3<T> coly(void) const
    {
        return Vector3<T>(a.y, b.y, c.y);
    }


    Vector3<T> colz(void) const
    {
        return Vector3<T>(a.z, b.z, c.z);
    }


    Matrix3<T> operator *(const Matrix3<T> &m) const;

    Matrix3<T> &operator *=(const Matrix3<T> &m)
    {
        return *this = *this * m;
    }


    Matrix3<T> transposed(void) const;

    void transpose(void)
    {
        *this = transposed();
    }






    T det() const;
# 205 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/matrix3.h"
    bool inverse(Matrix3<T>& inv) const;







    bool invert();


    void zero(void);


    void identity(void) {
        a.x = b.y = c.z = 1;
        a.y = a.z = 0;
        b.x = b.z = 0;
        c.x = c.y = 0;
    }


    bool is_nan(void)
    {
        return a.is_nan() || b.is_nan() || c.is_nan();
    }


    void from_euler(float roll, float pitch, float yaw);


    void to_euler(float *roll, float *pitch, float *yaw) const;






    Vector3<T> to_euler312() const;




    void from_euler312(float roll, float pitch, float yaw);



    void rotate(const Vector3<T> &g);




    void from_axis_angle(const Vector3<T> &v, float theta);


    void normalize(void);
};

typedef Matrix3<int16_t> Matrix3i;
typedef Matrix3<uint16_t> Matrix3ui;
typedef Matrix3<int32_t> Matrix3l;
typedef Matrix3<uint32_t> Matrix3ul;
typedef Matrix3<float> Matrix3f;
typedef Matrix3<double> Matrix3d;
# 15 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/polygon.h" 1
# 18 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/polygon.h"
       



template <typename T>
bool Polygon_outside(const Vector2<T> &P, const Vector2<T> *V, unsigned n);
template <typename T>
bool Polygon_complete(const Vector2<T> *V, unsigned n);
# 16 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2
# 1 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/quaternion.h" 1
# 18 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/quaternion.h"
       






class Quaternion {
public:
    float q1, q2, q3, q4;



    Quaternion()
    {
        q1 = 1;
        q2 = q3 = q4 = 0;
    }


    Quaternion(const float _q1, const float _q2, const float _q3, const float _q4) :
        q1(_q1), q2(_q2), q3(_q3), q4(_q4)
    {
    }


    void operator()(const float _q1, const float _q2, const float _q3, const float _q4)
    {
        q1 = _q1;
        q2 = _q2;
        q3 = _q3;
        q4 = _q4;
    }


    bool is_nan(void) const
    {
        return (((sizeof(q1) == sizeof(float)) ? __fpclassifyf(q1) : __fpclassifyd(q1)) == 0) || (((sizeof(q2) == sizeof(float)) ? __fpclassifyf(q2) : __fpclassifyd(q2)) == 0) || (((sizeof(q3) == sizeof(float)) ? __fpclassifyf(q3) : __fpclassifyd(q3)) == 0) || (((sizeof(q4) == sizeof(float)) ? __fpclassifyf(q4) : __fpclassifyd(q4)) == 0);
    }


    void rotation_matrix(Matrix3f &m) const;


    void rotation_matrix_norm(Matrix3f &m) const;

    void from_rotation_matrix(const Matrix3f &m);


    void earth_to_body(Vector3f &v) const;


    void from_euler(float roll, float pitch, float yaw);

    void from_vector312(float roll ,float pitch, float yaw);

    void to_axis_angle(Vector3f &v);

    void from_axis_angle(Vector3f v);

    void from_axis_angle(const Vector3f &axis, float theta);

    void rotate(const Vector3f &v);

    void from_axis_angle_fast(Vector3f v);

    void from_axis_angle_fast(const Vector3f &axis, float theta);

    void rotate_fast(const Vector3f &v);


    float get_euler_roll() const;


    float get_euler_pitch() const;


    float get_euler_yaw() const;


    void to_euler(float &roll, float &pitch, float &yaw) const;


    Vector3f to_vector312(void) const;

    float length(void) const;
    void normalize();


    void initialise()
    {
        q1 = 1.0f;
        q2 = q3 = q4 = 0.0f;
    }

    Quaternion inverse(void) const;


    float & operator[](uint8_t i)
    {
        float *_v = &q1;



        return _v[i];
    }

    const float & operator[](uint8_t i) const
    {
        const float *_v = &q1;



        return _v[i];
    }

    Quaternion operator*(const Quaternion &v) const;
    Quaternion &operator*=(const Quaternion &v);
    Quaternion operator/(const Quaternion &v) const;
};
# 17 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/AP_Math.h" 2





typedef AP_ParamV<Vector3f, AP_PARAM_VECTOR3F> AP_Vector3f;;




template <class Arithmetic1, class Arithmetic2>
typename std::enable_if<std::is_integral<typename std::common_type<Arithmetic1, Arithmetic2>::type>::value ,bool>::type
is_equal(const Arithmetic1 v_1, const Arithmetic2 v_2);

template <class Arithmetic1, class Arithmetic2>
typename std::enable_if<std::is_floating_point<typename std::common_type<Arithmetic1, Arithmetic2>::type>::value, bool>::type
is_equal(const Arithmetic1 v_1, const Arithmetic2 v_2);




template <class T>
inline bool is_zero(const T fVal1) {
    static_assert(std::is_floating_point<T>::value || std::is_base_of<T,AP_Float>::value,
                  "Template parameter not of type float");
    return (fabsf(static_cast<float>(fVal1)) < 1.1920928955078125e-7F);
}





template <class T>
float safe_asin(const T v);







template <class T>
float safe_sqrt(const T v);


bool inverse3x3(float m[], float invOut[]);


bool inverse4x4(float m[],float invOut[]);


float *mat_mul(float *A, float *B, uint8_t n);


bool inverse(float x[], float y[], uint16_t dim);






template <class T>
float wrap_180(const T angle, float unit_mod = 1);




template <class T>
auto wrap_180_cd(const T angle) -> decltype(wrap_180(angle, 100.f));






template <class T>
float wrap_360(const T angle, float unit_mod = 1);




template <class T>
auto wrap_360_cd(const T angle) -> decltype(wrap_360(angle, 100.f));




template <class T>
float wrap_PI(const T radian);




template <class T>
float wrap_2PI(const T radian);




template <class T>
T constrain_value(const T amt, const T low, const T high);

inline float constrain_float(const float amt, const float low, const float high)
{
    return constrain_value(amt, low, high);
}

inline int16_t constrain_int16(const int16_t amt, const int16_t low, const int16_t high)
{
    return constrain_value(amt, low, high);
}

inline int32_t constrain_int32(const int32_t amt, const int32_t low, const int32_t high)
{
    return constrain_value(amt, low, high);
}


static inline float radians(float deg)
{
    return deg * ((3.141592653589793f) / 180.0f);
}


static inline float degrees(float rad)
{
    return rad * (180.0f / (3.141592653589793f));
}

template<class T>
float sq(const T val)
{
    return powf(static_cast<float>(val), 2);
}





template<class T, class... Params>
float sq(const T first, const Params... parameters)
{
    return sq(first) + sq(parameters...);
}





template<class T, class... Params>
float norm(const T first, const Params... parameters)
{
    return sqrt(static_cast<float>(sq(first, parameters...)));
}

template<typename A, typename B>
static inline auto MIN(const A &one, const B &two) -> decltype(one < two ? one : two)
{
    return one < two ? one : two;
}

template<typename A, typename B>
static inline auto MAX(const A &one, const B &two) -> decltype(one > two ? one : two)
{
    return one > two ? one : two;
}

inline uint32_t hz_to_nsec(uint32_t freq)
{
    return 1000000000ULL / freq;
}

inline uint32_t nsec_to_hz(uint32_t nsec)
{
    return 1000000000ULL / nsec;
}

inline uint32_t usec_to_nsec(uint32_t usec)
{
    return usec * 1000ULL;
}

inline uint32_t nsec_to_usec(uint32_t nsec)
{
    return nsec / 1000ULL;
}

inline uint32_t hz_to_usec(uint32_t freq)
{
    return 1000000ULL / freq;
}

inline uint32_t usec_to_hz(uint32_t usec)
{
    return 1000000ULL / usec;
}




float linear_interpolate(float low_output, float high_output,
                         float var_value,
                         float var_low, float var_high);


uint16_t get_random16(void);
# 20 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/polygon.cpp" 2
# 37 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/polygon.cpp"
template <typename T>
bool Polygon_outside(const Vector2<T> &P, const Vector2<T> *V, unsigned n)
{
    unsigned i, j;
    bool outside = true;
    for (i = 0, j = n-1; i < n; j = i++) {
        if ((V[i].y > P.y) == (V[j].y > P.y)) {
            continue;
        }
        int32_t dx1, dx2, dy1, dy2;
        dx1 = P.x - V[i].x;
        dx2 = V[j].x - V[i].x;
        dy1 = P.y - V[i].y;
        dy2 = V[j].y - V[i].y;
        int8_t dx1s, dx2s, dy1s, dy2s, m1, m2;
#define sign(x) ((x)<0 ? -1 : 1)
        dx1s = ((dx1)<0 ? -1 : 1);
        dx2s = ((dx2)<0 ? -1 : 1);
        dy1s = ((dy1)<0 ? -1 : 1);
        dy2s = ((dy2)<0 ? -1 : 1);
        m1 = dx1s * dy2s;
        m2 = dx2s * dy1s;

        if (dy2 < 0) {
            if (m1 > m2) {
                outside = !outside;
            } else if (m1 < m2) {
                continue;
            } else if ( dx1 * (int64_t)dy2 > dx2 * (int64_t)dy1 ) {
                outside = !outside;
            }
        } else {
            if (m1 < m2) {
                outside = !outside;
            } else if (m1 > m2) {
                continue;
            } else if ( dx1 * (int64_t)dy2 < dx2 * (int64_t)dy1 ) {
                outside = !outside;
            }
        }
    }
    return outside;
}
# 88 "/mnt/disk_d/src/quad-copter/ardu-copter/3.4.2-git/ardupilot/libraries/AP_Math/polygon.cpp"
template <typename T>
bool Polygon_complete(const Vector2<T> *V, unsigned n)
{
    return (n >= 4 && V[n-1] == V[0]);
}


template bool Polygon_outside<int32_t>(const Vector2l &P, const Vector2l *V, unsigned n);
template bool Polygon_complete<int32_t>(const Vector2l *V, unsigned n);
template bool Polygon_outside<float>(const Vector2f &P, const Vector2f *V, unsigned n);
template bool Polygon_complete<float>(const Vector2f *V, unsigned n);
